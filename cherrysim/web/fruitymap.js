var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
define("src/engine/rendering/utils/Point", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/engine/math/Vector2", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Vector2 = void 0;
    class Vector2 {
        // Construction
        constructor(x, y) {
            x = x == undefined ? 0 : x;
            y = y == undefined ? 0 : y;
            this.v = [x, y];
        }
        static getVector2(point) {
            return new Vector2(point.x, point.y);
        }
        static getPoint(v) {
            return new Vector2(v.getX(), v.getY());
        }
        // Access
        set x(x) {
            this.v[0] = x;
        }
        get x() {
            return this.v[0];
        }
        set y(y) {
            this.v[1] = y;
        }
        get y() {
            return this.v[1];
        }
        // Operations
        static add(v1, v2) {
            return new Vector2(v1.v[0] + v2.v[0], v1.v[1] + v2.v[1]);
        }
        static subtract(v1, v2) {
            return new Vector2(v1.v[0] - v2.v[0], v1.v[1] - v2.v[1]);
        }
        static subtractPoints(p1, p2) {
            return new Vector2(p1.x - p2.x, p1.y - p2.y);
        }
        static multiply(v1, s) {
            return new Vector2(s * v1.v[0], s * v1.v[1]);
        }
        static divide(v1, s) {
            return new Vector2(v1.v[0] / s, v1.v[1] / s);
        }
        static normalize(v1) {
            let result = new Vector2(0, 0);
            let l = v1.getLength();
            for (let i = 0; i < 2; ++i) {
                result.v[i] /= l;
            }
            return result;
        }
        static normalizePoint(p) {
            let result = new Vector2(0, 0);
            let l = Vector2.getLengthOfPoint(p);
            result.x = p.x / l;
            result.y = p.y / l;
            return result;
        }
        static dot(v1, v2) {
            return v1.v[0] * v2.v[0] + v1.v[1] * v2.v[1];
        }
        static crossProduct(v1, v2) {
            return v1.getX() * v2.getY() - v1.getY() * v2.getX();
        }
        static getAngleBetween(v1, v2) {
            let numerator = Vector2.dot(v1, v2);
            let denominator = v1.getLength() * v2.getLength();
            let result = Math.acos(numerator / denominator);
            return result;
        }
        static getLengthOfPoint(p) {
            return Math.sqrt(p.x * p.x + p.y * p.y);
        }
        static getDistanceBetweenPoints(p1, p2) {
            let x = p1.x - p2.x;
            let y = p1.y - p2.y;
            return Math.sqrt(x * x + y * y);
        }
        get(index) {
            return this.v[index];
        }
        set(index, value) {
            this.v[index] = value;
        }
        getX() {
            return this.v[0];
        }
        setX(x) {
            this.v[0] = x;
        }
        getY() {
            return this.v[1];
        }
        setY(y) {
            this.v[1] = y;
        }
        getLength() {
            return Math.sqrt(this.v[0] * this.v[0] +
                this.v[1] * this.v[1]);
        }
        getLengthSqr() {
            return (this.v[0] * this.v[0] +
                this.v[1] * this.v[1]);
        }
        add(v1) {
            this.v[0] += v1.v[0];
            this.v[1] += v1.v[1];
            return this;
        }
        subtract(v1) {
            this.v[0] -= v1.v[0];
            this.v[1] -= v1.v[1];
            return this;
        }
        multiply(s) {
            this.v[0] = this.v[0] * s;
            this.v[1] = this.v[1] * s;
            return this;
        }
        divide(s) {
            this.v[0] = this.v[0] / s;
            this.v[1] = this.v[1] / s;
            return this;
        }
        normalize() {
            let l = this.getLength();
            for (let i = 0; i < 2; ++i) {
                this.v[i] /= l;
            }
            return this;
        }
        toJSON() {
            return { x: this.v[0], y: this.v[1] };
        }
    }
    exports.Vector2 = Vector2;
});
define("src/engine/math/Transform", ["require", "exports", "src/engine/math/Vector2", "src/engine/math/Matrix2x3"], function (require, exports, Vector2_1, Matrix2x3_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transform = void 0;
    class Transform {
        constructor() {
            /**
             * The global matrix transform. It can be swapped temporarily by some functions like getLocalBounds()
             *
             * @member {Matrix2x3}
             */
            this.worldTransform = new Matrix2x3_1.Matrix2x3();
            /**
             * The local matrix transform
             *
             * @member {Matrix2x3}
             */
            this.localTransform = new Matrix2x3_1.Matrix2x3();
            this._worldID = 0;
            /**
            * The coordinate of the object relative to the local coordinates of the parent.
            *
            * @member {Vector2}
            */
            this.position = new Vector2_1.Vector2(0, 0);
            /**
             * The scale factor of the object.
             *
             * @member {Vector2}
             */
            this.scale = new Vector2_1.Vector2(1, 1);
            /**
             * The rotation value of the object, in radians
             *
             * @member {Number}
             * @private
             */
            this.rotation = 0;
            /**
             * The skew amount, on the x and y axis.
             *
             * @member {Vector2}
             */
            this.skew = new Vector2_1.Vector2(0, 0);
            /**
             * The pivot point of the displayObject that it rotates around.
             *
             * @member {Vector2}
             */
            this.pivot = new Vector2_1.Vector2(0, 0);
            this._cx = 1; // cos rotation + skewY;
            this._sx = 0; // sin rotation + skewY;
            this._cy = 0; // cos rotation + Math.PI/2 - skewX;
            this._sy = 1; // sin rotation + Math.PI/2 - skewX;
            /**
             * Decomposes a matrix and sets the transforms properties based on it.
             *
             * @param {Matrix2x3} matrix - The matrix to decompose
             */
            this.setFromMatrix = function setFromMatrix(matrix) {
                matrix.decompose(this);
            };
            // Empty
        }
        /**
       * Updates the skew values when the skew or rotation changes.
       */
        updateSkew() {
            this._cx = Math.cos(this.rotation + this.skew.y);
            this._sx = Math.sin(this.rotation + this.skew.y);
            this._cy = -Math.sin(this.rotation - this.skew.x); // cos, added PI/2
            this._sy = Math.cos(this.rotation - this.skew.x); // sin, added PI/2
        }
        ;
        /**
         * Updates only local matrix
         */
        updateLocalTransform() {
            var lt = this.localTransform;
            lt.a = this._cx * this.scale.x;
            lt.b = this._sx * this.scale.x;
            lt.c = this._cy * this.scale.y;
            lt.d = this._sy * this.scale.y;
            lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
            lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
        }
        ;
        /**
         * Updates the values of the object and applies the parent's transform.
         *
         * @param {Transform} parentTransform - The transform of the parent of this object
         */
        updateTransform(parentTransform) {
            var lt = this.localTransform;
            lt.a = this._cx * this.scale.x;
            lt.b = this._sx * this.scale.x;
            lt.c = this._cy * this.scale.y;
            lt.d = this._sy * this.scale.y;
            lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
            lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
            // concat the parent matrix with the objects transform.
            var pt = parentTransform.worldTransform;
            var wt = this.worldTransform;
            wt.a = lt.a * pt.a + lt.b * pt.c;
            wt.b = lt.a * pt.b + lt.b * pt.d;
            wt.c = lt.c * pt.a + lt.d * pt.c;
            wt.d = lt.c * pt.b + lt.d * pt.d;
            wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
            wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
            this._worldID++;
        }
        ;
    }
    exports.Transform = Transform;
});
define("src/engine/math/Matrix2x3", ["require", "exports", "src/engine/math/Vector2"], function (require, exports, Vector2_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Matrix2x3 = void 0;
    /**
     * A 2x3 matrix with the following structure:
     *
     * | a | c | tx|
     * | b | d | ty|
     * | 0 | 0 | 1 |
     */
    class Matrix2x3 {
        // Construction
        /**
         * @param {number} [a=1] - x scale
         * @param {number} [b=0] - x skew
         * @param {number} [c=0] - y skew
         * @param {number} [d=1] - y scale
         * @param {number} [tx=0] - x translation
         * @param {number} [ty=0] - y translation
         */
        constructor(a, b, c, d, tx, ty) {
            this.array = null;
            this.a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            this.b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            this.c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            this.d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
            this.tx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
            this.ty = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
        }
        /**
         * sets the matrix properties
         *
         * @param {number} a - Matrix component
         * @param {number} b - Matrix component
         * @param {number} c - Matrix component
         * @param {number} d - Matrix component
         * @param {number} tx - Matrix component
         * @param {number} ty - Matrix component
         *
         * @return {Matrix2x3} This matrix. Good for chaining method calls.
         */
        set(a, b, c, d, tx, ty) {
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.tx = tx;
            this.ty = ty;
            return this;
        }
        /**
         * Sets the matrix based on all the available properties
         *
         * @param {number} x - Position on the x axis
         * @param {number} y - Position on the y axis
         * @param {number} pivotX - Pivot on the x axis
         * @param {number} pivotY - Pivot on the y axis
         * @param {number} scaleX - Scale on the x axis
         * @param {number} scaleY - Scale on the y axis
         * @param {number} rotation - Rotation in radians
         * @param {number} skewX - Skew on the x axis
         * @param {number} skewY - Skew on the y axis
         * @return {Matrix2x3} This matrix. Good for chaining method calls.
         */
        setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
            this.a = Math.cos(rotation + skewY) * scaleX;
            this.b = Math.sin(rotation + skewY) * scaleX;
            this.c = -Math.sin(rotation - skewX) * scaleY;
            this.d = Math.cos(rotation - skewX) * scaleY;
            this.tx = x - (pivotX * this.a + pivotY * this.c);
            this.ty = y - (pivotX * this.b + pivotY * this.d);
            return this;
        }
        // Matrix multiplication
        /**
         * Get a new position with the current transformation applied.
         * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
         *
         * @param {Vector2} pos - The origin
         * @param {Vector2} [newPos] - The point that the new position is assigned to (allowed to be same as input)
         * @return {Vector2} The new point, transformed through this matrix
         */
        apply(pos, newPos) {
            newPos = newPos || new Vector2_2.Vector2();
            var x = pos.x;
            var y = pos.y;
            newPos.x = this.a * x + this.c * y + this.tx;
            newPos.y = this.b * x + this.d * y + this.ty;
            return newPos;
        }
        /**
         * Get a new position with the inverse of the current transformation applied.
         * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
         *
         * @param {Vector2} pos - The origin
         * @param {Vector2} [newPos] - The point that the new position is assigned to (allowed to be same as input)
         * @return {Vector2} The new point, inverse-transformed through this matrix
         */
        applyInverse(pos, newPos) {
            newPos = newPos || new Vector2_2.Vector2();
            var id = 1 / (this.a * this.d + this.c * -this.b);
            var x = pos.x;
            var y = pos.y;
            newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
            newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;
            return newPos;
        }
        // Specific transformations
        /**
         * Translates the matrix on the x and y.
         *
         * @param {number} x How much to translate x by
         * @param {number} y How much to translate y by
         * @return {Matrix2x3} This matrix. Good for chaining method calls.
         */
        translate(x, y) {
            this.tx += x;
            this.ty += y;
            return this;
        }
        /**
         * Applies a scale transformation to the matrix.
         *
         * @param {number} x The amount to scale horizontally
         * @param {number} y The amount to scale vertically
         * @return {Matrix2x3} This matrix. Good for chaining method calls.
         */
        scale(x, y) {
            this.a *= x;
            this.d *= y;
            this.c *= x;
            this.b *= y;
            this.tx *= x;
            this.ty *= y;
            return this;
        }
        /**
         * Applies a rotation transformation to the matrix.
         *
         * @param {number} angle - The angle in radians.
         * @return {Matrix2x3} This matrix. Good for chaining method calls.
         */
        rotate(angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var a1 = this.a;
            var c1 = this.c;
            var tx1 = this.tx;
            this.a = a1 * cos - this.b * sin;
            this.b = a1 * sin + this.b * cos;
            this.c = c1 * cos - this.d * sin;
            this.d = c1 * sin + this.d * cos;
            this.tx = tx1 * cos - this.ty * sin;
            this.ty = tx1 * sin + this.ty * cos;
            return this;
        }
        /**
         * Appends the given Matrix to this Matrix.
         *
         * @param {Matrix2x3} matrix - The matrix to append.
         * @return {Matrix2x3} This matrix. Good for chaining method calls.
         */
        append(matrix) {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
            this.a = matrix.a * a1 + matrix.b * c1;
            this.b = matrix.a * b1 + matrix.b * d1;
            this.c = matrix.c * a1 + matrix.d * c1;
            this.d = matrix.c * b1 + matrix.d * d1;
            this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
            this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
            return this;
        }
        /**
         * Prepends the given Matrix to this Matrix.
         *
         * @param {Matrix2x3} matrix - The matrix to prepend
         * @return {Matrix2x3} This matrix. Good for chaining method calls.
         */
        prepend(matrix) {
            var tx1 = this.tx;
            if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
                var a1 = this.a;
                var c1 = this.c;
                this.a = a1 * matrix.a + this.b * matrix.c;
                this.b = a1 * matrix.b + this.b * matrix.d;
                this.c = c1 * matrix.a + this.d * matrix.c;
                this.d = c1 * matrix.b + this.d * matrix.d;
            }
            this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
            this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
            return this;
        }
        /**
         * Inverts this matrix
         *
         * @return {Matrix2x3} This matrix. Good for chaining method calls.
         */
        invert() {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
            var tx1 = this.tx;
            var n = a1 * d1 - b1 * c1;
            this.a = d1 / n;
            this.b = -b1 / n;
            this.c = -c1 / n;
            this.d = a1 / n;
            this.tx = (c1 * this.ty - d1 * tx1) / n;
            this.ty = -(a1 * this.ty - b1 * tx1) / n;
            return this;
        }
        /**
         * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
         *
         * @param {Transform} transform - The transform to apply the properties to.
         * @return {Transform} The transform with the newly applied properties
         */
        decompose(transform) {
            // sort out rotation / skew..
            var a = this.a;
            var b = this.b;
            var c = this.c;
            var d = this.d;
            var skewX = -Math.atan2(-c, d);
            var skewY = Math.atan2(b, a);
            var delta = Math.abs(skewX + skewY);
            if (delta < 0.00001 || Math.abs((Math.PI * 2) - delta) < 0.00001) {
                transform.rotation = skewY;
                transform.skew.x = transform.skew.y = 0;
            }
            else {
                transform.rotation = 0;
                transform.skew.x = skewX;
                transform.skew.y = skewY;
            }
            // next set scale
            transform.scale.x = Math.sqrt(a * a + b * b);
            transform.scale.y = Math.sqrt(c * c + d * d);
            // next set position
            transform.position.x = this.tx;
            transform.position.y = this.ty;
            return transform;
        }
        ;
        /**
         * Resets this Matix to an identity (default) matrix.
         *
         * @return {Matrix2x3} This matrix. Good for chaining method calls.
         */
        identity() {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.tx = 0;
            this.ty = 0;
            return this;
        }
        /**
         * Creates a new Matrix object with the same values as this one.
         *
         * @return {Matrix2x3} A copy of this matrix. Good for chaining method calls.
         */
        clone() {
            var matrix = new Matrix2x3();
            matrix.a = this.a;
            matrix.b = this.b;
            matrix.c = this.c;
            matrix.d = this.d;
            matrix.tx = this.tx;
            matrix.ty = this.ty;
            return matrix;
        }
        /**
         * Changes the values of the given matrix to be the same as the ones in this matrix
         *
         * @param {Matrix2x3} matrix - The matrix to copy from.
         * @return {Matrix2x3} The matrix given in parameter with its values updated.
         */
        copy(matrix) {
            matrix.a = this.a;
            matrix.b = this.b;
            matrix.c = this.c;
            matrix.d = this.d;
            matrix.tx = this.tx;
            matrix.ty = this.ty;
            return matrix;
        }
        // Array conversion
        /**
         * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
         *
         * a = array[0]
         * b = array[1]
         * c = array[3]
         * d = array[4]
         * tx = array[2]
         * ty = array[5]
         *
         * @param {number[]} array - The array that the matrix will be populated from.
         */
        fromArray(array) {
            this.a = array[0];
            this.b = array[1];
            this.c = array[3];
            this.d = array[4];
            this.tx = array[2];
            this.ty = array[5];
        }
        /**
         * Creates an array from the current Matrix object.
         *
         * @param {boolean} transpose - Whether we need to transpose the matrix or not
         * @param {Float32Array} [out=new Float32Array(9)] - If provided the array will be assigned to out
         * @return {number[]} the newly created array which contains the matrix
         */
        toArray(transpose, out) {
            if (!this.array) {
                this.array = new Float32Array(9);
            }
            var array = out || this.array;
            if (transpose) {
                array[0] = this.a;
                array[1] = this.b;
                array[2] = 0;
                array[3] = this.c;
                array[4] = this.d;
                array[5] = 0;
                array[6] = this.tx;
                array[7] = this.ty;
                array[8] = 1;
            }
            else {
                array[0] = this.a;
                array[1] = this.c;
                array[2] = this.tx;
                array[3] = this.b;
                array[4] = this.d;
                array[5] = this.ty;
                array[6] = 0;
                array[7] = 0;
                array[8] = 1;
            }
            return array;
        }
        // Getters and setters
        /**
         * Getter a
         * @return {number}
         */
        get a() {
            return this._a;
        }
        /**
         * Getter b
         * @return {number}
         */
        get b() {
            return this._b;
        }
        /**
         * Getter c
         * @return {number}
         */
        get c() {
            return this._c;
        }
        /**
         * Getter d
         * @return {number}
         */
        get d() {
            return this._d;
        }
        /**
         * Getter tx
         * @return {number}
         */
        get tx() {
            return this._tx;
        }
        /**
         * Getter ty
         * @return {number}
         */
        get ty() {
            return this._ty;
        }
        /**
         * Setter a
         * @param {number} value
         */
        set a(value) {
            this._a = value;
        }
        /**
         * Setter b
         * @param {number} value
         */
        set b(value) {
            this._b = value;
        }
        /**
         * Setter c
         * @param {number} value
         */
        set c(value) {
            this._c = value;
        }
        /**
         * Setter d
         * @param {number} value
         */
        set d(value) {
            this._d = value;
        }
        /**
         * Setter tx
         * @param {number} value
         */
        set tx(value) {
            this._tx = value;
        }
        /**
         * Setter ty
         * @param {number} value
         */
        set ty(value) {
            this._ty = value;
        }
    }
    exports.Matrix2x3 = Matrix2x3;
});
define("src/engine/general/OBB", ["require", "exports", "src/engine/general/AABB", "src/engine/math/Vector2"], function (require, exports, AABB_1, Vector2_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OBB = void 0;
    // Oriented bounding box
    class OBB {
        constructor(topLeft, topRight, bottomLeft, bottomRight) {
            this.topLeft = topLeft;
            this.topRight = topRight;
            this.bottomLeft = bottomLeft;
            this.bottomRight = bottomRight;
        }
        getAabb() {
            let minX = Math.min(this.topLeft.x, this.topRight.x, this.bottomLeft.x, this.bottomRight.x);
            let maxX = Math.max(this.topLeft.x, this.topRight.x, this.bottomLeft.x, this.bottomRight.x);
            let minY = Math.min(this.topLeft.y, this.topRight.y, this.bottomLeft.y, this.bottomRight.y);
            let maxY = Math.max(this.topLeft.y, this.topRight.y, this.bottomLeft.y, this.bottomRight.y);
            let aabb = new AABB_1.AABB(new Vector2_3.Vector2(minX, minY), new Vector2_3.Vector2(maxX, maxY));
            return aabb;
        }
        transform(transformMatrix) {
            let transformedTopLeft = transformMatrix.apply(this.topLeft);
            let transformedTopRight = transformMatrix.apply(this.topRight);
            let transformedBottomLeft = transformMatrix.apply(this.bottomLeft);
            let transformedBottomRight = transformMatrix.apply(this.bottomRight);
            let transformedObb = new OBB(transformedTopLeft, transformedTopRight, transformedBottomLeft, transformedBottomRight);
            return transformedObb;
        }
        toString() {
            return "topLeft x: " + this.topLeft.x + ", topLeft y: " + this.topLeft.y + "\n" +
                "topRight x: " + this.topRight.x + ", topRight y: " + this.topRight.y + "\n" +
                "bottomLeft x: " + this.bottomLeft.x + ", bottomLeft y: " + this.bottomLeft.y + "\n" +
                "bottomRight x: " + this.bottomRight.x + ", bottomRight y: " + this.bottomRight.y + "\n";
        }
    }
    exports.OBB = OBB;
});
define("src/engine/utils/IntersectionUtils", ["require", "exports", "src/engine/math/Vector2"], function (require, exports, Vector2_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntersectionUtils = void 0;
    class IntersectionUtils {
        // Line segment intersection
        static getIntersectingPointOfTwoVectors(v1, v2, e1, e2) {
            let x1 = v1.x;
            let y1 = v1.y;
            let x2 = v2.x;
            let y2 = v2.y;
            let x3 = e1.x;
            let y3 = e1.y;
            let x4 = e2.x;
            let y4 = e2.y;
            let denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
            if (denominator === 0) {
                // Lines are parallel or coincident.
                return null;
            }
            // u_a
            let numerator_ua = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
            let u_a = numerator_ua / denominator;
            // u_b
            let numerator_ub = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
            let u_b = numerator_ub / denominator;
            // Line segments only intersect if both u_a and u_b are in (0,1).
            // We use open intervals to prevent vector "touches" to be considered as intersections.
            // For numerical stability, we add a small number (epsilon) to the bounds.
            let epsilon = 0.0001;
            let lowerBound = 0.0 + epsilon;
            let upperBound = 1.0 - epsilon;
            if (u_a > lowerBound && u_a < upperBound && u_b > lowerBound && u_b < upperBound) {
                // Intersection point
                let x = x1 + u_a * (x2 - x1);
                let y = y1 + u_a * (y2 - y1);
                let intersectingPoint = new Vector2_4.Vector2(x, y);
                return intersectingPoint;
            }
            else {
                return null;
            }
        }
        // Intersection test - AABB <> AABB
        static testAabbAabbIntersection(a, b) {
            return !(b.max.x < a.min.x || a.max.x < b.min.x ||
                b.max.y < a.min.y || a.max.y < b.min.y);
        }
        // Intersection test - AABB <> Circle
        static testAabbCircleIntersection(aabb, circleCenter, radius) {
            const cx = circleCenter.x;
            const cy = circleCenter.y;
            const rx = aabb.min.x;
            const ry = aabb.min.y;
            const rw = aabb.width;
            const rh = aabb.height;
            // temporary variables to set edges for testing
            let testX = cx;
            let testY = cy;
            // which edge is closest?
            if (cx < rx)
                testX = rx; // test left edge
            else if (cx > rx + rw)
                testX = rx + rw; // right edge
            if (cy < ry)
                testY = ry; // top edge
            else if (cy > ry + rh)
                testY = ry + rh; // bottom edge
            // get distance from closest edges
            const distX = cx - testX;
            const distY = cy - testY;
            const distance = Math.sqrt((distX * distX) + (distY * distY));
            // if the distance is less than the radius, collision!
            if (distance <= radius) {
                return true;
            }
            return false;
        }
        static testAabbPolygonIntersection(aabb, points) {
            const polygonA = [
                new Vector2_4.Vector2(aabb.min.x, aabb.min.y),
                new Vector2_4.Vector2(aabb.max.x, aabb.min.y),
                new Vector2_4.Vector2(aabb.max.x, aabb.max.y),
                new Vector2_4.Vector2(aabb.min.x, aabb.max.y)
            ];
            const polygonB = points;
            return this.testPolygonPolygonIntersection(polygonA, polygonB);
        }
        // Intersection test - Polygon <> Polygon
        static testPolygonPolygonIntersection(polygonA, polygonB) {
            // Test whether any point is inside another
            for (let i = 0; i < polygonA.length; i++) {
                const point = polygonA[i];
                if (this.testPointPolygonIntersection(point, polygonB)) {
                    return true;
                }
            }
            for (let i = 0; i < polygonB.length; i++) {
                const point = polygonB[i];
                if (this.testPointPolygonIntersection(point, polygonA)) {
                    return true;
                }
            }
            return false;
        }
        // Intersection test - Point <> Circle
        static testPointCircleIntersection(point, circleCenter, circleRadius) {
            const distance = Vector2_4.Vector2.getDistanceBetweenPoints(point, circleCenter);
            return distance <= circleRadius;
        }
        // Intersection test - Point <> AABB
        static testPointAabbIntersection(point, aabb) {
            return ((point.x >= aabb.min.x) && (point.x <= aabb.max.x) &&
                (point.y >= aabb.min.y) && (point.y <= aabb.max.y));
        }
        // Intersection test - Point <> Polygon
        static testPointPolygonIntersection(point, polygon) {
            // 1. input validation
            if (polygon.length === 0) {
                // Malformed geofences are not allowed to intersect
                return false;
            }
            // 3. quick check, if the point is outside of the polygon max range
            let xMax = -Infinity;
            let xMin = +Infinity;
            let yMax = -Infinity;
            let yMin = +Infinity;
            for (let i = 0; i < polygon.length; i++) {
                let point = polygon[i];
                if (point.x > xMax) {
                    xMax = point.x;
                }
                if (point.x < xMin) {
                    xMin = point.x;
                }
                if (point.y > yMax) {
                    yMax = point.y;
                }
                if (point.y < yMin) {
                    yMin = point.y;
                }
            }
            if (point.x < xMin || point.x > xMax || point.y < yMin || point.y > yMax) {
                return false;
            }
            // 4. raycast check
            const rayStartPoint = new Vector2_4.Vector2(0.0, 0.0);
            let intersections = 0;
            for (let currentIndex = 0; currentIndex < polygon.length; currentIndex++) {
                const nextIndex = (currentIndex + 1) % polygon.length;
                const currentPoint = polygon[currentIndex];
                const nextPoint = polygon[nextIndex];
                //if the point is right on a polygon point it is inside
                //or if it is right on a polygon line it is as well inside
                if (IntersectionUtils.isPointEqualTo(currentPoint, point) || IntersectionUtils.isPointOnLine(currentPoint, nextPoint, point)) {
                    return true;
                }
                //check the intersections with the lines
                if (IntersectionUtils.isIntersected(point, rayStartPoint, currentPoint, nextPoint)) {
                    intersections++;
                }
                //check if rayLine intersects with a vertex and decrement intersections since it counts twice
                if (IntersectionUtils.isPointOnLine(rayStartPoint, point, currentPoint)) {
                    //if so check if the rayLine is the same Line as the polygon line and decrement again
                    const v1x1 = rayStartPoint.x - point.x;
                    const v1x2 = rayStartPoint.y - point.y;
                    const v2x1 = nextPoint.x - currentPoint.x;
                    const v2x2 = nextPoint.y - currentPoint.y;
                    if (IntersectionUtils.isCollinear(v1x1, v1x2, v2x1, v2x2)) {
                        intersections--;
                    }
                    intersections--;
                }
            }
            return intersections % 2 != 0;
        }
        // Helper methods
        static isPointEqualTo(point, point2) {
            return point2.x == point.x && point2.y == point.y;
        }
        static isCollinear(v1x1, v1x2, v2x1, v2x2) {
            return v1x1 * v2x2 == v1x2 * v2x1;
        }
        static isPointOnLine(startPoint, endPoint, targetPoint) {
            const v1x1 = startPoint.x;
            const v1x2 = startPoint.y;
            const v2x1 = endPoint.x - v1x1;
            const v2x2 = endPoint.y - v1x2;
            const dif1 = targetPoint.x - v1x1;
            const dif2 = targetPoint.y - v1x2;
            const leftEq = dif1 * v2x2;
            const rightEq = dif2 * v2x1;
            if (leftEq != rightEq) {
                return false;
            }
            let factor;
            if (Math.abs(v2x1) >= Math.abs(v2x2)) {
                factor = dif1 / v2x1;
            }
            else {
                factor = dif2 / v2x2;
            }
            return factor <= 1.0 && factor >= 0.0;
        }
        static isIntersected(targetPoint, rayStartPoint, p1, p2) {
            return IntersectionUtils.linesIntersect(rayStartPoint.x, rayStartPoint.y, targetPoint.x, targetPoint.y, p1.x, p1.y, p2.x, p2.y);
        }
        static linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
            return ((IntersectionUtils.relativeCCW(x1, y1, x2, y2, x3, y3) *
                IntersectionUtils.relativeCCW(x1, y1, x2, y2, x4, y4) <= 0)
                && (IntersectionUtils.relativeCCW(x3, y3, x4, y4, x1, y1) *
                    IntersectionUtils.relativeCCW(x3, y3, x4, y4, x2, y2) <= 0));
        }
        static relativeCCW(x1, y1, x2, y2, px, py) {
            x2 -= x1;
            y2 -= y1;
            px -= x1;
            py -= y1;
            let ccw = px * y2 - py * x2;
            if (ccw == 0.0) {
                // The point is colinear, classify based on which side of
                // the segment the point falls on.  We can calculate a
                // relative value using the projection of px,py onto the
                // segment - a negative value indicates the point projects
                // outside of the segment in the direction of the particular
                // endpoint used as the origin for the projection.
                ccw = px * x2 + py * y2;
                if (ccw > 0.0) {
                    // Reverse the projection to be relative to the original x2,y2
                    // x2 and y2 are simply negated.
                    // px and py need to have (x2 - x1) or (y2 - y1) subtracted
                    //    from them (based on the original values)
                    // Since we really want to get a positive answer when the
                    //    point is "beyond (x2,y2)", then we want to calculate
                    //    the inverse anyway - thus we leave x2 & y2 negated.
                    px -= x2;
                    py -= y2;
                    ccw = px * x2 + py * y2;
                    if (ccw < 0.0) {
                        ccw = 0.0;
                    }
                }
            }
            return (ccw < 0.0) ? -1 : ((ccw > 0.0) ? 1 : 0);
        }
    }
    exports.IntersectionUtils = IntersectionUtils;
});
define("src/engine/general/AABB", ["require", "exports", "src/engine/general/OBB", "src/engine/math/Vector2", "src/engine/utils/IntersectionUtils"], function (require, exports, OBB_1, Vector2_5, IntersectionUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AABB = void 0;
    // Axis aligned bounding box
    class AABB {
        constructor(min, max) {
            this.min = min;
            this.max = max;
        }
        getObb() {
            let topLeft = new Vector2_5.Vector2(this.min.x, this.min.y);
            let topRight = new Vector2_5.Vector2(this.max.x, this.min.y);
            let bottomLeft = new Vector2_5.Vector2(this.min.x, this.max.y);
            let bottomRight = new Vector2_5.Vector2(this.max.x, this.max.y);
            return new OBB_1.OBB(topLeft, topRight, bottomLeft, bottomRight);
        }
        intersects(aabb) {
            return IntersectionUtils_1.IntersectionUtils.testAabbAabbIntersection(this, aabb);
        }
        innerIntersects(aabb) {
            return !(aabb.max.x <= this.min.x || this.max.x <= aabb.min.x ||
                aabb.max.y <= this.min.y || this.max.y <= aabb.min.y);
        }
        // Derived methods
        get x() {
            return this.min.x;
        }
        get y() {
            return this.min.y;
        }
        get width() {
            return this.max.x - this.min.x;
        }
        get height() {
            return this.max.y - this.min.y;
        }
        get center() {
            return Vector2_5.Vector2.add(this.min, this.max).divide(2);
        }
        // Object methods
        toString() {
            return "minx: " + this.min.x + ", miny: " + this.min.y + "\n" +
                "maxx: " + this.max.x + ", maxy: " + this.max.y + "\n";
        }
        clone() {
            return new AABB(new Vector2_5.Vector2(this.min.x, this.min.y), new Vector2_5.Vector2(this.max.x, this.max.y));
        }
    }
    exports.AABB = AABB;
});
define("src/engine/locale/Localization", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Localization = void 0;
    class Localization {
    }
    exports.Localization = Localization;
});
define("src/engine/locale/UnresolvedLocalization", ["require", "exports", "src/engine/locale/Localization"], function (require, exports, Localization_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnresolvedLocalization = void 0;
    class UnresolvedLocalization extends Localization_1.Localization {
        getLocalizedStringFor(placeholderString) {
            return placeholderString;
        }
    }
    exports.UnresolvedLocalization = UnresolvedLocalization;
});
define("src/engine/rendering/texture/Texture", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Texture = void 0;
    var Texture;
    (function (Texture) {
        class Config {
            constructor() {
                /**
                 * True, if mipmapping is enabled (This will only be considered, if WebGL is used for rendering).
                 */
                this.mipmap = true;
            }
        }
        Texture.Config = Config;
    })(Texture = exports.Texture || (exports.Texture = {}));
});
define("src/engine/rendering/objects/text/TextStyle", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/engine/rendering/utils/Matrix", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/engine/rendering/objects/DisplayObject", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/engine/rendering/objects/DisplayObjectContainer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/engine/rendering/objects/GraphicsObject", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/engine/rendering/objects/SpriteObject", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/engine/rendering/objects/TextObject", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/engine/rendering/Renderer", ["require", "exports", "src/engine/math/Vector2"], function (require, exports, Vector2_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Renderer = void 0;
    /**
     * A renderer that renders instances of the {@link Scene} class to a rendering
     * target of size {@link Renderer#canvasSize}.
     *
     * <p>The renderer will create an {@link HTMLElement} during construction that
     * can be attached to the DOM afterwards by using the {@link Renderer#getHtmlElement} method.</p>
     *
     * <p>Before rendering, all resources (e.g. textures) should be
     * preloaded (e.g. if the renderer uses WebGL).</p>
     * <p>
     * After the resources have been loaded, the renderer renders the scenes in the
     * order given in the {@link Renderer#render} method.
     * </p>
     */
    class Renderer {
        // Construction
        /**
         * Creates a new renderer instance.
         */
        constructor(config) {
            // State
            this._dirty = true;
            this.config = config;
        }
        /**
         * The width and height of the render target given in pixels.
         */
        get renderTargetSize() {
            return this.config.renderTargetSize;
        }
        // Rendering resolution
        /**
         *
         * The ratio between physical pixels and device-independent pixels (dips) on
         * the device.
         *
         * <p>Default: window.devicePixelRatio</p>
         *
         * @return {number} the device's pixel ratio
         */
        get pixelRatio() {
            return this.config.pixelRatio;
        }
        // Rendering state
        /**
         * True, if the renderer's state has changed.
         *
         * <p>This field can be set to true by all display objects, when its state change makes
         * a rerendering necessary.</p>
         *
         * @return {boolean }
         */
        get dirty() {
            return this._dirty;
        }
        /**
         * Sets the renderer's dirty flag to {@code dirty}.
         *
         * <p>The dirty flag should only be set to true, if the render target should be rerendered completely.</p>
         *
         * @param {boolean } value
         */
        set dirty(value) {
            this._dirty = value;
        }
        /**
         * Creates a new matrix instance with the same values as in {@code m}.
         *
         * @param m the matrix to be adapted.
         */
        newMatrixFromMatrix(m) {
            return this.newMatrix(m.a, m.b, m.c, m.d, m.tx, m.ty);
        }
        /**
         * Creates a new point having the same value as {@code v}.
         *
         * @param v the vector to be adapted.
         */
        newPointFromVector2(v) {
            return this.newPoint(v.x, v.y);
        }
        /**
         * Creates a new point array based on the vector path {@code path}.
         *
         * @param path the path to be adapted.
         */
        newPointFromVector2Array(path) {
            let points = new Array();
            for (let i = 0; i < path.length; i++) {
                let point = path[i];
                points.push(this.newPointFromVector2(point));
            }
            return points;
        }
        // Getters and setters
        getConfig() {
            return this.config;
        }
    }
    exports.Renderer = Renderer;
    (function (Renderer) {
        /**
         * Maps a resource identifier to its source URL.
         */
        class ResourceDescription {
        }
        Renderer.ResourceDescription = ResourceDescription;
        class Config {
            constructor() {
                /**
                 * The width and height of the render target (e.g. canvas, WebGL context) given in pixels.
                 */
                this.renderTargetSize = new Vector2_6.Vector2(window.innerWidth, window.innerHeight);
                /**
                 * The ratio between physical pixels and device-independent pixels (dips) on the device.
                 *
                 * Default: window.devicePixelRatio
                 */
                this.pixelRatio = window.devicePixelRatio;
                /**
                 * The CORS settings used when loading resources (e.g. images).
                 *
                 * <p>Possible values can be found in
                 * <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes">CORS settings attributes</a></p>
                 *
                 * <p>Default: "use-credentials"</p>
                 */
                this.crossOriginAttribute = "use-credentials";
            }
        }
        Renderer.Config = Config;
        /**
         * Options for the render function.
         */
        class RenderingOptions {
            constructor() {
                /**
                 * True, if the pixels should be rounded to the next integer value.
                 *
                 * <p>Default: false</p>
                 */
                this.roundPixels = false;
            }
        }
        Renderer.RenderingOptions = RenderingOptions;
    })(Renderer = exports.Renderer || (exports.Renderer = {}));
});
define("src/engine/scene/GameObject", ["require", "exports", "src/engine/locale/UnresolvedLocalization"], function (require, exports, UnresolvedLocalization_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GameObject = void 0;
    /**
     * Base class of all game objects.
     *
     * Methods can be overridden to handle the different events that may occur at runtime.
     */
    class GameObject {
        // Construction
        constructor(environment) {
            this.environment = environment;
        }
        // Life cycle events
        /**
         * Called, whenever the object has been initialized in the game.
         */
        initialize() {
            // Default: Empty implementation
        }
        /**
         * Called, whenever a new update cycle of the game needs to be performed
         * @param lastFrametime The number of milliseconds this function should simulate.
         */
        update(lastFrametime) {
            // Default: Empty implementation
        }
        /**
         * Called, whenever the object has been destroyed from the game.
         */
        destroy() {
            // Default: Empty implementation
        }
        // Mouse events
        /**
         * Called, whenever the mouse moved into the game canvas.
         * @param x x coordinate given in canvas screen pixels.
         * @param y y coordinate given in canvas screen pixels.
         */
        onMouseIn(x, y) {
            return false;
        }
        /**
         * Called, whenever the mouse move out of the game canvas.
         * @param x
         * @param y
         */
        onMouseOut(x, y) {
            return false;
        }
        /**
         * Called, whenever the mouse move started.
         * @param x
         * @param y
         */
        onMouseStart(x, y) {
            return false;
        }
        /**
         * Called, whenever the mouse move changed.
         * @param x
         * @param y
         */
        onMouseMove(x, y) {
            return false;
        }
        /**
         * Called, whenever the mouse move ends.
         * @param x
         * @param y
         */
        onMouseEnd(x, y) {
            return false;
        }
        /**
         * Called, whenever the mouse wheel is used.
         * @param delta delta = -1, on mouse wheel down, delta = 1, on mouse wheel up
         * @param mouseX
         * @param mouseY
         */
        onMouseWheel(delta, mouseX, mouseY) {
            return false;
        }
        // Touch events
        /**
         * Called, whenever the touch or mouse click event started.
         * @param x
         * @param y
         */
        onTouchStart(x, y, touchIndex) {
            return false;
        }
        /**
         * Called, whenever the touch or mouse click moved.
         * @param x
         * @param y
         */
        onTouchMove(x, y, touchIndex) {
            return false;
        }
        /**
         * Called, whenever the touch of mouse click was released.
         * @param x
         * @param y
         */
        onTouchEnd(x, y, touchIndex) {
            return false;
        }
        // Key events
        /**
         * Called, whenever a key was pressed on the keyboard.
         * @param keyCode
         */
        onKeyDown(keyCode) {
            return false;
        }
        /**
         * Called, whenever a key was released on the keyboard.
         */
        onKeyUp(keyCode) {
            return false;
        }
        // Gesture events
        onPanningStart(x, y) {
            return false;
        }
        onPanningMove(x, y) {
            return false;
        }
        onPanningEnd(x, y) {
            return false;
        }
        onPinchingStart(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            return false;
        }
        onPinchingMove(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            return false;
        }
        onPinchingEnd(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            return false;
        }
        onRotatingStart(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            return false;
        }
        onRotatingMove(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            return false;
        }
        onRotatingEnd(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            return false;
        }
        onTap(x, y, numTaps) {
            return false;
        }
        // Localization events
        /**
         * Called, whenever the localization has changed.
         * This method must return false.
         */
        onLocalizationChanged() {
            return false;
        }
        getLocalization() {
            return this.environment.localization;
        }
        getLocalizedStringFor(placeholder) {
            return this.environment.localization.getLocalizedStringFor(placeholder);
        }
        // Package local!
        changeLocalization(localization) {
            this.environment.localization = localization;
        }
        // Resize events
        /**
         * Called, whenever the game canvas has been resized.
         * The new canvas width and height can be obtained using the
         * {@link getCanvasWidthInPx} and {@link getCanvasHeightInPx} methods.
         */
        onResize() {
            // Empty default implementation
        }
        getCanvasWidthInPx() {
            return this.environment.renderer.renderTargetSize.x;
        }
        getCanvasHeightInPx() {
            return this.environment.renderer.renderTargetSize.y;
        }
        getCanvasSizeInPx() {
            return this.environment.renderer.renderTargetSize;
        }
        // Package local
        setCanvasSizeInPx(widthInPx, heightInPx) {
            this.environment.renderer.renderTargetSize.x = widthInPx;
            this.environment.renderer.renderTargetSize.y = heightInPx;
        }
        // Getters and setters
        getEnvironment() {
            return this.environment;
        }
    }
    exports.GameObject = GameObject;
    (function (GameObject) {
        class Environment {
            constructor() {
                // Rendering
                // Locale
                /**
                 * The initial localization for english or german
                 * text translations.
                 * E.g. LocalizationDe or LocalizationEn
                 */
                this.localization = new UnresolvedLocalization_1.UnresolvedLocalization();
            }
        }
        GameObject.Environment = Environment;
    })(GameObject = exports.GameObject || (exports.GameObject = {}));
});
define("src/engine/scene/Camera", ["require", "exports", "src/engine/scene/SceneObject", "src/engine/math/Vector2", "src/engine/general/OBB", "src/engine/math/Matrix2x3", "src/engine/math/Transform"], function (require, exports, SceneObject_1, Vector2_7, OBB_2, Matrix2x3_2, Transform_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Camera = void 0;
    class Camera extends SceneObject_1.SceneObject {
        constructor(environment, screenWidth = environment.renderer.renderTargetSize.x, screenHeight = environment.renderer.renderTargetSize.y) {
            super(environment);
            // Cached data
            this.transform = new Transform_1.Transform();
            this.container = this.getEnvironment().renderer.newDisplayObjectContainer();
            this.screenWidth = screenWidth;
            this.screenHeight = screenHeight;
        }
        getView() {
            return this.container;
        }
        // Sets the pivot in world coordinates.
        setPivotX(pivotX) {
            this.container.pivot.x = pivotX;
        }
        // Return the pivot in world coordinates.
        getPivotX() {
            return this.container.pivot.x;
        }
        // Sets the pivot in world coordinates.
        setPivotY(pivotY) {
            this.container.pivot.y = pivotY;
        }
        // Return the pivot in world coordinates.
        getPivotY() {
            return this.container.pivot.y;
        }
        // Sets the camera's x translation in the world system.
        setX(x) {
            this.container.x = -x;
        }
        // Returns the camera's x coordinate in the world system.
        getX() {
            return -this.container.x;
        }
        // Sets the camera's y translation in the world system.
        setY(y) {
            this.container.y = -y;
        }
        // Returns the camera's y coordinate in the world system.
        getY() {
            return -this.container.y;
        }
        setTranslation(point) {
            this.setX(point.x);
            this.setY(point.y);
        }
        // Sets the camera's rotation in radian.
        setRotation(rotation) {
            this.container.rotation = -rotation;
        }
        // Returns the camera's rotation in radian.
        getRotation() {
            return -this.container.rotation;
        }
        // Sets the camera's scale in x direction.
        // scaleX = 2.0 means, the camera zooms out with factor 2
        setScaleX(scaleX) {
            this.container.scale.x = 1.0 / scaleX;
        }
        // Returns the camera's scale in x direction.
        getScaleX() {
            return 1.0 / this.container.scale.x;
        }
        // Sets the camera's scale in y direction.
        setScaleY(scaleY) {
            this.container.scale.y = 1.0 / scaleY;
        }
        // Returns the camera's scale in y direction.
        getScaleY() {
            return 1.0 / this.container.scale.y;
        }
        // Translates the camera with the passed vector in camera coordinates.
        translate(translation) {
            let localTransformMatrix = this.container.localTransform;
            localTransformMatrix = localTransformMatrix.translate(-translation.x, -translation.y);
            this.updateLocalTransform(localTransformMatrix);
        }
        // Rotates the camera around the focus point (in camera coordinates) without
        // changing the origin of the camera's local coordinate system.
        rotate(rotationAngle, focusPoint) {
            let localTransformMatrix = this.container.localTransform;
            localTransformMatrix = localTransformMatrix.translate(-focusPoint.x, -focusPoint.y);
            localTransformMatrix = localTransformMatrix.rotate(-rotationAngle);
            localTransformMatrix = localTransformMatrix.translate(focusPoint.x, focusPoint.y);
            this.updateLocalTransform(localTransformMatrix);
        }
        // Scales the camera to/from the focus point given in camera coordinates without
        // changing the origin of the camera's local coordinate system.
        scale(scaleX, scaleY, focusPoint) {
            let localTransformMatrix = this.container.localTransform;
            localTransformMatrix = localTransformMatrix.translate(-focusPoint.x, -focusPoint.y);
            localTransformMatrix = localTransformMatrix.scale(1 / scaleX, 1 / scaleY);
            localTransformMatrix = localTransformMatrix.translate(focusPoint.x, focusPoint.y);
            this.updateLocalTransform(localTransformMatrix);
        }
        updateLocalTransform(localTransformMatrix) {
            let m = new Matrix2x3_2.Matrix2x3(localTransformMatrix.a, localTransformMatrix.b, localTransformMatrix.c, localTransformMatrix.d, localTransformMatrix.tx, localTransformMatrix.ty);
            m.decompose(this.transform);
            this.container.setTransform(this.transform.position.x, this.transform.position.y, this.transform.scale.x, this.transform.scale.y, this.transform.rotation, this.transform.skew.x, this.transform.skew.y, this.transform.pivot.x, this.transform.pivot.y);
        }
        // Maps a point in the world coordinate system to the camera system.
        getImageCoordinateFromWorldPoint(worldPoint) {
            let point = this.getEnvironment().renderer.newPointFromVector2(worldPoint);
            return Vector2_7.Vector2.getVector2(this.container.toGlobal(point, point));
        }
        // Maps a point in the camera coordinate system to the world system.
        getWorldCoordinateFromImagePoint(imagePoint) {
            let point = this.getEnvironment().renderer.newPointFromVector2(imagePoint);
            return Vector2_7.Vector2.getVector2(this.container.toLocal(point, point));
        }
        getPixelsInTexels(numPixels) {
            let sourceInTexels = this.getWorldCoordinateFromImagePoint(new Vector2_7.Vector2(0, 0));
            let targetInTexels = this.getWorldCoordinateFromImagePoint(new Vector2_7.Vector2(numPixels, 0));
            let diffVectorInTexels = new Vector2_7.Vector2(targetInTexels.x - sourceInTexels.x, targetInTexels.y - sourceInTexels.y);
            let pixelsInTexels = Vector2_7.Vector2.getLengthOfPoint(diffVectorInTexels);
            return pixelsInTexels;
        }
        // Sets the camera's frustum in world coordinates.
        setFrustum(frustum) {
            // Reference OBB
            let topLeft = new Vector2_7.Vector2(0, 0);
            let topRight = new Vector2_7.Vector2(this.getScreenWidth(), 0);
            let bottomLeft = new Vector2_7.Vector2(0, this.getScreenHeight());
            let bottomRight = new Vector2_7.Vector2(this.getScreenWidth(), this.getScreenHeight());
            let referenceObb = new OBB_2.OBB(topLeft, topRight, bottomLeft, bottomRight);
            let referenceDirection = Vector2_7.Vector2.subtract(referenceObb.bottomRight, referenceObb.bottomLeft);
            let targetDirection = Vector2_7.Vector2.subtract(frustum.bottomRight, frustum.bottomLeft);
            // Scaling
            let referenceWidth = referenceDirection.getLength();
            let targetWidth = targetDirection.getLength();
            let scaleFactor = referenceWidth / targetWidth;
            let scaleMatrix = new Matrix2x3_2.Matrix2x3();
            scaleMatrix = scaleMatrix.scale(scaleFactor, scaleFactor);
            referenceObb = referenceObb.transform(scaleMatrix);
            // Rotation
            let angleInRad = Vector2_7.Vector2.getAngleBetween(referenceDirection, targetDirection);
            // Rotation sign
            let crossProduct = Vector2_7.Vector2.crossProduct(targetDirection, referenceDirection);
            if (crossProduct < 0) {
                angleInRad = -angleInRad;
            }
            let rotationMatrix = new Matrix2x3_2.Matrix2x3();
            rotationMatrix = rotationMatrix.rotate(angleInRad);
            referenceObb = referenceObb.transform(rotationMatrix);
            // Translate
            let scaleRotationMatrix = new Matrix2x3_2.Matrix2x3().scale(scaleFactor, scaleFactor).rotate(angleInRad);
            let transformedTopLeft = scaleRotationMatrix.apply(frustum.topLeft);
            let translationVector = new Vector2_7.Vector2(-transformedTopLeft.x, -transformedTopLeft.y);
            // Set Transform
            this.container.setTransform(translationVector.x, translationVector.y, scaleFactor, scaleFactor, angleInRad, 0, 0, 0, 0);
        }
        // Returns the camera's frustum in world coordinates.
        getFrustum() {
            // Transform the frustum from screen space to world space.
            let topLeft = new Vector2_7.Vector2(0, 0);
            let topRight = new Vector2_7.Vector2(this.screenWidth, 0);
            let bottomLeft = new Vector2_7.Vector2(0, this.screenHeight);
            let bottomRight = new Vector2_7.Vector2(this.screenWidth, this.screenHeight);
            let topLeftWorld = this.getWorldCoordinateFromImagePoint(topLeft);
            let topRightWorld = this.getWorldCoordinateFromImagePoint(topRight);
            let bottomLeftWorld = this.getWorldCoordinateFromImagePoint(bottomLeft);
            let bottomRightWorld = this.getWorldCoordinateFromImagePoint(bottomRight);
            let frustum = new Camera.Frustum(topLeftWorld, topRightWorld, bottomLeftWorld, bottomRightWorld);
            return frustum;
        }
        static getExtendedFrustum(oldCameraFrustum, aspectRatioBefore, aspectRatioAfter) {
            if (aspectRatioBefore > aspectRatioAfter) {
                return Camera.getHeightExtendedFrustum(oldCameraFrustum, aspectRatioAfter);
            }
            else if (aspectRatioBefore < aspectRatioAfter) {
                return Camera.getWidthExtendedFrustum(oldCameraFrustum, aspectRatioAfter);
            }
            else {
                return oldCameraFrustum;
            }
        }
        static getHeightExtendedFrustum(oldCameraFrustum, aspectRatioAfter) {
            const oldFrustumWidth = Vector2_7.Vector2.subtract(oldCameraFrustum.topRight, oldCameraFrustum.topLeft).getLength();
            const oldFrustumHeight = Vector2_7.Vector2.subtract(oldCameraFrustum.topLeft, oldCameraFrustum.bottomLeft).getLength();
            const newFrustumHeight = oldFrustumWidth / aspectRatioAfter;
            const scaleFactor = (newFrustumHeight - oldFrustumHeight) / 2;
            let extensionVector = Vector2_7.Vector2.subtract(oldCameraFrustum.topLeft, oldCameraFrustum.bottomLeft).normalize();
            extensionVector.multiply(scaleFactor);
            const topLeft = Vector2_7.Vector2.add(oldCameraFrustum.topLeft, extensionVector);
            const topRight = Vector2_7.Vector2.add(oldCameraFrustum.topRight, extensionVector);
            const bottomLeft = Vector2_7.Vector2.subtract(oldCameraFrustum.bottomLeft, extensionVector);
            const bottomRight = Vector2_7.Vector2.subtract(oldCameraFrustum.bottomRight, extensionVector);
            const newCameraFrustum = new Camera.Frustum(topLeft, topRight, bottomLeft, bottomRight);
            return newCameraFrustum;
        }
        static getWidthExtendedFrustum(oldCameraFrustum, aspectRatioAfter) {
            const oldFrustumWidth = Vector2_7.Vector2.subtract(oldCameraFrustum.topRight, oldCameraFrustum.topLeft).getLength();
            const oldFrustumHeight = Vector2_7.Vector2.subtract(oldCameraFrustum.topLeft, oldCameraFrustum.bottomLeft).getLength();
            const newFrustumWidth = oldFrustumHeight * aspectRatioAfter;
            const scaleFactor = (newFrustumWidth - oldFrustumWidth) / 2;
            let extensionVector = Vector2_7.Vector2.subtract(oldCameraFrustum.topLeft, oldCameraFrustum.topRight).normalize();
            extensionVector.multiply(scaleFactor);
            const topLeft = Vector2_7.Vector2.add(oldCameraFrustum.topLeft, extensionVector);
            const topRight = Vector2_7.Vector2.subtract(oldCameraFrustum.topRight, extensionVector);
            const bottomLeft = Vector2_7.Vector2.add(oldCameraFrustum.bottomLeft, extensionVector);
            const bottomRight = Vector2_7.Vector2.subtract(oldCameraFrustum.bottomRight, extensionVector);
            const newCameraFrustum = new Camera.Frustum(topLeft, topRight, bottomLeft, bottomRight);
            return newCameraFrustum;
        }
        getScreenWidth() {
            return this.screenWidth;
        }
        setScreenWidth(screenWidthInPx) {
            this.screenWidth = screenWidthInPx;
        }
        getScreenHeight() {
            return this.screenHeight;
        }
        setScreenHeight(screenHeightInPx) {
            this.screenHeight = screenHeightInPx;
        }
        update(lastFrametime) {
            super.update(lastFrametime);
        }
    }
    exports.Camera = Camera;
    (function (Camera) {
        class Frustum {
            constructor(topLeft, topRight, bottomLeft, bottomRight) {
                this.topLeft = topLeft;
                this.topRight = topRight;
                this.bottomLeft = bottomLeft;
                this.bottomRight = bottomRight;
            }
            getObb() {
                return new OBB_2.OBB(this.topLeft, this.topRight, this.bottomLeft, this.bottomRight);
            }
            static fromObb(obb) {
                let frustum = new Frustum(obb.topLeft, obb.topRight, obb.bottomLeft, obb.bottomRight);
                return frustum;
            }
        }
        Camera.Frustum = Frustum;
    })(Camera = exports.Camera || (exports.Camera = {}));
});
define("src/engine/scene/Scene", ["require", "exports", "src/engine/scene/GameObject", "src/engine/scene/Camera"], function (require, exports, GameObject_1, Camera_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Scene = void 0;
    class Scene extends GameObject_1.GameObject {
        // Construction
        constructor(environment) {
            super(environment);
            // Rendering
            this.roundPixels = false;
            // Scene objects
            this.camera = null;
            this.camera = new Camera_1.Camera(environment);
            this.setSceneGraph(this.camera);
            this.sceneObjects = new Array();
            this.sceneObjects.push(this.sceneGraph);
        }
        // Initialization
        initialize() {
            super.initialize();
            let sceneObjects = this.getSceneObjects();
            this.initializeSceneObjects(sceneObjects);
        }
        initializeSceneObjects(sceneObjects) {
            for (let i = 0; i < sceneObjects.length; i++) {
                let sceneObject = sceneObjects[i];
                if (!sceneObject.isInitialized()) {
                    sceneObject.setInitialized(true);
                    sceneObject.initialize();
                }
            }
        }
        // Locale
        changeLocalization(localization) {
            super.changeLocalization(localization);
            let sceneObjects = this.getSceneObjects();
            this.setLocalizationOnSceneObjects(sceneObjects, localization);
        }
        setLocalizationOnSceneObjects(sceneObjects, localization) {
            for (let i = 0; i < sceneObjects.length; i++) {
                let sceneObject = sceneObjects[i];
                sceneObject.changeLocalization(localization);
                sceneObject.onLocalizationChanged();
            }
        }
        onLocalizationChanged() {
            let sceneObjects = this.getSceneObjects();
            for (let i = 0; i < sceneObjects.length; i++) {
                let sceneObject = sceneObjects[i];
                sceneObject.onLocalizationChanged();
            }
            return false;
        }
        // Destruction
        destroy() {
            super.destroy();
            let sceneObjects = this.getSceneObjects();
            for (let i = 0; i < sceneObjects.length; i++) {
                let sceneObject = sceneObjects[i];
                sceneObject.destroy();
            }
        }
        // Updating
        update(lastFrametime) {
            super.update(lastFrametime);
            let sceneObjects = this.getSceneObjects();
            for (let i = 0; i < sceneObjects.length; i++) {
                let sceneObject = sceneObjects[i];
                if (!sceneObject.isPaused()) {
                    sceneObject.update(lastFrametime);
                }
            }
        }
        // Scene graph modification
        addSceneObject(sceneObject) {
            this.addSceneObjectToParent(sceneObject, this.sceneGraph);
        }
        addSceneObjectToParent(sceneObject, parent) {
            // 1. Check preconditions
            let sceneObjects = this.getSceneObjects();
            if (this.containsSceneObject(sceneObject)) {
                throw new Error("SceneObject could not be inserted, " +
                    "because the scene object is already in scene graph.");
            }
            if (!this.containsSceneObject(parent)) {
                throw new Error("SceneObject could not be inserted, " +
                    "because the parent object is not part of the scene.");
            }
            // 2. Insert into scene graph
            parent.addChild(sceneObject);
            // 3. Update scene graph
            this.updateSceneObjectsList();
            // 4. Notify scene object about parent change.
            sceneObject.onParentChanged();
        }
        setSceneObjectIndex(sceneObject, index) {
            let parent = sceneObject.getParent();
            if (parent == null) {
                throw new Error("The index of the scene object could not be changed, " +
                    "because the scene object does not contain a parent node and " +
                    "thus is not part of the scene graph.");
            }
            parent.setChildIndex(sceneObject, index);
            this.updateSceneObjectsList();
        }
        removeSceneObject(sceneObject) {
            // 1. Check preconditions
            let sceneObjects = this.getSceneObjects();
            if (!this.containsSceneObject(sceneObject)) {
                throw new Error("Scene object could not be removed, " +
                    "because the scene object is not part of the scene graph.");
            }
            // 2. Remove scene object
            let parent = sceneObject.getParent();
            parent.removeChild(sceneObject);
            // 3. Update scene graph
            this.updateSceneObjectsList();
            // 4. Notify scene object
            sceneObject.onParentChanged();
        }
        containsSceneObject(sceneObject) {
            for (let i = 0; i < this.sceneObjects.length; i++) {
                let currentSceneObject = this.sceneObjects[i];
                if (sceneObject.equals(currentSceneObject)) {
                    return true;
                }
            }
            return false;
        }
        // Package local! Should only be called by scene object or scene.
        // Is called, whenever the scene graph changes.
        updateSceneObjectsList() {
            if (this.sceneObjects) {
                this.sceneObjects = this.sceneGraph.getDescendantsAndSelf();
                // Initialize new scene objects
                let addedSceneObjects = this.getAddedSceneObjects(this.sceneObjects);
                this.initializeSceneObjects(addedSceneObjects);
            }
            else {
                this.sceneObjects = this.sceneGraph.getDescendantsAndSelf();
                // Initialize all scene objects
                this.initializeSceneObjects(this.sceneObjects);
            }
        }
        getAddedSceneObjects(allSceneObjects) {
            let newSceneObjects = new Array();
            for (let i = 0; i < allSceneObjects.length; i++) {
                let sceneObject = allSceneObjects[i];
                if (!sceneObject.isInitialized()) {
                    newSceneObjects.push(sceneObject);
                }
            }
            return newSceneObjects;
        }
        getSceneGraph() {
            return this.sceneGraph;
        }
        setSceneGraph(sceneObject) {
            this.sceneGraph = sceneObject;
            this.sceneGraph.setScene(this);
            this.updateSceneObjectsList();
        }
        getSceneObjects() {
            return this.sceneObjects;
        }
        setCamera(camera) {
            this.camera = camera;
            this.camera.setScene(this);
            let children = this.sceneGraph.getChildren();
            this.camera.addChildren(children);
            this.setSceneGraph(this.camera);
        }
        getCamera() {
            return this.camera;
        }
        // Event dispatching
        handleInputEvent(handlerName, values) {
            // Backward traverse through the list of scene objects
            // and delegate the input event to each scene object.
            // If the event has been processed, do not continue.
            // (Chain of responsibility).
            let sceneObjects = this.getSceneObjects();
            for (let i = sceneObjects.length - 1; i >= 0; i--) {
                let sceneObject = sceneObjects[i];
                if (!sceneObject.isPaused()) {
                    let handled = sceneObject[handlerName].apply(sceneObject, values);
                    if (handled) {
                        return true;
                    }
                }
            }
            return false;
        }
        handleResizeEvent(widthInPx, heightInPx) {
            super.setCanvasSizeInPx(widthInPx, heightInPx);
            let sceneObjects = this.getSceneObjects();
            this.setCanvasSizeOnSceneObjects(sceneObjects, widthInPx, heightInPx);
        }
        setCanvasSizeOnSceneObjects(sceneObjects, widthInPx, heightInPx) {
            for (let i = 0; i < sceneObjects.length; i++) {
                let sceneObject = sceneObjects[i];
                sceneObject.setCanvasSizeInPx(widthInPx, heightInPx);
            }
            for (let i = 0; i < sceneObjects.length; i++) {
                let sceneObject = sceneObjects[i];
                sceneObject.onResize();
            }
        }
        /**
         * Lets the visitor [[visitor]] visit (according to the visitor pattern) all
         * scene objects and return results for each scene object.
         *
         * <p>
         * Scene objects implementing the handler method [[handlerName]] can return
         * a result for the visit of the visitor [[visitor]]. If the handler returns
         * null, it is not added to the result map.
         * </p>
         *
         * <p>
         * Notice, that the scene graph will be traversed in reverse order.
         * </p>
         *
         * @param handlerName the name of the handler the visited scene object can
         * handle.
         * @param visitor the visitor
         * @returns a map mapping the visited scene object to its result.
         */
        visit(handlerName, visitor) {
            const resultMap = new Map();
            const sceneObjects = this.getSceneObjects();
            for (let i = sceneObjects.length - 1; i >= 0; i--) {
                const sceneObject = sceneObjects[i];
                if (typeof sceneObject[handlerName] === "function") {
                    const result = sceneObject[handlerName].apply(sceneObject, visitor);
                    if (result !== null) {
                        resultMap.set(sceneObject, result);
                    }
                }
            }
            return resultMap;
        }
        // Getters and setters
        setRoundPixels(roundPixels) {
            this.roundPixels = roundPixels;
        }
        isRoundPixels() {
            return this.roundPixels;
        }
    }
    exports.Scene = Scene;
});
define("src/engine/structs/SceneObjectIterator", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/engine/structs/SceneObjectListIterator", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SceneObjectListIterator = void 0;
    class SceneObjectListIterator {
        constructor(array) {
            this.array = array;
            this.pointer = -1;
        }
        hasNext() {
            return this.pointer + 1 <= this.array.length - 1;
        }
        next() {
            this.pointer++;
            return this.array[this.pointer];
        }
        remove() {
            throw new Error("UnsupportedOperationException");
        }
    }
    exports.SceneObjectListIterator = SceneObjectListIterator;
});
define("src/engine/scene/SceneObject", ["require", "exports", "src/engine/structs/SceneObjectListIterator", "src/engine/scene/GameObject"], function (require, exports, SceneObjectListIterator_1, GameObject_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SceneObject = void 0;
    // A scene object is a game object having a transformation
    // in the scene (position, rotation etc.) and can is part
    // of a hierarchical scene graph.
    class SceneObject extends GameObject_2.GameObject {
        // Initialization
        constructor(environment) {
            super(environment);
            // State
            this.initialized = false;
            this.paused = false;
            //// Scene graph
            // Back reference to the scene, which contains the scene object
            this.scene = null;
            // Back reference to the parent node in the scene graph.
            this.parent = null;
            this.sceneObjectEnvironment = environment;
            this.parent = null;
            this.children = new Array();
        }
        // Is the view that is finally used for rendering.
        // In most cases this equals getView().
        // @Override
        getRenderView() {
            return this.getView();
        }
        // General
        equals(sceneObject) {
            return this === sceneObject;
        }
        // Scene Graph
        getScene() {
            return this.scene;
        }
        setScene(scene) {
            // Set the own scene reference
            this.scene = scene;
            // Set the scene reference to all children recursively.
            for (let i = 0; i < this.getChildren().length; i++) {
                let child = this.getChildren()[i];
                child.setScene(scene);
            }
        }
        onParentChanged() {
            // Empty default implementation.
        }
        getParent() {
            return this.parent;
        }
        // Package local!
        setParent(parent) {
            if (this === parent) {
                throw new Error("Parent node could not be changed," +
                    "because parent node is identical with the node.");
            }
            let parentViewContainer = null;
            if (parent != null) {
                if (!(typeof parent.getView().addChild === 'function')) {
                    throw new Error("Parent node could not be changed, " +
                        "because the parent node's view is not a container.");
                }
                else {
                    parentViewContainer = parent.getView();
                }
            }
            let oldParent = this.parent;
            this.parent = parent;
            if (parent != null) {
                // The child should be in the same scene as the parent.
                this.setScene(parent.getScene());
                // Change parent-child relationship in display object scene hierarchy.
                this.getRenderView().setParent(parentViewContainer);
            }
            else {
                this.setScene(null);
                this.getRenderView().setParent(this.getEnvironment().renderer.newDisplayObjectContainer());
            }
        }
        getChildren() {
            return this.children;
        }
        // Returns all child nodes (recursively) including the node itself.
        // The list is ordered by preorder traversing.
        getDescendantsAndSelf() {
            let descendantsAndSelf = new Array();
            let iterator = new SceneObject.PreorderIterator(this);
            while (iterator.hasNext()) {
                let sceneObject = iterator.next();
                descendantsAndSelf.push(sceneObject);
            }
            return descendantsAndSelf;
        }
        // Package local! Should not be called outside this package.
        // Adds the scene object to the end of the list of all child nodes
        // and changes their parent node to the this node.
        addChild(child) {
            if (child == null) {
                throw new Error("Scene object could not be added as a child node, " +
                    "because scene object is null.");
            }
            if (child === this) {
                throw new Error("Scene object could not be added as child node, " +
                    "because scene object is identical with this node");
            }
            let oldParent = child.getParent();
            if (oldParent != null) {
                oldParent.removeChild(child);
            }
            this.children.push(child);
            child.setParent(this);
            // Both the old parent's scene and the new parent's scene must be updated.
            if (oldParent != null && oldParent.getScene() != null) {
                oldParent.getScene().updateSceneObjectsList();
            }
            if (this != null && this.getScene() != null) {
                this.getScene().updateSceneObjectsList();
            }
        }
        addChildren(children) {
            for (let i = 0; i < children.length; i++) {
                let child = children[i];
                this.addChild(child);
            }
        }
        // Removes the child from the list of all child nodes.
        removeChild(child) {
            if (!this.hasChild(child)) {
                return;
            }
            this.removeChildFromChildren(child);
            child.setParent(null);
            // Parent's scene has changed. Update object list in that scene.
            if (this.scene) {
                this.scene.updateSceneObjectsList();
            }
        }
        removeChildFromChildren(child) {
            let indexOfChild = this.getChildIndex(child);
            if (indexOfChild > -1) {
                this.children.splice(indexOfChild, 1);
            }
        }
        hasChild(child) {
            let indexOfChild = this.getChildIndex(child);
            if (indexOfChild === -1) {
                return false;
            }
            else {
                return true;
            }
        }
        setChildIndex(child, index) {
            if (!this.hasChild(child)) {
                throw new Error("Index of child could not be changed, " +
                    "because the object is not child of this node.");
            }
            if (index < 0 || index > this.children.length) {
                throw new Error("Index of child could not be changed, " +
                    "because the index is out of bounds.");
            }
            let container = null;
            if (!(typeof this.getView().addChild === 'function')) {
                throw new Error("Parent node could not be changed, " +
                    "because the parent node's view is not a container.");
            }
            else {
                container = this.getView();
            }
            let oldIndex = this.getChildIndex(child);
            if (index > oldIndex) {
                index--;
            }
            // Change the view container's scene graph.
            container.setChildIndex(child.getRenderView(), index);
            // Change the scene graph respectively.
            this.removeChildFromChildren(child);
            this.addChildAtIndex(index, child);
            // Scene has changed. Update object list in that scene.
            if (this.scene !== null) {
                this.scene.updateSceneObjectsList();
            }
        }
        addChildAtIndex(index, child) {
            // Inserts the item at index 'index'.
            this.children.splice(index, 0, child);
        }
        getChildIndex(child) {
            for (let i = 0; i < this.children.length; i++) {
                let currentChild = this.children[i];
                if (currentChild.equals(child)) {
                    return i;
                }
            }
            return -1;
        }
        addAfterObject(object, afterObject) {
            let index = this.getChildIndex(afterObject);
            if (index > -1) {
                this.addChild(object);
                this.setChildIndex(object, index + 1);
            }
        }
        // Getters and setters
        isInitialized() {
            return this.initialized;
        }
        setInitialized(initialized) {
            this.initialized = initialized;
        }
        isPaused() {
            return this.paused;
        }
        setPaused(paused) {
            this.paused = paused;
        }
        getEnvironment() {
            return this.sceneObjectEnvironment;
        }
    }
    exports.SceneObject = SceneObject;
    (function (SceneObject) {
        class Environment extends GameObject_2.GameObject.Environment {
        }
        SceneObject.Environment = Environment;
        class PreorderIterator {
            constructor(sceneObject) {
                // The iterator stack contains iterators
                // for all scene objects that iterator over the
                // object's children.
                this.iteratorStack = new Array();
                // Check precondition
                if (sceneObject == null) {
                    throw new Error("Preorder iterator could not be created for scene object null.");
                }
                // Wrap the root node in a list, so that
                // it is possible to iterator over the root itself.
                let wrapperList = new Array();
                wrapperList.push(sceneObject);
                this.iteratorStack.push(new SceneObjectListIterator_1.SceneObjectListIterator(wrapperList));
            }
            hasNext() {
                // A next element is always given, when at least
                // one iterator has a next element on the stack.
                for (let i = 0; i < this.iteratorStack.length; i++) {
                    let iterator = this.iteratorStack[i];
                    if (iterator.hasNext()) {
                        return true;
                    }
                }
                return false;
            }
            next() {
                // If user calls next although hasNext returns false,
                // we throw an exception.
                if (!this.hasNext()) {
                    throw new Error("Calling next although hasNext returns false is not allowed.");
                }
                // Take the iterator on top of the stack and
                // check if it has a next element.
                let currentIterator = this.iteratorStack[this.iteratorStack.length - 1];
                if (currentIterator.hasNext()) {
                    // If currentIterator has next element, return element.
                    // Moreover, the iterator of this element will be pushed to the stack.
                    let sceneObject = currentIterator.next();
                    let nextIterator = new SceneObjectListIterator_1.SceneObjectListIterator(sceneObject.getChildren());
                    this.iteratorStack.push(nextIterator);
                    return sceneObject;
                }
                else {
                    // If currentIterator has no next element,
                    // remove it from the stack and call this method
                    // recursively.
                    this.iteratorStack.pop();
                    return this.next();
                }
            }
            remove() {
                // Removing objects using iterator is not supported.
                throw new Error("UnsupportedOperationException");
            }
        }
        SceneObject.PreorderIterator = PreorderIterator;
    })(SceneObject = exports.SceneObject || (exports.SceneObject = {}));
});
define("src/engine/animation/Interpolator", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/engine/animation/Animation", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Animation = void 0;
    // Can be used to interpolate arbitrary numeric values.
    // The type of interpolation is given by an interpolator object.
    class Animation {
        constructor(interpolator) {
            this.observers = new Array();
            this.interpolator = interpolator;
            this.isAnimating = false;
            this.elapsedTimeInMs = 0;
            this.startValue = 0;
            this.endValue = 0;
            this.durationInMs = 0;
            this.delayInMs = 0;
            this.lastValue = 0;
        }
        addObserver(observer) {
            this.observers.push(observer);
        }
        removeObservers() {
            this.observers = new Array();
        }
        removeObserver(observer) {
            let index = this.observers.indexOf(observer);
            if (index >= 0) {
                this.observers.splice(index, 1);
            }
        }
        start(startValue, endValue, durationInMs, delayInMs) {
            this.isAnimating = true;
            this.elapsedTimeInMs = 0;
            this.startValue = startValue;
            this.endValue = endValue;
            this.durationInMs = durationInMs;
            this.delayInMs = delayInMs;
            this.notifyObserversAboutAnimationStart();
        }
        notifyObserversAboutAnimationStart() {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                observer.animationDidStart(this);
            }
        }
        stop() {
            this.isAnimating = false;
            this.notifyObserversAboutAnimationStop();
        }
        notifyObserversAboutAnimationStop() {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                observer.animationDidStop(this);
            }
        }
        // Returns the current interpolation value
        getValue(lastFrametimeInMs) {
            let timeProgress = 0;
            if (this.elapsedTimeInMs < this.delayInMs) {
                timeProgress = 0;
            }
            else {
                timeProgress = (this.elapsedTimeInMs - this.delayInMs) / this.durationInMs;
            }
            let interpolationValue = this.getEnsuredInterpolationValue(timeProgress);
            let range = this.endValue - this.startValue;
            let value = this.startValue + interpolationValue * range;
            if (timeProgress >= 1.0 && this.isAnimating) {
                this.stop();
                this.notifyObserversAboutAnimationFinish();
            }
            this.updateElapsedTimeInMs(lastFrametimeInMs);
            this.lastValue = value;
            return value;
        }
        updateElapsedTimeInMs(lastFrametimeInMs) {
            this.elapsedTimeInMs += lastFrametimeInMs;
        }
        getEnsuredInterpolationValue(timeProgress) {
            timeProgress = this.getEnsuredTimeProgress(timeProgress);
            return this.interpolator.getInterpolationValue(timeProgress);
        }
        getEnsuredTimeProgress(timeProgress) {
            if (timeProgress < 0) {
                timeProgress = 0;
            }
            else if (timeProgress > 1) {
                timeProgress = 1;
            }
            return timeProgress;
        }
        notifyObserversAboutAnimationFinish() {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                observer.animationDidFinish(this);
            }
        }
        getLastValue() {
            return this.lastValue;
        }
        // Getters and setters
        getInterpolator() {
            return this.interpolator;
        }
        isCurrentlyAnimating() {
            return this.isAnimating;
        }
        getStartValue() {
            return this.startValue;
        }
        getEndValue() {
            return this.endValue;
        }
        getDurationInMs() {
            return this.durationInMs;
        }
        setElapsedTimeInMs(elapsedTimeInMs) {
            this.elapsedTimeInMs = elapsedTimeInMs;
        }
        getElapsedTimeInMs() {
            return this.elapsedTimeInMs;
        }
    }
    exports.Animation = Animation;
});
define("src/engine/animation/LinearInterpolator", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinearInterpolator = void 0;
    class LinearInterpolator {
        getInterpolationValue(timeProgress) {
            return timeProgress;
        }
    }
    exports.LinearInterpolator = LinearInterpolator;
});
define("src/map/view/Layer", ["require", "exports", "src/engine/scene/SceneObject", "src/engine/animation/Animation", "src/engine/animation/LinearInterpolator"], function (require, exports, SceneObject_2, Animation_1, LinearInterpolator_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Layer = void 0;
    class Layer extends SceneObject_2.SceneObject {
        // Initialization
        constructor(environment) {
            super(environment);
            // View: Animation
            this.animationDurationInMs = 200;
            this.inBackground = false;
            // Observation
            this.visiblitityObservers = new Array();
            this.container = this.getEnvironment().renderer.newDisplayObjectContainer();
            this.fadeAnimation = new Animation_1.Animation(new LinearInterpolator_1.LinearInterpolator());
        }
        setContainer(container) {
            this.container = container;
        }
        // View
        // @Override
        getView() {
            return this.container;
        }
        // Observation
        addVisiblityObserver(observer) {
            this.visiblitityObservers.push(observer);
        }
        removeVisibilityObserver(observer) {
            let index = this.visiblitityObservers.indexOf(observer);
            if (index > -1) {
                this.visiblitityObservers.splice(index, 1);
            }
        }
        notifyObserversAboutVisibilityChange(visible) {
            for (let i = 0; i < this.visiblitityObservers.length; i++) {
                let observer = this.visiblitityObservers[i];
                observer.visibilityChanged(this);
            }
        }
        // Layers
        addLayer(layer) {
            this.addChild(layer);
        }
        addLayerAtIndex(layer, index) {
            this.addLayer(layer);
            this.setLayerAtIndex(layer, index);
        }
        addLayerAfterLayer(layer, afterLayer) {
            this.addAfterObject(layer, afterLayer);
        }
        setLayerAtIndex(layer, index) {
            this.setChildIndex(layer, index);
        }
        removeLayer(layer) {
            this.removeChild(layer);
        }
        hasLayer(layer) {
            return this.hasChild(layer);
        }
        // Animations
        animateVisible(visible, callback) {
            let endValue = 0;
            if (visible) {
                endValue = this.getCurrentMaxAlpha();
            }
            else {
                endValue = 0.0;
            }
            if (callback !== undefined) {
                let fadeAnimation = this.fadeAnimation;
                let observer = {
                    animationDidStart(animation) { },
                    animationDidStop(animation) {
                        fadeAnimation.removeObserver(observer);
                        callback();
                    },
                    animationDidFinish(animation) {
                        fadeAnimation.removeObserver(observer);
                        callback();
                    }
                };
                this.fadeAnimation.addObserver(observer);
            }
            this.animateAlphaToValue(endValue);
        }
        animateAlphaToValue(targetAlpha) {
            let startValue = this.getView().alpha;
            let endValue = targetAlpha;
            let durationInMs = this.animationDurationInMs;
            let delayInMs = 0;
            if (startValue !== endValue) {
                this.fadeAnimation.start(startValue, endValue, durationInMs, delayInMs);
            }
            else {
                this.fadeAnimation.stop();
                this.setAlpha(endValue);
            }
        }
        setAlpha(alpha) {
            let alphaBefore = this.getView().alpha;
            this.getView().alpha = alpha;
            if (alpha === 0 && alphaBefore !== 0) {
                this.notifyObserversAboutVisibilityChange(false);
            }
            else if (alpha === 1 && alphaBefore !== 1) {
                this.notifyObserversAboutVisibilityChange(true);
            }
        }
        toggleVisibility() {
            let visible = !this.isVisible();
            this.animateVisible(visible);
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.fadeAnimation.isCurrentlyAnimating()) {
                let currentValue = this.fadeAnimation.getValue(lastFrametime);
                this.setAlpha(currentValue);
            }
        }
        // Getters and setters
        isEmpty() {
            var _a, _b, _c;
            if ((_a = this.getChildren()) === null || _a === void 0 ? void 0 : _a.some(child => {
                return child instanceof Layer && !child.isEmpty();
            })) {
                return false;
            }
            return !(((_c = (_b = this.getView()) === null || _b === void 0 ? void 0 : _b.children) === null || _c === void 0 ? void 0 : _c.length) > 0);
        }
        isVisibleInWorld() {
            return this.getView().worldAlpha !== 0 && this.getView().alpha !== 0;
        }
        isVisible() {
            return this.getView().alpha !== 0;
        }
        setVisible(visible) {
            if (visible) {
                this.setAlpha(this.getCurrentMaxAlpha());
            }
            else {
                this.setAlpha(0.0);
            }
        }
        // Changes the max alpha value of this layer.
        setIsInBackground(inBackground) {
            this.inBackground = inBackground;
        }
        isInBackground() {
            return this.inBackground;
        }
        getCurrentMaxAlpha() {
            if (this.isInBackground()) {
                return 0.5;
            }
            else {
                return 1.0;
            }
        }
    }
    exports.Layer = Layer;
});
define("src/engine/input/InputEvent", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputEvent = void 0;
    // Represents a generic input event that can be recycled
    // to avoid memory allocations when used in an input event pool.
    class InputEvent {
        constructor() {
            this.values = [0.0, 0.0, 0.0, 0.0, 0.0];
        }
        // Setters
        setConfiguration(gesture, action, values) {
            this.gesture = gesture;
            this.action = action;
            this.timestampInMs = Date.now();
            this.values = values;
        }
        // Getters
        getGesture() {
            return this.gesture;
        }
        getAction() {
            return this.action;
        }
        getTimestampInMs() {
            return this.timestampInMs;
        }
        getValues() {
            return this.values;
        }
    }
    exports.InputEvent = InputEvent;
    (function (InputEvent) {
        let Gesture;
        (function (Gesture) {
            Gesture[Gesture["MOUSELEAVING"] = 0] = "MOUSELEAVING";
            Gesture[Gesture["HOVERING"] = 1] = "HOVERING";
            Gesture[Gesture["TOUCHING"] = 2] = "TOUCHING";
            Gesture[Gesture["KEYING"] = 3] = "KEYING";
            Gesture[Gesture["WHEELING"] = 4] = "WHEELING";
            Gesture[Gesture["PANNING"] = 5] = "PANNING";
            Gesture[Gesture["PINCHING"] = 6] = "PINCHING";
            Gesture[Gesture["ROTATING"] = 7] = "ROTATING";
            Gesture[Gesture["TAPPING"] = 8] = "TAPPING";
        })(Gesture = InputEvent.Gesture || (InputEvent.Gesture = {}));
        let Action;
        (function (Action) {
            Action[Action["NONE"] = 0] = "NONE";
            Action[Action["STARTED"] = 1] = "STARTED";
            Action[Action["MOVING"] = 2] = "MOVING";
            Action[Action["ENDING"] = 3] = "ENDING";
        })(Action = InputEvent.Action || (InputEvent.Action = {}));
    })(InputEvent = exports.InputEvent || (exports.InputEvent = {}));
});
/**
 * (c) Michael Zelensky 2015
 *
 * DESCRIPTION
 *
 * Ctrl, Shift, Alt, Cmd buttons detector for Mac
 * to support corresponding event.ctrlKey, event.shiftKey, event.altKey which do not work on Mac
 *
 * LICENSE
 *
 * Distributed under MIT License
 * You can use this code in your project without limitation, no matter if it is commercial or not,
 * with all copyright marks intact
 *
 * USAGE
 *
 * Just include this code into your JS or HTML and then check if key is pressed in your code, e.g.:
 *
 * window.onclick = function (event) {
 *     if (event.ctrlKey || macKeys.ctrlKey) {
 *         //do something
 *     }
 * }
 *
 */
define("src/engine/input/MacKeyDetector", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MacKeyDetector = void 0;
    /* tslint:disable */
    class MacKeyDetector {
        static enable() {
            (function () {
                let saywho;
                let isMac;
                let webkit;
                let mozilla;
                let opera;
                let kC;
                isMac = navigator.platform.toUpperCase().indexOf("MAC") >= 0;
                window.macKeys = {
                    cmdKey: false,
                    ctrlKey: false,
                    shiftKey: false,
                    altKey: false,
                    reset: function () {
                        this.cmdKey = false;
                        this.ctrlKey = false;
                        this.shiftKey = false;
                        this.altKey = false;
                    },
                };
                if (isMac) {
                    // browser detection, originates from: http://stackoverflow.com/questions/2400935/browser-detection-in-javascript
                    saywho = (function () {
                        let ua = navigator.userAgent;
                        let tem;
                        let M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
                        if (/trident/i.test(M[1])) {
                            tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
                            return { browser: "IE", version: (tem[1] || "") };
                        }
                        if (M[1] === "Chrome") {
                            tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
                            // if(tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
                            if (tem != null) {
                                return { browser: tem.slice(1)[0].replace("OPR", "Opera"), version: tem.slice(1)[1] };
                            }
                        }
                        M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, "-?"];
                        if ((tem = ua.match(/version\/(\d+)/i)) != null) {
                            M.splice(1, 1, tem[1]);
                        }
                        return { browser: M[0], version: M[1] };
                    })();
                    webkit = (saywho.browser === "Chrome" || saywho.browser === "Safari");
                    mozilla = saywho.browser === "Firefox";
                    opera = saywho.browser === "Opera";
                    window.onkeydown = function (e) {
                        kC = e.keyCode;
                        if (((webkit || opera) && (kC === 91 || kC === 93)) || (mozilla && kC === 224)) {
                            window.macKeys.cmdKey = true;
                        }
                        else if (kC === 16) {
                            window.macKeys.shiftKey = true;
                        }
                        else if (kC === 17) {
                            window.macKeys.ctrlKey = true;
                        }
                        else if (kC === 18) {
                            window.macKeys.altKey = true;
                        }
                    };
                    window.onkeyup = function (e) {
                        kC = e.keyCode;
                        if (((webkit || opera) && (kC === 91 || kC === 93)) || (mozilla && kC === 224)) {
                            window.macKeys.cmdKey = false;
                        }
                        else if (kC === 16) {
                            window.macKeys.shiftKey = false;
                        }
                        else if (kC === 17) {
                            window.macKeys.ctrlKey = false;
                        }
                        else if (kC === 18) {
                            window.macKeys.altKey = false;
                        }
                    };
                    window.onblur = function () {
                        window.macKeys.reset();
                    };
                }
            })();
        }
    }
    exports.MacKeyDetector = MacKeyDetector;
});
define("src/engine/input/GestureRecognizer", ["require", "exports", "src/engine/input/MacKeyDetector", "src/engine/math/Vector2"], function (require, exports, MacKeyDetector_1, Vector2_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GestureRecognizer = void 0;
    class GestureRecognizer {
        // Initialization
        constructor(environment, interactionView, htmlCanvasElement) {
            this.touchStartTimestampInMs = 0;
            this.touchEndTimestampInMs = 0;
            this.numberOfTaps = 0;
            this.waitingForTapFinish = false;
            // Pinch
            this.pinchFocusX = 0;
            this.pinchFocusY = 0;
            // Mouse click
            this.mouseDown = false;
            this.mouseX = 0;
            this.mouseY = 0;
            this.mouseMoving = false;
            this.lastMouseMoveTimestampInMs = 0;
            // Mouse outside
            this.mouseOutside = true;
            this.mouseOutTimestamp = 0;
            // Mouse wheel
            this.lastWheelEventTimestamp = -1;
            this.lastWheelEventDelta = 1;
            // Low-Level callbacks
            this.onMouseInCallbacks = new Array();
            this.onMouseOutCallbacks = new Array();
            this.onMouseStartedCallbacks = new Array();
            this.onMouseMovedCallbacks = new Array();
            this.onMouseStoppedCallbacks = new Array();
            this.onTouchStartedCallbacks = new Array();
            this.onTouchMovedCallbacks = new Array();
            this.onTouchEndCallbacks = new Array();
            this.onKeyDownCallbacks = new Array();
            this.onKeyUpCallbacks = new Array();
            this.onMouseWheelCallbacks = new Array();
            // High-Level callbacks
            this.onPanningStartedCallbacks = new Array();
            this.onPanningMoveCallbacks = new Array();
            this.onPanningEndCallbacks = new Array();
            this.onPinchingStartedCallbacks = new Array();
            this.onPinchingMoveCallbacks = new Array();
            this.onPinchingEndCallbacks = new Array();
            this.onRotatingStartedCallbacks = new Array();
            this.onRotatingMoveCallbacks = new Array();
            this.onRotatingEndCallbacks = new Array();
            this.onTapCallbacks = new Array();
            this.environment = environment;
            this.interactionView = interactionView;
            this.htmlCanvasElement = htmlCanvasElement;
            this.currentTouches = new Array();
            this.lastTouches = new Array();
            this.gestureState = GestureRecognizer.GestureState.NONE;
            this.enableMacKeyDetection();
            this.identifyPlatformCapabilities();
            this.registerInteraction();
        }
        enableMacKeyDetection() {
            MacKeyDetector_1.MacKeyDetector.enable();
        }
        identifyPlatformCapabilities() {
            this.supportsPointerEvents = !!window.PointerEvent;
            if (window.navigator.msPointerEnabled) {
                this.htmlCanvasElement.style['-ms-content-zooming'] = '';
                this.htmlCanvasElement.style['-ms-touch-action'] = '';
            }
            else if (this.supportsPointerEvents) {
                this.htmlCanvasElement.style['touch-action'] = '';
            }
        }
        // Event-Listener registration
        registerInteraction() {
            this.registerMouseDown();
            this.registerMouseMove();
            this.registerMouseUp();
            this.registerMouseUpOutside();
            this.registerMouseWheel();
            this.registerKeyboardDownEvent();
            this.registerKeyboardUpEvent();
            this.registerOnBlurEvent();
            this.registerTouchStart();
            this.registerTouchMove();
            this.registerTouchEnd();
            this.registerTouchEndOutside();
        }
        registerMouseDown() {
            const listener = (event) => {
                this.clearSelectionInDom();
                this.mouseDown = true;
                this.handleTouchStart(event);
                this.updateKeyState(event);
                event.preventDefault();
            };
            this.htmlCanvasElement.addEventListener("mousedown", listener, true);
        }
        clearSelectionInDom() {
            if (document.selection) {
                document.selection.empty();
            }
            else if (window.getSelection) {
                window.getSelection().removeAllRanges();
            }
        }
        registerMouseMove() {
            const listener = (event) => {
                let mousePosition = this.getLocalPosition(event);
                this.mouseX = mousePosition.x;
                this.mouseY = mousePosition.y;
                if (this.mouseOutside) {
                    let nowInMs = Date.now();
                    if (this.mouseInsideInteractionView(this.mouseX, this.mouseY)
                        && (nowInMs - this.mouseOutTimestamp) > GestureRecognizer.MIN_TIME_BETWEEN_MOUSEOUT_AND_MOUSEIN) {
                        this.mouseOutside = false;
                        this.handleMouseIn(event);
                    }
                }
                if (this.mouseDown === true) {
                    this.handleTouchMove(event);
                }
                else {
                    this.handleMouseMove(event);
                }
                this.updateKeyState(event);
            };
            this.htmlCanvasElement.addEventListener("mousemove", listener, true);
        }
        mouseInsideInteractionView(x, y) {
            let minX = this.interactionView.x;
            let minY = this.interactionView.y;
            let maxX = this.interactionView.x + this.interactionView.width;
            let maxY = this.interactionView.x + this.interactionView.height;
            return x >= minX && x <= maxX &&
                y >= minX && y <= maxY;
        }
        registerMouseUp() {
            const listener = (event) => {
                if (this.mouseDown === true) {
                    this.mouseDown = false;
                    this.handleTouchEnd(event);
                }
                this.updateKeyState(event);
            };
            this.htmlCanvasElement.addEventListener("mouseup", listener, true);
        }
        registerMouseUpOutside() {
            const listener = (event) => {
                if (this.mouseDown === true) {
                    this.mouseDown = false;
                    this.handleTouchEnd(event);
                }
                this.mouseOutside = true;
                this.mouseOutTimestamp = Date.now();
                // Handle as mouse move, but use cursor position outside the screen.
                this.onMouseMoved(-Number.MAX_VALUE, -Number.MAX_VALUE);
                this.handleMouseOut(event);
                this.updateKeyState(event);
            };
            this.htmlCanvasElement.addEventListener("mouseout", listener, true);
        }
        registerMouseWheel() {
            let that = this;
            let handleMouseWheelEvent = (e) => {
                that.handleMouseWheel(e);
                that.updateKeyState(e);
            };
            let item = this.htmlCanvasElement;
            if (item.addEventListener) {
                // IE9, Chrome, Safari, Opera
                item.addEventListener("mousewheel", handleMouseWheelEvent, false);
                // Firefox
                item.addEventListener("DOMMouseScroll", handleMouseWheelEvent, false);
            }
            else {
                // IE 6/7/8
                item.attachEvent("onmousewheel", handleMouseWheelEvent);
            }
        }
        registerKeyboardDownEvent() {
            let that = this;
            window.addEventListener("keydown", (key) => {
                // Do not handle the key event, if a text field or something else has the focus.
                if (document.activeElement === window.document.body) {
                    that.handleKeyDownEvent(key);
                    that.updateKeyState(key);
                }
            }, false);
        }
        registerKeyboardUpEvent() {
            let that = this;
            window.addEventListener("keyup", (key) => {
                // Do not handle the key event, if a text field or something else has the focus.
                if (document.activeElement === window.document.body) {
                    that.handleKeyUpEvent(key);
                    that.updateKeyState(key);
                }
            }, false);
        }
        registerOnBlurEvent() {
            let that = this;
            window.onblur = () => {
                that.updateKeyState(null);
            };
        }
        registerTouchStart() {
            this.htmlCanvasElement.addEventListener("touchstart", (event) => {
                let changedTouches = event.changedTouches;
                // Pass touch events one after another
                for (let i = 0, li = changedTouches.length; i < li; i++) {
                    event.modifiedTouches = [changedTouches[i]];
                    this.handleTouchStart(event);
                }
            });
        }
        registerTouchMove() {
            this.htmlCanvasElement.addEventListener("touchmove", (event) => {
                let changedTouches = event.changedTouches;
                // Pass touch events one after another
                for (let i = 0, li = changedTouches.length; i < li; i++) {
                    event.modifiedTouches = [changedTouches[i]];
                    this.handleTouchMove(event);
                }
            });
        }
        registerTouchEnd() {
            this.htmlCanvasElement.addEventListener("touchend", (event) => {
                let changedTouches = event.changedTouches;
                // Pass touch events one after another
                for (let i = 0, li = changedTouches.length; i < li; i++) {
                    event.modifiedTouches = [changedTouches[i]];
                    this.handleTouchEnd(event);
                }
            });
        }
        registerTouchEndOutside() {
            this.htmlCanvasElement.addEventListener("touchendoutside", (event) => {
                let changedTouches = event.changedTouches;
                // Pass touch events one after another
                for (let i = 0, li = changedTouches.length; i < li; i++) {
                    event.modifiedTouches = [changedTouches[i]];
                    this.handleTouchEnd(event);
                }
            });
        }
        // Handling Events
        handleMouseIn(event) {
            let position = this.getLocalPosition(event);
            // Call mouse in callback
            this.onMouseIn(position.x, position.y);
        }
        handleMouseMove(event) {
            let position = this.getLocalPosition(event);
            if (!this.mouseMoving) {
                this.mouseMoving = true;
                // Call start callback
                this.onMouseStarted(position.x, position.y);
            }
            // Call move callback
            this.lastMouseMoveTimestampInMs = Date.now();
            this.currentMouseMoveEvent = { position: this.environment.renderer.newPoint(position.x, position.y) };
            GestureRecognizer.mousePositionX = this.currentMouseMoveEvent.position.x;
            GestureRecognizer.mousePositionY = this.currentMouseMoveEvent.position.y;
            this.onMouseMoved(position.x, position.y);
        }
        handleMouseOut(event) {
            let position = this.getLocalPosition(event);
            // Call mouse out callback
            this.onMouseOut(position.x, position.y);
        }
        handleTouchStart(event) {
            // Init current and last touches
            let currentPosition = this.getLocalPosition(event);
            let lastPosition = this.environment.renderer.newPoint(currentPosition.x, currentPosition.y);
            let currentTouch = { identifier: this.getPointerId(event), position: currentPosition };
            let lastTouch = { identifier: this.getPointerId(event), position: lastPosition };
            this.currentTouches.push(currentTouch);
            this.lastTouches.push(lastTouch);
            // Call callback
            this.onTouchStart(event);
        }
        handleTouchMove(event) {
            // Update current touches
            for (let i = 0; i < this.currentTouches.length; i++) {
                let currentTouch = this.currentTouches[i];
                if (currentTouch.identifier === this.getPointerId(event)) {
                    this.currentTouches[i].position = this.getLocalPosition(event);
                    GestureRecognizer.mousePositionX = this.currentTouches[i].position.x;
                    GestureRecognizer.mousePositionY = this.currentTouches[i].position.y;
                }
            }
            // Call callback
            this.onTouchMove(event);
            // Update last position
            for (let i = 0; i < this.currentTouches.length; i++) {
                let currentTouch = this.currentTouches[i];
                if (currentTouch.identifier === this.getPointerId(event)) {
                    this.lastTouches[i].position = currentTouch.position;
                }
            }
        }
        handleTouchEnd(event) {
            // Call callback
            this.onTouchEnd(event);
            // Remove current and last touches
            for (let i = 0; i < this.currentTouches.length; i++) {
                if (this.currentTouches[i].identifier === this.getPointerId(event)) {
                    this.currentTouches.splice(i, 1);
                    this.lastTouches.splice(i, 1);
                }
            }
        }
        handleMouseWheel(e) {
            // Cross-browser wheel delta
            e = window.event || e; // old IE support
            let delta = this.getNormalizedMouseWheelDelta(e);
            if (this.tooManyMouseWheelEvents() || this.mouseWheelDeltaChangedTooQuickly(e, delta)) {
                // On some trackpads a pinch end always produces
                // a wheel delta inversely to the last one, leading
                // to an ugly "reverse zoom jump". To fix this,
                // we disallow quick delta changes.
                this.lastWheelEventTimestamp = Date.now();
                this.lastWheelEventDelta = delta;
                return false;
            }
            this.lastWheelEventTimestamp = Date.now();
            this.lastWheelEventDelta = delta;
            let mousePosition = new Vector2_8.Vector2(this.mouseX, this.mouseY);
            this.onMouseWheel(delta, mousePosition.x, mousePosition.y);
            return false;
        }
        /**
         * Returns the mouse wheel delta in range [0,1]
         * @param e mouse wheel event
         */
        getNormalizedMouseWheelDelta(e) {
            let d = e.detail;
            let w = e.wheelDelta;
            let n = 225;
            let n1 = n - 1;
            let f = 0;
            // Normalize delta
            d = d ? w && (f = w / d) ? d / f : -d / 1.35 : w / 120;
            // Quadratic scale if |d| > 1
            d = d < 1 ? d < -1 ? (-Math.pow(d, 2) - n1) / n : d : (Math.pow(d, 2) + n1) / n;
            // Delta *should* not be greater than 2...
            let delta = Math.min(Math.max(d / 2, -1), 1);
            return delta;
        }
        tooManyMouseWheelEvents() {
            return (Date.now() - this.lastWheelEventTimestamp) < 9;
        }
        mouseWheelDeltaChangedTooQuickly(e, delta) {
            return (Date.now() - this.lastWheelEventTimestamp) < 200 &&
                (this.lastWheelEventDelta > 0 && delta <= 0 || this.lastWheelEventDelta <= 0 && delta > 0);
        }
        handleKeyDownEvent(keyboardEvent) {
            // Call callback
            this.onKeyDown(keyboardEvent.keyCode);
        }
        handleKeyUpEvent(keyboardEvent) {
            // Call callback
            this.onKeyUp(keyboardEvent.keyCode);
        }
        onTouchStart(event) {
            // We ignore touch start, because we cannot distinguish
            // gestures without having access to recent touch positions.
            this.touchStartTimestampInMs = Date.now();
            this.touchStartEvent = { identifier: this.getPointerId(event), position: this.getLocalPosition(event) };
            // Call callback
            let lastTouchIndex = this.currentTouches.length - 1;
            this.onTouchStarted(this.currentTouches[lastTouchIndex].position.x, this.currentTouches[lastTouchIndex].position.y, this.currentTouches[lastTouchIndex].identifier);
        }
        onTouchMove(event) {
            // If this touch is definitely no tap, recognize other touch related gestures.
            if (!this.touchCanBeTap(event)) {
                this.handleNonTapTouchMoveEvent(event);
            }
            // Call callback
            let lastTouchIndex = this.currentTouches.length - 1;
            this.onTouchMoved(this.currentTouches[lastTouchIndex].position.x, this.currentTouches[lastTouchIndex].position.y, this.currentTouches[lastTouchIndex].identifier);
        }
        touchCanBeTap(event) {
            let gestureStateIsNone = this.gestureState === GestureRecognizer.GestureState.NONE;
            let onlyOneTapActive = this.currentTouches.length === 1;
            let distance = Math.sqrt((Math.pow(this.currentTouches[0].position.x - this.touchStartEvent.position.x, 2)) +
                (Math.pow(this.currentTouches[0].position.y - this.touchStartEvent.position.y, 2)));
            let shortDistanceToTouchStart = distance < GestureRecognizer.MAX_TAP_DISTANCE_PX;
            let shortTimeSinceTouchStart = (Date.now() - this.touchStartTimestampInMs) < GestureRecognizer.MAX_TAP_DURATION_MS;
            return gestureStateIsNone && onlyOneTapActive && shortDistanceToTouchStart && shortTimeSinceTouchStart;
        }
        handleNonTapTouchMoveEvent(event) {
            // Gesture state machine
            if (this.gestureState === GestureRecognizer.GestureState.NONE) {
                if (this.recognizedPinchEvent()) {
                    this.gestureState = GestureRecognizer.GestureState.PINCHING;
                    this.computePinchFocus();
                    let distance = this.getPinchDistance();
                    let scaleFactor = this.getScaleFactor();
                    this.onPinchingStarted(this.pinchFocusX, this.pinchFocusY, distance, scaleFactor);
                }
                else if (this.recognizedRotateEvent()) {
                    this.gestureState = GestureRecognizer.GestureState.ROTATING;
                    let rotation = this.getRotation();
                    this.computePinchFocus();
                    let distance = this.getPinchDistance();
                    let scaleFactor = this.getScaleFactor();
                    this.onRotatingStarted(rotation, this.pinchFocusX, this.pinchFocusY, distance, scaleFactor);
                }
                else if (this.recognizedPanEvent()) {
                    this.gestureState = GestureRecognizer.GestureState.PANNING;
                    let x = this.currentTouches[0].position.x;
                    let y = this.currentTouches[0].position.y;
                    this.onPanningStarted(x, y);
                }
            }
            else if (this.gestureState === GestureRecognizer.GestureState.PANNING) {
                if (this.recognizedPinchEvent()) {
                    this.gestureState = GestureRecognizer.GestureState.PINCHING;
                    this.computePinchFocus();
                    let distance = this.getPinchDistance();
                    let scaleFactor = this.getScaleFactor();
                    this.onPinchingStarted(this.pinchFocusX, this.pinchFocusY, distance, scaleFactor);
                }
                else if (this.recognizedRotateEvent()) {
                    this.gestureState = GestureRecognizer.GestureState.ROTATING;
                    let rotation = this.getRotation();
                    this.computePinchFocus();
                    let distance = this.getPinchDistance();
                    let scaleFactor = this.getScaleFactor();
                    this.onRotatingStarted(rotation, this.pinchFocusX, this.pinchFocusX, distance, scaleFactor);
                }
            }
            // Update gesture
            if (this.gestureState === GestureRecognizer.GestureState.PINCHING) {
                let distance = this.getPinchDistance();
                let scaleFactor = this.getScaleFactor();
                this.onPinchingMove(this.pinchFocusX, this.pinchFocusY, distance, scaleFactor);
            }
            else if (this.gestureState === GestureRecognizer.GestureState.ROTATING) {
                let rotation = this.getRotation();
                let distance = this.getPinchDistance();
                let scaleFactor = this.getScaleFactor();
                this.onRotatingMove(rotation, this.pinchFocusX, this.pinchFocusY, distance, scaleFactor);
            }
            else if (this.gestureState === GestureRecognizer.GestureState.PANNING) {
                let x = this.currentTouches[0].position.x;
                let y = this.currentTouches[0].position.y;
                this.onPanningMove(x, y);
            }
        }
        recognizedPinchEvent() {
            // At least two fingers
            if (this.currentTouches.length < 2) {
                return false;
            }
            let directionRatio = this.getDirectionRatio();
            let movementVector = this.getMovementVector();
            let movementVectorLength = Math.sqrt(movementVector.x * movementVector.x + movementVector.y * movementVector.y);
            return directionRatio > (GestureRecognizer.PINCH_ROTATE_DIFFERENCE_THRESHOLD)
                && movementVectorLength > GestureRecognizer.MOVEMENT_VECTOR_LENGTH_PINCH_ROTATE_THRESHOLD;
        }
        computePinchFocus() {
            let pinchFocus = this.getPinchFocus();
            this.pinchFocusX = pinchFocus.x;
            this.pinchFocusY = pinchFocus.y;
        }
        getPinchFocus() {
            let focusX = (this.currentTouches[0].position.x + this.currentTouches[1].position.x) / 2;
            let focusY = (this.currentTouches[0].position.y + this.currentTouches[1].position.y) / 2;
            return new Vector2_8.Vector2(focusX, focusY);
        }
        getPinchDistance() {
            // Current distance vector
            let currentDistanceVectorX = this.currentTouches[0].position.x - this.currentTouches[1].position.x;
            let currentDistanceVectorY = this.currentTouches[0].position.y - this.currentTouches[1].position.y;
            // Distance
            let distance = Math.sqrt(Math.pow(currentDistanceVectorX, 2) + Math.pow(currentDistanceVectorY, 2));
            return distance;
        }
        getScaleFactor() {
            // Current distance
            let currentDistanceVectorX = this.currentTouches[0].position.x - this.currentTouches[1].position.x;
            let currentDistanceVectorY = this.currentTouches[0].position.y - this.currentTouches[1].position.y;
            let currentDistance = Math.sqrt(Math.pow(currentDistanceVectorX, 2) + Math.pow(currentDistanceVectorY, 2));
            // Last distance
            let lastDistanceVectorX = this.lastTouches[0].position.x - this.lastTouches[1].position.x;
            let lastDistanceVectorY = this.lastTouches[0].position.y - this.lastTouches[1].position.y;
            let lastDistance = Math.sqrt(Math.pow(lastDistanceVectorX, 2) + Math.pow(lastDistanceVectorY, 2));
            // Scale factor
            let scaleFactor = currentDistance / lastDistance;
            return scaleFactor;
        }
        recognizedRotateEvent() {
            // At least two fingers
            if (this.currentTouches.length < 2) {
                return false;
            }
            // The difference between pinching and rotating must be big enough.
            // Moreover, the moving distance must exceed a threshold.
            let directionRatio = this.getDirectionRatio();
            let movementVector = this.getMovementVector();
            let movementVectorLength = Math.sqrt(movementVector.x * movementVector.x + movementVector.y * movementVector.y);
            return directionRatio < (1.0 / GestureRecognizer.PINCH_ROTATE_DIFFERENCE_THRESHOLD)
                && movementVectorLength > GestureRecognizer.MOVEMENT_VECTOR_LENGTH_PINCH_ROTATE_THRESHOLD;
        }
        getRotation() {
            let currentDistanceVectorX = this.currentTouches[0].position.x - this.currentTouches[1].position.x;
            let currentDistanceVectorY = this.currentTouches[0].position.y - this.currentTouches[1].position.y;
            let lastDistanceVectorX = this.lastTouches[0].position.x - this.lastTouches[1].position.x;
            let lastDistanceVectorY = this.lastTouches[0].position.y - this.lastTouches[1].position.y;
            let currentDistanceVectorLength = Math.sqrt(currentDistanceVectorX * currentDistanceVectorX + currentDistanceVectorY * currentDistanceVectorY);
            let lastDistanceVectorLength = Math.sqrt(lastDistanceVectorX * lastDistanceVectorX + lastDistanceVectorY * lastDistanceVectorY);
            let numerator = currentDistanceVectorX * lastDistanceVectorX + currentDistanceVectorY * lastDistanceVectorY;
            let denominator = Math.abs(currentDistanceVectorLength) * Math.abs(lastDistanceVectorLength);
            // Rotation
            let rotation = Math.acos(numerator / denominator);
            if (isNaN(rotation)) {
                rotation = 0;
            }
            // Sign
            let crossProduct = currentDistanceVectorX * lastDistanceVectorY - currentDistanceVectorY * lastDistanceVectorX;
            if (crossProduct > 0) {
                rotation = -rotation;
            }
            return rotation;
        }
        getDirectionRatio() {
            // If the movement vector's projection to the circle is greater
            // than the projection to the finger distance vector, we assume
            // this touch gesture to be a rotation.
            let movementVector = this.getMovementVector();
            // Current distance vector
            let currentDistanceVectorX = this.currentTouches[0].position.x - this.currentTouches[1].position.x;
            let currentDistanceVectorY = this.currentTouches[0].position.y - this.currentTouches[1].position.y;
            // Project movement vector to current distance vector
            let distanceVectorProjection = Math.abs(movementVector.x * currentDistanceVectorX + movementVector.y * currentDistanceVectorY);
            // Project movement vector to the normal vector of the current distance vector
            let perpendicularCurrentDistanceVectorX = -currentDistanceVectorY;
            let perpendicularCurrentDistanceVectorY = currentDistanceVectorX;
            let perpendicularDistanceVectorProjection = Math.abs(movementVector.x * perpendicularCurrentDistanceVectorX
                + movementVector.y * perpendicularCurrentDistanceVectorY);
            return distanceVectorProjection / perpendicularDistanceVectorProjection;
        }
        getMovementVector() {
            // Current distance vector
            let currentDistanceVectorX = this.currentTouches[0].position.x - this.currentTouches[1].position.x;
            let currentDistanceVectorY = this.currentTouches[0].position.y - this.currentTouches[1].position.y;
            // Last distance vector
            let lastDistanceVectorX = this.lastTouches[0].position.x - this.lastTouches[1].position.x;
            let lastDistanceVectorY = this.lastTouches[0].position.y - this.lastTouches[1].position.y;
            // Movement vector
            let movementVectorX = currentDistanceVectorX - lastDistanceVectorX;
            let movementVectorY = currentDistanceVectorY - lastDistanceVectorY;
            return new Vector2_8.Vector2(movementVectorX, movementVectorY);
        }
        recognizedPanEvent() {
            return this.currentTouches.length === 1;
        }
        onTouchEnd(event) {
            // If this touch is definitely no tap, recognize other touch related gestures.
            if (this.touchCanBeTap(event)) {
                this.handleTapTouchEndEvent();
            }
            else {
                this.handleNonTapTouchEndEvent();
            }
            // Call callback
            let lastTouchIndex = this.currentTouches.length - 1;
            this.onTouchEnded(this.currentTouches[lastTouchIndex].position.x, this.currentTouches[lastTouchIndex].position.y, this.currentTouches[lastTouchIndex].identifier);
        }
        handleTapTouchEndEvent() {
            // If no other touch event will be recognized within "touch timeout"" milliseconds,
            // the touch gesture will be considered as "completed".
            this.numberOfTaps++;
            this.touchEndTimestampInMs = Date.now();
            this.waitingForTapFinish = true;
        }
        handleNonTapTouchEndEvent() {
            // Stop gesture
            if (this.gestureState === GestureRecognizer.GestureState.PINCHING) {
                if (this.currentTouches.length === 2) {
                    let distance = this.getPinchDistance();
                    let scaleFactor = this.getScaleFactor();
                    this.onPinchingEnd(this.pinchFocusX, this.pinchFocusY, distance, scaleFactor);
                    this.gestureState = GestureRecognizer.GestureState.NONE;
                }
            }
            else if (this.gestureState === GestureRecognizer.GestureState.ROTATING) {
                if (this.currentTouches.length === 2) {
                    let rotation = this.getRotation();
                    let distance = this.getPinchDistance();
                    let scaleFactor = this.getScaleFactor();
                    this.onRotatingEnd(rotation, this.pinchFocusX, this.pinchFocusY, distance, scaleFactor);
                    this.gestureState = GestureRecognizer.GestureState.NONE;
                }
            }
            else if (this.gestureState === GestureRecognizer.GestureState.PANNING) {
                if (this.currentTouches.length === 1) {
                    let x = this.currentTouches[0].position.x;
                    let y = this.currentTouches[0].position.y;
                    this.onPanningEnd(x, y);
                    this.gestureState = GestureRecognizer.GestureState.NONE;
                }
            }
        }
        //// CALLBACKS
        /// LOW LEVEL EVENTS
        onMouseIn(x, y) {
            for (let i = 0; i < this.onMouseInCallbacks.length; i++) {
                let callback = this.onMouseInCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y]);
            }
        }
        onMouseOut(x, y) {
            for (let i = 0; i < this.onMouseOutCallbacks.length; i++) {
                let callback = this.onMouseOutCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y]);
            }
        }
        onMouseStarted(x, y) {
            for (let i = 0; i < this.onMouseStartedCallbacks.length; i++) {
                let callback = this.onMouseStartedCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y]);
            }
        }
        onMouseMoved(x, y) {
            for (let i = 0; i < this.onMouseMovedCallbacks.length; i++) {
                let callback = this.onMouseMovedCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y]);
            }
        }
        onMouseStopped(x, y) {
            for (let i = 0; i < this.onMouseStoppedCallbacks.length; i++) {
                let callback = this.onMouseStoppedCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y]);
            }
        }
        onTouchStarted(x, y, touchIndex) {
            for (let i = 0; i < this.onTouchStartedCallbacks.length; i++) {
                let callback = this.onTouchStartedCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y, touchIndex]);
            }
        }
        onTouchMoved(x, y, touchIndex) {
            for (let i = 0; i < this.onTouchMovedCallbacks.length; i++) {
                let callback = this.onTouchMovedCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y, touchIndex]);
            }
        }
        onTouchEnded(x, y, touchIndex) {
            for (let i = 0; i < this.onTouchEndCallbacks.length; i++) {
                let callback = this.onTouchEndCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y, touchIndex]);
            }
        }
        onKeyDown(keyCode) {
            for (let i = 0; i < this.onKeyDownCallbacks.length; i++) {
                let callback = this.onKeyDownCallbacks[i];
                callback.apply(this.callbackReceiver, [keyCode]);
            }
        }
        onKeyUp(keyCode) {
            for (let i = 0; i < this.onKeyUpCallbacks.length; i++) {
                let callback = this.onKeyUpCallbacks[i];
                callback.apply(this.callbackReceiver, [keyCode]);
            }
        }
        // Called, whenever the mouse wheel is used.
        // delta = -1, on mouse wheel down,
        // delta = 1, on mouse wheel up
        onMouseWheel(delta, mouseX, mouseY) {
            for (let i = 0; i < this.onMouseWheelCallbacks.length; i++) {
                let callback = this.onMouseWheelCallbacks[i];
                callback.apply(this.callbackReceiver, [delta, mouseX, mouseY]);
            }
        }
        /// HIGH-LEVEL EVENTS
        onPanningStarted(x, y) {
            for (let i = 0; i < this.onPanningStartedCallbacks.length; i++) {
                let callback = this.onPanningStartedCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y]);
            }
        }
        onPanningMove(x, y) {
            for (let i = 0; i < this.onPanningMoveCallbacks.length; i++) {
                let callback = this.onPanningMoveCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y]);
            }
        }
        onPanningEnd(x, y) {
            for (let i = 0; i < this.onPanningEndCallbacks.length; i++) {
                let callback = this.onPanningEndCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y]);
            }
        }
        onPinchingStarted(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            for (let i = 0; i < this.onPinchingStartedCallbacks.length; i++) {
                let callback = this.onPinchingStartedCallbacks[i];
                callback.apply(this.callbackReceiver, [pinchFocusX, pinchFocusY, distance, scaleFactor]);
            }
        }
        onPinchingMove(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            for (let i = 0; i < this.onPinchingMoveCallbacks.length; i++) {
                let callback = this.onPinchingMoveCallbacks[i];
                callback.apply(this.callbackReceiver, [pinchFocusX, pinchFocusY, distance, scaleFactor]);
            }
        }
        onPinchingEnd(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            for (let i = 0; i < this.onPinchingEndCallbacks.length; i++) {
                let callback = this.onPinchingEndCallbacks[i];
                callback.apply(this.callbackReceiver, [pinchFocusX, pinchFocusY, distance, scaleFactor]);
            }
        }
        onRotatingStarted(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            for (let i = 0; i < this.onRotatingStartedCallbacks.length; i++) {
                let callback = this.onRotatingStartedCallbacks[i];
                callback.apply(this.callbackReceiver, [rotation, pinchFocusX, pinchFocusY, distance, scaleFactor]);
            }
        }
        onRotatingMove(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            for (let i = 0; i < this.onRotatingMoveCallbacks.length; i++) {
                let callback = this.onRotatingMoveCallbacks[i];
                callback.apply(this.callbackReceiver, [rotation, pinchFocusX, pinchFocusY, distance, scaleFactor]);
            }
        }
        onRotatingEnd(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            for (let i = 0; i < this.onRotatingEndCallbacks.length; i++) {
                let callback = this.onRotatingEndCallbacks[i];
                callback.apply(this.callbackReceiver, [rotation, pinchFocusX, pinchFocusY, distance, scaleFactor]);
            }
        }
        onTap(x, y, numTaps) {
            for (let i = 0; i < this.onTapCallbacks.length; i++) {
                let callback = this.onTapCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y, numTaps]);
            }
        }
        // Updating
        update() {
            this.updateTapState();
            this.updateMouseState();
        }
        updateKeyState(event) {
            // Updates the current state of the control keys
            if (event == null) {
                GestureRecognizer.ctrlPressed = false;
                GestureRecognizer.shiftPressed = false;
                GestureRecognizer.altPressed = false;
            }
            else {
                GestureRecognizer.ctrlPressed = event.ctrlKey || window.macKeys.cmdKey;
                GestureRecognizer.shiftPressed = event.shiftKey || window.macKeys.shiftKey;
                GestureRecognizer.altPressed = event.altKey || window.macKeys.altKey;
            }
        }
        updateTapState() {
            if (this.waitingForTapFinish) {
                let now = Date.now();
                if (now - this.touchEndTimestampInMs > GestureRecognizer.DELAY_BETWEEN_TAPS_IN_MULTI_TAP_MS
                    || this.numberOfTaps >= GestureRecognizer.MAX_NUMBER_TAPS_IN_MULTI_TAP) {
                    this.onTap(this.touchStartEvent.position.x, this.touchStartEvent.position.y, this.numberOfTaps);
                    this.numberOfTaps = 0;
                    this.waitingForTapFinish = false;
                }
            }
        }
        updateMouseState() {
            if (this.mouseMoving) {
                let now = Date.now();
                if (now - this.lastMouseMoveTimestampInMs > GestureRecognizer.TIME_TO_RECOGNIZE_MOUSE_STOP_IN_MS) {
                    this.onMouseStopped(this.currentMouseMoveEvent.position.x, this.currentMouseMoveEvent.position.y);
                    this.mouseMoving = false;
                }
            }
        }
        // Getters and setters
        getGestureState() {
            return this.gestureState;
        }
        static isCtrlPressed() {
            return this.ctrlPressed;
        }
        static isShiftPressed() {
            return this.shiftPressed;
        }
        static isAltPressed() {
            return this.altPressed;
        }
        static getMousePositionX() {
            return this.mousePositionX;
        }
        static getMousePositionY() {
            return this.mousePositionY;
        }
        // Helper methods
        getLocalPosition(event) {
            const globalPoint = this.getGlobalPosition(event);
            return this.interactionView.worldTransform.applyInverse(this.environment.renderer.newPoint(globalPoint.x, globalPoint.y));
        }
        getGlobalPosition(event) {
            var rect = void 0;
            // IE 11 fix
            if (!this.htmlCanvasElement.parentElement) {
                rect = { x: 0, y: 0, width: 0, height: 0 };
            }
            else {
                rect = this.htmlCanvasElement.getBoundingClientRect();
            }
            var resolutionMultiplier = navigator.isCocoonJS ? this.environment.renderer.pixelRatio : 1.0 / this.environment.renderer.pixelRatio;
            const width = (this.htmlCanvasElement).width;
            const height = (this.htmlCanvasElement).height;
            let clientX = 0;
            let clientY = 0;
            if (this.supportsPointerEvents) {
                clientX = event instanceof PointerEvent || event instanceof MouseEvent ? event.clientX : event.modifiedTouches[0].clientX;
                clientY = event instanceof PointerEvent || event instanceof MouseEvent ? event.clientY : event.modifiedTouches[0].clientY;
            }
            else {
                clientX = event instanceof MouseEvent ? event.clientX : event.modifiedTouches[0].clientX;
                clientY = event instanceof MouseEvent ? event.clientY : event.modifiedTouches[0].clientY;
            }
            const x = (clientX - rect.left) * (width / rect.width) * resolutionMultiplier;
            const y = (clientY - rect.top) * (height / rect.height) * resolutionMultiplier;
            return this.environment.renderer.newPoint(x, y);
        }
        getPointerId(event) {
            if (this.supportsPointerEvents && event instanceof PointerEvent) {
                return event.pointerId;
            }
            else if (typeof TouchEvent !== 'undefined' && event instanceof TouchEvent) {
                return event.modifiedTouches[0].identifier || 0;
            }
            else {
                return 0;
            }
        }
    }
    exports.GestureRecognizer = GestureRecognizer;
    // Tap
    GestureRecognizer.MAX_TAP_DURATION_MS = 250;
    GestureRecognizer.MAX_TAP_DISTANCE_PX = 2;
    GestureRecognizer.DELAY_BETWEEN_TAPS_IN_MULTI_TAP_MS = 250;
    GestureRecognizer.MAX_NUMBER_TAPS_IN_MULTI_TAP = 2;
    // Pinch-Rotate
    GestureRecognizer.PINCH_ROTATE_DIFFERENCE_THRESHOLD = 5;
    GestureRecognizer.MOVEMENT_VECTOR_LENGTH_PINCH_ROTATE_THRESHOLD = 2;
    // Mouse move
    GestureRecognizer.TIME_TO_RECOGNIZE_MOUSE_STOP_IN_MS = 300;
    GestureRecognizer.mousePositionX = 0;
    GestureRecognizer.mousePositionY = 0;
    GestureRecognizer.MIN_TIME_BETWEEN_MOUSEOUT_AND_MOUSEIN = 200;
    // Keys
    GestureRecognizer.ctrlPressed = false;
    GestureRecognizer.shiftPressed = false;
    GestureRecognizer.altPressed = false;
    (function (GestureRecognizer) {
        let GestureState;
        (function (GestureState) {
            GestureState[GestureState["NONE"] = 0] = "NONE";
            GestureState[GestureState["PINCHING"] = 1] = "PINCHING";
            GestureState[GestureState["ROTATING"] = 2] = "ROTATING";
            GestureState[GestureState["PANNING"] = 3] = "PANNING";
        })(GestureState = GestureRecognizer.GestureState || (GestureRecognizer.GestureState = {}));
    })(GestureRecognizer = exports.GestureRecognizer || (exports.GestureRecognizer = {}));
});
define("src/engine/input/InputSystem", ["require", "exports", "src/engine/scene/GameObject", "src/engine/input/InputEvent", "src/engine/input/GestureRecognizer"], function (require, exports, GameObject_3, InputEvent_1, GestureRecognizer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputSystem = void 0;
    // The input system receives all input events and
    // pushes them to an input queue. Using the input queue
    // one can obtain all events in a single thread.
    class InputSystem extends GameObject_3.GameObject {
        constructor(environment, htmlElement) {
            super(environment);
            this.initInteractionView();
            this.initInputPool();
            this.initInputQueue();
            this.registerEvents(htmlElement);
        }
        initInteractionView() {
            // The input view is the view that captures all input events.
            this.inputView = this.getEnvironment().renderer.newGraphicsObject();
            this.layoutInputView();
            this.inputView.alpha = 0;
        }
        layoutInputView() {
            this.inputView.clear();
            this.inputView.beginFill(0xffffff);
            this.inputView.drawRect(0, 0, this.getEnvironment().renderer.renderTargetSize.x, this.getEnvironment().renderer.renderTargetSize.y);
            this.inputView.endFill();
        }
        initInputPool() {
            this.inputPool = new Array();
            // Fill the pool with a fixed numer of input events.
            for (let i = 0; i < InputSystem.QUEUE_CAPACITY; i++) {
                this.inputPool.push(new InputEvent_1.InputEvent());
            }
        }
        initInputQueue() {
            this.inputQueue = new Array();
        }
        registerEvents(htmlCanvasElement) {
            this.gestureRecognizer = new GestureRecognizer_1.GestureRecognizer(this.getEnvironment(), this.inputView, htmlCanvasElement);
            this.gestureRecognizer.callbackReceiver = this;
            this.gestureRecognizer.onMouseInCallbacks.push(this.mouseIn);
            this.gestureRecognizer.onMouseOutCallbacks.push(this.mouseOut);
            this.gestureRecognizer.onMouseStartedCallbacks.push(this.mouseStarted);
            this.gestureRecognizer.onMouseMovedCallbacks.push(this.mouseMoved);
            this.gestureRecognizer.onMouseStoppedCallbacks.push(this.mouseStopped);
            this.gestureRecognizer.onTouchStartedCallbacks.push(this.touchStarted);
            this.gestureRecognizer.onTouchMovedCallbacks.push(this.touchMoved);
            this.gestureRecognizer.onTouchEndCallbacks.push(this.touchEnded);
            this.gestureRecognizer.onKeyDownCallbacks.push(this.keyDown);
            this.gestureRecognizer.onKeyUpCallbacks.push(this.keyUp);
            this.gestureRecognizer.onMouseWheelCallbacks.push(this.mouseWheel);
            this.gestureRecognizer.onPanningStartedCallbacks.push(this.panningStarted);
            this.gestureRecognizer.onPanningMoveCallbacks.push(this.panningMoved);
            this.gestureRecognizer.onPanningEndCallbacks.push(this.panningEnded);
            this.gestureRecognizer.onPinchingStartedCallbacks.push(this.pinchingStarted);
            this.gestureRecognizer.onPinchingMoveCallbacks.push(this.pinchingMoved);
            this.gestureRecognizer.onPinchingEndCallbacks.push(this.pinchingEnded);
            this.gestureRecognizer.onRotatingStartedCallbacks.push(this.rotatingStarted);
            this.gestureRecognizer.onRotatingMoveCallbacks.push(this.rotatingMoved);
            this.gestureRecognizer.onRotatingEndCallbacks.push(this.rotatingEnded);
            this.gestureRecognizer.onTapCallbacks.push(this.tapped);
        }
        mouseIn(x, y) {
            let values = [x, y];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.MOUSELEAVING, InputEvent_1.InputEvent.Action.STARTED, values);
        }
        mouseOut(x, y) {
            let values = [x, y];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.MOUSELEAVING, InputEvent_1.InputEvent.Action.ENDING, values);
        }
        mouseStarted(x, y) {
            let values = [x, y];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.HOVERING, InputEvent_1.InputEvent.Action.STARTED, values);
        }
        mouseMoved(x, y) {
            let values = [x, y];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.HOVERING, InputEvent_1.InputEvent.Action.MOVING, values);
        }
        mouseStopped(x, y) {
            let values = [x, y];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.HOVERING, InputEvent_1.InputEvent.Action.ENDING, values);
        }
        touchStarted(x, y, touchIndex) {
            let values = [x, y, touchIndex];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.TOUCHING, InputEvent_1.InputEvent.Action.STARTED, values);
        }
        touchMoved(x, y, touchIndex) {
            let values = [x, y, touchIndex];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.TOUCHING, InputEvent_1.InputEvent.Action.MOVING, values);
        }
        touchEnded(x, y, touchIndex) {
            let values = [x, y, touchIndex];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.TOUCHING, InputEvent_1.InputEvent.Action.ENDING, values);
        }
        keyDown(keyCode) {
            let values = [keyCode];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.KEYING, InputEvent_1.InputEvent.Action.STARTED, values);
        }
        keyUp(keyCode) {
            let values = [keyCode];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.KEYING, InputEvent_1.InputEvent.Action.ENDING, values);
        }
        mouseWheel(delta, mouseX, mouseY) {
            let values = [delta, mouseX, mouseY];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.WHEELING, InputEvent_1.InputEvent.Action.NONE, values);
        }
        panningStarted(x, y) {
            let values = [x, y];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.PANNING, InputEvent_1.InputEvent.Action.STARTED, values);
        }
        panningMoved(x, y) {
            let values = [x, y];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.PANNING, InputEvent_1.InputEvent.Action.MOVING, values);
        }
        panningEnded(x, y) {
            let values = [x, y];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.PANNING, InputEvent_1.InputEvent.Action.ENDING, values);
        }
        pinchingStarted(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            let values = [pinchFocusX, pinchFocusY, distance, scaleFactor];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.PINCHING, InputEvent_1.InputEvent.Action.STARTED, values);
        }
        pinchingMoved(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            let values = [pinchFocusX, pinchFocusY, distance, scaleFactor];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.PINCHING, InputEvent_1.InputEvent.Action.MOVING, values);
        }
        pinchingEnded(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            let values = [pinchFocusX, pinchFocusY, distance, scaleFactor];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.PINCHING, InputEvent_1.InputEvent.Action.ENDING, values);
        }
        rotatingStarted(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            let values = [rotation, pinchFocusX, pinchFocusY, distance, scaleFactor];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.ROTATING, InputEvent_1.InputEvent.Action.STARTED, values);
        }
        rotatingMoved(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            let values = [rotation, pinchFocusX, pinchFocusY, distance, scaleFactor];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.ROTATING, InputEvent_1.InputEvent.Action.MOVING, values);
        }
        rotatingEnded(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            let values = [rotation, pinchFocusX, pinchFocusY, distance, scaleFactor];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.ROTATING, InputEvent_1.InputEvent.Action.ENDING, values);
        }
        tapped(x, y, numTaps) {
            let values = [x, y, numTaps];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.TAPPING, InputEvent_1.InputEvent.Action.NONE, values);
        }
        addInputEvent(gesture, action, values) {
            // Reuse input event using object pool.
            let inputEvent = this.inputPool.pop();
            if (inputEvent == null) {
                // Queue is full. Hence, we discard this input event.
                return;
            }
            // Configure the generic input event with the specific values.
            inputEvent.setConfiguration(gesture, action, values);
            // Insert input event to the input queue.
            this.inputQueue.unshift(inputEvent);
        }
        peekEvent() {
            return this.inputQueue[this.inputQueue.length - 1];
        }
        popEvent() {
            // Removes the event from the input queue and adds it
            // to the input pool to make it reusable.
            let inputEvent = this.inputQueue.pop();
            this.inputPool.push(inputEvent);
        }
        update(lastFrametime) {
            super.update(lastFrametime);
            // We need to update the gesture recognizer to
            // correctly recognize time based gestures.
            this.gestureRecognizer.update();
        }
        // Resizing
        // @Override
        onResize() {
            this.layoutInputView();
        }
        // Getters and setters
        getView() {
            return this.inputView;
        }
    }
    exports.InputSystem = InputSystem;
    // Constants
    InputSystem.QUEUE_CAPACITY = 128;
});
define("src/engine/Game", ["require", "exports", "src/engine/input/InputSystem", "src/engine/input/InputEvent"], function (require, exports, InputSystem_1, InputEvent_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Game = void 0;
    class Game {
        // Initialization
        constructor() {
            // Game loop
            this.running = false;
            this.paused = false;
            this.lastTimestampInMs = -1;
            this.useFixedTimesteps = false;
            this.extrapolationEnabled = false;
            this.lag = 0.0;
            this.MS_PER_UPDATE = 1000 / 60;
            this.currentFrametimeInMs = 0;
            // Sceneless game objects
            this.gameObjects = new Array();
            // Scene
            this.scenes = new Array();
            // Nothing to do
        }
        initEngine(environment, parentHtmlElement) {
            this.environment = environment;
            this.initRenderer(parentHtmlElement);
            this.initInputSystem();
            this.initLoadingScreen();
            this.initResources();
        }
        initRenderer(parentHtmlElement) {
            // Adds the render view to the DOM.
            parentHtmlElement.appendChild(this.environment.renderer.getHtmlElement());
        }
        initInputSystem() {
            this.inputSystem = new InputSystem_1.InputSystem(this.environment, this.environment.renderer.getHtmlElement());
            this.addScenelessGameObject(this.inputSystem);
        }
        initLoadingScreen() {
            let loadingScreenView = this.environment.renderer.newGraphicsObject();
            loadingScreenView.beginFill(0xffffff);
            loadingScreenView.drawRect(0, 0, this.environment.renderer.renderTargetSize.x, this.environment.renderer.renderTargetSize.y);
            loadingScreenView.endFill();
            this.environment.renderer.clear();
            this.environment.renderer.render(loadingScreenView);
        }
        initResources() {
            this.environment.renderer.loadResources(this.getResources(), () => {
                this.initGame();
            });
        }
        reloadGame() {
            this.destroyGame();
            this.initGame();
        }
        destroyGame() {
            this.destroyScenes();
        }
        initGame() {
            this.createScenes();
            this.initializeScenes();
            this.initializeScenelessObjects();
            this.updateLocalization();
            // onInitialized must be called after all other initializations, but notice it can stop rendering immediately
            let wasRunning = this.running;
            this.running = true;
            this.onInitialized();
            if (!wasRunning && this.running) {
                this.gameLoop();
            }
        }
        addScenelessGameObject(gameObject) {
            this.gameObjects.push(gameObject);
        }
        addScene(scene) {
            this.scenes.push(scene);
        }
        removeScene(scene) {
            let index = this.scenes.indexOf(scene);
            if (index > -1) {
                this.scenes.splice(index, 1);
            }
        }
        initializeScenes() {
            for (let i = 0; i < this.scenes.length; i++) {
                let scene = this.scenes[i];
                scene.initialize();
            }
        }
        initializeScenelessObjects() {
            for (let i = 0; i < this.gameObjects.length; i++) {
                let gameObject = this.gameObjects[i];
                gameObject.initialize();
            }
        }
        updateLocalization() {
            // Scene game objects
            for (let i = 0; i < this.scenes.length; i++) {
                let scene = this.scenes[i];
                scene.changeLocalization(this.environment.localization);
                scene.onLocalizationChanged();
            }
            // Sceneless game objects
            for (let i = 0; i < this.gameObjects.length; i++) {
                let gameObject = this.gameObjects[i];
                gameObject.changeLocalization(this.environment.localization);
                gameObject.onLocalizationChanged();
            }
        }
        /**
         * Will be called, before game loop is started
         */
        onInitialized() {
            // Empty default implementation.
        }
        // Game loop
        gameLoop() {
            if (this.running) {
                // Loop this function 60 times per second
                window.requestAnimationFrame(() => {
                    this.gameLoop();
                });
                if (!this.paused) {
                    this.currentFrametimeInMs = this.computeFrametime();
                    this.processInput();
                    if (this.useFixedTimesteps) {
                        this.fixedTimestepCycle(this.currentFrametimeInMs);
                    }
                    else {
                        this.variableTimestepCycle(this.currentFrametimeInMs);
                    }
                }
            }
        }
        computeFrametime() {
            let nowInMs = Date.now();
            if (this.lastTimestampInMs === -1) {
                // Initial frametime = 16 ms
                this.lastTimestampInMs = nowInMs;
                return (1.0 / 60) * 1000;
            }
            else {
                let frametimeInMs = nowInMs - this.lastTimestampInMs;
                this.lastTimestampInMs = nowInMs;
                return frametimeInMs;
            }
        }
        processInput() {
            let event = this.inputSystem.peekEvent();
            while (event != null) {
                this.inputSystem.popEvent();
                this.dispatchInputEvent(event);
                event = this.inputSystem.peekEvent();
            }
        }
        dispatchInputEvent(inputEvent) {
            let gesture = inputEvent.getGesture();
            if (gesture === InputEvent_2.InputEvent.Gesture.MOUSELEAVING) {
                this.handleMouseLeavingInputEvent(inputEvent);
            }
            else if (gesture === InputEvent_2.InputEvent.Gesture.HOVERING) {
                this.handleHoveringInputEvent(inputEvent);
            }
            else if (gesture === InputEvent_2.InputEvent.Gesture.TOUCHING) {
                this.handleTouchingInputEvent(inputEvent);
            }
            else if (gesture === InputEvent_2.InputEvent.Gesture.KEYING) {
                this.handleKeyingInputEvent(inputEvent);
            }
            else if (gesture === InputEvent_2.InputEvent.Gesture.WHEELING) {
                this.handleWheelingInputEvent(inputEvent);
            }
            else if (gesture === InputEvent_2.InputEvent.Gesture.PANNING) {
                this.handlePanningInputEvent(inputEvent);
            }
            else if (gesture === InputEvent_2.InputEvent.Gesture.PINCHING) {
                this.handlePinchingInputEvent(inputEvent);
            }
            else if (gesture === InputEvent_2.InputEvent.Gesture.ROTATING) {
                this.handleRotatingInputEvent(inputEvent);
            }
            else if (gesture === InputEvent_2.InputEvent.Gesture.TAPPING) {
                this.handleTappingInputEvent(inputEvent);
            }
        }
        handleMouseLeavingInputEvent(inputEvent) {
            let action = inputEvent.getAction();
            if (action === InputEvent_2.InputEvent.Action.STARTED) {
                this.handleInputEvent("onMouseIn", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.ENDING) {
                this.handleInputEvent("onMouseOut", inputEvent.getValues());
            }
        }
        handleHoveringInputEvent(inputEvent) {
            let action = inputEvent.getAction();
            if (action === InputEvent_2.InputEvent.Action.STARTED) {
                this.handleInputEvent("onMouseStart", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.MOVING) {
                this.handleInputEvent("onMouseMove", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.ENDING) {
                this.handleInputEvent("onMouseEnd", inputEvent.getValues());
            }
        }
        handleTouchingInputEvent(inputEvent) {
            let action = inputEvent.getAction();
            if (action === InputEvent_2.InputEvent.Action.STARTED) {
                this.handleInputEvent("onTouchStart", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.MOVING) {
                this.handleInputEvent("onTouchMove", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.ENDING) {
                this.handleInputEvent("onTouchEnd", inputEvent.getValues());
            }
        }
        handleKeyingInputEvent(inputEvent) {
            let action = inputEvent.getAction();
            if (action === InputEvent_2.InputEvent.Action.STARTED) {
                this.handleInputEvent("onKeyDown", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.ENDING) {
                this.handleInputEvent("onKeyUp", inputEvent.getValues());
            }
        }
        handleWheelingInputEvent(inputEvent) {
            let action = inputEvent.getAction();
            if (action === InputEvent_2.InputEvent.Action.NONE) {
                this.handleInputEvent("onMouseWheel", inputEvent.getValues());
            }
        }
        handlePanningInputEvent(inputEvent) {
            let action = inputEvent.getAction();
            if (action === InputEvent_2.InputEvent.Action.STARTED) {
                this.handleInputEvent("onPanningStart", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.MOVING) {
                this.handleInputEvent("onPanningMove", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.ENDING) {
                this.handleInputEvent("onPanningEnd", inputEvent.getValues());
            }
        }
        handlePinchingInputEvent(inputEvent) {
            let action = inputEvent.getAction();
            if (action === InputEvent_2.InputEvent.Action.STARTED) {
                this.handleInputEvent("onPinchingStart", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.MOVING) {
                this.handleInputEvent("onPinchingMove", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.ENDING) {
                this.handleInputEvent("onPinchingEnd", inputEvent.getValues());
            }
        }
        handleRotatingInputEvent(inputEvent) {
            let action = inputEvent.getAction();
            if (action === InputEvent_2.InputEvent.Action.STARTED) {
                this.handleInputEvent("onRotatingStart", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.MOVING) {
                this.handleInputEvent("onRotatingMove", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.ENDING) {
                this.handleInputEvent("onRotatingEnd", inputEvent.getValues());
            }
        }
        handleTappingInputEvent(inputEvent) {
            this.handleInputEvent("onTap", inputEvent.getValues());
        }
        handleInputEvent(handlerName, values) {
            // Let stateless game objects handle the input event.
            for (let i = 0; i < this.gameObjects.length; i++) {
                let gameObject = this.gameObjects[i];
                let handled = gameObject[handlerName].apply(gameObject, values);
                if (handled) {
                    return;
                }
            }
            // Let scenes handle the input event.
            // Iterate backwards to the scenes. The scenes
            // that will be displayed in front will receive
            // the input events first. If they handle the input event,
            // the subsequent scenes will not have the possibility
            // to handle the event.
            for (let i = this.scenes.length - 1; i >= 0; i--) {
                let scene = this.scenes[i];
                let handled = scene.handleInputEvent(handlerName, values);
                if (handled) {
                    return;
                }
            }
        }
        fixedTimestepCycle(frametimeInMs) {
            this.lag += frametimeInMs;
            this.lag = Math.min(this.lag, this.MS_PER_UPDATE * 5);
            while (this.lag >= this.MS_PER_UPDATE) {
                if (this.extrapolationEnabled && (this.lag - this.MS_PER_UPDATE) < this.MS_PER_UPDATE) {
                    this.rememberPreviousPositions();
                }
                this.update(frametimeInMs);
                this.lag -= this.MS_PER_UPDATE;
            }
            if (this.extrapolationEnabled) {
                let lagOffset = this.lag / this.MS_PER_UPDATE;
                this.rememberCurrentPositions();
                this.extrapolate(lagOffset);
                this.render();
                this.resetToCurrentPositions();
            }
            else {
                this.render();
            }
        }
        variableTimestepCycle(frametimeInMs) {
            this.update(frametimeInMs);
            this.render();
        }
        rememberPreviousPositions() {
            // Remember the previous positions to be able to extrapolate
            // the positions to reduce lag problems occuring when
            // a game loop with fixed timesteps is used.
            for (let i = 0; i < this.scenes.length; i++) {
                let scene = this.scenes[i];
                for (let j = 0; j < scene.getSceneObjects().length; j++) {
                    let sceneObject = scene.getSceneObjects()[j];
                    let displayObject = sceneObject.getView();
                    displayObject.previousX = displayObject.x;
                    displayObject.previousY = displayObject.y;
                    displayObject.previousScaleX = displayObject.scale.x;
                    displayObject.previousScaleY = displayObject.scale.y;
                }
            }
        }
        update(lastFrametime) {
            // Update game
            this.onUpdate(lastFrametime);
            // Update scenes
            for (let i = 0; i < this.scenes.length; i++) {
                let scene = this.scenes[i];
                scene.update(lastFrametime);
            }
            // Update game objects
            for (let i = 0; i < this.gameObjects.length; i++) {
                let gameObject = this.gameObjects[i];
                gameObject.update(lastFrametime);
            }
        }
        // @Override
        onUpdate(lastFrametime) {
            // Empty default implementation
        }
        rememberCurrentPositions() {
            for (let i = 0; i < this.scenes.length; i++) {
                let scene = this.scenes[i];
                for (let j = 0; j < scene.getSceneObjects().length; j++) {
                    let sceneObject = scene.getSceneObjects()[j];
                    let displayObject = sceneObject.getView();
                    displayObject.currentX = displayObject.x;
                    displayObject.currentY = displayObject.y;
                    displayObject.currentScaleX = displayObject.scale.x;
                    displayObject.currentScaleY = displayObject.scale.y;
                }
            }
        }
        extrapolate(lagOffset) {
            for (let i = 0; i < this.scenes.length; i++) {
                let scene = this.scenes[i];
                for (let j = 0; j < scene.getSceneObjects().length; j++) {
                    let sceneObject = scene.getSceneObjects()[j];
                    let displayObject = sceneObject.getView();
                    if ("previousX" in displayObject) {
                        displayObject.x
                            = displayObject.x + ((displayObject.x - displayObject.previousX) * lagOffset);
                    }
                    if ("previousY" in displayObject) {
                        displayObject.y
                            = displayObject.y + ((displayObject.y - displayObject.previousY) * lagOffset);
                    }
                    if ("previousScaleX" in displayObject) {
                        displayObject.scale.x
                            = displayObject.scale.x + ((displayObject.scale.x - displayObject.previousScaleX) * lagOffset);
                    }
                    if ("previousScaleY" in displayObject) {
                        displayObject.scale.y
                            = displayObject.scale.y + ((displayObject.scale.y - displayObject.previousScaleY) * lagOffset);
                    }
                }
            }
        }
        render() {
            // If no render object set the dirty flag to true, the rendering stage
            // will not be triggered to minimize the CPU and GPU utilization.
            // This slient rendering loop strategy is especially important for mobile devices,
            // if the scene is static most of the time.
            if (this.getEnvironment().renderer.dirty) {
                // Renders the stage on the renderer's canvas.
                this.environment.renderer.clear();
                for (let i = 0; i < this.scenes.length; i++) {
                    let scene = this.scenes[i];
                    let roundPixels = scene.isRoundPixels();
                    this.environment.renderer.render(scene.getSceneGraph().getRenderView(), { roundPixels: roundPixels });
                }
            }
            this.getEnvironment().renderer.dirty = false;
        }
        resetToCurrentPositions() {
            for (let i = 0; i < this.scenes.length; i++) {
                let scene = this.scenes[i];
                for (let j = 0; j < scene.getSceneObjects().length; j++) {
                    let sceneObject = scene.getSceneObjects()[j];
                    let displayObject = sceneObject.getView();
                    displayObject.x = displayObject.currentX;
                    displayObject.y = displayObject.currentY;
                    displayObject.scale.x = displayObject.currentScaleX;
                    displayObject.scale.y = displayObject.currentScaleY;
                }
            }
        }
        // Scene events
        /**
         * Publishes events to each game object.
         * @param callbackName The callback should start with "on". Please do not
         * use the same name than the caller to avoid endless recursions.
         * @param args The arguments that will be passed to the subscriber.
         */
        publishSceneEvent(callbackName, args) {
            // Publish event on game
            if (typeof this["" + callbackName] === "function") {
                this["" + callbackName].apply(this, args);
            }
            // Update scenes
            for (let i = 0; i < this.scenes.length; i++) {
                let scene = this.scenes[i];
                for (let j = 0; j < scene.getSceneObjects().length; j++) {
                    let sceneObject = scene.getSceneObjects()[j];
                    if (typeof sceneObject["" + callbackName] === "function") {
                        sceneObject["" + callbackName].apply(sceneObject, args);
                    }
                }
            }
            // Update game objects
            for (let i = 0; i < this.gameObjects.length; i++) {
                let gameObject = this.gameObjects[i];
                if (typeof gameObject["" + callbackName] === "function") {
                    gameObject["" + callbackName].apply(gameObject, args);
                }
            }
        }
        // Destruction
        destroy() {
            // Stop game
            this.stopGame();
            // Destroy all scene graphs with their corresponding display objects
            for (let i = 0; i < this.scenes.length; i++) {
                let scene = this.scenes[i];
                let rootView = scene.getSceneGraph().getView();
                rootView.destroy(true);
            }
            this.environment.renderer.destroy();
            this.environment.renderer.unloadAllResources();
        }
        stopGame() {
            this.running = false;
        }
        // Rendering
        /**
         * Resizes the game to the specified size.
         */
        setCanvasSize(widthInPx, heightInPx) {
            this.environment.renderer.renderTargetSize.x = widthInPx;
            this.environment.renderer.renderTargetSize.y = heightInPx;
            this.resize();
        }
        resize() {
            // Resize canvas
            this.environment.renderer.resize(this.environment.renderer.renderTargetSize.x, this.environment.renderer.renderTargetSize.y);
            // Stateless game objects
            for (let i = 0; i < this.gameObjects.length; i++) {
                let gameObject = this.gameObjects[i];
                gameObject.setCanvasSizeInPx(this.environment.renderer.renderTargetSize.x, this.environment.renderer.renderTargetSize.y);
                gameObject.onResize();
            }
            // Scene objects
            for (let i = this.scenes.length - 1; i >= 0; i--) {
                let scene = this.scenes[i];
                scene.handleResizeEvent(this.environment.renderer.renderTargetSize.x, this.environment.renderer.renderTargetSize.y);
            }
        }
        // State
        pause() {
            this.paused = true;
        }
        resume() {
            this.paused = false;
        }
        // Diagnosis
        getCurrentFrametimeInMs() {
            return this.currentFrametimeInMs;
        }
        // Getters and setters
        getHtmlElement() {
            return this.environment.renderer.getHtmlElement();
        }
        getEnvironment() {
            return this.environment;
        }
        getCanvasWidth() {
            return this.environment.renderer.renderTargetSize.x;
        }
        getCanvasHeight() {
            return this.environment.renderer.renderTargetSize.y;
        }
        getInputSystem() {
            return this.inputSystem;
        }
        getLocalization() {
            return this.environment.localization;
        }
        setLocalization(localization) {
            this.environment.localization = localization;
            this.updateLocalization();
        }
    }
    exports.Game = Game;
});
define("src/map/view/world/objects/WorldCamera", ["require", "exports", "src/engine/scene/Camera", "src/engine/general/AABB", "src/engine/animation/Animation", "src/engine/general/OBB", "src/engine/math/Vector2"], function (require, exports, Camera_2, AABB_2, Animation_2, OBB_3, Vector2_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorldCamera = void 0;
    // A camera that can be animated through procedural (dynamics)
    // and explicit (kinematics) animations. The camera's movement
    // is constrained to the dimensions of a world.
    class WorldCamera extends Camera_2.Camera {
        // Initialization
        constructor(config, environment, screenWidth = environment.renderer.renderTargetSize.x, screenHeight = environment.renderer.renderTargetSize.y) {
            super(environment, screenWidth, screenHeight);
            //// State
            // True, if borders should be enabled.
            this.bordersCurrentlyEnabled = true;
            //// Dynamics
            // Translation
            this.translationVelocity = new Vector2_9.Vector2();
            // Scale
            this.scaleVelocity = 1;
            this.scaleFocusPoint = new Vector2_9.Vector2();
            // Rotation
            this.rotationVelocity = 0;
            this.rotationFocusPoint = new Vector2_9.Vector2();
            // Cached data for performance optimization
            this.lastWorldTransform = null;
            this.lastWorldDimensions = null;
            this.canvasDimensionsChanged = true;
            this.config = config;
        }
        // Configuration
        setWorldDimensions(aabb) {
            // Set the world of reference
            this.worldDimensions = new AABB_2.AABB(new Vector2_9.Vector2(aabb.min.x, aabb.min.y), new Vector2_9.Vector2(aabb.max.x, aabb.max.y));
        }
        // Should be called whenever the world has been increased or decreased.
        setWorldDimensionsToFitChildren() {
            // Set the world of reference
            this.worldDimensions = new AABB_2.AABB(new Vector2_9.Vector2(0, 0), new Vector2_9.Vector2(this.container.width, this.container.height));
        }
        showWholeWorld() {
            // Camera should display whole scene at the beginning.
            let worldAabb = this.getCurrentWorldBordersInImageCoordinates();
            let worldObb = worldAabb.getObb();
            let frustum = Camera_2.Camera.Frustum.fromObb(worldObb);
            this.setFrustum(frustum);
        }
        // Dynamics
        addTranslationImpulse(translation) {
            this.translationVelocity = translation;
        }
        addRotationImpulse(rotationAngle, focusPoint) {
            this.rotationVelocity = rotationAngle;
            this.rotationFocusPoint = focusPoint;
        }
        addScaleImpulse(scale, focusPoint) {
            this.scaleVelocity = scale;
            this.scaleFocusPoint = focusPoint;
        }
        // Updating
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.isKinematicsRunning()) {
                this.updateKinematics(lastFrametime);
            }
            else {
                this.updateDynamics();
            }
        }
        isKinematicsRunning() {
            return this.frustumBottomLeftAnimationX != null
                && this.frustumTopLeftAnimationX.isCurrentlyAnimating();
        }
        updateKinematics(lastFrametime) {
            let topLeft = new Vector2_9.Vector2();
            topLeft.x = this.frustumTopLeftAnimationX.getValue(lastFrametime);
            topLeft.y = this.frustumTopLeftAnimationY.getValue(lastFrametime);
            let topRight = new Vector2_9.Vector2();
            topRight.x = this.frustumTopRightAnimationX.getValue(lastFrametime);
            topRight.y = this.frustumTopRightAnimationY.getValue(lastFrametime);
            let bottomLeft = new Vector2_9.Vector2();
            bottomLeft.x = this.frustumBottomLeftAnimationX.getValue(lastFrametime);
            bottomLeft.y = this.frustumBottomLeftAnimationY.getValue(lastFrametime);
            let bottomRight = new Vector2_9.Vector2();
            bottomRight.x = this.frustumBottomRightAnimationX.getValue(lastFrametime);
            bottomRight.y = this.frustumBottomRightAnimationY.getValue(lastFrametime);
            let targetObb = new OBB_3.OBB(topLeft, topRight, bottomLeft, bottomRight);
            this.setFrustum(Camera_2.Camera.Frustum.fromObb(targetObb));
        }
        updateDynamics() {
            this.updateMovement();
            this.resolveCollisions();
        }
        updateMovement() {
            let scaled = this.updateScale();
            let moved = this.updateTranslation();
            let rotated = this.updateRotation();
            return scaled || moved || rotated;
        }
        updateScale() {
            if (this.scaleSpeedIsNearZero()) {
                return false;
            }
            let smoothness = 8.0;
            this.scaleVelocity = this.scaleVelocity - ((this.scaleVelocity - 1) / smoothness);
            this.scale(this.scaleVelocity, this.scaleVelocity, this.scaleFocusPoint);
            return true;
        }
        scaleSpeedIsNearZero() {
            return Math.abs(this.scaleVelocity - 1) < 0.00001;
        }
        updateTranslation() {
            if (this.translationSpeedIsNearZero()) {
                return false;
            }
            let smoothness = 1.075;
            this.translationVelocity.x /= smoothness;
            this.translationVelocity.y /= smoothness;
            this.translate(this.translationVelocity);
            return true;
        }
        translationSpeedIsNearZero() {
            return Math.abs(this.translationVelocity.x) < 0.01 && Math.abs(this.translationVelocity.y) < 0.01;
        }
        updateRotation() {
            if (this.rotationSpeedIsNearZero()) {
                return false;
            }
            let smoothness = 1.075;
            this.rotationVelocity /= smoothness;
            this.rotate(this.rotationVelocity, this.rotationFocusPoint);
            return true;
        }
        rotationSpeedIsNearZero() {
            return Math.abs(this.rotationVelocity) < 0.001;
        }
        resolveCollisions() {
            if (this.config.bordersEnabled) {
                if (this.bordersCurrentlyEnabled) {
                    if (this.cameraTransformationHasChanged() || this.worldBordersHaveChanged() || this.canvasDimensionsHaveChanged()) {
                        let frustumAabb = this.getFrustumInImageCoordinates();
                        let worldAabb = this.getCurrentWorldBordersInImageCoordinates();
                        this.resolveInterpenetrations(worldAabb, frustumAabb);
                    }
                }
            }
        }
        cameraTransformationHasChanged() {
            const worldTransform = this.getView().worldTransform;
            if (this.lastWorldTransform == null ||
                worldTransform.a !== this.lastWorldTransform.a ||
                worldTransform.b !== this.lastWorldTransform.b ||
                worldTransform.c !== this.lastWorldTransform.c ||
                worldTransform.d !== this.lastWorldTransform.d ||
                worldTransform.tx !== this.lastWorldTransform.tx ||
                worldTransform.ty !== this.lastWorldTransform.ty) {
                this.lastWorldTransform = worldTransform.clone();
                return true;
            }
            else {
                return false;
            }
        }
        worldBordersHaveChanged() {
            if (this.lastWorldDimensions == null ||
                this.worldDimensions.min.x !== this.lastWorldDimensions.min.x ||
                this.worldDimensions.min.y !== this.lastWorldDimensions.min.y ||
                this.worldDimensions.max.x !== this.lastWorldDimensions.max.x ||
                this.worldDimensions.max.y !== this.lastWorldDimensions.max.y) {
                this.lastWorldDimensions = this.worldDimensions.clone();
                return true;
            }
            else {
                return false;
            }
        }
        canvasDimensionsHaveChanged() {
            if (this.canvasDimensionsChanged) {
                this.canvasDimensionsChanged = false;
                return true;
            }
            else {
                return false;
            }
        }
        getFrustumInImageCoordinates() {
            // It may happen, that the frustum itself is inside a container.
            // Thus, we have to transform the frustum AABB to the real image space.
            // Get frustum
            let frustumAabb = new AABB_2.AABB(new Vector2_9.Vector2(0, 0), new Vector2_9.Vector2(this.getScreenWidth(), this.getScreenHeight()));
            if (this.getParent() != null) {
                // Transform frustum to real image space.
                let topLeftInLocal = this.getEnvironment().renderer.newPoint(frustumAabb.min.x, frustumAabb.min.y);
                let topRightInLocal = this.getEnvironment().renderer.newPoint(frustumAabb.max.x, frustumAabb.min.y);
                let bottomLeftInLocal = this.getEnvironment().renderer.newPoint(frustumAabb.min.x, frustumAabb.max.y);
                let bottomRightInLocal = this.getEnvironment().renderer.newPoint(frustumAabb.max.x, frustumAabb.max.y);
                let topLeftInImage = this.getParent().getView().toGlobal(topLeftInLocal, topLeftInLocal);
                let topRightInImage = this.getParent().getView().toGlobal(topRightInLocal, topRightInLocal);
                let bottomLeftInImage = this.getParent().getView().toGlobal(bottomLeftInLocal, bottomLeftInLocal);
                let bottomRightInImage = this.getParent().getView().toGlobal(bottomRightInLocal, bottomRightInLocal);
                let frustumInImageSpace = new OBB_3.OBB(Vector2_9.Vector2.getVector2(topLeftInImage), Vector2_9.Vector2.getVector2(topRightInImage), Vector2_9.Vector2.getVector2(bottomLeftInImage), Vector2_9.Vector2.getVector2(bottomRightInImage));
                // Get AABB of frustum.
                let frustumAabbInImageSpace = frustumInImageSpace.getAabb();
                return frustumAabbInImageSpace;
            }
            else {
                return frustumAabb;
            }
        }
        getDefaultWorldBordersInWorldCoordinates() {
            let worldAabb = new AABB_2.AABB(this.worldDimensions.min, this.worldDimensions.max);
            let worldAabbWithAspectRatioFit = this.getWorldAabbToFitScreenAspectRatio(worldAabb);
            return worldAabbWithAspectRatioFit.getObb();
        }
        // Returns the world's oriented bounding box in world coordinates based on
        // the cameras current orientation.
        getCurrentWorldBordersInWorldCoordinates() {
            let worldAabbInImageCoordinates = this.getCurrentWorldBordersInImageCoordinates();
            let topLeft = this.getWorldCoordinateFromImagePoint(new Vector2_9.Vector2(worldAabbInImageCoordinates.min.x, worldAabbInImageCoordinates.min.y));
            let topRight = this.getWorldCoordinateFromImagePoint(new Vector2_9.Vector2(worldAabbInImageCoordinates.max.x, worldAabbInImageCoordinates.min.y));
            let bottomLeft = this.getWorldCoordinateFromImagePoint(new Vector2_9.Vector2(worldAabbInImageCoordinates.min.x, worldAabbInImageCoordinates.max.y));
            let bottomRight = this.getWorldCoordinateFromImagePoint(new Vector2_9.Vector2(worldAabbInImageCoordinates.max.x, worldAabbInImageCoordinates.max.y));
            let worldObbInWorldCoordinates = new OBB_3.OBB(topLeft, topRight, bottomLeft, bottomRight);
            return worldObbInWorldCoordinates;
        }
        getCurrentWorldBordersInImageCoordinates() {
            let worldDimensionsInImage = this.getWorldDimensionsInImageSpace();
            let worldAabb = worldDimensionsInImage.getAabb();
            worldAabb = this.getWorldAabbToFitScreenAspectRatio(worldAabb);
            return worldAabb;
        }
        getWorldDimensionsInImageSpace() {
            let topLeftInImage = this.getImageCoordinateFromWorldPoint(new Vector2_9.Vector2(this.worldDimensions.min.x, this.worldDimensions.min.y));
            let topRightInImage = this.getImageCoordinateFromWorldPoint(new Vector2_9.Vector2(this.worldDimensions.max.x, this.worldDimensions.min.y));
            let bottomLeftInImage = this.getImageCoordinateFromWorldPoint(new Vector2_9.Vector2(this.worldDimensions.min.x, this.worldDimensions.max.y));
            let bottomRightInImage = this.getImageCoordinateFromWorldPoint(new Vector2_9.Vector2(this.worldDimensions.max.x, this.worldDimensions.max.y));
            let worldInImageSpace = new OBB_3.OBB(topLeftInImage, topRightInImage, bottomLeftInImage, bottomRightInImage);
            return worldInImageSpace;
        }
        getWorldAabbToFitScreenAspectRatio(worldAabb) {
            let worldAspectRatio = (worldAabb.max.x - worldAabb.min.x) / (worldAabb.max.y - worldAabb.min.y);
            let screenAspectRatio = this.getScreenWidth() / this.getScreenHeight();
            if (worldAspectRatio > screenAspectRatio) {
                let targetWidth = worldAabb.max.x - worldAabb.min.x;
                let targetHeight = targetWidth / screenAspectRatio;
                let currentHeight = worldAabb.max.y - worldAabb.min.y;
                worldAabb.min.y = worldAabb.min.y - (targetHeight - currentHeight) / 2;
                worldAabb.max.y = worldAabb.max.y + (targetHeight - currentHeight) / 2;
            }
            else {
                let targetHeight = worldAabb.max.y - worldAabb.min.y;
                let targetWidth = targetHeight * screenAspectRatio;
                let currentWidth = worldAabb.max.x - worldAabb.min.x;
                worldAabb.min.x = worldAabb.min.x - (targetWidth - currentWidth) / 2;
                worldAabb.max.x = worldAabb.max.x + (targetWidth - currentWidth) / 2;
            }
            return worldAabb;
        }
        resolveInterpenetrations(worldAabb, frustumAabb) {
            worldAabb = this.resolveScalingConstraintViolations(worldAabb, frustumAabb);
            this.resolveTranslationConstraintViolations(worldAabb, frustumAabb);
        }
        resolveScalingConstraintViolations(worldAabb, frustumAabb) {
            // Resolve scale constraint violations by zooming the frustum's AABB to fit the world's AABB.
            let frustumWidth = frustumAabb.max.x - frustumAabb.min.x;
            let frustumHeight = frustumAabb.max.y - frustumAabb.min.y;
            let worldWidth = worldAabb.max.x - worldAabb.min.x;
            let worldHeight = worldAabb.max.y - worldAabb.min.y;
            if (frustumWidth > worldWidth || frustumHeight > worldHeight) {
                let scalingFactor = 0;
                if (this.config.useSoftBorders) {
                    scalingFactor = this.getSmoothScalingFactor(worldAabb, frustumAabb);
                }
                else {
                    scalingFactor = (worldAabb.max.x - worldAabb.min.x) /
                        (frustumAabb.max.x - frustumAabb.min.x);
                }
                if (scalingFactor !== 1) {
                    let minXOffset = Math.abs(worldAabb.min.x - frustumAabb.min.x);
                    let maxXOffset = Math.abs(frustumAabb.max.x - worldAabb.max.x);
                    let minYOffset = Math.abs(worldAabb.min.y - frustumAabb.min.y);
                    let maxYOffset = Math.abs(frustumAabb.max.y - worldAabb.max.y);
                    if ((minXOffset + maxXOffset) != 0 && (minYOffset + maxYOffset) != 0) {
                        let relativeOffsetX = minXOffset / (minXOffset + maxXOffset);
                        let relativeOffsetY = minYOffset / (minYOffset + maxYOffset);
                        let focusPoint = new Vector2_9.Vector2(frustumAabb.min.x + frustumWidth * relativeOffsetX, frustumAabb.min.y + frustumHeight * relativeOffsetY);
                        this.scale(scalingFactor, scalingFactor, focusPoint);
                    }
                    // Recompute the world AABB for the subsequent interpenetration resolution steps,
                    // because the screen space has changed due to the scaling.
                    worldAabb = this.getCurrentWorldBordersInImageCoordinates();
                }
            }
            return worldAabb;
        }
        getSmoothScalingFactor(worldAabb, frustumAabb) {
            let resistenceForce = 1;
            let scaleDistanceToTarget = (worldAabb.max.x - worldAabb.min.x) / (frustumAabb.max.x - frustumAabb.min.x);
            resistenceForce = 1 - ((1 - scaleDistanceToTarget) * 0.1);
            return resistenceForce;
        }
        resolveTranslationConstraintViolations(worldAabb, frustumAabb) {
            let moveX = 0.0;
            let moveY = 0.0;
            if (frustumAabb.min.x < worldAabb.min.x) {
                let movement = 0;
                if (this.config.useSoftBorders) {
                    let targetPosition = worldAabb.min.x;
                    let position = frustumAabb.min.x;
                    let velocity = this.translationVelocity.x;
                    movement = this.getSmoothMovement(targetPosition, position, velocity);
                }
                else {
                    movement = -(frustumAabb.min.x - worldAabb.min.x);
                }
                moveX += movement;
            }
            if (frustumAabb.max.x > worldAabb.max.x) {
                let movement = 0;
                if (this.config.useSoftBorders) {
                    let targetPosition = worldAabb.max.x;
                    let position = frustumAabb.max.x;
                    let velocity = this.translationVelocity.x;
                    movement = this.getSmoothMovement(targetPosition, position, velocity);
                }
                else {
                    movement = (frustumAabb.max.x - worldAabb.max.x);
                }
                moveX -= movement;
            }
            if (frustumAabb.min.y < worldAabb.min.y) {
                let movement = 0;
                if (this.config.useSoftBorders) {
                    let targetPosition = worldAabb.min.y;
                    let position = frustumAabb.min.y;
                    let velocity = this.translationVelocity.y;
                    movement = this.getSmoothMovement(targetPosition, position, velocity);
                }
                else {
                    movement = -(frustumAabb.min.y - worldAabb.min.y);
                }
                moveY += movement;
            }
            if (frustumAabb.max.y > worldAabb.max.y) {
                let movement = 0;
                if (this.config.useSoftBorders) {
                    let targetPosition = worldAabb.max.y;
                    let position = frustumAabb.max.y;
                    let velocity = this.translationVelocity.y;
                    movement = this.getSmoothMovement(targetPosition, position, velocity);
                }
                else {
                    movement = (frustumAabb.max.y - worldAabb.max.y);
                }
                moveY -= movement;
            }
            this.translate(new Vector2_9.Vector2(moveX, moveY));
        }
        getSmoothMovement(targetPosition, position, velocity) {
            // Resistence foce: Tries to recover the drift. Is only active, when user has released finger.
            let resistenceForce = 0;
            let distanceToTarget = Math.abs(position - targetPosition);
            resistenceForce = distanceToTarget * 0.1;
            return resistenceForce;
        }
        /**
         * Retransforms the camera to not collide with the world borders anymore.
         */
        resolveCollisionsWithWorldBorders() {
            let useSoftBordersBackup = this.isUsingSoftBorders();
            this.setUseSoftBorders(false);
            this.resolveCollisions();
            this.setUseSoftBorders(useSoftBordersBackup);
        }
        /**
         * reposition camera such that an AABB is entirely visible.
         *
         * @param aabb of interest in cm.
         */
        zoomIn(aabb) {
            let frustum = Camera_2.Camera.Frustum.fromObb(aabb.getObb());
            const screenAspectRatio = this.getScreenWidth() / this.getScreenHeight();
            const aabbAspectRatio = aabb.width / aabb.height;
            frustum = Camera_2.Camera.getExtendedFrustum(frustum, aabbAspectRatio, screenAspectRatio);
            this.setFrustum(frustum);
            this.resolveCollisionsWithWorldBorders();
        }
        // Kinematics
        startAnimation(interpolator, endObb, durationInMs, delayInMs) {
            this.frustumTopLeftAnimationX = new Animation_2.Animation(interpolator);
            this.frustumTopLeftAnimationY = new Animation_2.Animation(interpolator);
            this.frustumTopRightAnimationX = new Animation_2.Animation(interpolator);
            this.frustumTopRightAnimationY = new Animation_2.Animation(interpolator);
            this.frustumBottomLeftAnimationX = new Animation_2.Animation(interpolator);
            this.frustumBottomLeftAnimationY = new Animation_2.Animation(interpolator);
            this.frustumBottomRightAnimationX = new Animation_2.Animation(interpolator);
            this.frustumBottomRightAnimationY = new Animation_2.Animation(interpolator);
            let startObb = this.getFrustum().getObb();
            this.frustumTopLeftAnimationX.start(startObb.topLeft.x, endObb.topLeft.x, durationInMs, delayInMs);
            this.frustumTopLeftAnimationY.start(startObb.topLeft.y, endObb.topLeft.y, durationInMs, delayInMs);
            this.frustumTopRightAnimationX.start(startObb.topRight.x, endObb.topRight.x, durationInMs, delayInMs);
            this.frustumTopRightAnimationY.start(startObb.topRight.y, endObb.topRight.y, durationInMs, delayInMs);
            this.frustumBottomLeftAnimationX.start(startObb.bottomLeft.x, endObb.bottomLeft.x, durationInMs, delayInMs);
            this.frustumBottomLeftAnimationY.start(startObb.bottomLeft.y, endObb.bottomLeft.y, durationInMs, delayInMs);
            this.frustumBottomRightAnimationX.start(startObb.bottomRight.x, endObb.bottomRight.x, durationInMs, delayInMs);
            this.frustumBottomRightAnimationY.start(startObb.bottomRight.y, endObb.bottomRight.y, durationInMs, delayInMs);
        }
        // Resizing
        setScreenWidth(screenWidthInPx) {
            super.setScreenWidth(screenWidthInPx);
            this.canvasDimensionsChanged = true;
        }
        setScreenHeight(screenHeightInPx) {
            super.setScreenHeight(screenHeightInPx);
            this.canvasDimensionsChanged = true;
        }
        // Getters and setters
        setBordersEnabled(bordersEnabled) {
            this.bordersCurrentlyEnabled = bordersEnabled;
        }
        isBordersEnabled() {
            return this.bordersCurrentlyEnabled;
        }
        setUseSoftBorders(useSoftBorders) {
            this.config.useSoftBorders = useSoftBorders;
        }
        isUsingSoftBorders() {
            return this.config.useSoftBorders;
        }
        getWorldDimensions() {
            return this.worldDimensions;
        }
    }
    exports.WorldCamera = WorldCamera;
    (function (WorldCamera) {
        class Config {
            constructor() {
                /**
                 * True, if collisions with the map borders are enabled.
                 *
                 * Default: true
                 */
                this.bordersEnabled = true;
                /**
                 * True, if the camera should collide softly with the map borders.
                 *
                 * Default: true
                 */
                this.useSoftBorders = true;
            }
        }
        WorldCamera.Config = Config;
    })(WorldCamera = exports.WorldCamera || (exports.WorldCamera = {}));
});
define("src/map/view/world/World", ["require", "exports", "src/map/view/Layer"], function (require, exports, Layer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.World = void 0;
    class World extends Layer_1.Layer {
        // Initialization
        constructor(environment) {
            super(environment);
            this.lastCameraTransformMatrix = environment.renderer.newMatrix(0, 0, 0, 0, 0, 0);
        }
        // Scene initialization
        // @Override
        initialize() {
            super.initialize();
            this.getScene().setRoundPixels(true);
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            this.updateScenePixelAlignment();
        }
        updateScenePixelAlignment() {
            // If world camera does not move, enable pixel alignment mode for this scene.
            let worldCamera = this.getScene().getCamera();
            let transformMatrix = worldCamera.getView().localTransform;
            // We use a hysteresis to to remove jittering.
            let movingThreshold = 0.01;
            let stillnessThreshold = 0.001;
            if (this.matrixDifferenceExceedsThreshold(transformMatrix, this.lastCameraTransformMatrix, movingThreshold)) {
                this.lastCameraTransformMatrix.a = transformMatrix.a;
                this.lastCameraTransformMatrix.b = transformMatrix.b;
                this.lastCameraTransformMatrix.c = transformMatrix.c;
                this.lastCameraTransformMatrix.d = transformMatrix.d;
                this.lastCameraTransformMatrix.tx = transformMatrix.tx;
                this.lastCameraTransformMatrix.ty = transformMatrix.ty;
                this.getScene().setRoundPixels(false);
            }
            else if (!this.matrixDifferenceExceedsThreshold(transformMatrix, this.lastCameraTransformMatrix, stillnessThreshold)) {
                this.getScene().setRoundPixels(true);
            }
        }
        matrixDifferenceExceedsThreshold(m1, m2, threshold) {
            return (Math.abs(m1.a - m2.a) > threshold ||
                Math.abs(m1.b - m2.b) > threshold ||
                Math.abs(m1.c - m2.c) > threshold ||
                Math.abs(m1.d - m2.d) > threshold ||
                Math.abs(m1.tx - m2.tx) > threshold ||
                Math.abs(m1.ty - m2.ty) > threshold);
        }
    }
    exports.World = World;
});
define("src/map/view/hud/Hud", ["require", "exports", "src/map/view/Layer"], function (require, exports, Layer_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hud = void 0;
    class Hud extends Layer_2.Layer {
        // Initialization
        constructor(environment) {
            super(environment);
        }
        // @Override
        initialize() {
            super.initialize();
            // Use pixel alignment for all objects in th HUD.
            this.getScene().setRoundPixels(true);
        }
    }
    exports.Hud = Hud;
});
define("src/map/FruityMap", ["require", "exports", "src/engine/Game", "src/engine/scene/Scene", "src/map/view/world/objects/WorldCamera", "src/map/view/world/World", "src/map/view/hud/Hud", "src/engine/animation/Animation", "src/engine/animation/LinearInterpolator", "src/engine/scene/Camera"], function (require, exports, Game_1, Scene_1, WorldCamera_1, World_1, Hud_1, Animation_3, LinearInterpolator_2, Camera_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FruityMap = void 0;
    class FruityMap extends Game_1.Game {
        // Initialization
        constructor(options, environment, initializedCallback) {
            super();
            // Animation
            this.animation = new Animation_3.Animation(new LinearInterpolator_2.LinearInterpolator());
            this.animationPaused = false;
            // Observation
            this.initializedCallback = null;
            this.config = options;
            this.sceneEnvironment = environment.scene;
            this.imageResources = options.preloadingImages;
            this.initializedCallback = initializedCallback;
            this.initEngine(this.sceneEnvironment, options.parentHtmlElement);
            this.preventDefaultEventBehaviour();
        }
        preventDefaultEventBehaviour() {
            this.preventMouseWheelEventDefaultBehaviour();
            this.preventKeyDefaultBehaviour();
        }
        preventMouseWheelEventDefaultBehaviour() {
            let handleMouseWheelEvent = function (e) {
                if (e.altKey || e.shiftKey || e.ctrlKey || window.macKeys.cmdKey) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            };
            let canvasElement = this.getHtmlElement();
            if (canvasElement.addEventListener) {
                // IE9, Chrome, Safari, Opera
                canvasElement.addEventListener("mousewheel", handleMouseWheelEvent, false);
                // Firefox
                canvasElement.addEventListener("DOMMouseScroll", handleMouseWheelEvent, false);
            }
            else {
                // IE 6/7/8
                canvasElement.attachEvent("onmousewheel", handleMouseWheelEvent);
            }
        }
        preventKeyDefaultBehaviour() {
            window.addEventListener("keydown", function (e) {
                if (document.activeElement === window.document.body) {
                    let ONE_KEYCODE = 48;
                    let NINE_KEYCODE = 57;
                    if (e.keyCode >= ONE_KEYCODE && e.keyCode <= NINE_KEYCODE) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }
            }, false);
        }
        // @Override
        getResources() {
            return this.imageResources;
        }
        // @Override
        createScenes() {
            // World scene
            this.worldScene = new Scene_1.Scene(this.sceneEnvironment);
            this.worldCamera = new WorldCamera_1.WorldCamera(this.config.camera, this.sceneEnvironment);
            this.worldScene.setCamera(this.worldCamera);
            this.world = new World_1.World(this.sceneEnvironment);
            this.worldScene.addSceneObject(this.world);
            this.addScene(this.worldScene);
            // HUD scene
            this.hudScene = new Scene_1.Scene(this.sceneEnvironment);
            this.hud = new Hud_1.Hud(this.sceneEnvironment);
            this.hudScene.addSceneObject(this.hud);
            this.addScene(this.hudScene);
        }
        // @Override
        destroyScenes() {
            // HUD scene
            this.removeScene(this.hudScene);
            this.hudScene = null;
            // World Scene
            this.removeScene(this.worldScene);
            this.worldScene = null;
            this.worldCamera = null;
        }
        // @Override
        onInitialized() {
            if (this.initializedCallback != null) {
                this.initializedCallback();
                this.initializedCallback = null;
            }
        }
        // Animation
        setAnimationConfiguration(startTimeInSec, endTimeInSec, durationInMs, progressCallback) {
            this.animationConfiguration = {
                startTimeInSec: startTimeInSec,
                endTimeInSec: endTimeInSec,
                durationInMs: durationInMs,
                progressCallback: progressCallback,
            };
        }
        getAnimationConfiguration() {
            return this.animationConfiguration;
        }
        startAnimation() {
            // Animation
            let startValue = 0.0;
            let endValue = 1.0;
            let delayInMs = 0.0;
            this.animation.start(startValue, endValue, this.animationConfiguration.durationInMs, delayInMs);
            // Pause state
            this.animationPaused = false;
            // Layer state
            this.setAnimationModeEnabled(true);
            this.updateAnimationFrameWithProgress(0);
        }
        stopAnimation() {
            // Animation
            this.animation.stop();
            // Pause state
            this.animationPaused = false;
            // Layer state
            this.setAnimationModeEnabled(false);
        }
        pauseAnimation() {
            // Pause state
            this.animationPaused = true;
            // Layer state
            let elapsedTimeInMs = this.animation.getElapsedTimeInMs();
            let progress = elapsedTimeInMs / this.animationConfiguration.durationInMs;
            this.updateAnimationFrameWithProgress(progress);
        }
        resumeAnimation() {
            // Pause state
            this.animationPaused = false;
            // Layer state
            let elapsedTimeInMs = this.animation.getElapsedTimeInMs();
            let progress = elapsedTimeInMs / this.animationConfiguration.durationInMs;
            this.updateAnimationFrameWithProgress(progress);
        }
        seekAnimation(progress) {
            if (progress === 1) {
                this.stopAnimation();
            }
            else {
                // Animation
                if (!this.animation.isCurrentlyAnimating()) {
                    this.startAnimation();
                }
                let elapsedTimeInMs = progress * this.animationConfiguration.durationInMs;
                this.animation.setElapsedTimeInMs(elapsedTimeInMs);
                // Pause state
                this.animationPaused = true;
                // Layer state
                this.setAnimationModeEnabled(true);
                this.updateAnimationFrameWithProgress(progress);
            }
        }
        setAnimationModeEnabled(enabled) {
            this.publishSceneEvent("onAnimationModeEnabled", [enabled]);
        }
        updateAnimationFrameWithProgress(progress) {
            let timeInSec = this.animationConfiguration.startTimeInSec
                + (progress * (this.animationConfiguration.endTimeInSec - this.animationConfiguration.startTimeInSec));
            this.publishSceneEvent("onUpdateAnimationFrame", [timeInSec]);
        }
        // Updating
        // @Override
        onUpdate(lastFrametime) {
            if (this.animation.isCurrentlyAnimating()) {
                if (!this.animationPaused) {
                    let progress = this.animation.getValue(lastFrametime);
                    if (this.animationConfiguration.progressCallback != null) {
                        let start = this.animationConfiguration.startTimeInSec;
                        let end = this.animationConfiguration.endTimeInSec;
                        let currentTimeInSec = start + progress * (end - start);
                        this.animationConfiguration.progressCallback(progress, currentTimeInSec);
                    }
                    this.updateAnimationFrameWithProgress(progress);
                    // We explicitly call stop, to ensure that the stop callback will
                    // be called after the last animation update has completed.
                    if (progress === 1) {
                        this.stopAnimation();
                    }
                }
            }
        }
        // Resizing
        // @Override
        resize() {
            // Set screen size
            const screenWidthBefore = this.worldCamera.getScreenWidth();
            const screenHeightBefore = this.worldCamera.getScreenHeight();
            const screenWidthAfter = this.getEnvironment().renderer.renderTargetSize.x;
            const screenHeightAfter = this.getEnvironment().renderer.renderTargetSize.y;
            // Set frustum
            let frustum = this.worldCamera.getFrustum();
            if (screenWidthBefore > 0 && screenHeightBefore > 0 && screenWidthAfter > 0 && screenHeightAfter > 0) {
                const aspectRatioBefore = screenWidthBefore / screenHeightBefore;
                const aspectRatioAfter = screenWidthAfter / screenHeightAfter;
                frustum = Camera_3.Camera.getExtendedFrustum(frustum, aspectRatioBefore, aspectRatioAfter);
            }
            this.worldCamera.setScreenWidth(screenWidthAfter);
            this.worldCamera.setScreenHeight(screenHeightAfter);
            this.worldCamera.setFrustum(frustum);
            this.worldCamera.resolveCollisionsWithWorldBorders();
            super.resize();
        }
        // Getters and setters
        getWorld() {
            return this.world;
        }
        getHud() {
            return this.hud;
        }
        getEnvironment() {
            return this.sceneEnvironment;
        }
        getCamera() {
            return this.worldCamera;
        }
    }
    exports.FruityMap = FruityMap;
    (function (FruityMap) {
        class Options {
            constructor() {
                this.camera = new WorldCamera_1.WorldCamera.Config();
            }
        }
        FruityMap.Options = Options;
        class Environment {
        }
        FruityMap.Environment = Environment;
    })(FruityMap = exports.FruityMap || (exports.FruityMap = {}));
});
define("src/map/utils/DeviceUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeviceUtils = void 0;
    class DeviceUtils {
        /**
         * see also https://www.npmjs.com/package/ismobilejs
         */
        static isMobileDevice() {
            var apple_phone = /iPhone/i, apple_ipod = /iPod/i, apple_tablet = /iPad/i, android_phone = /\bAndroid(?:.+)Mobile\b/i, // Match 'Android' AND 'Mobile'
            android_tablet = /Android/i, amazon_phone = /\bAndroid(?:.+)SD4930UR\b/i, amazon_tablet = /\bAndroid(?:.+)(?:KF[A-Z]{2,4})\b/i, windows_phone = /Windows Phone/i, windows_tablet = /\bWindows(?:.+)ARM\b/i, // Match 'Windows' AND 'ARM'
            other_blackberry = /BlackBerry/i, other_blackberry_10 = /BB10/i, other_opera = /Opera Mini/i, other_chrome = /\b(CriOS|Chrome)(?:.+)Mobile/i, other_firefox = /Mobile(?:.+)Firefox\b/i; // Match 'Mobile' AND 'Firefox'
            function match(regex, userAgent) {
                return regex.test(userAgent);
            }
            function isMobile(userAgent) {
                var ua = userAgent ||
                    (typeof navigator !== 'undefined' ? navigator.userAgent : '');
                // Facebook mobile app's integrated browser adds a bunch of strings that
                // match everything. Strip it out if it exists.
                var tmp = ua.split('[FBAN');
                if (typeof tmp[1] !== 'undefined') {
                    ua = tmp[0];
                }
                // Twitter mobile app's integrated browser on iPad adds a "Twitter for
                // iPhone" string. Same probably happens on other tablet platforms.
                // This will confuse detection so strip it out if it exists.
                tmp = ua.split('Twitter');
                if (typeof tmp[1] !== 'undefined') {
                    ua = tmp[0];
                }
                var result = {
                    apple: {
                        phone: match(apple_phone, ua) && !match(windows_phone, ua),
                        ipod: match(apple_ipod, ua),
                        tablet: !match(apple_phone, ua) &&
                            match(apple_tablet, ua) &&
                            !match(windows_phone, ua),
                        device: (match(apple_phone, ua) ||
                            match(apple_ipod, ua) ||
                            match(apple_tablet, ua)) &&
                            !match(windows_phone, ua)
                    },
                    amazon: {
                        phone: match(amazon_phone, ua),
                        tablet: !match(amazon_phone, ua) && match(amazon_tablet, ua),
                        device: match(amazon_phone, ua) || match(amazon_tablet, ua)
                    },
                    android: {
                        phone: (!match(windows_phone, ua) && match(amazon_phone, ua)) ||
                            (!match(windows_phone, ua) && match(android_phone, ua)),
                        tablet: !match(windows_phone, ua) &&
                            !match(amazon_phone, ua) &&
                            !match(android_phone, ua) &&
                            (match(amazon_tablet, ua) || match(android_tablet, ua)),
                        device: (!match(windows_phone, ua) &&
                            (match(amazon_phone, ua) ||
                                match(amazon_tablet, ua) ||
                                match(android_phone, ua) ||
                                match(android_tablet, ua))) ||
                            match(/\bokhttp\b/i, ua)
                    },
                    windows: {
                        phone: match(windows_phone, ua),
                        tablet: match(windows_tablet, ua),
                        device: match(windows_phone, ua) || match(windows_tablet, ua)
                    },
                    other: {
                        blackberry: match(other_blackberry, ua),
                        blackberry10: match(other_blackberry_10, ua),
                        opera: match(other_opera, ua),
                        firefox: match(other_firefox, ua),
                        chrome: match(other_chrome, ua),
                        device: match(other_blackberry, ua) ||
                            match(other_blackberry_10, ua) ||
                            match(other_opera, ua) ||
                            match(other_firefox, ua) ||
                            match(other_chrome, ua)
                    }
                };
                (result.any =
                    result.apple.device ||
                        result.android.device ||
                        result.windows.device ||
                        result.other.device),
                    // excludes 'other' devices and ipods, targeting touchscreen phones
                    (result.phone =
                        result.apple.phone || result.android.phone || result.windows.phone),
                    (result.tablet =
                        result.apple.tablet || result.android.tablet || result.windows.tablet);
                return result;
            }
            if (DeviceUtils.isMobile === undefined) {
                DeviceUtils.isMobile = isMobile().any;
            }
            return DeviceUtils.isMobile;
        }
        static getPhysicalPixelsFromLogical(logicalPixels) {
            return logicalPixels;
        }
    }
    exports.DeviceUtils = DeviceUtils;
    DeviceUtils.isMobile = undefined;
});
define("src/map/utils/Logger", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Logger = void 0;
    class Logger {
        static logDebug(message) {
            if (Logger.loggingEnabled) {
                Logger.log("debug", message);
            }
        }
        static logVerbose(message) {
            if (Logger.loggingEnabled) {
                Logger.log("vbose", message);
            }
        }
        static log(level, message) {
            if (Logger.loggingEnabled) {
                Logger.doLog(level + " : " + message);
            }
        }
        static doLog(message) {
            if (Logger.loggingEnabled) {
                let time = new Date();
                let timeString = time.getHours() + ":" + time.getMinutes() + ":" + time.getSeconds();
                let totalMessage = timeString + ": " + message;
                Logger.logToConsole(totalMessage);
                // Logger.logToFile(totalMessage);
            }
        }
        static logLine() {
            if (Logger.loggingEnabled) {
                Logger.logDebug("---------------------------------------");
            }
        }
        static logToConsole(message) {
            if (Logger.loggingEnabled) {
                /* tslint:disable */
                console.log(message);
                /* tslint:enable */
            }
        }
    }
    exports.Logger = Logger;
    Logger.loggingEnabled = false;
});
define("src/app/relution/model/Model", ["require", "exports", "src/map/utils/Logger"], function (require, exports, Logger_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ModelPropertyBinding = exports.ModelPropertyOptions = exports.ModelProperty = exports.ModelSubTypes = exports.ModelTypeInfo = exports.ModelType = exports.Model = void 0;
    /**
     * Base class for all model classes.
     *
     * To make inheritance work correctly while deserialization and serialization of JSON objects,
     * attach the @ModelTypeInfo and @ModelSubTypes decorator to make the resolution polymorphic.
     *
     * Attach the @ModelProperty to all the data fields that should be considered while
     * serializing or deserializing JSON objects using the {@code RelutionMapModelLoader} class.
     *
     * Use the {@code clazz} attribute in the options passed to your @ModelProperty, if the property
     * refers to a submodel that also extends from this base class.
     *
     * Observation:
     * All observers are notified if they have a corresponding callback handler
     * with the name: "<name>Changed".
     * After each callback "modelChanged" will be called.
     */
    class Model {
        constructor() {
            // Observers
            this.observers = new Array();
        }
        // Metaprogramming
        static getTypeFieldForModelClass(modelClass) {
            for (let i = 0; i < Model.modelClassToTypeFieldBinder.length; i++) {
                let binder = Model.modelClassToTypeFieldBinder[i];
                if (binder.modelClass === modelClass) {
                    return binder.typeField;
                }
            }
            return null;
        }
        static getModelClassForType(typeValue) {
            for (let i = 0; i < Model.modelClassTypeBinder.length; i++) {
                let binder = Model.modelClassTypeBinder[i];
                if (binder.type === typeValue) {
                    return binder.modelClassWrapperFunction();
                }
            }
            return null;
        }
        static getPropertyBindingsForObject(object) {
            let propertyBindings = [];
            for (let classConstructor of Array.from(this.modelClassConstructorToPropertyBinding.keys())) {
                if (object instanceof classConstructor) {
                    propertyBindings.push(this.modelClassConstructorToPropertyBinding.get(classConstructor));
                }
            }
            return propertyBindings;
        }
        // Updating
        /**
         * Updates all model attributes for which getters and setters exist
         * from the given model.
         * @param model The updated model
         */
        update(model) {
            let propertyNames = Object.getOwnPropertyNames(model);
            for (let i = 0; i < propertyNames.length; i++) {
                let propertyName = propertyNames[i];
                try {
                    if (propertyName.substring(0, 2) !== "__" && propertyName.substring(0, 1) === "_") {
                        let accessor = propertyName.substring(1);
                        this[accessor] = model[accessor];
                    }
                }
                catch (e) {
                    Logger_1.Logger.logDebug("Failed to update model attribute \"" + propertyName + "\"");
                }
            }
        }
        // Cloning
        /**
         * Clones the object and deeply copies all attributes for which
         * getters and setters exist.
         */
        clone() {
            // 1. Create new object of same type (functions will be copied).
            let newModel = Object.create(this.constructor.prototype);
            // 2. Get all attributes
            let propertyNames = Object.getOwnPropertyNames(this);
            // 3. Flatly copy all non-model attributes
            this.flatCloneNonModelAttributes(newModel, propertyNames);
            // 4. All observers should be removed
            newModel.observers = [];
            // 5. Deeply copy all model attributes.
            this.deepCloneModelAttributes(newModel, propertyNames);
            // Return clone
            return newModel;
        }
        flatCloneNonModelAttributes(newModel, propertyNames) {
            for (let i = 0; i < propertyNames.length; i++) {
                let propertyName = propertyNames[i];
                try {
                    if (propertyName.substring(0, 2) === "__") {
                        newModel[propertyName] = this[propertyName];
                    }
                    else if (propertyName.substring(0, 1) === "_") {
                        newModel[propertyName] = this[propertyName];
                    }
                }
                catch (e) {
                    Logger_1.Logger.logDebug("flat cloning non model attributes failed.");
                }
            }
        }
        deepCloneModelAttributes(newModel, propertyNames) {
            for (let i = 0; i < propertyNames.length; i++) {
                let propertyName = propertyNames[i];
                try {
                    let accessor = null;
                    if (propertyName.substring(0, 2) === "__") {
                        accessor = propertyName.substring(2);
                    }
                    else if (propertyName.substring(0, 1) === "_") {
                        accessor = propertyName.substring(1);
                    }
                    try {
                        newModel[accessor] = JSON.parse(JSON.stringify(this[accessor]));
                    }
                    catch (e) {
                        newModel[accessor] = this[accessor];
                    }
                }
                catch (e) {
                    Logger_1.Logger.logDebug("Deep cloning model attributes failed.");
                }
            }
        }
        // Equals
        /**
         * Returns true, if all attributes are equal in terms of the "===" operator.
         * @param o the object to compare.
         */
        equals(o) {
            if (o === null || o === undefined) {
                return false;
            }
            let propertyNames = Object.getOwnPropertyNames(o);
            if (propertyNames.length !== Object.getOwnPropertyNames(this).length) {
                return false;
            }
            for (let i = 0; i < propertyNames.length; i++) {
                let propertyName = propertyNames[i];
                try {
                    let accessor = null;
                    if (propertyName.substring(0, 2) === "__") {
                        accessor = propertyName.substring(2);
                    }
                    else if (propertyName.substring(0, 1) === "_") {
                        accessor = propertyName.substring(1);
                    }
                    if (this[accessor] !== o[accessor]) {
                        return false;
                    }
                }
                catch (e) {
                    Logger_1.Logger.logDebug("Failed to compare model attribute \"" + propertyName + "\"");
                }
            }
            return true;
        }
        // Observation
        addObserver(observer) {
            this.observers.push(observer);
        }
        removeObserver(observer) {
            let index = this.observers.indexOf(observer);
            if (index > -1) {
                this.observers.splice(index, 1);
            }
        }
        isObserver(observer) {
            for (let i = 0; i < this.observers.length; i++) {
                let o = this.observers[i];
                if (o === observer) {
                    return true;
                }
            }
            return false;
        }
        notifyObservers(propertyName) {
            let postfix = "Changed";
            let callbackName = propertyName + postfix;
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                if (typeof observer["" + callbackName] === "function") {
                    observer["" + callbackName].apply(observer, [this]);
                }
                let generalCallback = "model" + postfix;
                if (typeof observer["" + generalCallback] === "function") {
                    observer["" + generalCallback].apply(observer, [this]);
                }
            }
        }
    }
    exports.Model = Model;
    // Metadata:
    // Binds the model classes to its type field used for polymorphic deserialization using the @ModelTypeInfo decorator.
    Model.modelClassToTypeFieldBinder = new Array();
    // Binds the model classes to its type value for poylmorphic deserialization.
    Model.modelClassTypeBinder = new Array();
    // Maps a property annotated with @ModelProperty the options object.
    Model.modelClassConstructorToPropertyBinding = new Map();
    (function (Model) {
        class ModelClassTypeFieldBinder {
            constructor(modelClass, typeField) {
                this.modelClass = modelClass;
                this.typeField = typeField;
            }
        }
        Model.ModelClassTypeFieldBinder = ModelClassTypeFieldBinder;
    })(Model = exports.Model || (exports.Model = {}));
    // tslint:disable-next-line:max-classes-per-file
    class ModelType {
        constructor(modelClass, type) {
            this.modelClassWrapperFunction = modelClass;
            this.type = type;
        }
    }
    exports.ModelType = ModelType;
    // @ModelTypeInfo
    /**
     * Decorator function to allow polymorphic deserializations of model classes.
     * It binds all classes inheriting from the annotated class to the type field.
     * @param type
     */
    function ModelTypeInfo(type) {
        return function (modelClass) {
            Model.modelClassToTypeFieldBinder.push(new Model.ModelClassTypeFieldBinder(modelClass, type));
        };
    }
    exports.ModelTypeInfo = ModelTypeInfo;
    // @ModelSubTypes
    /**
     * Decorator function to allow polymorphic deserializations of model classes.
     * It maps the sub class's constructor to its corresponding type field value.
     * This decorator requires also the @ModelTypeInfo decorator to be specified.
     * @param modelTypes
     */
    function ModelSubTypes(...modelTypes) {
        return function (modelClass) {
            for (let i = 0; i < modelTypes.length; i++) {
                let modelType = modelTypes[i];
                Model.modelClassTypeBinder.push(modelType);
            }
        };
    }
    exports.ModelSubTypes = ModelSubTypes;
    // @ModelProperty
    /**
     * Decorator functions used for annotating properties in an inheriting model class.
     * All fields annotated with this decorator will be synced.
     */
    function ModelProperty(options = new ModelPropertyOptions()) {
        return (target, propertyKey) => {
            const clazz = target.constructor;
            if (!Model.modelClassConstructorToPropertyBinding.has(clazz)) {
                Model.modelClassConstructorToPropertyBinding.set(clazz, new ModelPropertyBinding());
            }
            let binding = Model.modelClassConstructorToPropertyBinding.get(clazz);
            binding.propertyNameToOption.set(propertyKey, options);
        };
    }
    exports.ModelProperty = ModelProperty;
    class ModelPropertyOptions {
        constructor() {
            /**
             * The class's constructor the property is based on.
             *
             * E.g. private _subModels: Array<SubModel>
             * is based on SubModel.
             *
             * Default: undefined
             */
            this.clazz = undefined;
            /**
             * During serialization and deserialization the property will not be searched
             * in the current JSON node but in the {@code findIn} child node.
             * If this is undefined, the property will be searched in the current JSON node while
             * traversing the the JSON tree.
             *
             * Default: undefined
             */
            this.findIn = undefined;
        }
    }
    exports.ModelPropertyOptions = ModelPropertyOptions;
    class ModelPropertyBinding {
        constructor() {
            this.propertyNameToOption = new Map();
        }
    }
    exports.ModelPropertyBinding = ModelPropertyBinding;
});
define("src/app/relution/model/RelutionMapModel", ["require", "exports", "src/app/relution/model/Model"], function (require, exports, Model_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RelutionMapModel = void 0;
    /**
     * Base class for all models in the Relution map.
     *
     * All model classes that should be serialized/deserialized using
     * the RelutionMapModelLoader class should inherit from this class,
     * as the UUID identifier is required to match JSON objects and the
     * internal RelutionMap models.
     */
    class RelutionMapModel extends Model_1.Model {
        constructor() {
            // Properties
            super(...arguments);
            /**
             * The model UUID
             */
            this._uuid = null;
        }
        // Getters and setters
        get uuid() {
            return this._uuid;
        }
        set uuid(uuid) {
            this._uuid = uuid;
            this.notifyObservers("uuid");
        }
    }
    __decorate([
        (0, Model_1.ModelProperty)()
    ], RelutionMapModel.prototype, "_uuid", void 0);
    exports.RelutionMapModel = RelutionMapModel;
});
define("src/app/relution/model/RelutionMapObjectModel", ["require", "exports", "src/app/relution/model/RelutionMapModel"], function (require, exports, RelutionMapModel_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParentModel = exports.RelutionMapObjectModel = void 0;
    /**
     * Base class for all models bound to a RelutionMapObject view.
     */
    class RelutionMapObjectModel extends RelutionMapModel_1.RelutionMapModel {
        /**
         * sets the client object at construction time.
         *
         * @param boundObject used for construction
         */
        constructor(boundObject) {
            super();
            // Internal attributes
            /**
             * Two underscores, as we do not want it to be updated, when
             * the object is synced with a new version of it.
             */
            this.__visible = true;
            this.__boundObject = boundObject;
        }
        /**
         * gets the client object the map object was constructed from.
         *
         * @returns object providing property values.
         */
        getBoundObject() {
            return this.__boundObject;
        }
        // Getters and setters
        get visible() {
            return this.__visible;
        }
        set visible(visible) {
            this.__visible = visible;
            this.notifyObservers("visibility");
        }
        // Derived attributes
        /**
         * If the position is unknown, a view will not be created for this model.
         */
        hasUnknownPosition() {
            return false;
        }
        /**
         * Returns true, if the object is currently on the map.
         */
        isOnMap() {
            return true;
        }
        /**
         * Returns the UUID of the model this model existentially depends on.
         * This equals the value of the property annotated with @ModelProperty.
         * Returns null, if this model does not depend on any other model.
         *
         * Default: null
         */
        get parentUuid() {
            const propertyName = RelutionMapObjectModel.classNameToParentProperty.get(this.constructor.name);
            if (propertyName !== undefined) {
                const accessor = propertyName.substring(1);
                return this[accessor];
            }
            else {
                return null;
            }
        }
        /**
         * Sets the UUID of the model this model existentially depends on to {@code parentUuid}.
         * This equals setting the property annotated with @ModelProperty to {@code parentUuid}..
         */
        set parentUuid(parentUuid) {
            const propertyName = RelutionMapObjectModel.classNameToParentProperty.get(this.constructor.name);
            if (propertyName !== undefined) {
                const accessor = propertyName.substring(1);
                this[accessor] = parentUuid;
            }
        }
    }
    exports.RelutionMapObjectModel = RelutionMapObjectModel;
    // Meta attributes
    RelutionMapObjectModel.classNameToParentProperty = new Map();
    // @ParentModel
    /**
     * Decorator functions used for annotating properties in an inheriting model class.
     * All fields annotated with this decorator will be synced.
     */
    function ParentModel() {
        return (target, propertyKey) => {
            RelutionMapObjectModel.classNameToParentProperty.set(target.constructor.name, propertyKey);
        };
    }
    exports.ParentModel = ParentModel;
});
define("src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", ["require", "exports", "src/map/view/Layer"], function (require, exports, Layer_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FloorplanRelatedLayer = void 0;
    class FloorplanRelatedLayer extends Layer_3.Layer {
        constructor(environment, floorplanLayer) {
            super(environment);
            this.floorplanLayer = floorplanLayer;
        }
        getFloorplanLayer() {
            return this.floorplanLayer;
        }
    }
    exports.FloorplanRelatedLayer = FloorplanRelatedLayer;
});
define("src/app/relution/model/floor/FloorModel", ["require", "exports", "src/app/relution/model/RelutionMapModel", "src/app/relution/model/Model"], function (require, exports, RelutionMapModel_2, Model_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FloorModel = void 0;
    class FloorModel extends RelutionMapModel_2.RelutionMapModel {
        constructor() {
            super(...arguments);
            this.wallplanImageUrl = null;
            this.floorplanOverlayNameToImageUrl = new Map();
        }
        // Getters and setters
        get latitude() {
            return this._latitude;
        }
        set latitude(latitude) {
            this._latitude = latitude;
            this.notifyObservers("latitude");
        }
        get longitude() {
            return this._longitude;
        }
        set longitude(longitude) {
            this._longitude = longitude;
            this.notifyObservers("longitude");
        }
        get floorBaseInMeter() {
            return this._floorBaseInMeter;
        }
        set floorBaseInMeter(floorBaseInMeter) {
            this._floorBaseInMeter = floorBaseInMeter;
            this.notifyObservers("floorBaseInMeter");
        }
        get defaultSmartBeaconHeight() {
            return this._defaultSmartBeaconHeight;
        }
        set defaultSmartBeaconHeight(defaultSmartBeaconHeight) {
            this._defaultSmartBeaconHeight = defaultSmartBeaconHeight;
            this.notifyObservers("defaultSmartBeaconHeight");
        }
        get defaultAssetHeight() {
            return this._defaultAssetHeight;
        }
        set defaultAssetHeight(defaultAssetHeight) {
            this._defaultAssetHeight = defaultAssetHeight;
            this.notifyObservers("defaultAssetHeight");
        }
        get pixelPerMeter() {
            return this._pixelPerMeter;
        }
        set pixelPerMeter(pixelPerMeter) {
            this._pixelPerMeter = pixelPerMeter;
            this.notifyObservers("pixelPerMeter");
        }
        get lengthInMeter() {
            return this._lengthInMeter;
        }
        set lengthInMeter(lengthInMeter) {
            this._lengthInMeter = lengthInMeter;
            this.notifyObservers("lengthInMeter");
        }
        get orientation() {
            return this._orientation;
        }
        set orientation(orientation) {
            this._orientation = orientation;
            this.notifyObservers("orientation");
        }
    }
    __decorate([
        (0, Model_2.ModelProperty)()
    ], FloorModel.prototype, "_latitude", void 0);
    __decorate([
        (0, Model_2.ModelProperty)()
    ], FloorModel.prototype, "_longitude", void 0);
    __decorate([
        (0, Model_2.ModelProperty)()
    ], FloorModel.prototype, "_floorBaseInMeter", void 0);
    __decorate([
        (0, Model_2.ModelProperty)()
    ], FloorModel.prototype, "_defaultSmartBeaconHeight", void 0);
    __decorate([
        (0, Model_2.ModelProperty)()
    ], FloorModel.prototype, "_defaultAssetHeight", void 0);
    __decorate([
        (0, Model_2.ModelProperty)()
    ], FloorModel.prototype, "_pixelPerMeter", void 0);
    __decorate([
        (0, Model_2.ModelProperty)()
    ], FloorModel.prototype, "_lengthInMeter", void 0);
    __decorate([
        (0, Model_2.ModelProperty)()
    ], FloorModel.prototype, "_orientation", void 0);
    exports.FloorModel = FloorModel;
});
define("src/map/utils/GraphicsUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GraphicsUtils = void 0;
    class GraphicsUtils {
        static getPowerTwoTextureSize(imageWidth, imageHeight) {
            let maxNumberPixels = Math.max(imageWidth, imageHeight);
            let powerTwoSize = 1;
            while (powerTwoSize < maxNumberPixels) {
                powerTwoSize *= 2;
            }
            return powerTwoSize;
        }
    }
    exports.GraphicsUtils = GraphicsUtils;
});
define("src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/AbstractFloorplanLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/map/utils/GraphicsUtils", "src/engine/math/Vector2"], function (require, exports, FloorplanRelatedLayer_1, GraphicsUtils_1, Vector2_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractFloorplanLayer = void 0;
    class AbstractFloorplanLayer extends FloorplanRelatedLayer_1.FloorplanRelatedLayer {
        // Initialization
        constructor(environment, floorModel, texture) {
            super(environment, null);
            this.htmlImageElement = null;
            this.initModel(floorModel);
            this.initView(texture);
        }
        initModel(floorModel) {
            this.model = floorModel;
        }
        initView(texture) {
            this.initHtmlImageElement(texture);
            this.initBackgroundView();
        }
        initHtmlImageElement(texture) {
            // Set html image element
            this.htmlImageElement = texture.source;
            let powerTwoTextureSize = GraphicsUtils_1.GraphicsUtils.getPowerTwoTextureSize(this.htmlImageElement.naturalWidth, this.htmlImageElement.naturalHeight);
            this.htmlImageElement.width = powerTwoTextureSize;
            this.htmlImageElement.height = powerTwoTextureSize;
        }
        initBackgroundView() {
            // The background view is needed to span the view container as big as the floor size.
            this.backgroundView = this.getEnvironment().renderer.newGraphicsObject();
            this.backgroundView.beginFill(0x000000, 0);
            this.backgroundView.drawRect(0, 0, 1, 1);
            this.backgroundView.endFill();
            // Scaling
            this.backgroundView.width = this.getFloorSize().x;
            this.backgroundView.height = this.getFloorSize().y;
            // Scene graph
            this.getView().addChild(this.backgroundView);
        }
        // View
        getFloorSize() {
            let width = this.htmlImageElement.naturalWidth;
            let height = this.htmlImageElement.naturalHeight;
            return new Vector2_10.Vector2(width, height);
        }
        getCurrentFloorSizeInScreenPx() {
            let camera = this.getScene().getCamera();
            let floorSizeInTx = this.getFloorSize();
            let widthInTx = floorSizeInTx.x;
            let heightInTx = floorSizeInTx.y;
            let point1InWorld = new Vector2_10.Vector2(0, 0);
            let point2InWorld = new Vector2_10.Vector2(widthInTx, 0);
            let point3InWorld = new Vector2_10.Vector2(0, heightInTx);
            let point1InScreen = camera.getImageCoordinateFromWorldPoint(point1InWorld);
            let point2InScreen = camera.getImageCoordinateFromWorldPoint(point2InWorld);
            let point3InScreen = camera.getImageCoordinateFromWorldPoint(point3InWorld);
            let widthInPx = Vector2_10.Vector2.getLengthOfPoint(new Vector2_10.Vector2(point1InScreen.x - point2InScreen.x, point1InScreen.y - point2InScreen.y));
            let heightInPx = Vector2_10.Vector2.getLengthOfPoint(new Vector2_10.Vector2(point1InScreen.x - point3InScreen.x, point1InScreen.y - point3InScreen.y));
            return new Vector2_10.Vector2(widthInPx, heightInPx);
        }
        // Model updating
        getModel() {
            return this.model;
        }
    }
    exports.AbstractFloorplanLayer = AbstractFloorplanLayer;
});
define("src/map/utils/Language", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Language = void 0;
    class Language {
        // Options
        static setOptions(object, defaultOptions, options) {
            if (options) {
                for (let i in options) {
                    if (options.hasOwnProperty(i)) {
                        defaultOptions[i] = options[i];
                    }
                }
            }
            object.options = defaultOptions;
        }
        // Metaprogramming
        static getGetters(prototype) {
            return Object.keys(prototype).filter((name) => {
                return typeof Object.getOwnPropertyDescriptor(prototype, name)["get"] === "function";
            });
        }
        static getSetters(prototype) {
            return Object.keys(prototype).filter((name) => {
                return typeof Object.getOwnPropertyDescriptor(prototype, name)["set"] === "function";
            });
        }
    }
    exports.Language = Language;
});
define("src/map/view/world/layers/tileLayer/Tile", ["require", "exports", "src/engine/general/AABB", "src/engine/math/Vector2"], function (require, exports, AABB_3, Vector2_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tile = void 0;
    class Tile {
        constructor() {
            this.expired = false;
            this.replacingTiles = new Array();
            this.loaded = false;
            this.loadedCallbacks = new Array();
            this.id = Tile.lastId;
            Tile.lastId++;
        }
        equals(tile) {
            return this.id === tile.id;
        }
        getAabb(tileSizeInPx) {
            let tileSize = (tileSizeInPx * this.depthIndex);
            let tileMinWorldX = this.columnIndex * tileSize;
            let tileMinWorldY = this.rowIndex * tileSize;
            let tileMaxWorldX = tileMinWorldX + tileSize;
            let tileMaxWorldY = tileMinWorldY + tileSize;
            let tileAabb = new AABB_3.AABB(new Vector2_11.Vector2(tileMinWorldX, tileMinWorldY), new Vector2_11.Vector2(tileMaxWorldX, tileMaxWorldY));
            return tileAabb;
        }
        addLoadedCallback(loadedCallback) {
            this.loadedCallbacks.push(loadedCallback);
            if (this.loaded) {
                this.notifyCallbacksAboutLoaded();
            }
        }
        markAsLoaded() {
            this.loaded = true;
            this.notifyCallbacksAboutLoaded();
        }
        notifyCallbacksAboutLoaded() {
            for (let i = 0; i < this.loadedCallbacks.length; i++) {
                let loadedCallback = this.loadedCallbacks[i];
                loadedCallback();
            }
        }
        // Getters and setters
        getLogDepthIndex() {
            return Math.log(this.depthIndex) / Math.log(2);
        }
    }
    exports.Tile = Tile;
    Tile.lastId = 0;
});
define("src/map/view/world/layers/tileLayer/TileResponse", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TileResponse = void 0;
    class TileResponse {
        // Initialization
        constructor(tile, tileLoader) {
            this.tile = tile;
            this.tileLoader = tileLoader;
        }
        // Drawing
        drawTileOnCanvas() {
            return this.tileLoader.drawTileOnCanvas(this);
        }
        // Getters and setters
        getTile() {
            return this.tile;
        }
    }
    exports.TileResponse = TileResponse;
});
define("src/map/view/world/layers/tileLayer/TileLoader", ["require", "exports", "src/map/utils/Language"], function (require, exports, Language_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TileLoader = void 0;
    class TileLoader {
        // Initialization
        constructor(options) {
            Language_1.Language.setOptions(this, new TileLoader.Options(), options);
            this.createWhiteCanvas();
        }
        createWhiteCanvas() {
            this.emptyCanvas = document.createElement("canvas");
            let textureSize = this.options.tileSizeInPx;
            this.emptyCanvas.width = textureSize;
            this.emptyCanvas.height = textureSize;
            let ctx = this.emptyCanvas.getContext("2d");
            ctx.beginPath();
            ctx.rect(0, 0, this.emptyCanvas.width, this.emptyCanvas.height);
            ctx.fillStyle = "white";
            ctx.fill();
        }
        drawEmptyTileOnCanvas() {
            return this.emptyCanvas;
        }
        // Getters and setters
        getTileSizeInPx() {
            return this.options.tileSizeInPx;
        }
    }
    exports.TileLoader = TileLoader;
    (function (TileLoader) {
        class Options {
            constructor() {
                this.tileSizeInPx = 256;
            }
        }
        TileLoader.Options = Options;
    })(TileLoader = exports.TileLoader || (exports.TileLoader = {}));
});
define("src/map/view/world/layers/tileLayer/TilePainter", ["require", "exports", "src/engine/general/AABB", "src/engine/math/Vector2"], function (require, exports, AABB_4, Vector2_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TilePainter = void 0;
    class TilePainter {
        // Initialization
        constructor(htmlImageElement, tileSizeInPx) {
            // Painting: Paint base
            this.htmlImageElement = null;
            this.htmlImageSrc = "";
            this.drawBordersAroundTiles = false;
            this.htmlImageElement = htmlImageElement;
            this.tileSizeInPx = tileSizeInPx;
        }
        // Drawing API
        drawCanvasForTile(tile) {
            let imageAabb = this.getImageAabb();
            let tileAabb = tile.getAabb(this.tileSizeInPx);
            let tileWidth = tileAabb.max.x - tileAabb.min.x;
            let tileHeight = tileAabb.max.y - tileAabb.min.y;
            let imageWidth = imageAabb.max.x - imageAabb.min.x;
            let imageHeight = imageAabb.max.y - imageAabb.min.y;
            if (tileAabb.innerIntersects(imageAabb)) {
                let canvas = this.createCanvas();
                let clippedMinX = Math.max(imageAabb.min.x, tileAabb.min.x);
                let clippedMinY = Math.max(imageAabb.min.y, tileAabb.min.y);
                let clippedMaxX = Math.min(imageAabb.max.x, tileAabb.max.x);
                let clippedMaxY = Math.min(imageAabb.max.y, tileAabb.max.y);
                let sx = clippedMinX;
                let sy = clippedMinY;
                let swidth = clippedMaxX - clippedMinX;
                let sheight = clippedMaxY - clippedMinY;
                let x = imageAabb.min.x <= tileAabb.min.x ? 0
                    : (imageAabb.min.x - tileAabb.min.x) * (this.tileSizeInPx / tileWidth);
                let y = imageAabb.min.y <= tileAabb.min.y ? 0
                    : (imageAabb.min.y - tileAabb.min.y) * (this.tileSizeInPx / tileHeight);
                let width = canvas.width * swidth / tileWidth;
                let height = canvas.height * sheight / tileHeight;
                let ctx = canvas.getContext("2d");
                ctx.drawImage(this.htmlImageElement, sx, sy, swidth, sheight, x, y, width, height);
                if (this.drawBordersAroundTiles) {
                    canvas.style.border = "1px solid #000000";
                    ctx.strokeRect(0, 0, canvas.width, canvas.height);
                }
                return canvas;
            }
            else {
                // Let the canvas be white.
                return null;
            }
        }
        getImageAabb() {
            let minWorldX = 0;
            let minWorldY = 0;
            let maxWorldX = this.htmlImageElement.naturalWidth;
            let maxWorldY = this.htmlImageElement.naturalHeight;
            return new AABB_4.AABB(new Vector2_12.Vector2(minWorldX, minWorldY), new Vector2_12.Vector2(maxWorldX, maxWorldY));
        }
        createCanvas() {
            let canvas = document.createElement("canvas");
            const textureSize = this.tileSizeInPx;
            canvas.width = textureSize;
            canvas.height = textureSize;
            return canvas;
        }
    }
    exports.TilePainter = TilePainter;
});
define("src/map/view/world/layers/tileLayer/LocalTileLoader", ["require", "exports", "src/map/view/world/layers/tileLayer/TileLoader", "src/map/view/world/layers/tileLayer/TilePainter", "src/map/view/world/layers/tileLayer/TileResponse"], function (require, exports, TileLoader_1, TilePainter_1, TileResponse_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocalTileLoader = void 0;
    class LocalTileLoader extends TileLoader_1.TileLoader {
        // Initialization
        constructor(environment, source, options) {
            super(options);
            if (source instanceof HTMLImageElement) {
                this.htmlImageElement = source;
                this.initTilePainter();
            }
            else if (typeof source === "string") {
                let texture = environment.renderer.getTexture("" + source);
                this.htmlImageElement = texture.source;
                this.initTilePainter();
            }
            else {
                throw new Error("source has wrong type");
            }
        }
        initTilePainter() {
            this.tilePainter = new TilePainter_1.TilePainter(this.htmlImageElement, this.getTileSizeInPx());
        }
        // World dimensions
        // @Override
        getWorldWidth() {
            return this.htmlImageElement.naturalWidth;
        }
        // @Override
        getWorldHeight() {
            return this.htmlImageElement.naturalHeight;
        }
        // Tile loading
        loadTile(tile, responseCallback) {
            // Since the image is already loaded (local), we can immediately call the response callback.
            let tileResponse = new TileResponse_1.TileResponse(tile, this);
            responseCallback(tileResponse);
            return null;
        }
        cancelTile(tileImage) {
            // Tile loading cannot be canceled, because tiles are not loaded...
        }
        // Tile drawing
        drawTileOnCanvas(tileResponse) {
            let tile = tileResponse.getTile();
            let canvas = this.tilePainter.drawCanvasForTile(tile);
            if (!canvas) {
                canvas = this.drawEmptyTileOnCanvas();
            }
            return canvas;
        }
    }
    exports.LocalTileLoader = LocalTileLoader;
});
define("src/map/view/world/layers/tileLayer/TileReplacement", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TileReplacement = void 0;
    class TileReplacement {
        constructor() {
            this.oldTiles = new Array();
            this.newTiles = new Array();
        }
    }
    exports.TileReplacement = TileReplacement;
});
define("src/map/view/world/layers/tileLayer/TileEngine", ["require", "exports", "src/engine/scene/GameObject", "src/map/view/world/layers/tileLayer/Tile", "src/map/view/world/layers/tileLayer/TileReplacement", "src/engine/math/Vector2"], function (require, exports, GameObject_4, Tile_1, TileReplacement_1, Vector2_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TileEngine = void 0;
    class TileEngine extends GameObject_4.GameObject {
        // Initialization
        constructor(config, environment, worldCamera, tileSizeInPx) {
            super(environment);
            this.lastPivot = new Vector2_13.Vector2();
            this.lastScale = new Vector2_13.Vector2();
            this.lastOrientation = 0;
            this.lastPosition = new Vector2_13.Vector2();
            this.currentVisibleTiles = new Array();
            this.lastVisibleTiles = new Array();
            this.tileReplacements = new Array();
            this.tilesToAdd = new Array();
            this.tilesToRemove = new Array();
            // Observers
            this.observers = new Array();
            this.config = config;
            this.worldCamera = worldCamera;
            this.tileSizeInPx = tileSizeInPx;
        }
        // Observation
        addTileEngineObserver(observer) {
            this.observers.push(observer);
        }
        onLoadTiles(tiles) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                observer.onLoadTiles(tiles);
            }
        }
        onReplaceTiles(tileReplacements) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                observer.onReplaceTiles(tileReplacements);
            }
        }
        onUnloadTiles(tiles) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                observer.onUnloadTiles(tiles);
            }
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.hasFrustumChanged()) {
                this.updateLastFrustum();
                this.updateCurrentlyVisibleTiles();
                if (this.tileVisibilityChanged()) {
                    this.updateTileReplacements();
                    this.updateTilesToAdd();
                    this.updateTilesToRemove();
                    if (this.tileReplacements.length !== 0) {
                        this.onReplaceTiles(this.tileReplacements);
                    }
                    if (this.tilesToAdd.length !== 0) {
                        this.onLoadTiles(this.tilesToAdd);
                    }
                    if (this.tilesToRemove.length !== 0) {
                        this.onUnloadTiles(this.tilesToRemove);
                    }
                    this.lastVisibleTiles = this.currentVisibleTiles;
                }
            }
        }
        hasFrustumChanged() {
            return this.lastPivot.x !== this.worldCamera.getPivotX() ||
                this.lastPivot.y !== this.worldCamera.getPivotY() ||
                this.lastScale.x !== this.worldCamera.getScaleX() ||
                this.lastScale.y !== this.worldCamera.getScaleY() ||
                this.lastOrientation !== this.worldCamera.getRotation() ||
                this.lastPosition.x !== this.worldCamera.getX() ||
                this.lastPosition.y !== this.worldCamera.getY();
        }
        updateLastFrustum() {
            this.lastPivot.x = this.worldCamera.getPivotX();
            this.lastScale.x = this.worldCamera.getScaleX();
            this.lastScale.y = this.worldCamera.getScaleY();
            this.lastOrientation = this.worldCamera.getRotation();
            this.lastPosition.x = this.worldCamera.getX();
            this.lastPosition.y = this.worldCamera.getY();
        }
        updateCurrentlyVisibleTiles() {
            // 1. Identify quadtree depth
            let depth = this.getQuadtreeDepth();
            // 2. Add new tiles
            let collidingTiles = [];
            let frustum = this.worldCamera.getFrustum();
            let frustumAabb = frustum.getObb().getAabb();
            let minColumn = Math.floor(frustumAabb.min.x / (this.tileSizeInPx * depth));
            let maxColumn = Math.floor(frustumAabb.max.x / (this.tileSizeInPx * depth));
            let minRow = Math.floor(frustumAabb.min.y / (this.tileSizeInPx * depth));
            let maxRow = Math.floor(frustumAabb.max.y / (this.tileSizeInPx * depth));
            for (let i = minColumn; i <= maxColumn; i++) {
                for (let j = minRow; j <= maxRow; j++) {
                    let columnIndex = i;
                    let rowIndex = j;
                    let depthIndex = depth;
                    let tile = this.getCurrentlyVisibleTile(columnIndex, rowIndex, depthIndex);
                    // Reuse tiles that were visible before to save performance
                    // and to ensure that the tile Id does not change until it will be removed.
                    if (!tile) {
                        tile = new Tile_1.Tile();
                        tile.columnIndex = i;
                        tile.rowIndex = j;
                        tile.depthIndex = depth;
                    }
                    collidingTiles.push(tile);
                }
            }
            // 4. Update currently visible tiles.
            this.currentVisibleTiles = collidingTiles;
        }
        getQuadtreeDepth() {
            // If scaleFactor = 1, we have achieved the quadtree's bottom layer.
            // So zooming further in does not increase the resolution.
            let depth = this.worldCamera.getScaleX();
            depth = Math.max(1, depth);
            depth = this.getNearestPowerOfTwo(depth);
            return depth;
        }
        getNearestPowerOfTwo(n) {
            let powerTwoSize = 1;
            while (powerTwoSize < n) {
                powerTwoSize *= 2;
            }
            if (this.config.loadTilesForRetinaDisplay) {
                powerTwoSize = Math.max(1, powerTwoSize / 2);
            }
            else {
                powerTwoSize = Math.max(1, powerTwoSize);
            }
            return powerTwoSize;
        }
        getCurrentlyVisibleTile(columnIndex, rowIndex, depthIndex) {
            for (let i = 0; i < this.currentVisibleTiles.length; i++) {
                let tile = this.currentVisibleTiles[i];
                if (tile.columnIndex === columnIndex && tile.rowIndex === rowIndex && tile.depthIndex === depthIndex) {
                    return tile;
                }
            }
            return null;
        }
        tileVisibilityChanged() {
            // Early out
            if (this.currentVisibleTiles.length !== this.lastVisibleTiles.length) {
                return true;
            }
            for (let i = 0; i < this.currentVisibleTiles.length; i++) {
                let currentVisibleTile = this.currentVisibleTiles[i];
                if (!this.arrayContainsTile(this.lastVisibleTiles, currentVisibleTile)) {
                    return true;
                }
            }
            return false;
        }
        arrayContainsTile(tileArray, tile) {
            for (let i = 0; i < tileArray.length; i++) {
                let lastVisibleTile = tileArray[i];
                if (lastVisibleTile.equals(tile)) {
                    return true;
                }
            }
            return false;
        }
        updateTileReplacements() {
            this.tileReplacements = [];
            for (let i = 0; i < this.currentVisibleTiles.length; i++) {
                let currentVisibleTile = this.currentVisibleTiles[i];
                // If tile was not visible before
                if (!this.arrayContainsTile(this.lastVisibleTiles, currentVisibleTile)) {
                    let overlappingTiles = this.getOverlappingTilesForTile(currentVisibleTile, this.lastVisibleTiles);
                    // Iterate over all tiles that will cover the new tile
                    for (let j = 0; j < overlappingTiles.length; j++) {
                        let overlappingTile = overlappingTiles[j];
                        // The overlapping tile must be removed in this update cycle.
                        if (!this.arrayContainsTile(this.currentVisibleTiles, overlappingTile)) {
                            overlappingTile.expired = true;
                            overlappingTile.replacingTiles.push(currentVisibleTile);
                            this.addReplacementTuple(overlappingTile, currentVisibleTile);
                        }
                    }
                }
            }
            return this.tileReplacements;
        }
        getOverlappingTilesForTile(tile, tileArray) {
            let overlappingTiles = new Array();
            for (let i = 0; i < tileArray.length; i++) {
                let potentialOverlappingTile = tileArray[i];
                if (this.tileOverlapsTile(potentialOverlappingTile, tile)) {
                    overlappingTiles.push(potentialOverlappingTile);
                }
            }
            return overlappingTiles;
        }
        tileOverlapsTile(tile1, tile2) {
            // Solution 1: Exploiting quadtree properties
            // To save performance, we exploit the mathematical properties of the quadtree
            // instead of checking tile intersections.
            if (tile1.depthIndex === tile2.depthIndex) {
                return false;
            }
            let lowerTile = tile1.depthIndex < tile2.depthIndex ? tile1 : tile2;
            let higherTile = tile1.depthIndex < tile2.depthIndex ? tile2 : tile1;
            let depthFactor = higherTile.depthIndex / lowerTile.depthIndex;
            let lowerTileMinRow = higherTile.rowIndex * depthFactor;
            let lowerTileMaxRow = lowerTileMinRow + 1;
            let lowerTileMinCol = higherTile.columnIndex * depthFactor;
            let lowerTileMaxCol = lowerTileMinCol + 1;
            return (lowerTile.rowIndex === lowerTileMinRow || lowerTile.rowIndex === lowerTileMaxRow)
                && (lowerTile.columnIndex === lowerTileMinCol || lowerTile.columnIndex === lowerTileMaxCol);
            /*
            // Solution 2. Intersection test
            let tile1Aabb = tile1.getAabb(this.tileSizeInPx);
            let tile2Aabb = tile2.getAabb(this.tileSizeInPx);
            return tile1Aabb.innerIntersects(tile2Aabb);
            */
        }
        addReplacementTuple(oldTile, newTile) {
            let tileReplacement = this.getTileReplacementForTuple(oldTile, newTile);
            if (tileReplacement == null) {
                tileReplacement = new TileReplacement_1.TileReplacement();
                this.tileReplacements.push(tileReplacement);
            }
            if (!this.arrayContainsTile(tileReplacement.newTiles, newTile)) {
                tileReplacement.newTiles.push(newTile);
            }
            if (!this.arrayContainsTile(tileReplacement.oldTiles, oldTile)) {
                tileReplacement.oldTiles.push(oldTile);
            }
        }
        getTileReplacementForTuple(oldTile, newTile) {
            for (let i = 0; i < this.tileReplacements.length; i++) {
                let tileReplacement = this.tileReplacements[i];
                if (this.arrayContainsTile(tileReplacement.oldTiles, oldTile)
                    || this.arrayContainsTile(tileReplacement.newTiles, newTile)) {
                    return tileReplacement;
                }
            }
            return null;
        }
        tileIsInReplacements(tile) {
            for (let i = 0; i < this.tileReplacements.length; i++) {
                let tileReplacement = this.tileReplacements[i];
                if (this.arrayContainsTile(tileReplacement.newTiles, tile)
                    || this.arrayContainsTile(tileReplacement.oldTiles, tile)) {
                    return true;
                }
            }
            return false;
        }
        updateTilesToAdd() {
            this.tilesToAdd = [];
            for (let i = 0; i < this.currentVisibleTiles.length; i++) {
                let currentVisibleTile = this.currentVisibleTiles[i];
                if (!this.arrayContainsTile(this.lastVisibleTiles, currentVisibleTile)) {
                    // Do not add to tilesToAdd list if tile will be replaced
                    if (!this.tileIsInReplacements(currentVisibleTile)) {
                        this.tilesToAdd.push(currentVisibleTile);
                    }
                }
            }
            return this.tilesToAdd;
        }
        updateTilesToRemove() {
            this.tilesToRemove = [];
            for (let i = 0; i < this.lastVisibleTiles.length; i++) {
                let lastVisibleTile = this.lastVisibleTiles[i];
                if (!this.arrayContainsTile(this.currentVisibleTiles, lastVisibleTile)) {
                    if (!this.tileIsInReplacements(lastVisibleTile)) {
                        lastVisibleTile.expired = true;
                        this.tilesToRemove.push(lastVisibleTile);
                    }
                }
            }
            return this.tilesToRemove;
        }
        // Getters and setters
        setTileSizeInPx(tileSizeInPx) {
            this.tileSizeInPx = tileSizeInPx;
        }
        getTileSizeInPx() {
            return this.tileSizeInPx;
        }
    }
    exports.TileEngine = TileEngine;
    (function (TileEngine) {
        class Config {
            constructor() {
                /**
                 * True, if the double number of tiles should be loaded and shrinked
                 * to make the tiles look more crispy on retina displays.
                 *
                 * Default: false
                 */
                this.loadTilesForRetinaDisplay = false;
            }
        }
        TileEngine.Config = Config;
    })(TileEngine = exports.TileEngine || (exports.TileEngine = {}));
});
define("src/map/view/world/layers/tileLayer/TileObject", ["require", "exports", "src/engine/scene/SceneObject", "src/engine/animation/Animation", "src/engine/animation/LinearInterpolator"], function (require, exports, SceneObject_3, Animation_4, LinearInterpolator_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TileObject = void 0;
    class TileObject extends SceneObject_3.SceneObject {
        // Initialization
        constructor(environment) {
            super(environment);
            // Model
            this.tile = null;
            this.lastTile = null;
            this.initView();
            this.initAnimation();
        }
        initView() {
            this.tileSprite = this.getEnvironment().renderer.newSpriteObject();
        }
        initAnimation() {
            this.animation = new Animation_4.Animation(new LinearInterpolator_3.LinearInterpolator());
        }
        reset() {
            this.lastTile = this.tile;
            this.tile = null;
            this.tileSprite.alpha = 0.0;
            this.animation.stop();
            this.animation.removeObservers();
        }
        // View
        getView() {
            return this.tileSprite;
        }
        // Animation
        animateVisible(visible, stoppedCallback) {
            let startValue = this.getView().alpha;
            let endValue = visible ? 1.0 : 0.0;
            let durationInMs = 250;
            let delayInMs = 0;
            this.animation.removeObservers();
            if (stoppedCallback) {
                this.animation.addObserver({
                    animationDidStart: (animation) => { },
                    animationDidStop: (animation) => { stoppedCallback(animation); },
                    animationDidFinish: (animation) => { },
                });
            }
            this.animation.start(startValue, endValue, durationInMs, delayInMs);
        }
        // Updating
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.animation.isCurrentlyAnimating()) {
                let currentAlpha = this.animation.getValue(lastFrametime);
                this.getView().alpha = currentAlpha;
            }
        }
        // Getters and setters
        setTile(tile) {
            this.tile = tile;
        }
        getTile() {
            return this.tile;
        }
        setLastTile(lastTile) {
            this.lastTile = lastTile;
        }
        getLastTile() {
            return this.lastTile;
        }
    }
    exports.TileObject = TileObject;
});
define("src/map/view/world/layers/tileLayer/TileLayer", ["require", "exports", "src/map/view/Layer", "src/map/view/world/layers/tileLayer/TileEngine", "src/map/view/world/layers/tileLayer/TileObject", "src/map/utils/Logger"], function (require, exports, Layer_4, TileEngine_1, TileObject_1, Logger_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TileLayer = void 0;
    class TileLayer extends Layer_4.Layer {
        // Initialization
        constructor(config, environment, tileLoader) {
            super(environment);
            this.updateIntervalInMs = 1;
            this.reservedFrametimeForTextureLoadingInPercent = 10;
            // Updating: Ready-to-load queue
            this.readyToLoadQueue = new Array();
            this.readyToLoadQueueChanged = false;
            this.lastRequestStartTimeMs = 0;
            // Updating: Loading queue
            this.loadingQueue = new Array();
            // Updating: Texture loading queue
            this.textureLoadingQueue = new Array();
            this.textureLoadingQueueChanged = false;
            this.screenCenterInWorld = null;
            this.lastTextureLoadingTimestampInMs = 0;
            this.newTextureCreated = false;
            this.config = config;
            this.tileLoader = tileLoader;
            this.initBackgroundView();
        }
        initBackgroundView() {
            // The background view is needed to span the view container as big as the tile layer is.
            this.backgroundView = this.getEnvironment().renderer.newGraphicsObject();
            this.backgroundView.beginFill(0x000000, 0);
            this.backgroundView.drawRect(0, 0, 1, 1);
            this.backgroundView.endFill();
            // Scaling
            this.backgroundView.width = this.tileLoader.getWorldWidth();
            this.backgroundView.height = this.tileLoader.getWorldHeight();
            // Scene graph
            this.getView().addChild(this.backgroundView);
        }
        // @Override
        initialize() {
            super.initialize();
            this.initTileEngine();
            this.initTileObjectPool();
            this.initVisibleTileObjects();
        }
        initTileEngine() {
            let worldCamera = this.getScene().getCamera();
            this.tileEngine = new TileEngine_1.TileEngine(this.config.tileEngine, this.getEnvironment(), worldCamera, this.tileLoader.getTileSizeInPx());
            this.tileEngine.addTileEngineObserver(this);
        }
        initTileObjectPool() {
            // Pool Size
            // We define the pool size to be the triple amount of tiles visible in the screen,
            // to ensure that blending effects with overlapping tiles are also possible.
            // This is because when the camera switches from one depth layer to the next,
            // the lower layer shows 2*maxVisibleTilesInScreen tiles and the layer above 1*maxVisibleTilesInScreen.
            let screenWidth = window.screen.width;
            let screenHeight = window.screen.height;
            let tileSizeInPx = this.tileEngine.getTileSizeInPx();
            let maxVisibleTilesInScreen = ((screenWidth / tileSizeInPx) + 2) * (((screenHeight / tileSizeInPx) + 2));
            let poolSize = this.config.texturePoolSizeFactor * maxVisibleTilesInScreen;
            // Init pool
            this.tileObjectPool = new Array();
            for (let i = 0; i < poolSize; i++) {
                this.addTileObjectToPool();
            }
        }
        addTileObjectToPool() {
            let tileObject = this.createInitialTileObject();
            this.tileObjectPool.push(tileObject);
            this.addChild(tileObject);
        }
        createInitialTileObject() {
            let tileObject = new TileObject_1.TileObject(this.getEnvironment());
            let canvas = this.tileLoader.drawEmptyTileOnCanvas();
            // Mipmapping is disabled, because texSubImage2D causes weird blending effects
            // while zooming, when mipmapping is enabled.
            tileObject.getView().texture = this.getEnvironment().renderer.newTexture(undefined, { mipmap: false });
            return tileObject;
        }
        initVisibleTileObjects() {
            this.visibleTileObjects = new Array();
        }
        // Event-Handling: Loading Tiles
        // @Override
        onLoadTiles(tiles) {
            for (let i = 0; i < tiles.length; i++) {
                let tile = tiles[i];
                this.loadTile(tile);
            }
        }
        loadTile(tile) {
            this.loadTileAsync(tile, function (loadedTile, tileObject) {
                if (tileObject != null && tileObject.getTile() != null && loadedTile.id === tileObject.getTile().id) {
                    tileObject.getView().alpha = 1;
                }
            });
        }
        loadTileAsync(tile, completionCallback) {
            // Load tile object into GPU asynchronously
            let asyncLoadRequest = new TileLayer.AsyncLoadRequest(tile, completionCallback);
            // We use a FIFO data structure to sequentially handle the asynchronous loading requests.
            // To ensure that large queues will be handled in a minimum amount of time, we make use
            // of the expiration mechanism offered in the tile engine. Therefore, in large scale zooming
            // scenarios rapid tile replacements will lead to lots of tile expirations even before
            // they have been handled. Thus, the load requests referring to expired tiles will be skipped
            // in a minimum amount of time.
            this.readyToLoadQueue.push(asyncLoadRequest);
            this.readyToLoadQueueChanged = true;
        }
        // Event-Handling: Replacing Tiles
        // @Override
        onReplaceTiles(tileReplacements) {
            for (let i = 0; i < tileReplacements.length; i++) {
                const tileReplacement = tileReplacements[i];
                const oldTiles = tileReplacement.oldTiles;
                const newTiles = tileReplacement.newTiles;
                this.replaceTiles(oldTiles, newTiles);
            }
        }
        replaceTiles(oldTiles, newTiles) {
            let that = this;
            let numNewTilesLoaded = 0;
            let onTileLoaded = function (tile, tileObject) {
                // @Synchronized-Start
                numNewTilesLoaded++;
                if (numNewTilesLoaded === newTiles.length) {
                    // If some tiles have not been loaded due to expiration, we
                    // consider this replacement set to be cancelled. Therefore
                    // we unload all tiles that have benn loaded yet and will soon
                    // be replaced by other tiles. However, if all tiles have been loaded
                    // we ignore the expired flag of all tiles and complete the loading
                    // process by blending them over with the old tiles.
                    let visibleNewTileObjects = that.getVisibleTileObjectsForTiles(newTiles);
                    if (visibleNewTileObjects.length !== newTiles.length) {
                        for (let i = 0; i < newTiles.length; i++) {
                            let newTile = newTiles[i];
                            if (newTile.replacingTiles.length > 0) {
                                that.unloadTile(newTile);
                            }
                        }
                        visibleNewTileObjects = that.getVisibleTileObjectsForTiles(newTiles);
                    }
                    that.blendTileObjects(oldTiles, newTiles, visibleNewTileObjects);
                }
                // @Synchronized-End
            };
            for (let i = 0; i < newTiles.length; i++) {
                let newTile = newTiles[i];
                this.loadTileAsync(newTile, onTileLoaded);
            }
        }
        blendTileObjects(oldTiles, newTiles, animatingNewTileObjects) {
            // Animation Finished callback
            let that = this;
            let numAnimationsFinished = 0;
            let onAnimationEndCallback = function () {
                // @Synchronized-Start
                numAnimationsFinished++;
                if (numAnimationsFinished === animatingNewTileObjects.length) {
                    that.unloadOldTilesWhenFullRegionIsCoveredByNewerTiles(oldTiles, newTiles);
                }
                // @Synchronized-End
            };
            let onAnimationStopped = function (animation) {
                // Will be called, when the animation has finished or when it has been cancelled,
                // which happens when the tile object is moved to the object pool.
                animation.removeObservers();
                onAnimationEndCallback();
            };
            if (animatingNewTileObjects.length > 0) {
                // Blend in new tile objects.
                for (let i = 0; i < animatingNewTileObjects.length; i++) {
                    let newTileObject = animatingNewTileObjects[i];
                    newTileObject.animateVisible(true, onAnimationStopped);
                }
            }
            else {
                // This case may happen if all new tiles have been unloaded before being
                // animated. In this case we do not need to blend them, because all
                // of them are already in the object pool or in reuse. Thus we
                // just unload the old tile objects.
                that.unloadOldTilesWhenFullRegionIsCoveredByNewerTiles(oldTiles, newTiles);
            }
        }
        unloadOldTilesWhenFullRegionIsCoveredByNewerTiles(oldTiles, newTiles) {
            let replacingTiles = this.getReplacingTiles(newTiles);
            let that = this;
            let numReplacingTilesLoaded = 0;
            let replacingTileLoadedCallback = function () {
                numReplacingTilesLoaded++;
                if (numReplacingTilesLoaded === replacingTiles.length) {
                    that.informReplacedTilesAboutLoadedTiles(newTiles);
                    that.unloadTiles(oldTiles);
                }
            };
            // If the tiles have really been loaded or if we do
            // not have to wait until tiles of other layers fully
            // cover the region, we finish the loading process by
            // informing depending layers about the load completion
            // and unload the old tiles. Otherwise, we unload the
            // old tiles only until until the region has been
            // completely covered by tiles that will be replace our new tiles.
            if (this.tilesAreVisible(newTiles) || replacingTiles.length === 0) {
                this.informReplacedTilesAboutLoadedTiles(newTiles);
                this.unloadTiles(oldTiles);
            }
            else {
                // 1. Since the new tiles will be definitely replaced by
                // tiles of a newer layer, we can unload all of its tiles now
                // to prevent the algorithm to load lots of textures in
                // the GPU when the camera touches lots of layers
                // in a short period of time, which leads to a great
                // object pool expansion.
                this.unloadTiles(newTiles);
                // 2. Now wait until the region is fully covered
                // by newer tiles. Then inform the depending layers
                // about the load completion. This will ensure that
                // the upper most layer will be unloaded and only
                // the bottom most layer will be visible.
                for (let i = 0; i < replacingTiles.length; i++) {
                    let replacingTile = replacingTiles[i];
                    replacingTile.addLoadedCallback(replacingTileLoadedCallback);
                }
            }
        }
        getReplacingTiles(newTiles) {
            let replacingTiles = new Array();
            for (let i = 0; i < newTiles.length; i++) {
                let newTile = newTiles[i];
                if (newTile.replacingTiles != null) {
                    for (let j = 0; j < newTile.replacingTiles.length; j++) {
                        let replacingTile = newTile.replacingTiles[j];
                        replacingTiles.push(replacingTile);
                    }
                }
            }
            return replacingTiles;
        }
        tilesAreVisible(tiles) {
            for (let i = 0; i < tiles.length; i++) {
                let tile = tiles[i];
                let tileObject = this.getVisibleTileObjectForTile(tile);
                if (tileObject == null) {
                    return false;
                }
            }
            return true;
        }
        informReplacedTilesAboutLoadedTiles(newTiles) {
            for (let i = 0; i < newTiles.length; i++) {
                let newTile = newTiles[i];
                newTile.markAsLoaded();
            }
        }
        unloadTiles(tiles) {
            for (let i = 0; i < tiles.length; i++) {
                let tile = tiles[i];
                this.unloadTile(tile);
            }
        }
        // Event-Handling: Unloading Tiles
        // @Override
        onUnloadTiles(tiles) {
            for (let i = 0; i < tiles.length; i++) {
                const tile = tiles[i];
                this.unloadTile(tile);
            }
        }
        unloadTile(tile) {
            // Unload tile object, (if already/yet exists)
            let tileObject = this.getVisibleTileObjectForTile(tile);
            if (tileObject != null) {
                this.unloadTileObject(tileObject);
            }
        }
        unloadTileObject(tileObject) {
            let index = this.visibleTileObjects.indexOf(tileObject);
            if (index > -1) {
                this.visibleTileObjects.splice(index, 1);
            }
            else {
                Logger_2.Logger.logVerbose("A tile object unload was requested, " +
                    "although the object was not visible before!");
            }
            this.tileObjectPool.push(tileObject);
            tileObject.reset();
        }
        // Helper methods
        getVisibleTileObjectsForTiles(tiles) {
            let tileObjects = new Array();
            for (let i = 0; i < tiles.length; i++) {
                let tile = tiles[i];
                let tileObject = this.getVisibleTileObjectForTile(tile);
                if (tileObject != null) {
                    tileObjects.push(tileObject);
                }
            }
            return tileObjects;
        }
        getVisibleTileObjectForTile(tile) {
            for (let i = 0; i < this.visibleTileObjects.length; i++) {
                let tileObject = this.visibleTileObjects[i];
                let currentTile = tileObject.getTile();
                if (tile.equals(currentTile)) {
                    return tileObject;
                }
            }
            return null;
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            // 1. TileEngine: Find intersections of camera and tiles in quadtree.
            this.tileEngine.update(lastFrametime);
            // 2. Reprioritize ready-to-load queue.
            this.reprioritizeReadyToLoadQueue();
            // 3. Handle ready-to-load queue
            this.handleReadyToLoadQueue();
            // 4. Abort expired tile loading requests
            this.abortExpiredRequests();
            // 5. Reprioritize texture loading queue
            this.reprioritizeTextureLoadingQueue();
            // 6. Handle texture loading queue
            this.handleTextureLoadingQueue();
        }
        // Updating: Repriorization ready-to-load queue
        reprioritizeReadyToLoadQueue() {
            if (this.readyToLoadQueueChanged) {
                this.readyToLoadQueueChanged = false;
                this.reprioritizeAsyncLoadRequestQueue(this.readyToLoadQueue);
            }
        }
        reprioritizeAsyncLoadRequestQueue(queue) {
            // The load requests that are near to the screen center will be prioritized higher.
            if (queue.length > 0) {
                this.precomputeScreenCenterInWorld();
                let currentStartIndex = 0;
                let currentDepthIndex = queue[0].tile.depthIndex;
                for (let i = 0; i < queue.length; i++) {
                    let asyncLoadRequest = queue[i];
                    if (currentDepthIndex !== asyncLoadRequest.tile.depthIndex) {
                        this.reprioritizeSubQueue(queue, currentStartIndex, i);
                        currentStartIndex = i;
                        currentDepthIndex = asyncLoadRequest.tile.depthIndex;
                    }
                }
                this.reprioritizeSubQueue(queue, currentStartIndex, queue.length);
            }
        }
        precomputeScreenCenterInWorld() {
            let worldCamera = this.getScene().getCamera();
            let screenCenterInImage = this.getEnvironment().renderer.newPoint(worldCamera.getScreenWidth() / 2, worldCamera.getScreenHeight() / 2);
            this.screenCenterInWorld = this.getView().toLocal(screenCenterInImage, screenCenterInImage);
        }
        reprioritizeSubQueue(queue, startIndex, endIndex) {
            // Copy shallow subqueue
            let subQueue = queue.slice(startIndex, endIndex);
            // Sort subqueue
            let that = this;
            subQueue.sort(function (request1, request2) {
                let distanceToScreenCenter1 = that.getDistanceToScreenCenter(request1.tile);
                let distanceToScreenCenter2 = that.getDistanceToScreenCenter(request2.tile);
                return distanceToScreenCenter1 - distanceToScreenCenter2;
            });
            // Remove unsorted queue
            queue.splice(startIndex, endIndex - startIndex);
            // Insert sorted queue
            this.insertToQueue(queue, startIndex, subQueue);
        }
        getDistanceToScreenCenter(tile) {
            if ("squaredDistanceToScreenCenter" in tile) {
                return tile.squaredDistanceToScreenCenter;
            }
            else {
                let tileSizeInPx = this.tileEngine.getTileSizeInPx();
                let tileX = tile.columnIndex * tileSizeInPx * tile.depthIndex;
                let tileY = tile.rowIndex * tileSizeInPx * tile.depthIndex;
                let screenCenterInWorld = this.screenCenterInWorld;
                let diffX = screenCenterInWorld.x - tileX;
                let diffY = screenCenterInWorld.y - tileY;
                let squaredDistanceToScreenCenter = diffX * diffX + diffY * diffY;
                tile.squaredDistanceToScreenCenter = squaredDistanceToScreenCenter;
                return squaredDistanceToScreenCenter;
            }
        }
        insertToQueue(queue, startIndex, subQueue) {
            Array.prototype.splice.apply(queue, [startIndex, 0].concat(subQueue));
            return queue;
        }
        // Updating: Handle ready-to-load queue
        handleReadyToLoadQueue() {
            // Throttle asynchronous load requests on the client side.
            // Otherwise the server may throttle us (much heavier).
            const accumulatedTimeSinceLastRequestInMs = Date.now() - this.lastRequestStartTimeMs;
            const timeDiffBetweenLoadRequestsInMs = this.updateIntervalInMs;
            if (accumulatedTimeSinceLastRequestInMs > timeDiffBetweenLoadRequestsInMs) {
                // Remove expired requests to be sure that the first
                // element is definitely unexpired.
                this.removeExpiredRequestsFromReadyToLoadQueue();
                if (this.readyToLoadQueue.length > 0) {
                    this.lastRequestStartTimeMs = Date.now();
                    // Remove load request from ready-to-load queue.
                    let asyncLoadRequest = this.readyToLoadQueue[0];
                    this.readyToLoadQueue.splice(0, 1);
                    // Add to loading queue
                    this.loadingQueue.push(asyncLoadRequest);
                    // Start loading
                    this.startLoadingTile(asyncLoadRequest);
                }
            }
        }
        removeExpiredRequestsFromReadyToLoadQueue() {
            for (let i = 0; i < this.readyToLoadQueue.length; i++) {
                let request = this.readyToLoadQueue[i];
                if (request.tile.expired) {
                    this.readyToLoadQueue.splice(i, 1);
                    i--;
                    request.completionCallback(request.tile, null);
                }
            }
        }
        startLoadingTile(request) {
            let tile = request.tile;
            request.tileRequest = this.tileLoader.loadTile(tile, (tileResponse) => {
                // On completion, remove request from loading queue and
                // add to texture loading queue.
                let index = this.loadingQueue.indexOf(request);
                if (index > -1) {
                    this.loadingQueue.splice(index, 1);
                    request.tileResponse = tileResponse;
                    this.textureLoadingQueue.push(request);
                    this.textureLoadingQueueChanged = true;
                }
                else {
                    Logger_2.Logger.logVerbose("Removing asynchronous load request "
                        + "from loading queue not possible!");
                }
            });
        }
        // Updating: Handle expired load requests
        abortExpiredRequests() {
            for (let i = 0; i < this.loadingQueue.length; i++) {
                let request = this.loadingQueue[i];
                if (request.tile.expired) {
                    this.loadingQueue.splice(i, 1);
                    i--;
                    this.tileLoader.cancelTile(request.tileRequest);
                    request.completionCallback(request.tile, null);
                }
            }
        }
        // Updating: Repriorization texture loading queue
        reprioritizeTextureLoadingQueue() {
            if (this.textureLoadingQueueChanged) {
                this.textureLoadingQueueChanged = false;
                this.reprioritizeAsyncLoadRequestQueue(this.textureLoadingQueue);
            }
        }
        // Updating: Handle texture loading queue
        handleTextureLoadingQueue() {
            // We reduce the amount of tile loads to a certain fraction of frame time
            // to keep zooming smooth.
            let now = Date.now();
            const targetFrametimeInMs = (1.0 / 60) * 1000;
            if (now - this.lastTextureLoadingTimestampInMs > targetFrametimeInMs) {
                // We reserve 10% of CPU time per frame for texture loading.
                let reservedTimeForTileLoadingInMs = targetFrametimeInMs * (this.reservedFrametimeForTextureLoadingInPercent / 100);
                let beforeInMs = Date.now();
                this.newTextureCreated = false;
                while (this.textureLoadingQueue.length > 0
                    && Date.now() - beforeInMs < reservedTimeForTileLoadingInMs && !this.newTextureCreated) {
                    let asyncLoadRequest = this.textureLoadingQueue[0];
                    this.textureLoadingQueue.splice(0, 1);
                    this.loadTextureToGpu(asyncLoadRequest);
                }
                this.lastTextureLoadingTimestampInMs = Date.now();
            }
        }
        loadTextureToGpu(asyncLoadRequest) {
            let tile = asyncLoadRequest.tile;
            let tileResponse = asyncLoadRequest.tileResponse;
            let completionCallback = asyncLoadRequest.completionCallback;
            let tileObject = null;
            // First check if tile object has not been expired before.
            // If it has been expired, we skip the loading procedure and
            // pass the callback a null pointer.
            if (!tile.expired) {
                // If tile is still in cache/object pool, reuse it, otherwise load it.
                tileObject = this.getTileObjectInPoolForTile(tile);
                if (tileObject != null) {
                    tileObject = this.removeTileObjectInPool(tileObject);
                }
                else {
                    tileObject = this.pullOldestTileObjectFromPool();
                    this.loadTileObjectFromTileReponse(tileObject, tileResponse);
                }
                this.visibleTileObjects.push(tileObject);
                this.initTileObject(tileObject, tile);
            }
            // Completion callback
            if (completionCallback != null) {
                completionCallback(tile, tileObject);
            }
        }
        getTileObjectInPoolForTile(tile) {
            for (let i = 0; i < this.tileObjectPool.length; i++) {
                let tileObject = this.tileObjectPool[this.tileObjectPool.length - 1 - i];
                let lastTile = tileObject.getLastTile();
                if (lastTile != null
                    && tile.columnIndex === lastTile.columnIndex
                    && tile.rowIndex === lastTile.rowIndex
                    && tile.depthIndex === lastTile.depthIndex) {
                    return tileObject;
                }
            }
            return null;
        }
        removeTileObjectInPool(tileObject) {
            let index = this.tileObjectPool.indexOf(tileObject);
            if (index > -1) {
                this.tileObjectPool.splice(index, 1);
            }
            else {
                Logger_2.Logger.logVerbose("Removing tile object from pool failed, " +
                    "because object is not in pool anymore!");
            }
            return tileObject;
        }
        pullOldestTileObjectFromPool() {
            // Increase the pool size by creating new tile objects if necessary.
            if (this.tileObjectPool.length === 0) {
                this.addTileObjectToPool();
                // Since new textures will be loaded to the GPU in the rendering phase
                // and not in the loadSource method of BaseTexture, we mark this
                // frame as completed and will not allow other textures to be loaded
                // in this frame to preserve smooth zooming.
                this.newTextureCreated = true;
                Logger_2.Logger.logVerbose("Added tile object to pool.");
                Logger_2.Logger.logVerbose("Current pool size: " + this.tileObjectPool.length);
                Logger_2.Logger.logVerbose("Current visible tiles size: " + this.visibleTileObjects.length);
            }
            // Pull oldest tile object
            let tileObject = this.tileObjectPool[0];
            this.tileObjectPool.splice(0, 1);
            return tileObject;
        }
        loadTileObjectFromTileReponse(tileObject, tileResponse) {
            // Drawing
            let canvas = tileResponse.drawTileOnCanvas();
            // Updates texture using gl.texSubImage2D
            // Thus, texture objects in OpenGL will be reused, so no
            // create and destroy operations are necessary.
            // After conducting some benchmark tests, however, we did not
            // experience significant performance improvements compared
            // to gl.texImage2D.
            tileObject.getView().texture.load(canvas);
        }
        initTileObject(tileObject, tile) {
            // Set tile
            tileObject.setTile(tile);
            // Position
            let tileSizeInPx = this.tileEngine.getTileSizeInPx();
            tileObject.getView().x = tile.columnIndex * tileSizeInPx * tile.depthIndex;
            tileObject.getView().y = tile.rowIndex * tileSizeInPx * tile.depthIndex;
            // Scale
            tileObject.getView().scale.x = tile.depthIndex;
            tileObject.getView().scale.y = tile.depthIndex;
            // Alpha
            tileObject.getView().alpha = 0;
            // Z-ordering.
            this.getView().removeChild(tileObject.getView());
            this.getView().addChild(tileObject.getView());
        }
    }
    exports.TileLayer = TileLayer;
    (function (TileLayer) {
        class Config {
            constructor() {
                /**
                 * Determines the number of textures reserved for the tile layer.
                 * More specifically, this factor will be multiplied by the maximum
                 * number of tiles possible to display on the canvas.
                 *
                 * Default: 3
                 */
                this.texturePoolSizeFactor = 3;
                /**
                 * The tile engine configuration
                 */
                this.tileEngine = new TileEngine_1.TileEngine.Config();
            }
        }
        TileLayer.Config = Config;
        class AsyncLoadRequest {
            constructor(tile, completionCallback) {
                this.tile = tile;
                this.tileResponse = null;
                this.completionCallback = completionCallback;
            }
        }
        TileLayer.AsyncLoadRequest = AsyncLoadRequest;
    })(TileLayer = exports.TileLayer || (exports.TileLayer = {}));
});
define("src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/TileBasedFloorplanLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/AbstractFloorplanLayer", "src/map/view/world/layers/tileLayer/LocalTileLoader", "src/map/view/world/layers/tileLayer/TileLayer"], function (require, exports, AbstractFloorplanLayer_1, LocalTileLoader_1, TileLayer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TileBasedFloorplanLayer = void 0;
    class TileBasedFloorplanLayer extends AbstractFloorplanLayer_1.AbstractFloorplanLayer {
        // Initialization
        constructor(config, environment, floorModel, texture) {
            super(environment, floorModel, texture);
            this.config = config;
            this.initTileLoader();
            this.initTileLayer();
        }
        initTileLoader() {
            this.tileLoader = new LocalTileLoader_1.LocalTileLoader(this.getEnvironment(), this.htmlImageElement, {
                tileSizeInPx: this.config.tileSizeInPx
            });
        }
        initTileLayer() {
            this.tileLayer = new TileLayer_1.TileLayer(this.config.tileLayer, this.getEnvironment(), this.tileLoader);
            this.addChild(this.tileLayer);
        }
    }
    exports.TileBasedFloorplanLayer = TileBasedFloorplanLayer;
    (function (TileBasedFloorplanLayer) {
        class Config {
            constructor() {
                /**
                 * The tile size (in texels)
                 *
                 * Default: 256
                 */
                this.tileSizeInPx = 256;
                /**
                 * The configuration of the tile layer
                 */
                this.tileLayer = new TileLayer_1.TileLayer.Config();
            }
        }
        TileBasedFloorplanLayer.Config = Config;
    })(TileBasedFloorplanLayer = exports.TileBasedFloorplanLayer || (exports.TileBasedFloorplanLayer = {}));
});
define("src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/ImageBasedFloorplanLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/AbstractFloorplanLayer", "src/map/utils/GraphicsUtils", "src/engine/math/Vector2"], function (require, exports, AbstractFloorplanLayer_2, GraphicsUtils_2, Vector2_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImageBasedFloorplanLayer = void 0;
    class ImageBasedFloorplanLayer extends AbstractFloorplanLayer_2.AbstractFloorplanLayer {
        // Initialization
        constructor(environment, floorModel, texture) {
            super(environment, floorModel, texture);
            this.initImageBasedView();
        }
        initImageBasedView() {
            this.initSprite();
            this.initCanvas();
            this.loadTextureFromCanvas();
        }
        initSprite() {
            this.floorplanImage = this.getEnvironment().renderer.newSpriteObject();
            this.getView().addChild(this.floorplanImage);
        }
        initCanvas() {
            this.createCanvas();
            this.drawImageToCanvas();
        }
        createCanvas() {
            this.canvas = document.createElement("canvas");
            let powerTwoTextureSize = GraphicsUtils_2.GraphicsUtils.getPowerTwoTextureSize(this.htmlImageElement.naturalWidth, this.htmlImageElement.naturalHeight);
            this.canvas.width = powerTwoTextureSize;
            this.canvas.height = powerTwoTextureSize;
            return this.canvas;
        }
        drawImageToCanvas() {
            let ctx = this.canvas.getContext("2d");
            ctx.drawImage(this.htmlImageElement, 0, 0, this.htmlImageElement.naturalWidth, this.htmlImageElement.naturalHeight, 0, 0, this.canvas.width, this.canvas.height);
        }
        loadTextureFromCanvas() {
            this.floorplanImage.texture = this.getEnvironment().renderer.newTexture(this.canvas);
            this.floorplanImage.width = this.htmlImageElement.naturalWidth;
            this.floorplanImage.height = this.htmlImageElement.naturalHeight;
        }
        getSize() {
            return new Vector2_14.Vector2(this.floorplanImage.width, this.floorplanImage.height);
        }
    }
    exports.ImageBasedFloorplanLayer = ImageBasedFloorplanLayer;
});
define("src/map/utils/SystemUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SystemUtils = void 0;
    class SystemUtils {
        static getOperatingSystem() {
            let os = SystemUtils.OperatingSystem.UNKNOWN;
            if (window.navigator.userAgent.indexOf("Windows NT 10.0") !== -1) {
                os = SystemUtils.OperatingSystem.WINDOWS_10;
            }
            else if (window.navigator.userAgent.indexOf("Windows NT 6.2") !== -1) {
                os = SystemUtils.OperatingSystem.WINDOWS_8;
            }
            else if (window.navigator.userAgent.indexOf("Windows NT 6.1") !== -1) {
                os = SystemUtils.OperatingSystem.WINDOWS_7;
            }
            else if (window.navigator.userAgent.indexOf("Windows NT 6.0") !== -1) {
                os = SystemUtils.OperatingSystem.WINDOWS_VISTA;
            }
            else if (window.navigator.userAgent.indexOf("Windows NT 5.1") !== -1) {
                os = SystemUtils.OperatingSystem.WINDOWS_XP;
            }
            else if (window.navigator.userAgent.indexOf("Windows NT 5.0") !== -1) {
                os = SystemUtils.OperatingSystem.WINDOWS_2000;
            }
            else if (window.navigator.userAgent.indexOf("Mac") !== -1) {
                os = SystemUtils.OperatingSystem.MAC;
            }
            else if (window.navigator.userAgent.indexOf("X11") !== -1) {
                os = SystemUtils.OperatingSystem.UNIX;
            }
            else if (window.navigator.userAgent.indexOf("Linux") !== -1) {
                os = SystemUtils.OperatingSystem.LINUX;
            }
            return os;
        }
        static isRetinaDisplay() {
            let retina = (window.devicePixelRatio || ((window.screen).deviceXDPI / (window.screen).logicalXDPI)) > 1;
            return retina;
        }
        static getBrowser() {
            if (this.isOpera()) {
                return SystemUtils.Browser.OPERA;
            }
            else if (this.isFirefox()) {
                return SystemUtils.Browser.FIREFOX;
            }
            else if (this.isSafari()) {
                return SystemUtils.Browser.SAFARI;
            }
            else if (this.isIE()) {
                return SystemUtils.Browser.IE;
            }
            else if (this.isChrome()) {
                return SystemUtils.Browser.CHROME;
            }
            else {
                return SystemUtils.Browser.UNKNOWN;
            }
        }
        static isOpera() {
            return (!!window['opr'] && !!window['opr'].addons) || !!window['opera'] || navigator.userAgent.indexOf(' OPR/') >= 0;
        }
        static isFirefox() {
            //noinspection TypeScriptUnresolvedVariable
            return typeof InstallTrigger !== 'undefined';
        }
        static isSafari() {
            return /constructor/i.test(window['HTMLElement']) || ((p) => {
                return p.toString() === "[object SafariRemoteNotification]";
            })(!window['safari'] || window['safari'].pushNotification);
        }
        static isIE() {
            return /*@cc_on!@*/ false || !!window.document['documentMode'];
        }
        static isChrome() {
            return !!window['chrome'] && !!window['chrome'].webstore;
        }
    }
    exports.SystemUtils = SystemUtils;
    (function (SystemUtils) {
        let OperatingSystem;
        (function (OperatingSystem) {
            OperatingSystem[OperatingSystem["WINDOWS_10"] = 0] = "WINDOWS_10";
            OperatingSystem[OperatingSystem["WINDOWS_8"] = 1] = "WINDOWS_8";
            OperatingSystem[OperatingSystem["WINDOWS_7"] = 2] = "WINDOWS_7";
            OperatingSystem[OperatingSystem["WINDOWS_VISTA"] = 3] = "WINDOWS_VISTA";
            OperatingSystem[OperatingSystem["WINDOWS_XP"] = 4] = "WINDOWS_XP";
            OperatingSystem[OperatingSystem["WINDOWS_2000"] = 5] = "WINDOWS_2000";
            OperatingSystem[OperatingSystem["MAC"] = 6] = "MAC";
            OperatingSystem[OperatingSystem["UNIX"] = 7] = "UNIX";
            OperatingSystem[OperatingSystem["LINUX"] = 8] = "LINUX";
            OperatingSystem[OperatingSystem["UNKNOWN"] = 9] = "UNKNOWN";
        })(OperatingSystem = SystemUtils.OperatingSystem || (SystemUtils.OperatingSystem = {}));
        let Browser;
        (function (Browser) {
            Browser[Browser["OPERA"] = 0] = "OPERA";
            Browser[Browser["FIREFOX"] = 1] = "FIREFOX";
            Browser[Browser["SAFARI"] = 2] = "SAFARI";
            Browser[Browser["IE"] = 3] = "IE";
            Browser[Browser["EDGE"] = 4] = "EDGE";
            Browser[Browser["CHROME"] = 5] = "CHROME";
            Browser[Browser["UNKNOWN"] = 6] = "UNKNOWN";
        })(Browser = SystemUtils.Browser || (SystemUtils.Browser = {}));
    })(SystemUtils = exports.SystemUtils || (exports.SystemUtils = {}));
});
define("src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/FloorplanLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/TileBasedFloorplanLayer", "src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/ImageBasedFloorplanLayer", "src/map/utils/SystemUtils", "src/engine/math/Vector2"], function (require, exports, FloorplanRelatedLayer_2, TileBasedFloorplanLayer_1, ImageBasedFloorplanLayer_1, SystemUtils_1, Vector2_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FloorplanLayer = void 0;
    class FloorplanLayer extends FloorplanRelatedLayer_2.FloorplanRelatedLayer {
        // Initialization
        constructor(config, environment, floorModel, texture) {
            super(environment, null);
            this.config = config;
            this.initFloorplanLayerImpl(floorModel, texture);
        }
        initFloorplanLayerImpl(floorModel, texture) {
            // For testing purposes, we enable the tile engine only for Windows 7 and Chrome.
            if (this.floorplanIsBig(floorModel) || this.platformHasMipmappingProblems()) {
                this.floorplanLayerImpl = new TileBasedFloorplanLayer_1.TileBasedFloorplanLayer(this.config.tileBasedFloorplanLayer, this.getEnvironment(), floorModel, texture);
            }
            else {
                this.floorplanLayerImpl = new ImageBasedFloorplanLayer_1.ImageBasedFloorplanLayer(this.getEnvironment(), floorModel, texture);
            }
            this.addChild(this.floorplanLayerImpl);
        }
        floorplanIsBig(floorModel) {
            let widthInTx = floorModel.pixelPerMeter * floorModel.lengthInMeter;
            return widthInTx > 8192;
        }
        platformHasMipmappingProblems() {
            return SystemUtils_1.SystemUtils.getOperatingSystem() === SystemUtils_1.SystemUtils.OperatingSystem.WINDOWS_7
                && SystemUtils_1.SystemUtils.getBrowser() === SystemUtils_1.SystemUtils.Browser.CHROME;
        }
        // View
        getFloorSize() {
            return this.floorplanLayerImpl.getFloorSize();
        }
        // Coordinate transformations
        // Screen pixels -> Relative texels
        getRelativeWorldCoordsFromScreenPixels(pointInScreenPx) {
            let camera = this.getScene().getCamera();
            let pointInWorldTx = camera.getWorldCoordinateFromImagePoint(pointInScreenPx);
            let pointInRelativeWorldCoords = this.getRelativeCoordinatesFromTexels(pointInWorldTx);
            return pointInRelativeWorldCoords;
        }
        // Relative texels -> screen pixels
        getScreenPixelsFromRelativeCoords(pointInRelativeCoords) {
            let pointInWorldTx = this.getTexelsFromRelativeCoordinates(pointInRelativeCoords);
            let pointInScreenPx = this.getScreenPixelsFromTexels(pointInWorldTx);
            return pointInScreenPx;
        }
        // World texels -> Relative texels
        getRelativeCoordinatesFromTexels(pointInTexels) {
            let floorSize = this.getFloorSize();
            let xRelative = pointInTexels.x / floorSize.x;
            let yRelative = pointInTexels.y / floorSize.y;
            let pointRelative = new Vector2_15.Vector2(xRelative, yRelative);
            return pointRelative;
        }
        getTexelsFromRelativeDistance(distanceAsRelative) {
            let floorSize = this.getFloorSize();
            let xInTx = distanceAsRelative * floorSize.x;
            return xInTx;
        }
        // Relative texels -> World texels
        getTexelsFromRelativeCoordinates(pointInRelativeCoords) {
            let floorSize = this.getFloorSize();
            let xInTx = pointInRelativeCoords.x * floorSize.x;
            let yInTx = pointInRelativeCoords.y * floorSize.y;
            let pointInTx = new Vector2_15.Vector2(xInTx, yInTx);
            return pointInTx;
        }
        // World texels -> screen pixels
        getScreenPixelsFromTexels(pointInWorldTx) {
            let camera = this.getScene().getCamera();
            return camera.getImageCoordinateFromWorldPoint(pointInWorldTx);
        }
        // Screen pixels -> World texels
        getTexelsFromScreenPixels(pointInPx) {
            let camera = this.getScene().getCamera();
            return camera.getWorldCoordinateFromImagePoint(pointInPx);
        }
        // World texels -> Centimeter
        getCmFromTexels(distanceInTx) {
            let cmPerTexel = (1.0 / this.getModel().pixelPerMeter) * 100.0;
            let distanceInCm = distanceInTx * cmPerTexel;
            return distanceInCm;
        }
        // Relative -> Centimeter
        getRelativeFromCm(distanceInCm) {
            const cmPerTexel = 100 / this.getModel().pixelPerMeter;
            const distanceInTx = distanceInCm / cmPerTexel;
            const floorWidthInTx = this.getFloorSize().x;
            const distanceInRelative = distanceInTx / floorWidthInTx;
            return distanceInRelative;
        }
        getCmFromRelative(distanceInRelative) {
            const cmPerTexel = (1.0 / this.getModel().pixelPerMeter) * 100.0;
            const floorWidthInTx = this.getFloorSize().x;
            const distanceInCm = distanceInRelative * floorWidthInTx * cmPerTexel;
            return distanceInCm;
        }
        // Screen pixels -> World texels
        getTexelWidthFromPixelWidth(pixelWidth) {
            let v1 = this.getTexelsFromScreenPixels(new Vector2_15.Vector2(pixelWidth, 0));
            let v2 = this.getTexelsFromScreenPixels(new Vector2_15.Vector2(0, 0));
            let texelWidth = Vector2_15.Vector2.getLengthOfPoint(new Vector2_15.Vector2(v2.x - v1.x, v2.y - v1.y));
            return texelWidth;
        }
        // Centimeter -> World texels
        getTexelsFromCm(distanceInCm) {
            let texelsPerCm = this.getModel().pixelPerMeter / 100.0;
            let distanceInTx = distanceInCm * texelsPerCm;
            return distanceInTx;
        }
        // Centimeter -> Screen pixels
        getPixelsFromCm(widthInCm) {
            return (widthInCm / 100) * this.getModel().pixelPerMeter;
        }
        getCurrentFloorSizeInScreenPx() {
            return this.floorplanLayerImpl.getCurrentFloorSizeInScreenPx();
        }
        // Model updating
        getModel() {
            return this.floorplanLayerImpl.getModel();
        }
    }
    exports.FloorplanLayer = FloorplanLayer;
    (function (FloorplanLayer) {
        class Config {
            constructor() {
                /**
                 * Configuration of the tile based floorplan layer.
                 */
                this.tileBasedFloorplanLayer = new TileBasedFloorplanLayer_1.TileBasedFloorplanLayer.Config();
            }
        }
        FloorplanLayer.Config = Config;
    })(FloorplanLayer = exports.FloorplanLayer || (exports.FloorplanLayer = {}));
});
define("src/map/view/world/objects/WorldObject", ["require", "exports", "src/engine/scene/SceneObject", "src/engine/animation/Animation", "src/engine/animation/LinearInterpolator"], function (require, exports, SceneObject_4, Animation_5, LinearInterpolator_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorldObject = void 0;
    class WorldObject extends SceneObject_4.SceneObject {
        // Initialization
        constructor(environment) {
            super(environment);
            // View: Animation
            this.visibilityAnimationDurationInMs = 200;
            this.initWorldObjectViews();
        }
        initWorldObjectViews() {
            this.renderView = this.getEnvironment().renderer.newDisplayObjectContainer();
            this.mainView = this.getEnvironment().renderer.newDisplayObjectContainer();
            this.renderView.addChild(this.mainView);
            this.visibilityAnimation = new Animation_5.Animation(new LinearInterpolator_4.LinearInterpolator());
        }
        // View
        // @Override
        getView() {
            return this.mainView;
        }
        // @Override
        getRenderView() {
            return this.renderView;
        }
        // Visibility
        animateInvisible() {
            let startValue = this.renderView.alpha;
            let endValue = 0.0;
            let durationInMs = this.visibilityAnimationDurationInMs;
            let delayInMs = 0;
            this.visibilityAnimation.start(startValue, endValue, durationInMs, delayInMs);
        }
        setInvisible() {
            this.visibilityAnimation.stop();
            this.renderView.alpha = 0.0;
        }
        animateVisible() {
            let startValue = this.renderView.alpha;
            let endValue = 1.0;
            let durationInMs = this.visibilityAnimationDurationInMs;
            let delayInMs = 0;
            this.visibilityAnimation.start(startValue, endValue, durationInMs, delayInMs);
            // Resume the scene object, if it was invisible before.
            this.setPaused(false);
        }
        setVisible() {
            this.visibilityAnimation.stop();
            this.renderView.alpha = 1.0;
        }
        // Update
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            this.updateVisibilityAnimation(lastFrametime);
        }
        updateVisibilityAnimation(lastFrametime) {
            if (this.visibilityAnimation.isCurrentlyAnimating()) {
                let currentValue = this.visibilityAnimation.getValue(lastFrametime);
                let oldAlpha = this.renderView.alpha;
                this.renderView.alpha = currentValue;
                if (oldAlpha > 0 && currentValue === 0) {
                    // Disable update of this scene object, since it
                    // is not visible anymore. Setting it visible will
                    // resume the scene object.
                    this.setPaused(true);
                }
            }
        }
    }
    exports.WorldObject = WorldObject;
});
define("src/app/relution/view/world/RelutionMapAttributeObject", ["require", "exports", "src/map/view/world/objects/WorldObject"], function (require, exports, WorldObject_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RelutionMapAttributeObject = void 0;
    /**
     * Binds the object's lifetime to the lifetime of zero or more Relution map objects.
     *
     * @export
     * @class RelutionMapAttributeObject
     * @extends {WorldObject}
     */
    class RelutionMapAttributeObject extends WorldObject_1.WorldObject {
        // Initialization
        constructor(environment, object, ...args) {
            super(environment);
            // Model
            this.dependentObjects = new Array();
            if (object !== undefined) {
                this.addObjectDependencies(object, ...args);
                this.syncObjectVisibilityWithoutAnimation();
            }
        }
        // Destruction
        // @Override
        destroy() {
            this.removeObjectDependencies();
            super.destroy();
        }
        // Object dependencies
        addObjectDependencies(object, ...args) {
            this.addObjectDependency(object);
            for (let i = 0; i < args.length; i++) {
                let argObject = args[i];
                this.addObjectDependency(argObject);
            }
        }
        // Adds object dependencies at runtime
        // @Override
        addObjectDependency(object) {
            this.dependentObjects.push(object);
            object.getModel().addObserver(this);
            this.syncObjectVisibilityWithAnimation();
        }
        // @Override
        removeObjectDependency(object) {
            let index = this.dependentObjects.indexOf(object);
            if (index > -1) {
                this.dependentObjects.splice(index, 1);
                object.getModel().removeObserver(this);
                this.syncObjectVisibilityWithAnimation();
            }
        }
        removeObjectDependencies() {
            while (this.dependentObjects.length > 0) {
                this.removeObjectDependency(this.dependentObjects[0]);
            }
        }
        // Model Event-Handling
        // @Override
        visibilityChanged(model) {
            this.syncObjectVisibilityWithAnimation();
        }
        syncObjectVisibilityWithAnimation() {
            // Fade out visibility wrapper if at least one dependent object is invisible.
            if (this.atLeastOneDependentObjectIsInvisible()) {
                this.animateInvisible();
            }
            else {
                this.animateVisible();
            }
        }
        syncObjectVisibilityWithoutAnimation() {
            if (this.atLeastOneDependentObjectIsInvisible()) {
                this.setInvisible();
            }
            else {
                this.setVisible();
            }
        }
        atLeastOneDependentObjectIsInvisible() {
            for (let i = 0; i < this.dependentObjects.length; i++) {
                let object = this.dependentObjects[i];
                if (!object.getModel().visible) {
                    return true;
                }
            }
            return false;
        }
        // Getters and setters
        dependsOnObject(object) {
            for (let i = 0; i < this.dependentObjects.length; i++) {
                let dependentObject = this.dependentObjects[i];
                if (object.getModel().uuid === dependentObject.getModel().uuid) {
                    return true;
                }
            }
            return false;
        }
        getDependentObjects() {
            return this.dependentObjects;
        }
    }
    exports.RelutionMapAttributeObject = RelutionMapAttributeObject;
});
define("src/map/utils/DateUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DateUtils = void 0;
    class DateUtils {
        static getTimeSince(date) {
            if (typeof date !== "object") {
                date = new Date(date);
            }
            let passedMs = new Date() - date;
            return DateUtils.getFormattedTimeDifference(passedMs);
        }
        static getFormattedTimeDifference(timeDifferenceInMs) {
            let seconds = Math.floor(timeDifferenceInMs / 1000);
            let intervalType;
            let interval = Math.floor(seconds / 31536000);
            if (interval >= 1) {
                intervalType = "year";
            }
            else {
                interval = Math.floor(seconds / 2592000);
                if (interval >= 1) {
                    intervalType = "month";
                }
                else {
                    interval = Math.floor(seconds / 86400);
                    if (interval >= 1) {
                        intervalType = "day";
                    }
                    else {
                        interval = Math.floor(seconds / 3600);
                        if (interval >= 1) {
                            intervalType = "hour";
                        }
                        else {
                            interval = Math.floor(seconds / 60);
                            if (interval >= 1) {
                                intervalType = "minute";
                            }
                            else {
                                interval = seconds;
                                intervalType = "second";
                            }
                        }
                    }
                }
            }
            if (interval > 1 || interval === 0) {
                intervalType += "s";
            }
            let result = [];
            result.push(interval);
            result.push(intervalType);
            return result;
        }
        static getFormattedTime(timeInMs) {
            // Create a date object with the current time
            let now = new Date(timeInMs);
            // Create an array with the current month, day and time
            let date = [now.getMonth() + 1, now.getDate(), now.getFullYear()];
            // Create an array with the current hour, minute and second
            let time = [now.getHours(), now.getMinutes(), now.getSeconds()];
            // Determine AM or PM suffix based on the hour
            let suffix = (time[0] < 12) ? "AM" : "PM";
            // Convert hour from military time
            time[0] = (time[0] < 12) ? time[0] : time[0] - 12;
            // If hour is 0, set it to 12
            time[0] = time[0] || 12;
            // If seconds and minutes are less than 10, add a zero
            for (let i = 1; i < 3; i++) {
                if (time[i] < 10) {
                    time[i] = "0" + time[i];
                }
            }
            // Return the formatted string
            return date.join("/") + " " + time.join(":") + " " + suffix;
        }
    }
    exports.DateUtils = DateUtils;
});
define("src/app/relution/view/world/RelutionMapObject", ["require", "exports", "src/engine/general/AABB", "src/map/utils/DeviceUtils", "src/app/relution/view/world/RelutionMapAttributeObject", "src/map/utils/DateUtils", "src/engine/math/Vector2"], function (require, exports, AABB_5, DeviceUtils_1, RelutionMapAttributeObject_1, DateUtils_1, Vector2_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RelutionModelBinding = exports.RelutionViewModelMapping = exports.RelutionMapObject = void 0;
    /**
     * All objects in the Relution map's world that are editable, selectable
     * and contain a reference to a Relution model, should inherit from this
     * base class.
     *
     * @export
     * @class RelutionMapObject
     * @extends {WorldObject}
     */
    class RelutionMapObject extends RelutionMapAttributeObject_1.RelutionMapAttributeObject {
        // Construction
        constructor(config, environment, floorplanLayer, model, dependingObject, ...args) {
            super(environment, dependingObject, ...args);
            // Observation
            this.observers = new Array();
            // State
            this.editModeActive = false;
            this.mouseOver = false;
            this.mouseAboveEditPoint = false;
            this.selected = false;
            this.floorplanLayer = floorplanLayer;
            this.config = config;
            this.initRelutionMapObjectModel(model);
            this.initRelutionMapObjectView();
            this.updateVisibilityWithoutAnimation();
        }
        initRelutionMapObjectModel(model) {
            this.model = model;
            this.model.addObserver(this);
        }
        initRelutionMapObjectView() {
            this.setEditModeActive(this.config.editModeActive);
            this.model.visible = this.config.visible;
        }
        // Observation
        addObserver(observer) {
            this.observers.push(observer);
        }
        removeObserver(observer) {
            let index = this.observers.indexOf(observer);
            if (index >= 0) {
                this.observers.splice(index, 1);
            }
        }
        notifyObservers(callback, args) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Model-binding
        updateModel(model) {
            this.model.update(model);
            this.onModelUpdated(model);
        }
        /**
         * Updates the view based on the updated model.
         * @param model
         */
        onModelUpdated(model) {
            // Empty default implementation
        }
        // Map insertion
        /**
         * Returns true, if the object's model can change its state from onMap=true
         * to onMap=false and, thus, may be removed from the map.
         * Default: false
         *
         * @returns {boolean}
         * @memberof RelutionMapObject
         */
        isMovableToStock() {
            return false;
        }
        isOnMap() {
            if (this.getDependentObjects().length > 0) {
                // Inner object case
                return this.getDependentObjects()[0].isOnMap();
            }
            else {
                // Root object
                return this.model.isOnMap();
            }
        }
        // Visibility
        // View: Visibility
        updateVisibilityWithoutAnimation() {
            if (this.model.visible) {
                this.setVisible();
            }
            else {
                this.setInvisible();
            }
        }
        updateVisibilityWithAnimation() {
            if (this.model.visible) {
                this.animateVisible();
            }
            else {
                this.animateInvisible();
            }
        }
        // @Override
        visibilityChanged(model) {
            this.updateVisibilityWithAnimation();
        }
        // Mouse over
        isMouseOver() {
            return this.mouseOver;
        }
        setMouseOver(mouseOver) {
            if (this.mouseOverStateWillChange(mouseOver)) {
                this.mouseOver = mouseOver;
                this.redraw();
            }
        }
        mouseOverStateWillChange(newMouseOver) {
            return this.mouseOver !== newMouseOver;
        }
        // Mouse above edit point
        isMouseAboveEditPoint() {
            return this.mouseAboveEditPoint;
        }
        setMouseAboveEditPoint(mouseAboveEditPoint) {
            if (this.mouseAboveEditPointStateWillChange(mouseAboveEditPoint)) {
                this.mouseAboveEditPoint = mouseAboveEditPoint;
                this.redraw();
            }
        }
        mouseAboveEditPointStateWillChange(newMouseAboveEditPointState) {
            return this.mouseAboveEditPoint !== newMouseAboveEditPointState;
        }
        getCenter() {
            const objectBoundsInImage = this.getAabbInImageCoordinates();
            const deltaX = objectBoundsInImage.max.x - objectBoundsInImage.min.x;
            const deltaY = objectBoundsInImage.max.y - objectBoundsInImage.min.y;
            return new Vector2_16.Vector2(deltaX / 2, deltaY / 2);
        }
        // Popup info
        /**
         * Returns the content of the popup view that is displayed,
         * whenever the user hovers the map object.
         *
         * By default, this method returns an empty string.
         */
        getPopupInfo() {
            return "";
        }
        /**
         * Returns true, if popup infos are supported.
         *
         * Default: true
         */
        isPopupInfoSupported() {
            return true;
        }
        /**
         * Returns the time as a localized formatted string.
         * @param timeInMs
         */
        getLocalizedTimeSinceString(timeInMs) {
            let timeSince = DateUtils_1.DateUtils.getTimeSince(timeInMs);
            let interval = timeSince[0];
            let intervalType = timeSince[1];
            let timeSinceString = ""
                + this.getLocalizedStringFor("popup_time_unit_prefix")
                + "" + interval + " " + this.getLocalizedStringFor("popup_time_unit_" + intervalType)
                + this.getLocalizedStringFor("popup_time_unit_postfix");
            return timeSinceString;
        }
        // Editing
        /**
         * Returns true, if the edit mode is enabled.
         *
         * @abstract
         * @returns {boolean}
         * @memberof RelutionMapObject
         */
        isEditModeActive() {
            return this.editModeActive;
        }
        setEditModeActive(editModeActive) {
            this.editModeActive = editModeActive;
        }
        /**
         * Returns true, if the point (x,y) given in screen coordinates is
         * close to an area that should be visualized as editable, e.g.
         * the bottom right corner of a rectangle.
         * Default behavior: No point on the object is editable.
         * @param x
         * @param y
         */
        pointIsCloseToEditableArea(x, y) {
            return false;
        }
        /**
         * Event handler called when the user started editing the object.
         * Default behavior: Editing will be ignored.
         * @param x
         * @param y
         */
        onEditStart(x, y) {
            // Nothing to do
        }
        /**
         * Event handler called, when the user moves the mouse cursor while editing the object.
         * Default behavior: Editing will be ignored.
         * @param x
         * @param y
         */
        onEditMove(x, y) {
            // Nothing to do
        }
        /**
         * Event handler called, when the user stopped moving the mouse cursor while editing the object.
         * Default behavior: Editing will be ignored.
         * @param x
         * @param y
         */
        onEditStop(x, y) {
            // Nothing to do
        }
        // Moving
        /**
         * Returns true, if the object is movable.
         *
         * Default: true
         */
        isMovable() {
            return true;
        }
        /**
         * Event handler called, when the user started moving the object.
         * @param x
         * @param y
         */
        onMoveStarted(x, y) {
            // Empty default implementation
        }
        /**
         * Event handler called, when the user moves the mouse cursor while moving the object.
         * @param x
         * @param y
         */
        onMoveChanged(x, y) {
            // Empty default implementation
        }
        /**
         * Event handler called, when the user stopped moving the mouse cursor while moving the object.
         * @param x
         * @param y
         */
        onMoveStopped(x, y) {
            // Empty default implementation
        }
        // Selection
        isSelectable() {
            // By default, a Relution map object is selectable.
            return true;
        }
        isSelected() {
            return this.selected;
        }
        setSelected(selected) {
            let selectedBefore = this.selected;
            this.selected = selected;
            this.redraw();
            if (this.selected && !selectedBefore) {
                this.notifyObservers("onObjectSelected", [this]);
            }
            else if (!this.selected && selectedBefore) {
                this.notifyObservers("onObjectUnselected", [this]);
            }
        }
        // Intersection
        /**
         * Returns true, if the AABB (given in screen pixels) intersects the object.
         *
         * @param aabb an axis-aligned bounding box
         */
        intersectsAabb(aabb) {
            let objectAabb = this.getAabbInImageCoordinates();
            return aabb.intersects(objectAabb);
        }
        /**
         * Returns true, if the point (x,y), given in screen pixels,
         * intersects the object.
         *
         * @abstract
         * @param {number} x
         * @param {number} y
         * @returns {boolean}
         * @memberof RelutionMapObject
         */
        intersectsPointInScreenPx(x, y) {
            let aabb = this.getAabbInImageCoordinates();
            return ((x >= aabb.min.x) && (x <= aabb.max.x) &&
                (y >= aabb.min.y) && (y <= aabb.max.y));
        }
        // Dimensions
        /**
         * Returns the object's axis-aligned-bounding-box
         *
         * @returns {AABB}
         * @memberof RelutionMapObject
         */
        getAabbInImageCoordinates() {
            let bounds = this.getAabbReferenceView().getBounds();
            // On mobile devices, we increase the bounds if necessary,
            // because tapping is more difficult than clicking.
            let aabb = null;
            if (DeviceUtils_1.DeviceUtils.isMobileDevice()) {
                let minPixels = DeviceUtils_1.DeviceUtils.getPhysicalPixelsFromLogical(40);
                let width = bounds.width;
                let height = bounds.height;
                let xAddition = Math.max((minPixels - width) / 2, 0);
                let yAddition = Math.max((minPixels - height) / 2, 0);
                aabb = new AABB_5.AABB(new Vector2_16.Vector2(bounds.x - xAddition, bounds.y - yAddition), new Vector2_16.Vector2(bounds.x + width + xAddition, bounds.y + height + yAddition));
            }
            else {
                aabb = new AABB_5.AABB(new Vector2_16.Vector2(bounds.x, bounds.y), new Vector2_16.Vector2(bounds.x + bounds.width, bounds.y + bounds.height));
            }
            return aabb;
        }
        /**
         * Returns the reference view used for AABB computation.
         * This method can be overridden, if the reference view is not
         * the same as returned by {@link getView}.
         */
        getAabbReferenceView() {
            return this.getView();
        }
        // Getters and setters
        getFloorplanLayer() {
            return this.floorplanLayer;
        }
        getModel() {
            return this.model;
        }
    }
    exports.RelutionMapObject = RelutionMapObject;
    // Metadata
    RelutionMapObject.viewModelClassMappings = new Array();
    (function (RelutionMapObject) {
        class Config {
            constructor() {
                /**
                 * True, if the edit mode should be enabled by default.
                 *
                 * Default: True
                 */
                this.editModeActive = true;
                /**
                 * True, if the Relution map object should be visible by default.
                 *
                 * Default: true
                 */
                this.visible = true;
            }
        }
        RelutionMapObject.Config = Config;
    })(RelutionMapObject = exports.RelutionMapObject || (exports.RelutionMapObject = {}));
    class RelutionViewModelMapping {
        constructor(viewClass, modelClass) {
            this.viewClass = null;
            this.modelClass = null;
            this.viewClass = viewClass;
            this.modelClass = modelClass;
        }
    }
    exports.RelutionViewModelMapping = RelutionViewModelMapping;
    /**
     * Decorator that maps Relution map object classes to its corresponding model classes.
     * @param modelClass
     */
    function RelutionModelBinding(modelClass) {
        return function (viewClass) {
            RelutionMapObject.viewModelClassMappings.push(new RelutionViewModelMapping(viewClass, modelClass));
        };
    }
    exports.RelutionModelBinding = RelutionModelBinding;
});
define("src/app/relution/utils/MouseUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MouseUtils = void 0;
    class MouseUtils {
        static isHandCursorStyle() {
            return window.document.body.style.cursor === "pointer";
        }
        static changeToHandCursorStyle() {
            window.document.body.style.cursor = "pointer";
        }
        static isDefaultCursorStyle() {
            return window.document.body.style.cursor === "default" || window.document.body.style.cursor === "";
        }
        static changeToDefaultCursorStyle() {
            window.document.body.style.cursor = "default";
        }
        static changeToMoveCursorStyle() {
            window.document.body.style.cursor = "move";
        }
    }
    exports.MouseUtils = MouseUtils;
});
define("src/app/relution/view/world/management/RelutionMapObjectModelBinder", ["require", "exports", "src/app/relution/view/world/RelutionMapObject"], function (require, exports, RelutionMapObject_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RelutionMapObjectModelBinder = void 0;
    class RelutionMapObjectModelBinder {
        // Construction
        constructor(config, environment, floorplanLayer, bindings) {
            // Observation
            this.observers = new Array();
            // Metadata: Layer-object bindnig
            this.bindings = new Array();
            // Factory
            this.modelFactory = null;
            this.configFactory = null;
            this.objectFactory = null;
            this.config = config;
            this.environment = environment;
            this.floorplanLayer = floorplanLayer;
            this.bindings = bindings;
        }
        // Observation
        addObserver(observer) {
            this.observers.push(observer);
        }
        removeObserver(observer) {
            if (!observer || !this.observers || !this.observers.length) {
                return false;
            }
            let index = this.observers.indexOf(observer);
            if (index !== -1) {
                this.observers.splice(index, 1);
            }
        }
        getObservers() {
            return this.observers;
        }
        notifyObservers(callback, args) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Factories
        setModelFactory(factory) {
            this.modelFactory = factory;
        }
        getModelFactory() {
            return this.modelFactory;
        }
        setConfigFactory(factory) {
            this.configFactory = factory;
        }
        getConfigFactory() {
            return this.configFactory;
        }
        setObjectFactory(factory) {
            this.objectFactory = factory;
        }
        getObjectFactory() {
            return this.objectFactory;
        }
        // Binding object model
        bindObjectToModel(model) {
            // 1. Get view class
            let viewClass = this.getViewClassForModel(model);
            if (viewClass === null) {
                throw new Error("Failed to find a corresponding view class for model " + model);
            }
            // 2. Create view configuration
            let config = this.createConfigForView(viewClass);
            // 3. Create view
            let view = null;
            if (this.objectFactory !== null) {
                view = this.objectFactory(model, config);
            }
            else {
                view = new viewClass(config, this.environment, this.floorplanLayer, model);
            }
            view.addObserver(this);
            // 4. Initialize view
            model.visible = this.isTypeOfObjectVisible(view);
            view.updateVisibilityWithoutAnimation();
            return view;
        }
        isTypeOfObjectVisible(view) {
            // walk inheritance chain to super classes until objectTypeVisibility is found
            for (let objectType = view.constructor; objectType && objectType !== RelutionMapObject_1.RelutionMapObject; objectType = Object.getPrototypeOf(objectType)) {
                const objectTypeVisible = this.config.objectTypeVisibility.get(objectType);
                if (objectTypeVisible !== undefined) {
                    return typeof objectTypeVisible === 'function' ? objectTypeVisible(view) : objectTypeVisible;
                }
            }
            return false;
        }
        getViewClassForModel(model) {
            for (let modelClass = model.constructor; !!modelClass; modelClass = Object.getPrototypeOf(modelClass)) {
                for (let i = 0; i < RelutionMapObject_1.RelutionMapObject.viewModelClassMappings.length; i++) {
                    let viewModelClassMapping = RelutionMapObject_1.RelutionMapObject.viewModelClassMappings[i];
                    if (viewModelClassMapping.modelClass === modelClass) {
                        let viewClass = viewModelClassMapping.viewClass;
                        if (this.containsBindingToObjectClass(viewClass)) {
                            return viewClass;
                        }
                        else {
                            throw new Error("Layer class does not have a binding for object class " + viewClass);
                        }
                    }
                }
            }
            return null;
        }
        containsBindingToObjectClass(objectClass) {
            for (let i = 0; i < this.bindings.length; i++) {
                let binding = this.bindings[i];
                for (let j = 0; j < binding.objectClasses.length; j++) {
                    let currentObjectClass = binding.objectClasses[j];
                    if (currentObjectClass === objectClass) {
                        return true;
                    }
                }
            }
            return false;
        }
        createConfigForView(viewClass) {
            let config;
            if (this.configFactory != null) {
                config = this.configFactory(viewClass);
            }
            else {
                config = new RelutionMapObject_1.RelutionMapObject.Config();
            }
            // 1. Edit mode
            config.editModeActive = this.config.editModeEnabled;
            // 2. Object type visibility
            config.visible = this.isTypeOfViewVisible(viewClass);
            return config;
        }
        isTypeOfViewVisible(viewClass) {
            // Create a psudo instance of the class without calling its constructor, just needed to use the instanceof operator.
            const pseudoInstance = Object.create(viewClass.prototype);
            let visible = true;
            // As long as the view is substitutable with one object type that is invisible, the view should be set to invisible.
            this.config.objectTypeVisibility.forEach((objectTypeVisible, objectType) => {
                if (pseudoInstance instanceof objectType && !objectTypeVisible) {
                    visible = false;
                }
            });
            return visible;
        }
        // Unbinding object model
        unbindObjectToModel(view) {
            view.removeObserver(this);
        }
        getObjectWithUuid(uuid) {
            for (let i = 0; i < this.getObjects().length; i++) {
                let object = this.getObjects()[i];
                if (object.getModel().uuid === uuid) {
                    return object;
                }
            }
            return null;
        }
        getObjectWithModel(model) {
            for (let i = 0; i < this.getObjects().length; i++) {
                let object = this.getObjects()[i];
                if (object.getModel().uuid === model.uuid) {
                    return object;
                }
            }
            return null;
        }
        existsObject(view) {
            let views = this.getObjects();
            for (let i = 0; i < views.length; i++) {
                let currentView = views[i];
                if (view === currentView) {
                    return true;
                }
            }
            return false;
        }
        containsObject(objects, object) {
            for (let i = 0; i < objects.length; i++) {
                let currentObject = objects[i];
                if (object === currentObject) {
                    return true;
                }
            }
            return false;
        }
        getAllVisibleObjects() {
            let allVisibleViews = new Array();
            let views = this.getObjects();
            for (let i = 0; i < views.length; i++) {
                let view = views[i];
                if (view.getModel().visible) {
                    allVisibleViews.push(view);
                }
            }
            return allVisibleViews;
        }
    }
    exports.RelutionMapObjectModelBinder = RelutionMapObjectModelBinder;
});
define("src/app/relution/view/world/management/ViewModelBinderDelegate", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/app/relution/view/world/management/ViewModelBinder", ["require", "exports", "src/map/utils/Logger"], function (require, exports, Logger_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ViewModelBinder = void 0;
    /**
     * Binds a set of models to views.
     * Whenever a new set of models is loaded, the views will be synchronized.
     *
     * @export
     * @class ViewModelBinder
     * @template M The model type
     * @template V The view type
     */
    class ViewModelBinder {
        // Construction
        constructor(delegate) {
            // Observation
            this.observers = new Array();
            // Models
            this.models = new Array();
            // Views
            this.viewsOnMap = new Array();
            this.viewsInStock = new Array();
            this.delegate = delegate;
        }
        // Observation
        addObserver(observer) {
            this.observers.push(observer);
        }
        removeObserver(observer) {
            if (!observer || !this.observers || !this.observers.length) {
                return false;
            }
            let index = this.observers.indexOf(observer);
            if (index !== -1) {
                this.observers.splice(index, 1);
            }
        }
        getObservers() {
            return this.observers;
        }
        notifyObservers(callback, args) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Load views
        loadViews(models) {
            let removedViews = this.getAllViews();
            this.notifyObservers("onBeforeViewsLoaded", []);
            this.removeAllViews();
            for (let i = 0; i < models.length; i++) {
                let model = models[i];
                this.addViewForModel(model);
            }
            this.notifyObservers("onAfterViewsLoaded", []);
            this.notifyObservers("onViewsUnloaded", [removedViews]);
            this.notifyObservers("onViewsLoaded", [this.getAllViews()]);
        }
        // Update views
        updateViews(models) {
            this.models = models;
            // Notify observers
            this.notifyObservers("onBeforeViewsUpdated", []);
            let removedViews = this.removeViewsNotExistingAnymore(models);
            let updatedViews = this.updateExistingViews(models);
            let addedViews = this.addViews(models);
            // Notify observers
            this.notifyObservers("onAfterViewsUpdated", []);
            this.notifyObservers("onViewsLoaded", [addedViews]);
            this.notifyObservers("onViewsUnloaded", [removedViews]);
        }
        updateView(model) {
            this.updateModels(model);
            const updatedModels = [model];
            // Notify observers
            this.notifyObservers("onBeforeViewsUpdated", []);
            let updatedViews = this.updateExistingViews(updatedModels);
            let addedViews = this.addViews(updatedModels);
            // Notify observers
            this.notifyObservers("onAfterViewsUpdated", []);
            this.notifyObservers("onViewsLoaded", [addedViews]);
        }
        updateModels(model) {
            let index = this.getIndexOfModel(model.uuid);
            if (index != -1) {
                this.models[index] = model;
            }
            else {
                this.models.push(model);
            }
        }
        getIndexOfModel(uuid) {
            if (!this.models || this.models.length == 0) {
                return -1;
            }
            for (let i = 0; i < this.models.length; i++) {
                if (this.models[i].uuid === uuid) {
                    return i;
                }
            }
            return -1;
        }
        // Add views
        addViews(models) {
            let addedViews = [];
            for (let i = 0; i < models.length; i++) {
                let model = models[i];
                let uuid = model.uuid;
                let view = this.getViewWithUuid(uuid);
                if (view == null) {
                    this.addViewForModel(model);
                    view = this.getViewWithUuid(uuid);
                    if (view !== null) {
                        addedViews.push(view);
                    }
                }
            }
            return addedViews;
        }
        addViewForModel(model) {
            try {
                let view = this.delegate.createViewForModel(model);
                if (model.isOnMap()) {
                    this.setViewToMap(view);
                    this.notifyObservers("onViewSetToMap", [view]);
                }
                else {
                    this.setViewToStock(view);
                    this.notifyObservers("onViewSetToStock", [view]);
                }
                return view;
            }
            catch (e) {
                Logger_3.Logger.logDebug("Failed to add view for model " + model + ". " + e);
            }
            return null;
        }
        // Updating views
        updateExistingViews(models) {
            let updatedViews = [];
            for (let i = 0; i < models.length; i++) {
                let model = models[i];
                let uuid = model.uuid;
                let view = this.getViewWithUuid(uuid);
                if (view != null) {
                    updatedViews.push(view);
                    view.updateModel(model);
                }
            }
            return updatedViews;
        }
        // Remove views
        removeAllViews() {
            let removedViews = this.getAllViews();
            for (let i = 0; i < this.viewsOnMap.length; i++) {
                let view = this.viewsOnMap[i];
                let removed = this.removeViewOnMap(view);
                if (removed) {
                    i--;
                }
            }
            for (let i = 0; i < this.viewsInStock.length; i++) {
                let view = this.viewsInStock[i];
                let removed = this.removeViewInStock(view);
                if (removed) {
                    i--;
                }
            }
            this.viewsOnMap = new Array();
            this.viewsInStock = new Array();
            return removedViews;
        }
        removeViewsNotExistingAnymore(models) {
            let removedViews = [];
            let views = this.getAllViews();
            for (let i = 0; i < views.length; i++) {
                let view = views[i];
                let uuid = view.getModel().uuid;
                let newModel = this.getModelWithUuid(uuid, models);
                if (newModel == null) {
                    removedViews.push(view);
                    this.removeView(view);
                }
            }
            return removedViews;
        }
        removeView(view) {
            if (view.getModel().isOnMap()) {
                return this.removeViewOnMap(view);
            }
            else {
                return this.removeViewInStock(view);
            }
        }
        removeViewOnMap(view) {
            let index = this.viewsOnMap.indexOf(view, 0);
            if (index > -1) {
                this.viewsOnMap.splice(index, 1);
                this.delegate.removeViewFromMap(view);
                this.delegate.destroyView(view);
                return true;
            }
            return false;
        }
        removeViewInStock(view) {
            let index = this.viewsInStock.indexOf(view, 0);
            if (index > -1) {
                this.viewsInStock.splice(index, 1);
                this.delegate.destroyView(view);
                return true;
            }
            return false;
        }
        // Accessing
        getAllViews() {
            return this.viewsOnMap.concat(this.viewsInStock);
        }
        getAllVisibleViews() {
            return this.getAllViews().filter(view => view.getModel().visible);
        }
        getViewWithUuid(uuid) {
            return this.getAllViews().find(view => view.getModel().uuid === uuid);
        }
        getModelWithUuid(uuid, models) {
            return models.find(model => model.uuid === uuid);
        }
        // Map <-> Stock change
        moveViewToMap(view) {
            this.setViewToMap(view);
            this.notifyObservers("onViewMovedToMap", [view]);
        }
        setViewToMap(view) {
            // If view is already in map, do not change anything.
            if (!this.isViewOnMap(view)) {
                // If view is in stock, remove it from the list.
                let index = this.viewsInStock.indexOf(view, 0);
                if (index > -1) {
                    this.viewsInStock.splice(index, 1);
                }
                this.viewsOnMap.push(view);
                this.delegate.addViewToMap(view);
            }
        }
        moveViewToStock(view) {
            this.setViewToStock(view);
            this.notifyObservers("onViewMovedToStock", [view]);
        }
        setViewToStock(view) {
            // If view is already in stock, do not change anything.
            if (!this.isViewInStock(view)) {
                // If view is on map, remove it from the list.
                let index = this.viewsOnMap.indexOf(view, 0);
                if (index > -1) {
                    this.viewsOnMap.splice(index, 1);
                }
                this.delegate.removeViewFromMap(view);
                this.viewsInStock.push(view);
            }
        }
        isViewOnMap(view) {
            let index = this.viewsOnMap.indexOf(view, 0);
            return index >= 0;
        }
        isViewInStock(view) {
            let index = this.viewsInStock.indexOf(view, 0);
            return index >= 0;
        }
        getViewsOnMap() {
            return this.viewsOnMap;
        }
        getVisibleViewsOnMap() {
            let visibleViewsOnMap = new Array();
            for (let i = 0; i < this.viewsOnMap.length; i++) {
                let view = this.viewsOnMap[i];
                if (view.getModel().visible) {
                    visibleViewsOnMap.push(view);
                }
            }
            return visibleViewsOnMap;
        }
        getViewsInStock() {
            return this.viewsInStock;
        }
        // Binding
        isViewMatchingModel(view, model) {
            return view.getModel().uuid === model.uuid;
        }
        // Getters and setters
        getModels() {
            return this.models;
        }
        getViews() {
            return this.getAllViews();
        }
    }
    exports.ViewModelBinder = ViewModelBinder;
});
define("src/app/relution/view/world/management/AutonomousObjectModelBinder", ["require", "exports", "src/app/relution/view/world/management/RelutionMapObjectModelBinder", "src/app/relution/view/world/management/ViewModelBinder"], function (require, exports, RelutionMapObjectModelBinder_1, ViewModelBinder_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AutonomousObjectModelBinder = void 0;
    class AutonomousObjectModelBinder extends RelutionMapObjectModelBinder_1.RelutionMapObjectModelBinder {
        // Construction
        constructor(config, environment, floorplanLayer, bindings, parentSceneObject) {
            super(config, environment, floorplanLayer, bindings);
            this.viewModelBinder = new ViewModelBinder_1.ViewModelBinder(this);
            this.viewModelBinder.addObserver(this);
            this.parentSceneObject = parentSceneObject;
        }
        // View-Model binding
        // @Override
        loadModels(models) {
            this.viewModelBinder.loadViews(models);
        }
        // @Override
        updateModels(models) {
            this.viewModelBinder.updateViews(models);
        }
        // @Override
        updateModel(model) {
            this.viewModelBinder.updateView(model);
        }
        // @Override
        createViewForModel(model) {
            return this.bindObjectToModel(model);
        }
        // Object observation
        onObjectSelected(object) {
            this.notifyObservers("onObjectSelected", [object]);
        }
        onObjectUnselected(object) {
            this.notifyObservers("onObjectUnselected", [object]);
        }
        onObjectMoveStarted(object, x, y) {
            this.notifyObservers("onObjectMoveStarted", [object, x, y]);
        }
        onObjectMoveChanged(object, x, y) {
            this.notifyObservers("onObjectMoveChanged", [object, x, y]);
        }
        onObjectMoveStopped(object, x, y) {
            this.notifyObservers("onObjectMoveStopped", [object, x, y]);
        }
        // View-Model binder delegate methods
        // @Override
        addViewToMap(view) {
            this.parentSceneObject.addChild(view);
            this.notifyObservers("onObjectAddedToMap", [view]);
        }
        // @Override
        removeViewFromMap(view) {
            this.parentSceneObject.removeChild(view);
            this.notifyObservers("onObjectRemovedFromMap", [view]);
        }
        // @Override
        destroyView(view) {
            view.destroy();
        }
        // View-Model binder observation
        onBeforeViewsLoaded(objects) {
            this.notifyObservers("onBeforeObjectsLoaded", [objects]);
        }
        onAfterViewsLoaded(objects) {
            this.notifyObservers("onAfterObjectsLoaded", [objects]);
        }
        onBeforeViewsUpdated(objects) {
            this.notifyObservers("onBeforeObjectsUpdated", [objects]);
        }
        onAfterViewsUpdated(objects) {
            this.notifyObservers("onAfterObjectsUpdated", [objects]);
        }
        onViewsLoaded(objects) {
            this.notifyObservers("onObjectsLoaded", [objects]);
        }
        onViewsUnloaded(objects) {
            this.notifyObservers("onObjectsUnloaded", [objects]);
        }
        onViewSetToMap(object) {
            this.notifyObservers("onObjectSetToMap", [object]);
        }
        onViewSetToStock(object) {
            this.notifyObservers("onObjectSetToStock", [object]);
        }
        onViewMovedToMap(object) {
            this.notifyObservers("onObjectMovedToMap", [object]);
        }
        onViewMovedToStock(object) {
            this.notifyObservers("onObjectMovedToStock", [object]);
        }
        // Accessing objects
        getObjects() {
            return this.viewModelBinder.getViews();
        }
        getObjectsOnMap() {
            return this.viewModelBinder.getViewsOnMap();
        }
        getObjectsInStock() {
            return this.viewModelBinder.getViewsInStock();
        }
        // Changing object state
        moveObjectToMap(object) {
            this.viewModelBinder.moveViewToMap(object);
        }
        moveObjectToStock(object) {
            this.viewModelBinder.moveViewToStock(object);
        }
    }
    exports.AutonomousObjectModelBinder = AutonomousObjectModelBinder;
});
define("src/app/relution/view/world/RelutionMapAttributeObjectLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer"], function (require, exports, FloorplanRelatedLayer_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RelutionMapAttributeObjectLayer = void 0;
    /**
     * Binds this layer containing Relution map attribute objects to the Relution map object layer.
     * Whenever a Relution map object will be created/deleted/modified, all Relution map attribute objects
     * that existentially depend on the Relution map object, will be created/deleted/modified, as well.
     *
     * @export
     * @class RelutionMapAttributeObjectLayer
     * @extends {FloorplanRelatedLayer}
     */
    class RelutionMapAttributeObjectLayer extends FloorplanRelatedLayer_3.FloorplanRelatedLayer {
        // Initialization
        constructor(environment, relutionMapObjectLayer, floorplanLayer = undefined) {
            super(environment, floorplanLayer !== undefined ? floorplanLayer : (relutionMapObjectLayer !== undefined ? relutionMapObjectLayer.getFloorplanLayer() : undefined));
            // Relution map attribute objects
            this.attributeObjects = new Array();
            this.setTargetLayer(this);
            if (relutionMapObjectLayer !== undefined) {
                relutionMapObjectLayer.addObserver(this);
            }
        }
        // Event-Handling: Relution map object layer
        // @Override
        onObjectsLoaded(objects) {
            this.loadAttributeObjects(objects);
        }
        // @Override
        onObjectsUnloaded(objects) {
            this.removeAttributeObjectsForMapObjects(objects);
        }
        // @Override
        onObjectMovedToMap(object) {
            this.updateAttributeObjectVisibility(object);
        }
        // @Override
        onObjectMovedToStock(object) {
            this.updateAttributeObjectVisibility(object);
        }
        // Loading attribute objects
        loadAttributeObjects(objects) {
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                this.loadAttributeObjectsForMapObject(object);
            }
        }
        loadAttributeObjectsForMapObject(object) {
            let attributeObjects = this.createAttributeObjectsForObject(object);
            for (let j = 0; j < attributeObjects.length; j++) {
                let attributeObject = attributeObjects[j];
                this.attributeObjects.push(attributeObject);
                this.getTargetLayer().addChild(attributeObject);
                this.updateAttributeObjectVisibility(object);
            }
        }
        // Unloading attribute objects
        removeAttributeObjectsForMapObjects(objects) {
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                this.removeAttributeObjectsForMapObject(object);
            }
        }
        removeAttributeObjectsForMapObject(object) {
            for (let i = 0; i < this.attributeObjects.length; i++) {
                let attributeObject = this.attributeObjects[i];
                if (attributeObject.dependsOnObject(object)) {
                    this.removeAttributeObject(attributeObject);
                    i--;
                }
            }
        }
        removeAttributeObject(attributeObject) {
            const index = this.attributeObjects.indexOf(attributeObject);
            if (index >= 0) {
                this.attributeObjects.splice(index, 1);
                attributeObject.getParent().removeChild(attributeObject);
                attributeObject.destroy();
            }
        }
        // Accessing attribute objects
        getAttributeObjects() {
            return this.attributeObjects;
        }
        getAttributeObjectsForObject(object) {
            let result = new Array();
            for (let i = 0; i < this.attributeObjects.length; i++) {
                let attributeObject = this.attributeObjects[i];
                if (attributeObject.dependsOnObject(object)) {
                    result.push(attributeObject);
                }
            }
            return result;
        }
        // @Override
        isEmpty() {
            var _a;
            return !(((_a = this.getAttributeObjects()) === null || _a === void 0 ? void 0 : _a.length) > 0) && super.isEmpty();
        }
        // Updating visibility
        updateAttributeObjectVisibility(object) {
            let attributeObjects = this.getAttributeObjectsForObject(object);
            for (let i = 0; i < attributeObjects.length; i++) {
                let attributeObject = attributeObjects[i];
                let dependentObjects = attributeObject.getDependentObjects();
                if (this.allObjectsVisible(dependentObjects)) {
                    attributeObject.getView().visible = true;
                }
                else {
                    attributeObject.getView().visible = false;
                }
            }
        }
        allObjectsVisible(objects) {
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                if (!object.getModel().isOnMap()) {
                    return false;
                }
            }
            return true;
        }
        // Target Layer
        // The Layer where the attribute objects are added as children. Default: this
        setTargetLayer(targetLayer) {
            this.targetLayer = targetLayer;
        }
        getTargetLayer() {
            return this.targetLayer;
        }
    }
    exports.RelutionMapAttributeObjectLayer = RelutionMapAttributeObjectLayer;
});
define("src/app/relution/utils/UuidUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UuidUtils = void 0;
    class UuidUtils {
        static randomUuid() {
            var dt = new Date().getTime();
            var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = (dt + Math.random() * 16) % 16 | 0;
                dt = Math.floor(dt / 16);
                return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
            return uuid;
        }
    }
    exports.UuidUtils = UuidUtils;
});
define("src/app/relution/view/world/management/CoupledObjectModelBinder", ["require", "exports", "src/app/relution/view/world/management/RelutionMapObjectModelBinder", "src/app/relution/model/RelutionMapObjectModel", "src/app/relution/view/world/RelutionMapAttributeObjectLayer", "src/app/relution/utils/UuidUtils"], function (require, exports, RelutionMapObjectModelBinder_2, RelutionMapObjectModel_1, RelutionMapAttributeObjectLayer_1, UuidUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CoupledObjectModelBinder = void 0;
    /**
     * <h1>
     * Binds the Relution map objects to their corresponding models.
     * </h1>
     *
     * <p>
     * In contrast to the autonomous model binder, this model binder is coupled to the life cycle
     * of a superordinate layer, it is existentially depending on.
     * Whenever an object is created in the superior layer, this model binder will be notified
     * and ordered to create the Relution map objects of the generic type V that should existentially
     * depend on the superior object.
     * Hence, in contrast to the autonomous model binder, object creation will not be triggered by
     * model injection directly, but by the creation of objects in the superior layer.
     * </p>
     */
    class CoupledObjectModelBinder extends RelutionMapObjectModelBinder_2.RelutionMapObjectModelBinder {
        // Construction
        constructor(config, environment, floorplanLayer, bindings, targetLayer, superiorLayer) {
            super(config, environment, floorplanLayer, bindings);
            // Model
            this.models = new Array();
            this.targetLayer = targetLayer;
            this.superiorLayer = superiorLayer;
            this.attributeLayer = new CoupledObjectModelBinder.DependentAttributeObjectLayer(environment, this, superiorLayer, floorplanLayer);
            this.attributeLayer.setTargetLayer(this.targetLayer);
        }
        // Loading object models
        loadModels(models) {
            this.models = models;
            this.updateViewsForModels(models);
        }
        updateModels(models) {
            this.models = models;
            this.updateViewsForModels(models);
        }
        updateModel(model) {
            let index = this.getIndexOfModel(model.uuid);
            if (index != -1) {
                this.models[index] = model;
            }
            else {
                this.models.push(model);
            }
            this.updateViewsForModels([model]);
        }
        getIndexOfModel(uuid) {
            if (!this.models || this.models.length == 0) {
                return -1;
            }
            for (let i = 0; i < this.models.length; i++) {
                if (this.models[i].uuid === uuid) {
                    return i;
                }
            }
            return -1;
        }
        updateViewsForModels(models) {
            // 1. Removing models:
            this.removeViewsNotExistingAnymore(models);
            // 2. Existing models:
            // Models that already have an existing view, will be updated normally.
            this.updateExistingViewsForModels(models);
            // 3. Added models:
            // Views will only be created for new models, if the superordinate
            // layer, already has matching map objects.
            this.createViewsForMatchingModels(models);
        }
        removeViewsNotExistingAnymore(models) {
            let objects = this.getObjects();
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                let model = this.getModelWithUuid(models, object.getModel().uuid);
                if (model === null) {
                    this.unbindObjectToModel(object);
                    this.attributeLayer.unloadAttributeObject(object);
                }
            }
        }
        getModelWithUuid(models, uuid) {
            for (let i = 0; i < models.length; i++) {
                let model = models[i];
                if (model.uuid === uuid) {
                    return model;
                }
            }
            return null;
        }
        updateExistingViewsForModels(models) {
            for (let i = 0; i < models.length; i++) {
                let model = models[i];
                let object = this.getObjectWithModel(model);
                if (object !== null) {
                    object.updateModel(model);
                }
            }
        }
        createViewsForMatchingModels(models) {
            for (let i = 0; i < models.length; i++) {
                let model = models[i];
                let object = this.getObjectWithModel(model);
                if (object === null) {
                    let parentModelUuid = model.parentUuid;
                    let parentObject = this.superiorLayer.getObjectWithUuid(parentModelUuid);
                    if (parentObject !== null) {
                        this.attributeLayer.loadAttributeObjectsForSuperiorObject(parentObject);
                    }
                }
            }
        }
        // Model access
        getModelsWithParentModel(parentModel) {
            let models = [];
            for (let i = 0; i < this.models.length; i++) {
                let model = this.models[i];
                if (model.parentUuid === parentModel.uuid) {
                    models.push(model);
                }
            }
            return models;
        }
        // Object access
        // @Override
        getObjects() {
            return this.attributeLayer.getAttributeObjects();
        }
        // @Override
        getObjectsOnMap() {
            let objects = this.getObjects();
            let objectsOnMap = [];
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                if (object.isOnMap()) {
                    objectsOnMap.push(object);
                }
            }
            return objectsOnMap;
        }
        // @Override
        getObjectsInStock() {
            let objects = this.getObjects();
            let objectsInStock = [];
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                if (!object.isOnMap()) {
                    objectsInStock.push(object);
                }
            }
            return objectsInStock;
        }
        // Object state change
        moveObjectToMap(object) {
            // Not allowed, only Relution map object layers using the autonomous object-model binding,
            // are allowed to move objects into map or stock.
        }
        moveObjectToStock(object) {
            // Not allowed, only Relution map object layers using the autonomous object-model binding,
            // are allowed to move objects into map or stock.
        }
    }
    exports.CoupledObjectModelBinder = CoupledObjectModelBinder;
    (function (CoupledObjectModelBinder) {
        class DependentAttributeObjectLayer extends RelutionMapAttributeObjectLayer_1.RelutionMapAttributeObjectLayer {
            // Construction
            constructor(environment, modelBinder, superiorLayer, floorplanLayer = undefined) {
                super(environment, superiorLayer, floorplanLayer);
                // Configuration
                /**
                 * If true, an object of the subordinate layer will be created with default parameters, a random UUID and
                 * a matching parent UUID, whenever an object of the superior layer has been created.
                 * Thus, if the paramter is set to true, model injection is not required explicitly.
                 */
                this.createModelsImplicitly = true;
                this.modelBinder = modelBinder;
                this.superiorLayer = superiorLayer;
            }
            // Loading attribute objects
            /**
             * Explicitly triggers the attribute object creation for the specified superior object.
             * @param superiorObject
             */
            loadAttributeObjectsForSuperiorObject(superiorObject) {
                this.loadAttributeObjectsForMapObject(superiorObject);
            }
            // @Override
            createAttributeObjectsForObject(object) {
                if (this.createModelsImplicitly) {
                    return this.createAttributeObjectsWithImplicitModelCreation(object);
                }
                else {
                    return this.createAttributeObjectsForExplicitlyInjectedModels(object);
                }
            }
            createAttributeObjectsWithImplicitModelCreation(parentObject) {
                let parentModel = parentObject.getModel();
                let modelFactory = this.modelBinder.getModelFactory();
                let model = null;
                if (modelFactory === null) {
                    model = new RelutionMapObjectModel_1.RelutionMapObjectModel();
                }
                else {
                    model = modelFactory(parentModel);
                }
                if (model !== null) {
                    if (model.uuid === null) {
                        model.uuid = UuidUtils_1.UuidUtils.randomUuid();
                    }
                    if (model.parentUuid === null) {
                        model.parentUuid = parentModel.uuid;
                    }
                    this.modelBinder.models.push(model);
                    let object = this.modelBinder.bindObjectToModel(model);
                    return [object];
                }
                else {
                    return [];
                }
            }
            createAttributeObjectsForExplicitlyInjectedModels(parentObject) {
                let parentModel = parentObject.getModel();
                let childModels = this.modelBinder.getModelsWithParentModel(parentModel);
                let objects = [];
                for (let childModel of childModels) {
                    let object = this.modelBinder.bindObjectToModel(childModel);
                    objects.push(object);
                }
                return objects;
            }
            // Unloading attribute object
            unloadAttributeObject(attributeObject) {
                this.removeAttributeObject(attributeObject);
            }
        }
        CoupledObjectModelBinder.DependentAttributeObjectLayer = DependentAttributeObjectLayer;
    })(CoupledObjectModelBinder = exports.CoupledObjectModelBinder || (exports.CoupledObjectModelBinder = {}));
});
define("src/app/relution/view/world/RelutionMapObjectLayer", ["require", "exports", "src/app/relution/utils/MouseUtils", "src/app/relution/view/world/management/AutonomousObjectModelBinder", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/app/relution/view/world/management/CoupledObjectModelBinder"], function (require, exports, MouseUtils_1, AutonomousObjectModelBinder_1, FloorplanRelatedLayer_4, CoupledObjectModelBinder_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RelutionMapObjectBinding = exports.RelutionMapObjectLayer = void 0;
    /**
     * Base class for all layers maintaining Relution map objects.
     *
     * @export
     * @class RelutionMapObjectLayer
     * @extends {Layer}
     */
    class RelutionMapObjectLayer extends FloorplanRelatedLayer_4.FloorplanRelatedLayer {
        // Construction
        constructor(config, environment, floorplanLayer, dependingMapObjectLayer = undefined) {
            super(environment, floorplanLayer);
            // Object-Model binding
            this.objectModelBinder = null;
            // State
            this.mouseCursorChanged = false;
            this.hoveringObject = null;
            this.objectOfCurrentEditablePoint = null;
            this.editingObject = null;
            this.movingObject = null;
            this.config = config;
            let bindings = this.initLayerObjectClassBinder();
            this.initObjectModelBinder(dependingMapObjectLayer, config, floorplanLayer, bindings);
        }
        initLayerObjectClassBinder() {
            // Only bind the classes that are bound to the layer's class.
            let myBindings = this.getBindingsForThisClass();
            for (let i = 0; i < myBindings.length; i++) {
                let objectClass = myBindings[i];
                // We enforce a class load by calling an empty function on it.
                objectClass.__initialize = function () { };
                objectClass.__initialize();
            }
            return myBindings;
        }
        getBindingsForThisClass() {
            let myBindings = [];
            for (let i = 0; i < RelutionMapObjectLayer.allBindings.length; i++) {
                let binding = RelutionMapObjectLayer.allBindings[i];
                if (binding.layerClass === this.constructor) {
                    myBindings.push(binding);
                }
            }
            return myBindings;
        }
        initObjectModelBinder(dependingMapObjectLayer, config, floorplanLayer, bindings) {
            if (dependingMapObjectLayer === undefined) {
                this.objectModelBinder = new AutonomousObjectModelBinder_1.AutonomousObjectModelBinder(config, this.getEnvironment(), floorplanLayer, bindings, this);
            }
            else {
                this.objectModelBinder = new CoupledObjectModelBinder_1.CoupledObjectModelBinder(config, this.getEnvironment(), floorplanLayer, bindings, this, dependingMapObjectLayer);
            }
        }
        // Observation
        addObserver(observer) {
            this.objectModelBinder.addObserver(observer);
        }
        removeObserver(observer) {
            this.objectModelBinder.removeObserver(observer);
        }
        getObservers() {
            return this.objectModelBinder.getObservers();
        }
        // Loading object models
        loadModels(models) {
            this.objectModelBinder.loadModels(models);
        }
        updateModels(models) {
            this.objectModelBinder.updateModels(models);
        }
        updateModel(model) {
            this.objectModelBinder.updateModel(model);
        }
        setModelFactory(factory) {
            this.objectModelBinder.setModelFactory(factory);
        }
        setConfigFactory(factory) {
            this.objectModelBinder.setConfigFactory(factory);
        }
        setObjectFactory(factory) {
            this.objectModelBinder.setObjectFactory(factory);
        }
        // Object access
        getObjectWithUuid(uuid) {
            return this.objectModelBinder.getObjectWithUuid(uuid);
        }
        existsObject(view) {
            return this.objectModelBinder.existsObject(view);
        }
        containsObject(objects, object) {
            return this.objectModelBinder.containsObject(objects, object);
        }
        getObjects() {
            return this.objectModelBinder.getObjects();
        }
        getObjectsOnMap() {
            return this.objectModelBinder.getObjectsOnMap();
        }
        getObjectsInStock() {
            return this.objectModelBinder.getObjectsInStock();
        }
        getAllVisibleObjects() {
            return this.objectModelBinder.getAllVisibleObjects();
        }
        moveObjectToMap(object) {
            this.objectModelBinder.moveObjectToMap(object);
        }
        moveObjectToStock(object) {
            this.objectModelBinder.moveObjectToStock(object);
        }
        // Hovering
        // @Override
        onMouseMove(x, y) {
            super.onMouseMove(x, y);
            if (this.isVisibleInWorld()) {
                this.changeEditPointVisibility(x, y);
                this.changeHoveringObjectIfNecessary(x, y);
            }
            this.changeMouseCursorIfNecessary(x, y);
            return false;
        }
        changeEditPointVisibility(x, y) {
            let object = this.getObjectEditableOnPoint(x, y);
            if (object !== null) {
                if (this.objectOfCurrentEditablePoint !== object) {
                    if (this.objectOfCurrentEditablePoint !== null) {
                        this.objectOfCurrentEditablePoint.setMouseAboveEditPoint(false);
                        this.objectOfCurrentEditablePoint = null;
                    }
                    this.objectOfCurrentEditablePoint = object;
                    this.objectOfCurrentEditablePoint.setMouseAboveEditPoint(true);
                }
            }
            else {
                if (this.objectOfCurrentEditablePoint !== null) {
                    let objects = this.getObjects();
                    for (let i = 0; i < objects.length; i++) {
                        let currentObject = objects[i];
                        currentObject.setMouseAboveEditPoint(false);
                    }
                    this.objectOfCurrentEditablePoint = null;
                }
            }
        }
        changeHoveringObjectIfNecessary(x, y) {
            let collidingObject = this.getCollidingObject(x, y);
            if (collidingObject !== null) {
                if (this.hoveringObject !== collidingObject) {
                    if (this.hoveringObject !== null) {
                        this.hoveringObject.setMouseOver(false);
                        this.hoveringObject = null;
                    }
                    this.hoveringObject = collidingObject;
                    this.hoveringObject.setMouseOver(true);
                }
            }
            else {
                if (this.hoveringObject !== null) {
                    this.hoveringObject.setMouseOver(false);
                    this.hoveringObject = null;
                }
            }
            return false;
        }
        changeMouseCursorIfNecessary(x, y) {
            if (this.isEditModeActive()) {
                this.handleMouseMove(x, y);
                return false;
            }
            else {
                return false;
            }
        }
        handleMouseMove(x, y) {
            if (this.isVisibleInWorld()) {
                if (this.isPointAboveEditPoint(x, y)) {
                    MouseUtils_1.MouseUtils.changeToMoveCursorStyle();
                    this.mouseCursorChanged = true;
                }
                else if (this.isPointCollidingWithObject(x, y)) {
                    MouseUtils_1.MouseUtils.changeToHandCursorStyle();
                    this.mouseCursorChanged = true;
                }
                else {
                    if (this.mouseCursorChanged === true) {
                        MouseUtils_1.MouseUtils.changeToDefaultCursorStyle();
                        this.mouseCursorChanged = false;
                    }
                }
            }
            else {
                if (this.mouseCursorChanged === true) {
                    MouseUtils_1.MouseUtils.changeToDefaultCursorStyle();
                    this.mouseCursorChanged = false;
                }
            }
        }
        // Editing
        // @Override
        onTouchStart(x, y, touchIndex) {
            super.onTouchStart(x, y, touchIndex);
            if (!this.isVisibleInWorld()) {
                return false;
            }
            else {
                if (this.isEditModeActive()) {
                    return this.handleTouchStart(x, y);
                }
                else {
                    return false;
                }
            }
        }
        handleTouchStart(x, y) {
            if (this.isPointAboveEditPoint(x, y)) {
                this.editingObject = this.getObjectEditableOnPoint(x, y);
                this.editingObject.onEditStart(x, y);
                return true;
            }
            else if (this.isPointCollidingWithObject(x, y)) {
                let object = this.getCollidingObject(x, y, (object) => {
                    return object.isMovable();
                });
                if (object !== null) {
                    this.movingObject = object;
                    this.movingObject.onMoveStarted(x, y);
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        // @Override
        onTouchMove(x, y, touchIndex) {
            super.onTouchMove(x, y, touchIndex);
            if (!this.isVisibleInWorld()) {
                return false;
            }
            else {
                if (this.isEditModeActive()) {
                    return this.handleTouchMove(x, y);
                }
                else {
                    return false;
                }
            }
        }
        handleTouchMove(x, y) {
            if (this.editingObject !== null) {
                this.editingObject.onEditMove(x, y);
                return true;
            }
            else if (this.movingObject !== null) {
                this.movingObject.onMoveChanged(x, y);
                return true;
            }
            else {
                return false;
            }
        }
        // @Override
        onTouchEnd(x, y, touchIndex) {
            super.onTouchEnd(x, y, touchIndex);
            if (!this.isVisibleInWorld()) {
                return false;
            }
            else {
                if (this.isEditModeActive()) {
                    return this.handleTouchEnd(x, y);
                }
                else {
                    return false;
                }
            }
        }
        handleTouchEnd(x, y) {
            if (this.editingObject !== null) {
                this.editingObject.onEditStop(x, y);
                this.editingObject = null;
                return true;
            }
            else if (this.movingObject !== null) {
                this.movingObject.onMoveStopped(x, y);
                this.movingObject = null;
                return true;
            }
            else {
                return false;
            }
        }
        // Collision detection
        /**
         * Returns the object that succeeds the intersection test on the screen position (x,y) first.
         * @param x \in [0, screenWidth]
         * @param y \in [0, screenHeight]
         * @param condition An additional condition the object must fulfill to pass the hit test.
         * If no additional condition is required, pass undefined.
         */
        getCollidingObject(x, y, condition = undefined) {
            if (this.isVisibleInWorld()) {
                let objects = this.objectModelBinder.getAllVisibleObjects();
                for (let i = 0; i < objects.length; i++) {
                    let view = objects[i];
                    if (condition === undefined || condition(view)) {
                        if (view.intersectsPointInScreenPx(x, y)) {
                            return view;
                        }
                    }
                }
                return null;
            }
            return null;
        }
        isPointCollidingWithObject(x, y) {
            let object = this.getCollidingObject(x, y);
            return object !== null;
        }
        getObjectEditableOnPoint(x, y) {
            if (this.isVisibleInWorld()) {
                let objects = this.objectModelBinder.getAllVisibleObjects();
                for (let i = 0; i < objects.length; i++) {
                    let view = objects[i];
                    if (view.pointIsCloseToEditableArea(x, y)) {
                        return view;
                    }
                }
                return null;
            }
            return null;
        }
        isPointAboveEditPoint(x, y) {
            let object = this.getObjectEditableOnPoint(x, y);
            return object !== null;
        }
        // Visibility
        toggleObjectVisibility(uuid) {
            let view = this.getObjectWithUuid(uuid);
            if (view != null) {
                // Change visibility field in model.
                // All object related objects should become invisible now.
                let visible = !view.getModel().visible;
                let model = view.getModel();
                model.visible = visible;
            }
        }
        supportsObjectTypeVisibility(objectType, filter) {
            let objects = this.objectModelBinder.getObjects();
            return objects.some(view => view instanceof objectType && (!filter || filter(view)));
        }
        toggleObjectTypeVisibility(objectType, visible) {
            // 1. Update map
            this.config.objectTypeVisibility.set(objectType, visible);
            // 1. Update views
            let objects = this.objectModelBinder.getObjects();
            for (let i = 0; i < objects.length; i++) {
                let view = objects[i];
                if (view instanceof objectType) {
                    view.getModel().visible = this.objectModelBinder.isTypeOfObjectVisible(view);
                }
            }
        }
        // @Override
        isEmpty() {
            var _a;
            return !(((_a = this.objectModelBinder.getObjects()) === null || _a === void 0 ? void 0 : _a.length) > 0) && super.isEmpty();
        }
        // Modes
        setEditModeActive(editModeActive) {
            this.config.editModeEnabled = editModeActive;
            let objects = this.objectModelBinder.getObjectsOnMap();
            for (let i = 0; i < objects.length; i++) {
                let view = objects[i];
                view.setEditModeActive(editModeActive);
            }
        }
        isEditModeActive() {
            return this.config.editModeEnabled;
        }
    }
    exports.RelutionMapObjectLayer = RelutionMapObjectLayer;
    // Metadata: Binds Relution map object classes to their corresponding layers via decorator
    RelutionMapObjectLayer.allBindings = new Array();
    (function (RelutionMapObjectLayer) {
        class Binding {
            constructor(layerClass, objectClasses) {
                this.layerClass = null;
                this.objectClasses = null;
                this.layerClass = layerClass;
                this.objectClasses = objectClasses;
            }
        }
        RelutionMapObjectLayer.Binding = Binding;
        class Config {
            constructor() {
                /**
                 * True, if edit mode should be enabled from the beginning.
                 *
                 * Default: false
                 */
                this.editModeEnabled = false;
                /**
                 * Maps {@link RelutionMapObject} subclasses (more specifically the class's constructor function) to a boolean,
                 * indicating whether objects compatible with this type should be visible or not.
                 *
                 * <p>
                 * Note, that if an object type is not contained in this map, the object type is treated as set to visible (true).
                 * If setting the visibility of type {@link Beacon} to true, all beacons will be visible.
                 * If setting the visibility of the base class {@link Device} to false, beacons and all other devices will not be visible.
                 *
                 * Hence, to make an object visible, the visibilities of all object types compatible with the object must be set to true or not
                 * contained in this map.
                 * </p>
                 *
                 * <p>
                 * Note, that the object type visibility can be set independently to the layer visibility. To make the object visible, the layer
                 * must be visible, as well!
                 * </p>
                 *
                 * Default: Empty map (all object types are visible)
                 */
                this.objectTypeVisibility = new Map();
            }
        }
        RelutionMapObjectLayer.Config = Config;
    })(RelutionMapObjectLayer = exports.RelutionMapObjectLayer || (exports.RelutionMapObjectLayer = {}));
    /**
     * Decorator to bind Relution map object classes to Relution map object layers.
     * @param relutionMapObjectClass
     */
    function RelutionMapObjectBinding(...objectClasses) {
        return function (layerClass) {
            RelutionMapObjectLayer.allBindings.push((new RelutionMapObjectLayer.Binding(layerClass, objectClasses)));
        };
    }
    exports.RelutionMapObjectBinding = RelutionMapObjectBinding;
});
define("src/app/relution/model/device/DeviceModel", ["require", "exports", "src/app/relution/model/RelutionMapObjectModel", "src/app/relution/model/Model", "src/engine/math/Vector2"], function (require, exports, RelutionMapObjectModel_2, Model_3, Vector2_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KnxModel = exports.BACnetModel = exports.MeshGatewayModel = exports.BeaconModel = exports.BleNodeModel = exports.AssetModel = exports.SmartBeaconBaseModel = exports.BeaconBaseModel = exports.DeviceModel = void 0;
    /**
     * Base class of all Relution device models.
     */
    let DeviceModel = class DeviceModel extends RelutionMapObjectModel_2.RelutionMapObjectModel {
        constructor() {
            // General
            super(...arguments);
            this._name = "";
            // Details
            this._positionEstimate = null;
            // Properties
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._fixed = "";
            this._onMap = false;
            // Internal attributes
            this._inactive = false;
        }
        // Getters and setters
        get name() {
            return this._name;
        }
        set name(name) {
            this._name = name;
            this.notifyObservers("name");
        }
        get status() {
            return this._status;
        }
        set status(status) {
            this._status = status;
            this.notifyObservers("status");
        }
        get platform() {
            return this._platform;
        }
        set platform(platform) {
            this._platform = platform;
            this.notifyObservers("platform");
        }
        get lastConnectionDate() {
            return this._lastConnectionDate;
        }
        set lastConnectionDate(lastConnectionDate) {
            this._lastConnectionDate = lastConnectionDate;
            this.notifyObservers("lastConnectionDate");
        }
        get deviceId() {
            return this._deviceId;
        }
        set deviceId(deviceId) {
            this._deviceId = deviceId;
            this.notifyObservers("deviceId");
        }
        get os() {
            return this._os;
        }
        set os(os) {
            this._os = os;
            this.notifyObservers("os");
        }
        get siteUuid() {
            return this._siteUuid;
        }
        set siteUuid(siteUuid) {
            this._siteUuid = siteUuid;
            this.notifyObservers("siteUuid");
        }
        get x() {
            return this._x;
        }
        set x(x) {
            this._x = x;
            this.notifyObservers("x");
        }
        get y() {
            return this._y;
        }
        set y(y) {
            this._y = y;
            this.notifyObservers("y");
        }
        get z() {
            return this._z;
        }
        set z(z) {
            this._z = z;
            this.notifyObservers("z");
        }
        get fixed() {
            return this._fixed;
        }
        set fixed(fixed) {
            this._fixed = fixed;
            this.notifyObservers("fixed");
        }
        get onMap() {
            return this._onMap;
        }
        set onMap(onMap) {
            this._onMap = onMap;
            this.notifyObservers("onMap");
            if (this._onMap) {
                // Position has "changed", when device is set to map.
                this.x = this.x;
                this.y = this.y;
            }
        }
        get positionEstimate() {
            return this._positionEstimate;
        }
        set positionEstimate(positionEstimate) {
            this._positionEstimate = positionEstimate;
            this.notifyObservers("positionEstimate");
            // Since some devices use the position estimate field for obtaining the x
            // and y fields, we must call xChanged and yChanged.
            this.notifyObservers("x");
            this.notifyObservers("y");
        }
        get inactive() {
            return this._inactive;
        }
        set inactive(inactive) {
            this._inactive = inactive;
            this.notifyObservers("inactive");
        }
        // Derived attributes
        isBleNode() {
            return this._platform == "BLENODE";
        }
        isDumbBeacon() {
            return this._platform == "BEACON";
        }
        isMeshgw() {
            return this._platform == "EDGEROUTER";
        }
        isAsset() {
            return this._platform == "ASSET";
        }
        isAnyKindOfBeacon() {
            return this.isBleNode() || this.isDumbBeacon() || this.isMeshgw();
        }
        // Position
        getPosition() {
            // Take the position set by the user or, if it does not exist,
            // take the estimated position. If no position exist return the
            // coordinate system"s origin.
            if (!this.userPositionIsUnknown()) {
                return new Vector2_17.Vector2(this._x, this._y);
            }
            else if (!this.estimatedPositionIsUnknown()) {
                return new Vector2_17.Vector2(this._positionEstimate.x, this._positionEstimate.y);
            }
            else {
                return new Vector2_17.Vector2();
            }
        }
        // @Override
        hasUnknownPosition() {
            return this.userPositionIsUnknown() && this.estimatedPositionIsUnknown();
        }
        userPositionIsUnknown() {
            return !this.onMap ||
                (this._x == 0 && this._y == 0) ||
                (this._x == -1 && this._y == -1) ||
                !Number.isFinite(this._x) && !Number.isFinite(this._y);
        }
        estimatedPositionIsUnknown() {
            return !this.isAsset() ||
                (this._positionEstimate == null) ||
                (this.positionEstimate.x == -1 && this._positionEstimate.y == -1) ||
                (this.positionEstimate.x == 0 && this._positionEstimate.y == 0) ||
                (("undefined" === typeof this.positionEstimate.x)) && ("undefined" === typeof this.positionEstimate.y);
        }
        estimatedPositionIsOutdoor(p) {
            return this.isAsset() && (p.x == 0 && p.y == 0);
        }
        // On Map
        isOnMap() {
            // In case a position estimate is given, the device should be shown in any case.
            if (this.isAsset()) {
                return true;
            }
            return this.onMap;
        }
    };
    __decorate([
        (0, Model_3.ModelProperty)()
    ], DeviceModel.prototype, "_name", void 0);
    __decorate([
        (0, Model_3.ModelProperty)()
    ], DeviceModel.prototype, "_status", void 0);
    __decorate([
        (0, Model_3.ModelProperty)()
    ], DeviceModel.prototype, "_platform", void 0);
    __decorate([
        (0, Model_3.ModelProperty)()
    ], DeviceModel.prototype, "_lastConnectionDate", void 0);
    __decorate([
        (0, Model_3.ModelProperty)()
    ], DeviceModel.prototype, "_deviceId", void 0);
    __decorate([
        (0, Model_3.ModelProperty)()
    ], DeviceModel.prototype, "_os", void 0);
    __decorate([
        (0, Model_3.ModelProperty)()
    ], DeviceModel.prototype, "_siteUuid", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], DeviceModel.prototype, "_positionEstimate", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "properties", clazz: Number })
    ], DeviceModel.prototype, "_x", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "properties", clazz: Number })
    ], DeviceModel.prototype, "_y", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "properties", clazz: Number })
    ], DeviceModel.prototype, "_z", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "properties" })
    ], DeviceModel.prototype, "_fixed", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "properties", clazz: Boolean })
    ], DeviceModel.prototype, "_onMap", void 0);
    DeviceModel = __decorate([
        (0, Model_3.ModelTypeInfo)("platform"),
        (0, Model_3.ModelSubTypes)(new Model_3.ModelType(() => BleNodeModel, "BLENODE"), new Model_3.ModelType(() => BeaconModel, "BEACON"), new Model_3.ModelType(() => AssetModel, "ASSET"), new Model_3.ModelType(() => MeshGatewayModel, "EDGEROUTER"), new Model_3.ModelType(() => BACnetModel, "BACNET"), new Model_3.ModelType(() => KnxModel, "KNX"))
    ], DeviceModel);
    exports.DeviceModel = DeviceModel;
    (function (DeviceModel) {
        class PositionEstimate extends Model_3.Model {
            // Getters and setters
            get floorId() {
                return this._floorId;
            }
            set floorId(floorId) {
                this._floorId = floorId;
            }
            get x() {
                return this._x;
            }
            set x(x) {
                this._x = x;
            }
            get y() {
                return this._y;
            }
            set y(y) {
                this._y = y;
            }
            get z() {
                return this._z;
            }
            set z(z) {
                this._z = z;
            }
            get accuracy() {
                return this._accuracy;
            }
            set accuracy(accuracy) {
                this._accuracy = accuracy;
            }
            get measurementTimeSec() {
                return this._measurementTimeSec;
            }
            set measurementTimeSec(measurementTimeSec) {
                this._measurementTimeSec = measurementTimeSec;
            }
            get state() {
                return this._state;
            }
            set state(state) {
                this._state = state;
            }
            get motionState() {
                return this._motionState;
            }
            set motionState(motionState) {
                this._motionState = motionState;
            }
        }
        __decorate([
            (0, Model_3.ModelProperty)()
        ], PositionEstimate.prototype, "_floorId", void 0);
        __decorate([
            (0, Model_3.ModelProperty)()
        ], PositionEstimate.prototype, "_x", void 0);
        __decorate([
            (0, Model_3.ModelProperty)()
        ], PositionEstimate.prototype, "_y", void 0);
        __decorate([
            (0, Model_3.ModelProperty)()
        ], PositionEstimate.prototype, "_z", void 0);
        __decorate([
            (0, Model_3.ModelProperty)()
        ], PositionEstimate.prototype, "_accuracy", void 0);
        __decorate([
            (0, Model_3.ModelProperty)()
        ], PositionEstimate.prototype, "_measurementTimeSec", void 0);
        __decorate([
            (0, Model_3.ModelProperty)()
        ], PositionEstimate.prototype, "_state", void 0);
        __decorate([
            (0, Model_3.ModelProperty)()
        ], PositionEstimate.prototype, "_motionState", void 0);
        DeviceModel.PositionEstimate = PositionEstimate;
    })(DeviceModel = exports.DeviceModel || (exports.DeviceModel = {}));
    exports.DeviceModel = DeviceModel;
    // tslint:disable-next-line:max-classes-per-file
    class BeaconBaseModel extends DeviceModel {
        constructor() {
            // Properties
            super(...arguments);
            // Simulator related attributes
            this._connectionLossCounter = -1;
            this._inConnectionPartner = -1;
            this._inConnectionRssi = -1;
            this._inConnectionHasMasterBit = false;
            this._inConnectionPartnerHasMasterBit = false;
            this._lastSentMessageTimestampMs = 0;
            this._ledOn = false;
        }
        // Getters and setters
        get macAddress() {
            return this._macAddress;
        }
        set macAddress(macAddress) {
            this._macAddress = macAddress;
            this.notifyObservers("macAddress");
        }
        get dBmRX() {
            return this._dBmRX;
        }
        set dBmRX(dBmRX) {
            this._dBmRX = dBmRX;
            this.notifyObservers("dBmRX");
        }
        get dBmTX() {
            return this._dBmTX;
        }
        set dBmTX(dBmTX) {
            this._dBmTX = dBmTX;
            this.notifyObservers("dBmTX");
        }
        get calibratedRssi() {
            return this._calibratedRssi;
        }
        set calibratedRssi(calibratedRssi) {
            this._calibratedRssi = calibratedRssi;
            this.notifyObservers("calibratedRssi");
        }
        get batteryInfo() {
            return this._batteryInfo;
        }
        set batteryInfo(batteryInfo) {
            this._batteryInfo = batteryInfo;
        }
        get manufacturerId() {
            return this._manufacturerId;
        }
        set manufacturerId(manufacturerId) {
            this._manufacturerId = manufacturerId;
            this.notifyObservers("manufacturerId");
        }
        get connectionLossCounter() {
            return this._connectionLossCounter;
        }
        set connectionLossCounter(connectionLossCounter) {
            this._connectionLossCounter = connectionLossCounter;
            this.notifyObservers("connectionLossCounter");
        }
        get inConnectionPartner() {
            return this._inConnectionPartner;
        }
        set inConnectionPartner(inConnectionPartner) {
            this._inConnectionPartner = inConnectionPartner;
            this.notifyObservers("inConnectionPartner");
        }
        get inConnectionRssi() {
            return this._inConnectionRssi;
        }
        set inConnectionRssi(inConnectionRssi) {
            this._inConnectionRssi = inConnectionRssi;
            this.notifyObservers("inConnectionRssi");
        }
        get inConnectionHasMasterBit() {
            return this._inConnectionHasMasterBit;
        }
        set inConnectionHasMasterBit(inConnectionHasMasterBit) {
            this._inConnectionHasMasterBit = inConnectionHasMasterBit;
            this.notifyObservers("inConnectionHasMasterBit");
        }
        get inConnectionPartnerHasMasterBit() {
            return this._inConnectionPartnerHasMasterBit;
        }
        set inConnectionPartnerHasMasterBit(inConnectionPartnerHasMasterBit) {
            this._inConnectionPartnerHasMasterBit = inConnectionPartnerHasMasterBit;
            this.notifyObservers("inConnectionPartnerHasMasterBit");
        }
        get lastSentAdvertisingMessage() {
            return this._lastSentAdvertisingMessage;
        }
        set lastSentAdvertisingMessage(lastSentAdvertisingMessage) {
            this._lastSentAdvertisingMessage = lastSentAdvertisingMessage;
            this.notifyObservers("lastSentAdvertisingMessage");
        }
        get lastSentMessageTimestampMs() {
            return this._lastSentMessageTimestampMs;
        }
        set lastSentMessageTimestampMs(lastSentMessageTimestampMs) {
            this._lastSentMessageTimestampMs = lastSentMessageTimestampMs;
            this.notifyObservers("lastSentMessageTimestampMs");
        }
        get ledOn() {
            return this._ledOn;
        }
        set ledOn(ledOn) {
            this._ledOn = ledOn;
            this.notifyObservers("ledOn");
        }
    }
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], BeaconBaseModel.prototype, "_manufacturerId", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], BeaconBaseModel.prototype, "_macAddress", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], BeaconBaseModel.prototype, "_dBmRX", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], BeaconBaseModel.prototype, "_dBmTX", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], BeaconBaseModel.prototype, "_calibratedRssi", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], BeaconBaseModel.prototype, "_batteryInfo", void 0);
    __decorate([
        (0, Model_3.ModelProperty)()
    ], BeaconBaseModel.prototype, "_connectionLossCounter", void 0);
    __decorate([
        (0, Model_3.ModelProperty)()
    ], BeaconBaseModel.prototype, "_inConnectionPartner", void 0);
    __decorate([
        (0, Model_3.ModelProperty)()
    ], BeaconBaseModel.prototype, "_inConnectionRssi", void 0);
    __decorate([
        (0, Model_3.ModelProperty)()
    ], BeaconBaseModel.prototype, "_inConnectionHasMasterBit", void 0);
    __decorate([
        (0, Model_3.ModelProperty)()
    ], BeaconBaseModel.prototype, "_inConnectionPartnerHasMasterBit", void 0);
    __decorate([
        (0, Model_3.ModelProperty)()
    ], BeaconBaseModel.prototype, "_lastSentAdvertisingMessage", void 0);
    __decorate([
        (0, Model_3.ModelProperty)()
    ], BeaconBaseModel.prototype, "_lastSentMessageTimestampMs", void 0);
    __decorate([
        (0, Model_3.ModelProperty)()
    ], BeaconBaseModel.prototype, "_ledOn", void 0);
    exports.BeaconBaseModel = BeaconBaseModel;
    // tslint:disable-next-line:max-classes-per-file
    class SmartBeaconBaseModel extends BeaconBaseModel {
        // Getters and setters
        get chipId() {
            return this._chipId;
        }
        set chipId(chipId) {
            this._chipId = chipId;
            this.notifyObservers("chipId");
        }
        get nodeId() {
            return this._nodeId;
        }
        set nodeId(nodeId) {
            this._nodeId = nodeId;
            this.notifyObservers("nodeId");
        }
    }
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], SmartBeaconBaseModel.prototype, "_chipId", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], SmartBeaconBaseModel.prototype, "_nodeId", void 0);
    exports.SmartBeaconBaseModel = SmartBeaconBaseModel;
    // tslint:disable-next-line:max-classes-per-file
    class AssetModel extends SmartBeaconBaseModel {
        // Getters and setters
        get assetId() {
            return this._assetId;
        }
        set assetId(assetId) {
            this._assetId = assetId;
            this.notifyObservers("assetId");
        }
        get discoveredTimeSec() {
            return this._discoveredTimeSec;
        }
        set discoveredTimeSec(discoveredTimeSec) {
            this._discoveredTimeSec = discoveredTimeSec;
            this.notifyObservers("discoveredTimeSec");
        }
        get lostTimeSec() {
            return this._lostTimeSec;
        }
        set lostTimeSec(lostTimeSec) {
            this._lostTimeSec = lostTimeSec;
            this.notifyObservers("lostTimeSec");
        }
        get trackingState() {
            return this._trackingState;
        }
        set trackingState(trackingState) {
            this._trackingState = trackingState;
            this.notifyObservers("trackingState");
        }
    }
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], AssetModel.prototype, "_assetId", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], AssetModel.prototype, "_discoveredTimeSec", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], AssetModel.prototype, "_lostTimeSec", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], AssetModel.prototype, "_trackingState", void 0);
    exports.AssetModel = AssetModel;
    // tslint:disable-next-line:max-classes-per-file
    class BleNodeModel extends SmartBeaconBaseModel {
        // Getters and setters
        get nonConnections() {
            return this._nonConnections;
        }
        set nonConnections(nonConnections) {
            this._nonConnections = nonConnections;
            this.notifyObservers("nonConnections");
        }
        get connections() {
            return this._connections;
        }
        set connections(connections) {
            this._connections = connections;
            this.notifyObservers("connections");
        }
        get uptimeSeconds() {
            return this._uptimeSeconds;
        }
        set uptimeSeconds(uptimeSeconds) {
            this._uptimeSeconds = uptimeSeconds;
            this.notifyObservers("uptimeSeconds");
        }
        get version() {
            return this._version;
        }
        set version(version) {
            this._version = version;
            this.notifyObservers("version");
        }
        get clusterId() {
            return this._clusterId;
        }
        set clusterId(clusterId) {
            this._clusterId = clusterId;
            this.notifyObservers("clusterId");
        }
        get clusterSize() {
            return this._clusterSize;
        }
        set clusterSize(clusterSize) {
            this._clusterSize = clusterSize;
            this.notifyObservers("clusterSize");
        }
        get freeIn() {
            return this._freeIn;
        }
        set freeIn(freeIn) {
            this._freeIn = freeIn;
            this.notifyObservers("freeIn");
        }
        get freeOut() {
            return this._freeOut;
        }
        set freeOut(freeOut) {
            this._freeOut = freeOut;
            this.notifyObservers("freeOut");
        }
    }
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], BleNodeModel.prototype, "_nonConnections", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], BleNodeModel.prototype, "_connections", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], BleNodeModel.prototype, "_uptimeSeconds", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], BleNodeModel.prototype, "_version", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], BleNodeModel.prototype, "_clusterId", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], BleNodeModel.prototype, "_clusterSize", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], BleNodeModel.prototype, "_freeIn", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], BleNodeModel.prototype, "_freeOut", void 0);
    exports.BleNodeModel = BleNodeModel;
    // tslint:disable-next-line:max-classes-per-file
    class BeaconModel extends BeaconBaseModel {
    }
    exports.BeaconModel = BeaconModel;
    // tslint:disable-next-line:max-classes-per-file
    class MeshGatewayModel extends BleNodeModel {
        // Getters and setters
        get communicationBeacon() {
            return this._communicationBeacon;
        }
        set communicationBeacon(communicationBeacon) {
            this._communicationBeacon = communicationBeacon;
            this.notifyObservers("communicationBeacon");
        }
        get communicationBeaconUuid() {
            return this._communicationBeaconUuid;
        }
        set communicationBeaconUuid(communicationBeaconUuid) {
            this._communicationBeaconUuid = communicationBeaconUuid;
            this.notifyObservers("communicationBeaconUuid");
        }
    }
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], MeshGatewayModel.prototype, "_communicationBeacon", void 0);
    __decorate([
        (0, Model_3.ModelProperty)({ findIn: "details" })
    ], MeshGatewayModel.prototype, "_communicationBeaconUuid", void 0);
    exports.MeshGatewayModel = MeshGatewayModel;
    // tslint:disable-next-line:max-classes-per-file
    class BACnetModel extends DeviceModel {
    }
    exports.BACnetModel = BACnetModel;
    // tslint:disable-next-line:max-classes-per-file
    class KnxModel extends DeviceModel {
    }
    exports.KnxModel = KnxModel;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceMapObject", ["require", "exports", "src/app/relution/view/world/RelutionMapObject", "src/engine/math/Vector2"], function (require, exports, RelutionMapObject_2, Vector2_18) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeviceMapObject = void 0;
    class DeviceMapObject extends RelutionMapObject_2.RelutionMapObject {
        // Initialization
        constructor(config, environment, floorplanLayer, model) {
            super(config, environment, floorplanLayer, model);
            // View: Dimensions
            this.maxDeviceSizeInMeter = 1.0;
            this.minDeviceSizeInPixels = 10;
            // View: State
            this.invalidated = false;
            this.pivotCentered = false;
            this.initContainerView();
            this.initDeviceView();
        }
        initContainerView() {
            this.initContainer();
            this.updateVisibilityWithoutAnimation();
        }
        initContainer() {
            this.container = this.getEnvironment().renderer.newDisplayObjectContainer();
            this.getView().addChild(this.container);
            this.updateViewPositionFromModelPosition();
        }
        initDeviceView() {
            this.spriteView = this.getEnvironment().renderer.newSpriteObject();
            this.getView().addChild(this.spriteView);
            this.updateTexture();
            this.setMinViewDeviceSize();
            this.setMaxViewSize();
            this.reset();
        }
        updateTexture() {
            const textureName = this.getTextureName();
            this.spriteView.texture = this.getEnvironment().renderer.getTexture(textureName);
            this.redraw();
        }
        // @Override
        setMinViewDeviceSize() {
            this.setMinDeviceSizeInPixels(10);
        }
        // @Override
        setMaxViewSize() {
            this.setMaxDeviceSizeInMeter(1.0);
        }
        // Resetting
        reset() {
            this.setEditModeActive(false);
            this.userMovesDevice = false;
            this.setFreezed(false);
            this.redraw();
            this.getView().scale = this.getEnvironment().renderer.newPoint(1, 1);
            // Retransform object, after its dimensions have changed.
            this.invalidate();
        }
        // Rendering
        redraw() {
            this.updateTint();
            this.updateSpritePivot();
            this.updateSpriteSize();
        }
        // Redrawing
        updateTint() {
            if (this.isSelected()) {
                this.spriteView.tint = DeviceMapObject.SELECTED_COLOR;
            }
            else if (this.isHighlighted()) {
                this.spriteView.tint = DeviceMapObject.HIGHLIGHTED_COLOR;
            }
            else {
                this.spriteView.tint = this.getColor();
            }
        }
        updateSpritePivot() {
            this.spriteView.pivot.x = this.spriteView.texture.width / 2;
            this.spriteView.pivot.y = this.spriteView.texture.height / 2;
        }
        updateSpriteSize() {
            let targetWidth = this.getTargetDeviceSizeInPx();
            const targetHeight = this.spriteView.texture.height * (targetWidth / this.spriteView.texture.width);
            this.spriteView.width = targetWidth;
            this.spriteView.height = targetHeight;
        }
        updateViewPositionFromModelPosition() {
            let modelPosition = this.getModel().getPosition();
            this.getView().x = modelPosition.x * this.getFloorplanLayer().getFloorSize().x;
            this.getView().y = modelPosition.y * this.getFloorplanLayer().getFloorSize().y;
            this.getView().visible = !this.getModel().estimatedPositionIsOutdoor(modelPosition);
        }
        getMaxDeviceSizeInMeter() {
            return this.maxDeviceSizeInMeter;
        }
        setMaxDeviceSizeInMeter(maxDeviceSizeInMeter) {
            this.maxDeviceSizeInMeter = maxDeviceSizeInMeter;
        }
        getMinDeviceSizeInPixels() {
            return this.minDeviceSizeInPixels;
        }
        setMinDeviceSizeInPixels(minDeviceSizeInPixels) {
            this.minDeviceSizeInPixels = minDeviceSizeInPixels;
        }
        /**
         * The current width of the device given in pixels.
         */
        getWidth() {
            return this.spriteView.width;
        }
        /**
         * The width of the device texture given in pixels.
         */
        getTextureWidth() {
            return this.spriteView.texture.width;
        }
        /**
         * The height of the device texture given in pixels.
         */
        getTextureHeight() {
            return this.spriteView.texture.height;
        }
        // Model Event handling
        updateModelPositionFromViewPosition() {
            // We prestore its position, because changing the
            // models values might call observers directly modifying
            // the view coordinates.
            let viewX = this.getView().x;
            let viewY = this.getView().y;
            this.getModel().x = viewX / this.getFloorSize().x;
            this.getModel().y = viewY / this.getFloorSize().y;
            this.getView().visible = !this.getModel().estimatedPositionIsOutdoor(this.getModel().getPosition());
        }
        updateModelPositionFromViewPositionAndConsiderWorldConstraints() {
            let viewX = this.getView().x;
            let viewY = this.getView().y;
            this.getModel().x = Math.max(0, Math.min(1, viewX / this.getFloorSize().x));
            this.getModel().y = Math.max(0, Math.min(1, viewY / this.getFloorSize().y));
        }
        // @Override
        xChanged(deviceModel) {
            // Do not update beacon position, if beacon is in stock
            if (this.getModel().isOnMap()) {
                this.updateViewPositionFromModelPosition();
            }
        }
        // @Override
        yChanged(deviceModel) {
            // Do not update beacon position, if beacon is in stock
            if (this.getModel().isOnMap()) {
                this.updateViewPositionFromModelPosition();
            }
        }
        // @Override
        visibilityChanged(deviceModel) {
            super.visibilityChanged(deviceModel);
            this.updateVisibilityWithAnimation();
        }
        // @Override
        onMapChanged() {
            this.updateTexture();
        }
        // Name
        // @Override
        getName() {
            return this.getModel().name;
        }
        // Popup info
        getNamePosition(textBound) {
            const objectBoundsInImage = this.getAabbInImageCoordinates();
            const deltaX = objectBoundsInImage.max.x - objectBoundsInImage.min.x;
            return new Vector2_18.Vector2(deltaX + textBound.width / 2, this.getCenter().y);
        }
        // @Override
        getPopupInfo() {
            let content;
            // General device information
            content = this.getLocalizedStringFor("popup_device_name") + ": "
                + this.getModel().name;
            // Device specific information
            content += this.getDeviceSpecificPopupInfo();
            return content;
        }
        getDeviceSpecificPopupInfo() {
            // Default empty implementation
            return "";
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (!this.isFreezed()) {
                this.updateTransform();
            }
        }
        updateTransform() {
            this.updateScale();
            this.updateRotation();
            this.invalidated = false;
        }
        updateScale() {
            let scaleFactor = 1.0;
            if (this.getScene() != null) {
                let camera = this.getScene().getCamera();
                scaleFactor = camera.getScaleX();
            }
            if (this.lastScaleFactor !== scaleFactor || this.invalidated) {
                this.lastScaleFactor = scaleFactor;
                this.getView().scale.x = scaleFactor;
                this.getView().scale.y = scaleFactor;
                let maxDeviceSizeInMeter = this.getMaxDeviceSizeInMeter();
                let deviceSizeInScreenPixels = this.getDeviceSizeInScreenPixels();
                let deviceSizeInTexels = deviceSizeInScreenPixels * scaleFactor;
                let deviceSizeInMeter = this.getTexelSizeInMeter(deviceSizeInTexels);
                if (deviceSizeInMeter >= maxDeviceSizeInMeter) {
                    // Max beacon size in meter:
                    // Device should only scale if it does not cover
                    // more than maxDeviceSize meters of world space.
                    let maxScaleCorrection = maxDeviceSizeInMeter / deviceSizeInMeter;
                    // Min device size in pixels.
                    // However, devices should not be display too small.
                    // Hence, we define a minimum device size in pixels.
                    let newDeviceSizeInScreenPixels = deviceSizeInScreenPixels * maxScaleCorrection;
                    let minDeviceSizeInPx = this.getMinDeviceSizeInPixels();
                    if (newDeviceSizeInScreenPixels < minDeviceSizeInPx) {
                        let minScaleCorrection = minDeviceSizeInPx / deviceSizeInScreenPixels;
                        this.getView().scale.x = this.getView().scale.x * minScaleCorrection;
                        this.getView().scale.y = this.getView().scale.y * minScaleCorrection;
                    }
                    else {
                        this.getView().scale.x = this.getView().scale.x * maxScaleCorrection;
                        this.getView().scale.y = this.getView().scale.y * maxScaleCorrection;
                    }
                }
            }
        }
        getDeviceSizeInScreenPixels() {
            let bounds = this.getView().getBounds();
            return bounds.width;
        }
        getTexelSizeInMeter(sizeInTexels) {
            let sizeInMeter = sizeInTexels / this.getFloorplanLayer().getModel().pixelPerMeter;
            return sizeInMeter;
        }
        getSizeInPx(sizeInMeter) {
            let sizeInPx = sizeInMeter * this.getFloorplanLayer().getModel().pixelPerMeter;
            return sizeInPx;
        }
        updateRotation() {
            let camera = this.getScene().getCamera();
            let orientation = camera.getRotation();
            if (this.getView().rotation !== orientation || this.invalidated) {
                this.getView().rotation = orientation;
            }
        }
        invalidate() {
            this.invalidated = true;
            if (this.getScene() != null) {
                this.updateTransform();
            }
        }
        // Moving
        // @Override
        onMoveStarted(x, y) {
            if (this.intersectsPointInScreenPx(x, y)) {
                if (this.isEditModeActive()) {
                    this.userMovesDevice = true;
                    let mouseInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_18.Vector2(x, y));
                    let viewPositionInTx = this.getView().position;
                    this.movingPointInDeviceLocalTx = new Vector2_18.Vector2(mouseInTx.x - viewPositionInTx.x, mouseInTx.y - viewPositionInTx.y);
                    this.notifyObservers("onObjectMoveStarted", [this, x, y]);
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        // @Override
        onMoveChanged(x, y) {
            if (this.userMovesDevice) {
                let mouseInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_18.Vector2(x, y));
                this.getView().x = mouseInTx.x - this.movingPointInDeviceLocalTx.x;
                this.getView().y = mouseInTx.y - this.movingPointInDeviceLocalTx.y;
                this.updateModelPositionFromViewPosition();
                this.notifyObservers("onObjectMoveChanged", [this, x, y]);
                return true;
            }
            else {
                return false;
            }
        }
        // @Override
        onMoveStopped(x, y) {
            if (this.userMovesDevice) {
                this.userMovesDevice = false;
                this.movingPointInDeviceLocalTx = null;
                this.updateModelPositionFromViewPositionAndConsiderWorldConstraints();
                this.notifyObservers("onObjectMoveStopped", [this, x, y]);
                return true;
            }
            else {
                return false;
            }
        }
        // Model updating
        addToMap() {
            // Set beacon model to be on the map.
            this.getModel().onMap = true;
            // Update the view position.
            this.updateViewPositionFromModelPosition();
        }
        removeFromMap() {
            this.getModel().onMap = false;
        }
        // Selection
        // @Override
        isSelectable() {
            // A device is only selectable, if it is on the map and not in the stock.
            return this.isOnMap();
        }
        // Destruction
        // @Override
        destroy() {
            super.destroy();
            // Destroy without removing texture
            this.getView().destroy(false);
        }
        // Getters and setters
        getModel() {
            return super.getModel();
        }
        getFloorSize() {
            return new Vector2_18.Vector2(this.getFloorplanLayer().getFloorSize().x, this.getFloorplanLayer().getFloorSize().y);
        }
        isFreezed() {
            return this.freezed;
        }
        // Freezed means that the beacon does
        // not do anything in its update method.
        setFreezed(freezed) {
            this.freezed = freezed;
        }
        // The status category below must directly match the definitions in our bluerange-dashboard-ui
        // The status category maps to the device-status
        isDeviceStatusGood() {
            return this.getModel().status === "COMPLIANT";
        }
        isDeviceStatusWarning() {
            return this.getModel().status === "NONCOMPLIANT" || this.getModel().status === "ENROLLMENT_PENDING";
        }
        isDeviceStatusError() {
            return !this.isDeviceStatusGood() && !this.isDeviceStatusWarning();
        }
        isInactive() {
            return this.inactive;
        }
        setInactive(inactive) {
            this.inactive = inactive;
            this.redraw();
        }
        isHighlighted() {
            return this.highlighted;
        }
        setHighlighted(highlighted) {
            this.highlighted = highlighted;
            this.redraw();
        }
        isUserMovingBeacon() {
            return this.userMovesDevice;
        }
        setUserMovesBeacon(userMovesBeacon) {
            this.userMovesDevice = userMovesBeacon;
        }
        setPivotCentered(pivotCentered) {
            this.pivotCentered = pivotCentered;
            this.redraw();
        }
        isPivotCentered() {
            return this.pivotCentered;
        }
        getSpriteView() {
            return this.spriteView;
        }
    }
    exports.DeviceMapObject = DeviceMapObject;
    // Constants
    DeviceMapObject.SELECTED_COLOR = 0x00ACE9;
    DeviceMapObject.HIGHLIGHTED_COLOR = 0x04BF8A;
    DeviceMapObject.NORMAL_COLOR = 0x04BF8A;
    DeviceMapObject.WARNING_COLOR = 0xF59C00;
    DeviceMapObject.ERROR_COLOR = 0xD9534F;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceLayer/BeaconMapObject", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceMapObject", "src/map/utils/DeviceUtils", "src/app/relution/model/device/DeviceModel", "src/app/relution/view/world/RelutionMapObject"], function (require, exports, DeviceMapObject_1, DeviceUtils_2, DeviceModel_1, RelutionMapObject_3) {
    "use strict";
    var BeaconMapObject_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BeaconMapObject = void 0;
    let BeaconMapObject = BeaconMapObject_1 = class BeaconMapObject extends DeviceMapObject_1.DeviceMapObject {
        // Initialization
        constructor(config, environment, floorplanLayer, model) {
            super(config, environment, floorplanLayer, model);
        }
        // @Override
        getTextureName() {
            return "beacon_white";
        }
        // @Override
        getColor() {
            if (this.getModel().isBleNode() || this.getModel().isMeshgw()) {
                if (this.isDeviceStatusGood()) {
                    return BeaconMapObject_1.NORMAL_COLOR;
                }
                else if (this.isDeviceStatusWarning()) {
                    return DeviceMapObject_1.DeviceMapObject.WARNING_COLOR;
                }
                else {
                    return BeaconMapObject_1.ERROR_COLOR;
                }
            }
            else {
                return BeaconMapObject_1.DUMB_BEACON_COLOR;
            }
        }
        // @Override
        getTargetDeviceSizeInPx() {
            return DeviceUtils_2.DeviceUtils.getPhysicalPixelsFromLogical(15);
        }
        // Popup info
        // @Override
        getDeviceSpecificPopupInfo() {
            let content = "\n";
            content += this.getLocalizedStringFor("popup_device_serial") + ": "
                + this.getModel().deviceId;
            content += "\n";
            content += this.getLocalizedStringFor("popup_device_last_connected") + ": "
                + this.getLocalizedLastConnectionDateString(this);
            if (this.getModel().batteryInfo != null) {
                content += "\n";
                const batteryValue = this.getModel().batteryInfo / 10;
                let batteryValueString = "";
                if (batteryValue == 0) {
                    batteryValueString = "-";
                }
                else {
                    batteryValueString = "" + (batteryValue) + "V";
                }
                content += this.getLocalizedStringFor("popup_device_battery") + ": " + batteryValueString;
            }
            content += "\n";
            content += this.getLocalizedStringFor("popup_device_version") + ": "
                + this.getModel().os;
            content += "\n";
            content += this.getLocalizedStringFor("popup_device_node_id") + ": "
                + this.getModel().nodeId;
            return content;
        }
        getLocalizedLastConnectionDateString(device) {
            return this.getLocalizedTimeSinceString(device.getModel().lastConnectionDate);
        }
        // Stock movability
        // @Override
        isMovableToStock() {
            return true;
        }
        // Getters and setters
        // @Override
        getModel() {
            return super.getModel();
        }
    };
    // Constants
    BeaconMapObject.NORMAL_COLOR = DeviceMapObject_1.DeviceMapObject.NORMAL_COLOR;
    BeaconMapObject.DUMB_BEACON_COLOR = BeaconMapObject_1.NORMAL_COLOR;
    BeaconMapObject = BeaconMapObject_1 = __decorate([
        (0, RelutionMapObject_3.RelutionModelBinding)(DeviceModel_1.BleNodeModel)
    ], BeaconMapObject);
    exports.BeaconMapObject = BeaconMapObject;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceLayer/AssetMapObject", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceMapObject", "src/app/relution/model/device/DeviceModel", "src/map/utils/DeviceUtils", "src/app/relution/view/world/RelutionMapObject"], function (require, exports, DeviceMapObject_2, DeviceModel_2, DeviceUtils_3, RelutionMapObject_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AssetMapObject = void 0;
    let AssetMapObject = class AssetMapObject extends DeviceMapObject_2.DeviceMapObject {
        // Initialization
        constructor(config, environment, floorplanLayer, model) {
            super(config, environment, floorplanLayer, model);
        }
        // @Override
        getTextureName() {
            if (this.getModel().onMap) {
                return "asset_device_fixed_white";
            }
            else {
                return "asset_device_white";
            }
        }
        // @Override
        getColor() {
            if (this.isDeviceStatusGood()) {
                return DeviceMapObject_2.DeviceMapObject.NORMAL_COLOR;
            }
            else if (this.isDeviceStatusWarning()) {
                return DeviceMapObject_2.DeviceMapObject.WARNING_COLOR;
            }
            else {
                return DeviceMapObject_2.DeviceMapObject.ERROR_COLOR;
            }
        }
        // @Override
        getTargetDeviceSizeInPx() {
            let logicalPixels;
            if (this.getModel().onMap) {
                logicalPixels = 15;
            }
            else {
                logicalPixels = 20;
            }
            return DeviceUtils_3.DeviceUtils.getPhysicalPixelsFromLogical(logicalPixels);
        }
        updateSpritePivot() {
            super.updateSpritePivot();
            // Tracked assets have a pivot on the bottom center, whereas
            // sensor assets (onMap=false...) should have a centered pivot.
            if (!this.isPivotCentered() && !this.getModel().onMap) {
                this.getSpriteView().pivot.y = this.getSpriteView().texture.height;
            }
        }
        // Popup info
        // @Override
        getDeviceSpecificPopupInfo() {
            const asset = this.getModel();
            let content = "\n";
            content += this.getLocalizedStringFor("popup_device_serial") + ": "
                + asset.deviceId;
            content += "\n";
            content += this.getLocalizedStringFor("popup_device_last_connected") + ": "
                + this.getLocalizedLastMeasurementDateString(this);
            if (asset.positionEstimate !== null && asset.positionEstimate !== undefined) {
                if (asset.positionEstimate.motionState && asset.positionEstimate.motionState !== "UNKNOWN") {
                    content += "\n";
                    content += this.getLocalizedStringFor("popup_device_motion_state") + ": "
                        + this.getLocalizedStringFor("popup_device_motion_state__" + asset.positionEstimate.motionState);
                }
            }
            if (asset.batteryInfo != null) {
                content += "\n";
                const batteryValue = asset.batteryInfo / 10;
                let batteryValueString = "";
                if (batteryValue == 0) {
                    batteryValueString = "-";
                }
                else {
                    batteryValueString = "" + (batteryValue) + "V";
                }
                content += this.getLocalizedStringFor("popup_device_battery") + ": " + batteryValueString;
            }
            if (asset.positionEstimate !== null && asset.positionEstimate !== undefined) {
                if (asset.positionEstimate && isFinite(asset.positionEstimate.z)) {
                    content += "\n";
                    content += this.getLocalizedStringFor("popup_device_zpos") + ": " + asset.positionEstimate.z;
                }
            }
            return content;
        }
        getLocalizedLastMeasurementDateString(asset) {
            if (asset.getModel().positionEstimate != null) {
                return this.getLocalizedTimeSinceString(asset.getModel().positionEstimate.measurementTimeSec * 1000);
            }
            else {
                return "?";
            }
        }
        // Getters and setters
        // @Ovveride
        getModel() {
            return super.getModel();
        }
        isEditModeActive() {
            // Assets are currently uneditable.
            return false;
        }
    };
    AssetMapObject = __decorate([
        (0, RelutionMapObject_4.RelutionModelBinding)(DeviceModel_2.AssetModel)
    ], AssetMapObject);
    exports.AssetMapObject = AssetMapObject;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceLayer/MeshGatewayMapObject", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/BeaconMapObject", "src/map/utils/DeviceUtils", "src/app/relution/model/device/DeviceModel", "src/app/relution/view/world/RelutionMapObject"], function (require, exports, BeaconMapObject_2, DeviceUtils_4, DeviceModel_3, RelutionMapObject_5) {
    "use strict";
    var MeshGatewayMapObject_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MeshGatewayMapObject = void 0;
    let MeshGatewayMapObject = MeshGatewayMapObject_1 = class MeshGatewayMapObject extends BeaconMapObject_2.BeaconMapObject {
        // Initialization
        constructor(config, environment, floorplanLayer, model) {
            super(config, environment, floorplanLayer, model);
        }
        // View
        // @Override
        setMinViewDeviceSize() {
            this.setMinDeviceSizeInPixels(20);
        }
        // @Override
        setMaxViewSize() {
            this.setMaxDeviceSizeInMeter(2.0);
        }
        // @Override
        getTextureName() {
            return "gateway_white";
        }
        // @Override
        getTargetDeviceSizeInPx() {
            return MeshGatewayMapObject_1.MESHGW_SIZE_IN_PX;
        }
        showMeshGatewayInsteadOfCommunicationBeacon(showMeshgw) {
            if (this.communicationBeacon != null) {
                if (showMeshgw) {
                    this.getView().visible = true;
                    this.communicationBeacon.getView().visible = false;
                }
                else {
                    this.getView().visible = false;
                    this.communicationBeacon.getView().visible = true;
                }
            }
        }
        // Communication beacon
        syncWithCommunicationBeacon() {
            // Register as observer on communication beacon position change events.
            if (!this.communicationBeacon.getModel().isObserver(this)) {
                this.communicationBeacon.getModel().addObserver(this);
            }
            if (this.getModel().isObserver(this)) {
                this.getModel().addObserver(this);
            }
            // Synchronize position with communication beacon. MeshGateway holds the correct position.
            this.syncPositionWithCommunicationBeacon(this.getModel());
        }
        // @Override
        xChanged(deviceModel) {
            super.xChanged(deviceModel);
            this.syncPositionWithCommunicationBeacon(deviceModel);
        }
        // @Override
        yChanged(deviceModel) {
            super.yChanged(deviceModel);
            this.syncPositionWithCommunicationBeacon(deviceModel);
        }
        syncPositionWithCommunicationBeacon(deviceModel) {
            if (this.communicationBeacon != null && deviceModel === this.communicationBeacon.getModel()) {
                if (this.getModel().x !== this.communicationBeacon.getModel().x) {
                    this.getModel().x = this.communicationBeacon.getModel().x;
                }
                if (this.getModel().y !== this.communicationBeacon.getModel().y) {
                    this.getModel().y = this.communicationBeacon.getModel().y;
                }
            }
            if (deviceModel == this.getModel()) {
                if (this.communicationBeacon != null) {
                    if (this.getModel().x !== this.communicationBeacon.getModel().x) {
                        this.communicationBeacon.getModel().x = this.getModel().x;
                    }
                    if (this.getModel().y !== this.communicationBeacon.getModel().y) {
                        this.communicationBeacon.getModel().y = this.getModel().y;
                    }
                }
            }
        }
        // Popup info
        // @Override
        getDeviceSpecificPopupInfo() {
            let meshGateway = this;
            let communicationBeacon = meshGateway.getCommunicationBeacon();
            let content = "\n";
            content += this.getLocalizedStringFor("popup_device_serial") + ": "
                + this.getModel().deviceId;
            content += "\n";
            content += this.getLocalizedStringFor("popup_device_last_connected") + ": "
                + this.getLocalizedLastConnectionDateString(meshGateway);
            content += "\n";
            content += this.getLocalizedStringFor("popup_device_meshgw_version") + ": "
                + meshGateway.getModel().os;
            if (communicationBeacon != null) {
                content += communicationBeacon.getDeviceSpecificPopupInfo();
            }
            return content;
        }
        // Getters and setters
        // @Override
        getModel() {
            return super.getModel();
        }
        setCommunicationBeacon(communicationBeacon) {
            this.communicationBeacon = communicationBeacon;
            this.syncWithCommunicationBeacon();
        }
        getCommunicationBeacon() {
            return this.communicationBeacon;
        }
        isCommunicationBeacon() {
            return this.communicationBeacon;
        }
    };
    // View
    MeshGatewayMapObject.MESHGW_SIZE_IN_PX = DeviceUtils_4.DeviceUtils.getPhysicalPixelsFromLogical(30);
    MeshGatewayMapObject = MeshGatewayMapObject_1 = __decorate([
        (0, RelutionMapObject_5.RelutionModelBinding)(DeviceModel_3.MeshGatewayModel)
    ], MeshGatewayMapObject);
    exports.MeshGatewayMapObject = MeshGatewayMapObject;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceLayer/BACnetDeviceMapObject", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceMapObject", "src/app/relution/model/device/DeviceModel", "src/map/utils/DeviceUtils", "src/app/relution/view/world/RelutionMapObject"], function (require, exports, DeviceMapObject_3, DeviceModel_4, DeviceUtils_5, RelutionMapObject_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BACnetDeviceMapObject = void 0;
    let BACnetDeviceMapObject = class BACnetDeviceMapObject extends DeviceMapObject_3.DeviceMapObject {
        // Initialization
        constructor(config, environment, floorplanLayer, model) {
            super(config, environment, floorplanLayer, model);
        }
        // @Override
        getTextureName() {
            return "bacnet_white";
        }
        // @Override
        getColor() {
            if (this.isDeviceStatusGood()) {
                return DeviceMapObject_3.DeviceMapObject.NORMAL_COLOR;
            }
            else if (this.isDeviceStatusWarning()) {
                return DeviceMapObject_3.DeviceMapObject.WARNING_COLOR;
            }
            else {
                return DeviceMapObject_3.DeviceMapObject.ERROR_COLOR;
            }
        }
        // @Override
        getTargetDeviceSizeInPx() {
            return DeviceUtils_5.DeviceUtils.getPhysicalPixelsFromLogical(15);
        }
        // Stock movability
        // @Override
        isMovableToStock() {
            return true;
        }
        // Getters and setters
        // @Ovveride
        getModel() {
            return super.getModel();
        }
    };
    BACnetDeviceMapObject = __decorate([
        (0, RelutionMapObject_6.RelutionModelBinding)(DeviceModel_4.BACnetModel)
    ], BACnetDeviceMapObject);
    exports.BACnetDeviceMapObject = BACnetDeviceMapObject;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceLayer/KnxDeviceMapObject", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceMapObject", "src/app/relution/model/device/DeviceModel", "src/map/utils/DeviceUtils", "src/app/relution/view/world/RelutionMapObject"], function (require, exports, DeviceMapObject_4, DeviceModel_5, DeviceUtils_6, RelutionMapObject_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KnxDeviceMapObject = void 0;
    let KnxDeviceMapObject = class KnxDeviceMapObject extends DeviceMapObject_4.DeviceMapObject {
        // Initialization
        constructor(config, environment, floorplanLayer, model) {
            super(config, environment, floorplanLayer, model);
        }
        // @Override
        getTextureName() {
            return "knx_white";
        }
        // @Override
        getColor() {
            if (this.isDeviceStatusGood()) {
                return DeviceMapObject_4.DeviceMapObject.NORMAL_COLOR;
            }
            else if (this.isDeviceStatusWarning()) {
                return DeviceMapObject_4.DeviceMapObject.WARNING_COLOR;
            }
            else {
                return DeviceMapObject_4.DeviceMapObject.ERROR_COLOR;
            }
        }
        // @Override
        getTargetDeviceSizeInPx() {
            return DeviceUtils_6.DeviceUtils.getPhysicalPixelsFromLogical(15);
        }
        // Stock movability
        // @Override
        isMovableToStock() {
            return true;
        }
        // Getters and setters
        // @Ovveride
        getModel() {
            return super.getModel();
        }
    };
    KnxDeviceMapObject = __decorate([
        (0, RelutionMapObject_7.RelutionModelBinding)(DeviceModel_5.KnxModel)
    ], KnxDeviceMapObject);
    exports.KnxDeviceMapObject = KnxDeviceMapObject;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceLayer", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/BeaconMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/AssetMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/MeshGatewayMapObject", "src/app/relution/view/world/RelutionMapObjectLayer", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/BACnetDeviceMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/KnxDeviceMapObject"], function (require, exports, BeaconMapObject_3, AssetMapObject_1, MeshGatewayMapObject_2, RelutionMapObjectLayer_1, BACnetDeviceMapObject_1, KnxDeviceMapObject_1) {
    "use strict";
    var DeviceLayer_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeviceLayer = void 0;
    let DeviceLayer = DeviceLayer_1 = class DeviceLayer extends RelutionMapObjectLayer_1.RelutionMapObjectLayer {
        // Initialization
        constructor(environment, floorplanLayer, config = new DeviceLayer_1.Config()) {
            super(config, environment, floorplanLayer);
            this.deviceLayerConfig = config;
            this.addObserver(this);
        }
        // Observation
        // @Override
        onAfterObjectsLoaded(objects) {
            this.connectCommunicationBeaconsAndMeshGateway();
        }
        // @Override
        onAfterObjectsUpdated(objects) {
            this.connectCommunicationBeaconsAndMeshGateway();
        }
        // @Override
        onObjectAddedToMap(object) {
            this.addObjectToMap(object);
        }
        // @Override
        onObjectRemovedFromMap(object) {
            this.removeObjectFromMap(object);
        }
        addObjectToMap(view) {
            view.reset();
            // TODO: Check should be removed, after asset placement feature has been added.
            if (view instanceof BeaconMapObject_3.BeaconMapObject || view instanceof KnxDeviceMapObject_1.KnxDeviceMapObject || view instanceof BACnetDeviceMapObject_1.BACnetDeviceMapObject) {
                view.addToMap();
            }
            view.setEditModeActive(this.isEditModeActive());
        }
        removeObjectFromMap(view) {
            // TODO: Check should be removed, after asset placement feature has been added.
            if (view instanceof BeaconMapObject_3.BeaconMapObject || view instanceof KnxDeviceMapObject_1.KnxDeviceMapObject || view instanceof BACnetDeviceMapObject_1.BACnetDeviceMapObject) {
                view.removeFromMap();
            }
            view.reset();
        }
        // Accessing
        getDeviceWithUuid(uuid) {
            let allDevices = this.objectModelBinder.getObjects();
            for (let i = 0; i < allDevices.length; i++) {
                let device = allDevices[i];
                if (device.getModel().uuid === uuid) {
                    return device;
                }
            }
            return null;
        }
        getDeviceWithDeviceId(deviceId) {
            let allDevices = this.objectModelBinder.getObjects();
            for (let i = 0; i < allDevices.length; i++) {
                let device = allDevices[i];
                if (device.getModel().deviceId === deviceId) {
                    return device;
                }
            }
            return null;
        }
        getBeaconWithNodeId(nodeId) {
            //NodeId 0 is not a valid address for a device
            if (nodeId === 0)
                return null;
            let beacons = this.getAllBeacons();
            for (let i = 0; i < beacons.length; i++) {
                let beacon = beacons[i];
                if (beacon.getModel().nodeId === nodeId) {
                    return beacon;
                }
            }
            return null;
        }
        getBeaconWithSerial(serialNumber) {
            let beacons = this.getAllBeacons();
            for (let i = 0; i < beacons.length; i++) {
                let beacon = beacons[i];
                if (beacon.getModel().deviceId === serialNumber) {
                    return beacon;
                }
            }
            return null;
        }
        filterBeacons(devices) {
            let beacons = new Array();
            for (let i = 0; i < devices.length; i++) {
                let device = devices[i];
                if (device instanceof BeaconMapObject_3.BeaconMapObject) {
                    beacons.push(device);
                }
            }
            return beacons;
        }
        // MeshGateway appearance
        connectCommunicationBeaconsAndMeshGateway() {
            let beacons = this.getAllBeacons();
            for (let i = 0; i < beacons.length; i++) {
                let beacon = beacons[i];
                if (beacon instanceof MeshGatewayMapObject_2.MeshGatewayMapObject) {
                    let communicationBeacon = this.getCommunicationBeaconForMeshGateway(beacon);
                    if (communicationBeacon != null) {
                        let meshGateway = beacon;
                        meshGateway.setCommunicationBeacon(communicationBeacon);
                    }
                }
            }
            this.updateMeshGatewayAppearance();
        }
        getCommunicationBeaconForMeshGateway(meshGateway) {
            let beacons = this.getAllBeacons();
            for (let i = 0; i < beacons.length; i++) {
                let beacon = beacons[i];
                if (meshGateway.getModel().communicationBeaconUuid === beacon.getModel().uuid) {
                    return beacon;
                }
            }
            return null;
        }
        updateMeshGatewayAppearance() {
            let beacons = this.getAllBeacons();
            for (let i = 0; i < beacons.length; i++) {
                let beacon = beacons[i];
                if (beacon instanceof MeshGatewayMapObject_2.MeshGatewayMapObject) {
                    let meshgateway = beacon;
                    meshgateway.showMeshGatewayInsteadOfCommunicationBeacon(this.deviceLayerConfig.showMeshGatewayInsteadOfCommunicationBeaconEnabled);
                }
            }
        }
        // Getters and setters
        getBeaconsOnMap() {
            let beaconsOnMap = [];
            for (let i = 0; i < this.objectModelBinder.getObjectsOnMap().length; i++) {
                let view = this.objectModelBinder.getObjectsOnMap()[i];
                if (view instanceof BeaconMapObject_3.BeaconMapObject) {
                    beaconsOnMap.push(view);
                }
            }
            return beaconsOnMap;
        }
        getBeaconsInStock() {
            let beaconsInStock = [];
            for (let i = 0; i < this.objectModelBinder.getObjectsInStock().length; i++) {
                let view = this.objectModelBinder.getObjectsInStock()[i];
                if (view instanceof BeaconMapObject_3.BeaconMapObject) {
                    beaconsInStock.push(view);
                }
            }
            return beaconsInStock;
        }
        getVisibleBeaconsOnMap() {
            let visibleBeaconsOnMap = new Array();
            for (let i = 0; i < this.objectModelBinder.getObjectsOnMap().length; i++) {
                let device = this.objectModelBinder.getObjectsOnMap()[i];
                if (device.getModel().visible) {
                    if (device instanceof BeaconMapObject_3.BeaconMapObject) {
                        visibleBeaconsOnMap.push(device);
                    }
                }
            }
            return visibleBeaconsOnMap;
        }
        getAllBeacons() {
            let allBeacons = new Array();
            let beaconsOnMap = this.getBeaconsOnMap();
            let beaconsInStock = this.getBeaconsInStock();
            for (let i = 0; i < beaconsOnMap.length; i++) {
                let beacon = beaconsOnMap[i];
                allBeacons.push(beacon);
            }
            for (let i = 0; i < beaconsInStock.length; i++) {
                let beacon = beaconsInStock[i];
                allBeacons.push(beacon);
            }
            return allBeacons;
        }
        getAllVisibleBeacons() {
            let visibleBeaconsOnMap = new Array();
            let allBeacons = this.getAllBeacons();
            for (let i = 0; i < allBeacons.length; i++) {
                let beacon = allBeacons[i];
                if (beacon.getModel().visible) {
                    visibleBeaconsOnMap.push(beacon);
                }
            }
            return visibleBeaconsOnMap;
        }
        getAssets() {
            let assets = [];
            let views = this.objectModelBinder.getObjects();
            for (let i = 0; i < views.length; i++) {
                let view = views[i];
                if (view instanceof AssetMapObject_1.AssetMapObject) {
                    assets.push(view);
                }
            }
            return assets;
        }
        getVisibleAssets() {
            let visibleAssets = new Array();
            let assets = this.getAssets();
            for (let i = 0; i < assets.length; i++) {
                let asset = assets[i];
                if (asset.getModel().visible) {
                    visibleAssets.push(asset);
                }
            }
            return visibleAssets;
        }
        getAllDevices() {
            return new Array().concat(this.objectModelBinder.getObjects());
        }
        getAllVisibleDevices() {
            let visibleDevices = new Array();
            let allDevices = this.getAllDevices();
            for (let i = 0; i < allDevices.length; i++) {
                let device = allDevices[i];
                if (device.getModel().visible) {
                    visibleDevices.push(device);
                }
            }
            return visibleDevices;
        }
        // Getters and setters
        setShowMeshGatewayInsteadOfCommunicationBeaconEnabled(enabled) {
            this.deviceLayerConfig.showMeshGatewayInsteadOfCommunicationBeaconEnabled = enabled;
            this.updateMeshGatewayAppearance();
        }
        isShowingMeshGatewayInsteadOfCommunicationBeaconEnabled() {
            return this.deviceLayerConfig.showMeshGatewayInsteadOfCommunicationBeaconEnabled;
        }
    };
    DeviceLayer = DeviceLayer_1 = __decorate([
        (0, RelutionMapObjectLayer_1.RelutionMapObjectBinding)(AssetMapObject_1.AssetMapObject, BeaconMapObject_3.BeaconMapObject, MeshGatewayMapObject_2.MeshGatewayMapObject, BACnetDeviceMapObject_1.BACnetDeviceMapObject, KnxDeviceMapObject_1.KnxDeviceMapObject)
    ], DeviceLayer);
    exports.DeviceLayer = DeviceLayer;
    (function (DeviceLayer) {
        class Config extends RelutionMapObjectLayer_1.RelutionMapObjectLayer.Config {
            constructor() {
                super(...arguments);
                /**
                 * If true, the gateway view will replace the communication.
                 *
                 * Default: true
                 */
                this.showMeshGatewayInsteadOfCommunicationBeaconEnabled = true;
            }
        }
        DeviceLayer.Config = Config;
    })(DeviceLayer = exports.DeviceLayer || (exports.DeviceLayer = {}));
    exports.DeviceLayer = DeviceLayer;
});
define("src/app/relution/utils/RssiToDistance", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RssiToDistance = void 0;
    class RssiToDistance {
        static rssiToDistance(rssi) {
            return RssiToDistance.rssiToDistanceWithA(rssi, -55);
        }
        static rssiToDistanceWithA(rssi, A) {
            let N = 2.5;
            let distanceInMetre = Math.pow(10, (A - rssi) / (10 * N));
            return distanceInMetre;
        }
    }
    exports.RssiToDistance = RssiToDistance;
    RssiToDistance.MIN_RSSI = -90;
});
define("src/app/relution/view/world/layers/deviceLayers/beaconRangeLayer/BeaconRange", ["require", "exports", "src/app/relution/utils/RssiToDistance", "src/app/relution/view/world/RelutionMapAttributeObject"], function (require, exports, RssiToDistance_1, RelutionMapAttributeObject_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BeaconRange = void 0;
    class BeaconRange extends RelutionMapAttributeObject_2.RelutionMapAttributeObject {
        // Initialization
        constructor(environment, floorModel, beacon) {
            super(environment, beacon);
            this.initModel(floorModel, beacon);
            this.initView();
        }
        initModel(floorModel, beacon) {
            this.floorModel = floorModel;
            this.beacon = beacon;
            this.radiusInPixels = this.computeRadius();
        }
        computeRadius() {
            let minStableConnectionRssi = -75;
            let calibratedRssi = this.getBeacon().getModel().calibratedRssi;
            let distanceInMeter = RssiToDistance_1.RssiToDistance.rssiToDistanceWithA(minStableConnectionRssi, calibratedRssi);
            let radiusInPixel = this.floorModel.pixelPerMeter * distanceInMeter;
            return radiusInPixel;
        }
        initView() {
            this.redrawCircle();
            this.updatePivot();
            this.updateScale();
            this.updatePosition();
            this.updateAppeareance();
        }
        redrawCircle() {
            this.rangeView = this.getEnvironment().renderer.newSpriteObject();
            this.getView().addChild(this.rangeView);
            this.rangeView.texture = this.getEnvironment().renderer.getTexture("range");
        }
        updatePivot() {
            this.rangeView.pivot.x = this.rangeView.width / 2;
            this.rangeView.pivot.y = this.rangeView.height / 2;
        }
        updateScale() {
            this.rangeView.scale.x = this.radiusInPixels / (this.rangeView.texture.width / 2);
            this.rangeView.scale.y = this.radiusInPixels / (this.rangeView.texture.height / 2);
        }
        updateAppeareance() {
            this.rangeView.alpha = 1;
        }
        // Destruction
        // @Override
        destroy() {
            super.destroy();
            this.rangeView.destroy();
        }
        // Model Event-Handling
        // @Override
        xChanged(deviceModel) {
            this.updatePosition();
        }
        // @Override
        yChanged(deviceModel) {
            this.updatePosition();
        }
        // @Override
        lastConnectionDateChanged(deviceMode) {
            this.updateAppeareance();
        }
        updatePosition() {
            this.rangeView.x = this.beacon.getView().x;
            this.rangeView.y = this.beacon.getView().y;
        }
        // Getters and setters
        getBeacon() {
            return this.beacon;
        }
    }
    exports.BeaconRange = BeaconRange;
});
define("src/app/relution/view/world/layers/deviceLayers/beaconRangeLayer/BeaconRangeLayer", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/BeaconMapObject", "src/app/relution/view/world/layers/deviceLayers/beaconRangeLayer/BeaconRange", "src/app/relution/view/world/RelutionMapAttributeObjectLayer"], function (require, exports, BeaconMapObject_4, BeaconRange_1, RelutionMapAttributeObjectLayer_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BeaconRangeLayer = void 0;
    class BeaconRangeLayer extends RelutionMapAttributeObjectLayer_2.RelutionMapAttributeObjectLayer {
        // Initialization
        constructor(environment, deviceLayer) {
            super(environment, deviceLayer);
        }
        // Device attribute object creation
        // @Override
        createAttributeObjectsForObject(device) {
            let ranges = [];
            if (device instanceof BeaconMapObject_4.BeaconMapObject) {
                let beacon = device;
                let range = new BeaconRange_1.BeaconRange(this.getEnvironment(), this.getFloorplanLayer().getModel(), beacon);
                ranges.push(range);
            }
            return ranges;
        }
    }
    exports.BeaconRangeLayer = BeaconRangeLayer;
});
define("src/app/relution/model/indoor/PositionEstimateModel", ["require", "exports", "src/app/relution/model/Model", "src/app/relution/model/RelutionMapModel", "src/engine/math/Vector2"], function (require, exports, Model_4, RelutionMapModel_3, Vector2_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PositionEstimateModel = void 0;
    class PositionEstimateModel extends RelutionMapModel_3.RelutionMapModel {
        constructor() {
            super(...arguments);
            // Derived attributes
            this.positions = null;
        }
        // Getters and setters
        set siteUuid(siteUuid) {
            this._siteUuid = siteUuid;
            this.notifyObservers("siteUuid");
        }
        get siteUuid() {
            return this._siteUuid;
        }
        set deviceUuid(deviceUuid) {
            this._deviceUuid = deviceUuid;
            this.notifyObservers("deviceUuid");
        }
        get deviceUuid() {
            return this._deviceUuid;
        }
        set floorId(floorId) {
            this._floorId = floorId;
            this.notifyObservers("floorId");
        }
        get floorId() {
            return this._floorId;
        }
        set x(x) {
            this._x = x;
            this.notifyObservers("x");
        }
        get x() {
            return this._x;
        }
        set y(y) {
            this._y = y;
            this.notifyObservers("y");
        }
        get y() {
            return this._y;
        }
        set accuracy(accuracy) {
            this._accuracy = accuracy;
            this.notifyObservers("accuracy");
        }
        get accuracy() {
            return this._accuracy;
        }
        set measurementTimes(measurementTimes) {
            this._measurementTimes = measurementTimes;
            this.notifyObservers("measurementTime");
        }
        get measurementTimes() {
            return this._measurementTimes;
        }
        set amount(amount) {
            this._amount = amount;
            this.notifyObservers("amount");
        }
        get amount() {
            return this._amount;
        }
        set startTimeSec(startTimeSec) {
            this._startTimeSec = startTimeSec;
            this.notifyObservers("startTimeSec");
        }
        get startTimeSec() {
            return this._startTimeSec;
        }
        set endTimeSec(endTimeSec) {
            this._endTimeSec = endTimeSec;
            this.notifyObservers("endTimeSec");
        }
        get endTimeSec() {
            return this._endTimeSec;
        }
        // Derived attributes
        getPositions() {
            if (this.positions == null) {
                this.computePositions();
            }
            return this.positions;
        }
        computePositions() {
            this.positions = [];
            let numPositions = this._x.length;
            for (let i = 0; i < numPositions; i++) {
                let x = this._x[i];
                let y = this._y[i];
                this.positions.push(new Vector2_19.Vector2(x, y));
            }
        }
    }
    __decorate([
        (0, Model_4.ModelProperty)()
    ], PositionEstimateModel.prototype, "_siteUuid", void 0);
    __decorate([
        (0, Model_4.ModelProperty)()
    ], PositionEstimateModel.prototype, "_deviceUuid", void 0);
    __decorate([
        (0, Model_4.ModelProperty)()
    ], PositionEstimateModel.prototype, "_floorId", void 0);
    __decorate([
        (0, Model_4.ModelProperty)()
    ], PositionEstimateModel.prototype, "_x", void 0);
    __decorate([
        (0, Model_4.ModelProperty)()
    ], PositionEstimateModel.prototype, "_y", void 0);
    __decorate([
        (0, Model_4.ModelProperty)()
    ], PositionEstimateModel.prototype, "_accuracy", void 0);
    __decorate([
        (0, Model_4.ModelProperty)()
    ], PositionEstimateModel.prototype, "_measurementTimes", void 0);
    __decorate([
        (0, Model_4.ModelProperty)()
    ], PositionEstimateModel.prototype, "_amount", void 0);
    __decorate([
        (0, Model_4.ModelProperty)()
    ], PositionEstimateModel.prototype, "_startTimeSec", void 0);
    __decorate([
        (0, Model_4.ModelProperty)()
    ], PositionEstimateModel.prototype, "_endTimeSec", void 0);
    __decorate([
        (0, Model_4.ModelProperty)()
    ], PositionEstimateModel.prototype, "positions", void 0);
    exports.PositionEstimateModel = PositionEstimateModel;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceAccuracyRangeLayer/DeviceAccuracyRange", ["require", "exports", "src/app/relution/view/world/RelutionMapAttributeObject", "src/engine/animation/Animation", "src/engine/animation/LinearInterpolator", "src/engine/math/Vector2"], function (require, exports, RelutionMapAttributeObject_3, Animation_6, LinearInterpolator_5, Vector2_20) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeviceAccuracyRange = void 0;
    class DeviceAccuracyRange extends RelutionMapAttributeObject_3.RelutionMapAttributeObject {
        // Constructor
        constructor(environment, floorplanLayer, assetDevice) {
            super(environment, assetDevice);
            // View: Animation
            this.accuracyCircleResolution = 3;
            this.floorplanLayer = floorplanLayer;
            this.assetDevice = assetDevice;
            this.accuracyRangeScaleAnimation = new Animation_6.Animation(new LinearInterpolator_5.LinearInterpolator());
            this.initView();
            this.updateAccuracyRange(assetDevice.getModel(), 0);
        }
        initView() {
            this.accuracyRangeView = this.getEnvironment().renderer.newGraphicsObject();
            this.getView().addChild(this.accuracyRangeView);
            // Pivot
            this.accuracyRangeView.pivot.x = this.accuracyRangeView.width / 2;
            this.accuracyRangeView.pivot.y = this.accuracyRangeView.height / 2;
            // Paint
            this.accuracyRangeView.beginFill(0x0000ff);
            this.accuracyRangeView.drawCircle(0, 0, this.accuracyCircleResolution);
            this.accuracyRangeView.endFill();
            // Scale
            this.accuracyRangeView.scale.x = 1 / this.accuracyCircleResolution;
            this.accuracyRangeView.scale.y = 1 / this.accuracyCircleResolution;
            // Position
            this.accuracyRangeView.x = 0;
            this.accuracyRangeView.y = 0;
            // Alpha
            this.accuracyRangeView.alpha = 0.00;
        }
        // Model Event-Handling
        // @Override
        xChanged(deviceModel) {
            this.updateAccuracyRange(deviceModel);
        }
        // @Override
        yChanged(deviceModel) {
            this.updateAccuracyRange(deviceModel);
        }
        updateAccuracyRange(deviceModel, animationDurationInMs = 200) {
            if (deviceModel.positionEstimate !== null && deviceModel.positionEstimate !== undefined) {
                // Update alpha
                if (deviceModel.estimatedPositionIsUnknown() || !deviceModel.userPositionIsUnknown()) {
                    this.accuracyRangeView.alpha = 0.00;
                }
                else {
                    this.accuracyRangeView.alpha = 0.15;
                }
                // Update position
                this.setPosition(Vector2_20.Vector2.getVector2(this.assetDevice.getView().position));
                // Update scale
                this.setAccuracy(deviceModel.positionEstimate.accuracy, animationDurationInMs);
            }
        }
        setPosition(position) {
            this.accuracyRangeView.x = position.x;
            this.accuracyRangeView.y = position.y;
        }
        setAccuracy(accuracyInCm, animationDurationInMs) {
            // Animate scaling, if animation is currently not running.
            if (!this.accuracyRangeScaleAnimation.isCurrentlyAnimating()) {
                let radiusInCm = accuracyInCm * 3;
                let radiusInPixel = this.floorplanLayer.getModel().pixelPerMeter * (radiusInCm / 100);
                let startValue = this.accuracyRangeView.scale.x;
                let endValue = radiusInPixel / this.accuracyCircleResolution;
                let durationInMs = animationDurationInMs;
                let delayInMs = 0;
                this.accuracyRangeScaleAnimation.start(startValue, endValue, durationInMs, delayInMs);
            }
        }
        // Updating
        update(lastFrametime) {
            super.update(lastFrametime);
            this.updateAccuracyRangeScaleAnimation(lastFrametime);
        }
        updateAccuracyRangeScaleAnimation(lastFrametime) {
            if (this.accuracyRangeScaleAnimation.isCurrentlyAnimating()) {
                let currentScale = this.accuracyRangeScaleAnimation.getValue(lastFrametime);
                this.accuracyRangeView.scale.x = currentScale;
                this.accuracyRangeView.scale.y = currentScale;
            }
        }
    }
    exports.DeviceAccuracyRange = DeviceAccuracyRange;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceTrackLayer/DeviceTrack", ["require", "exports", "src/map/utils/DeviceUtils", "src/engine/math/Vector2", "src/app/relution/view/world/RelutionMapAttributeObject"], function (require, exports, DeviceUtils_7, Vector2_21, RelutionMapAttributeObject_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeviceTrack = void 0;
    class DeviceTrack extends RelutionMapAttributeObject_4.RelutionMapAttributeObject {
        // Initialization
        constructor(environment, floorplanLayer, model, device, deviceAccuracyRange) {
            super(environment, device);
            this.pathPostProcessingEnabled = false;
            this.lastClusterReferencePosition = null;
            // View: State
            this.invalidated = true;
            this.lastScaleFactor = Number.MAX_VALUE;
            // View: Animation
            this.animationModeEnabled = false;
            this.progress = 1.0;
            this.initModel(floorplanLayer, model, device, deviceAccuracyRange);
            this.initView();
        }
        initModel(floorplanLayer, model, device, deviceAccuracyRange) {
            this.floorplanLayer = floorplanLayer;
            this.model = model;
            this.device = device;
            this.deviceAccuracyRange = deviceAccuracyRange;
        }
        initView() {
            this.container = this.getEnvironment().renderer.newDisplayObjectContainer();
            this.getView().addChild(this.container);
            this.initPathView();
        }
        initPathView() {
            this.pathView = this.getEnvironment().renderer.newGraphicsObject();
            this.container.addChild(this.pathView);
            this.redrawPathViewWithLineWidth(0);
        }
        // Painting
        redrawPathViewWithLineWidth(lineWidth) {
            this.redrawPathViewWithLineWidthAndProgress(lineWidth, 1.0);
        }
        redrawPathViewWithLineWidthAndProgress(lineWidth, progress) {
            // Position processing pipeline
            let positions = this.getPositionsFromModel();
            positions = this.getPositionsUntilProgress(positions, progress);
            positions = this.simplifyPositions(positions);
            positions = this.removeDuplicates(positions);
            positions = this.getPostprocessedPositions(positions);
            positions = this.getPositionsInWorldCoordinates(positions);
            positions = this.constrainPathLength(positions);
            let subpaths = this.splitPathToSubpaths(positions);
            // Drawing
            this.drawSubpaths(subpaths, lineWidth);
            let lastSubpath = subpaths[subpaths.length - 1];
            if (lastSubpath != null && lastSubpath.length > 0) {
                // Update asset position
                this.moveDeviceToLastSubpathPosition(subpaths);
                // Update asset range position and scale
                this.updateAccuracyRangeInModel(this.model.accuracy[this.model.amount === null ? this.model.accuracy.length - 1 : this.model.amount - 1]);
                // Update position estimate model
                this.updateMeasurementTimeInModel(this.model.measurementTimes[this.model.amount === null ? this.model.measurementTimes.length - 1 : this.model.amount - 1]);
            }
        }
        getPositionsFromModel() {
            if (this.model.amount === undefined || this.model.amount === null) {
                return this.model.getPositions().slice();
            }
            else {
                return this.model.getPositions().slice(0, this.model.amount);
            }
        }
        simplifyPositions(positions) {
            // Simplify path: Draw in the level of detail depending on the current zoom level.
            let toleranceInPx = 10;
            let floorWidthInScreenPx = this.floorplanLayer.getCurrentFloorSizeInScreenPx().x;
            let relativeTolerance = toleranceInPx / floorWidthInScreenPx;
            // positions = Simplify.simplify(positions, relativeTolerance);
            return positions;
        }
        getPostprocessedPositions(positions) {
            if (this.pathPostProcessingEnabled) {
                positions = this.smoothPositions(positions);
                positions = this.clusterPositions(positions);
            }
            return positions;
        }
        splitPathToSubpaths(positions) {
            let subpaths = new Array();
            // Add first position to subpath
            let firstSubpath = new Array();
            subpaths.push(firstSubpath);
            if (positions.length > 0) {
                if (!this.device.getModel().estimatedPositionIsOutdoor(positions[0])) {
                    firstSubpath.push(positions[0]);
                }
            }
            // Add all other positions to the corresponding subpath
            for (let i = 1; i < positions.length; i++) {
                // Create new subpath whenever the end of a unknown position sequence is reached.
                if (this.device.getModel().estimatedPositionIsOutdoor(positions[i - 1])
                    && !this.device.getModel().estimatedPositionIsOutdoor(positions[i])) {
                    let subpath = new Array();
                    subpaths.push(subpath);
                }
                // Do not add unknown positions to a subpath
                if (!this.device.getModel().estimatedPositionIsOutdoor(positions[i])) {
                    subpaths[subpaths.length - 1].push(positions[i]);
                }
            }
            // Remove empty subpaths
            for (let i = 0; i < subpaths.length; i++) {
                let subpath = subpaths[i];
                if (subpath.length === 0) {
                    subpaths.splice(i, 1);
                    i--;
                }
            }
            return subpaths;
        }
        drawSubpaths(subpaths, lineWidth) {
            this.pathView.clear();
            for (let i = 0; i < subpaths.length; i++) {
                let subpath = subpaths[i];
                this.drawSubpath(subpath, lineWidth);
            }
        }
        drawSubpath(positions, lineWidth) {
            // Line width
            let adjustedLineWidth = DeviceUtils_7.DeviceUtils.getPhysicalPixelsFromLogical(lineWidth);
            // Color
            let targetColor = 0xe94b36;
            // Drawing
            if (positions.length !== 0) {
                this.pathView.moveTo(positions[0].x, positions[0].y);
            }
            let numPoints = positions.length;
            for (let i = 2; i < numPoints; i++) {
                let currentLineWidth = (adjustedLineWidth * i) / numPoints;
                if (currentLineWidth > 0.001) {
                    let currentAlpha = i / numPoints;
                    let currentRed = ((targetColor & 0xff0000) >> 16);
                    let currentGreen = ((targetColor & 0x00ff00) >> 8);
                    let currentBlue = ((targetColor & 0x0000ff) >> 0);
                    let red = currentRed - currentRed * ((numPoints - i) / numPoints);
                    let green = currentGreen - currentGreen * ((numPoints - i) / numPoints);
                    let blue = currentBlue - currentBlue * ((numPoints - i) / numPoints);
                    let currentColor = (red << 16) + (green << 8) + (blue << 0);
                    this.pathView.lineStyle(currentLineWidth, currentColor, currentAlpha);
                    // We always draw 2 lines to get the smooth corners
                    // created by the drawPolygon method.
                    this.pathView.lineTo(positions[i - 2].x, positions[i - 2].y);
                    this.pathView.lineTo(positions[i - 1].x, positions[i - 1].y);
                    this.pathView.lineTo(positions[i - 0].x, positions[i - 0].y);
                }
            }
        }
        getPositionsUntilProgress(positions, progress) {
            // Check, if list is empty
            if (positions === undefined || positions === null || positions.length === 0) {
                return [];
            }
            // Constrain progress limits
            progress = Math.max(0, Math.min(progress, 1));
            // Get final position index determined by progress
            let finalTimeInMs = this.model.startTimeSec + (this.model.endTimeSec - this.model.startTimeSec) * progress;
            let measurementTimes = this.model.measurementTimes;
            let i = 0;
            for (; i < measurementTimes.length; i++) {
                let measurementTime = measurementTimes[i];
                if (measurementTime >= finalTimeInMs) {
                    break;
                }
            }
            i = measurementTimes[Math.min(i, measurementTimes.length - 1)] == finalTimeInMs ? i : i - 1;
            let stopIndex = Math.min(Math.max(i, 0), positions.length - 1);
            // Add artificial final position to get interpolated animation
            let lastPosition = positions[stopIndex];
            let nextPosition = positions[Math.min(stopIndex + 1, positions.length - 1)];
            // Compute interpolated end position only if start and end position of
            // the interpolation is not an unknown position.
            if (!this.device.getModel().estimatedPositionIsOutdoor(lastPosition)
                && !this.device.getModel().estimatedPositionIsOutdoor(nextPosition)) {
                let diffX = nextPosition.x - lastPosition.x;
                let diffY = nextPosition.y - lastPosition.y;
                let lastTime = this.model.measurementTimes[stopIndex];
                let nextTime = this.model.measurementTimes[Math.min(stopIndex + 1, positions.length - 1)];
                let interpolatedX = 0;
                let interpolatedY = 0;
                if (lastTime !== nextTime) {
                    let interpolationProgress = (finalTimeInMs - lastTime) / (nextTime - lastTime);
                    interpolatedX = lastPosition.x + diffX * interpolationProgress;
                    interpolatedY = lastPosition.y + diffY * interpolationProgress;
                }
                else {
                    interpolatedX = lastPosition.x;
                    interpolatedY = lastPosition.y;
                }
                // Copy positions
                positions.splice(Math.min(stopIndex + 1, positions.length - 1), positions.length - stopIndex - 1);
                // Add interpolated value
                positions.push(new Vector2_21.Vector2(interpolatedX, interpolatedY));
            }
            else {
                // Copy positions
                positions.splice(Math.min(stopIndex + 1, positions.length - 1), positions.length - stopIndex - 1);
            }
            return positions;
        }
        getPositionsInWorldCoordinates(positions) {
            let worldPositions = new Array();
            let floorSizeX = this.floorplanLayer.getFloorSize().x;
            let floorSizeY = this.floorplanLayer.getFloorSize().y;
            for (let i = 0; i < positions.length; i++) {
                let x = (positions[i].x * floorSizeX);
                let y = (positions[i].y * floorSizeY);
                worldPositions[i] = new Vector2_21.Vector2(x, y);
            }
            return worldPositions;
        }
        constrainPathLength(positions) {
            const maxPathLength = 150;
            return positions.slice(Math.max(0, positions.length - 1 - maxPathLength), positions.length);
        }
        smoothPositions(positions) {
            let smoothedPositions = this.convolve(positions);
            return smoothedPositions;
        }
        convolve(f) {
            // Output
            let b = new Array();
            // Define kernel
            // let w = this.getAverageKernel(3);
            let w = this.getGaussianKernel(3.5);
            // let w = this.getGaussianKernel(9.5);
            let r = Math.floor(w.length / 2);
            // Extend left end
            let beginIndex = 0;
            for (let i = 0; i < r; i++) {
                f.splice(beginIndex, 0, f[0]);
            }
            // Extend right end
            let endIndex = f.length - 1;
            for (let i = 0; i < r; i++) {
                f.splice(endIndex, 0, f[endIndex]);
            }
            // Convole function
            for (let i = r; i < f.length - r; i++) {
                b[i - r] = new Vector2_21.Vector2(0, 0);
                for (let j = i - r; j < i + r; j++) {
                    b[i - r].x += f[j].x * w[j - (i - r)];
                    b[i - r].y += f[j].y * w[j - (i - r)];
                }
            }
            // Return result
            return b;
        }
        getAverageKernel(r) {
            let w = [];
            for (let i = 0; i < r * 2; i++) {
                w[i] = 1 / (r * 2);
            }
            return w;
        }
        getGaussianKernel(sigma) {
            // Input
            let truncate = 4.0;
            let sd = sigma;
            // Make the radius of the filter equal to truncate standard deviations
            let lw = Math.floor(truncate * sd + 0.5);
            let weights = [];
            weights[lw] = 1.0;
            let sum = 1.0;
            sd = sd * sd;
            // Calculate the kernel:
            for (let i = 1; i < lw + 1; i++) {
                let tmp = Math.exp(-0.5 * (i * i) / sd);
                weights[lw + i] = tmp;
                weights[lw - i] = tmp;
                sum += 2.0 * tmp;
            }
            for (let i = 2; i < 2 * lw + 1; i++) {
                weights[i] /= sum;
            }
            return weights;
        }
        roundPositions(positions) {
            let cellWidthInMeter = 1.0;
            let cellWidthInTexel = this.floorplanLayer.getModel().pixelPerMeter * cellWidthInMeter;
            let relativeCellWidth = cellWidthInTexel / this.floorplanLayer.getFloorSize().x;
            let relativeCellHeight = cellWidthInTexel / this.floorplanLayer.getFloorSize().y;
            for (let i = 0; i < positions.length; i++) {
                let position = positions[i];
                position.x = Math.floor(position.x / relativeCellWidth) * relativeCellWidth;
                position.y = Math.floor(position.y / relativeCellHeight) * relativeCellHeight;
            }
            return positions;
        }
        clusterPositions(positions) {
            let clusterThresholdInMeter = 1.5;
            let clusterThresholdInTexels = this.floorplanLayer.getModel().pixelPerMeter * clusterThresholdInMeter;
            let relativeClusterThreshold = clusterThresholdInTexels / this.floorplanLayer.getFloorSize().x;
            // this.lastClusterReferencePosition = null;
            for (let i = 0; i < positions.length; i++) {
                if (this.lastClusterReferencePosition) {
                    let distanceToClusterReferencePosition = Vector2_21.Vector2.getLengthOfPoint(Vector2_21.Vector2.subtractPoints(positions[i], this.lastClusterReferencePosition));
                    let newClusterShouldBeCreated = distanceToClusterReferencePosition > relativeClusterThreshold;
                    if (newClusterShouldBeCreated) {
                        this.lastClusterReferencePosition = positions[i];
                    }
                    else {
                        positions[i].x = this.lastClusterReferencePosition.x;
                        positions[i].y = this.lastClusterReferencePosition.y;
                    }
                }
                else {
                    this.lastClusterReferencePosition = positions[i];
                }
            }
            return positions;
        }
        removeDuplicates(positions) {
            let newPositions = new Array();
            if (positions != null && positions.length > 0) {
                newPositions.push(positions[0]);
            }
            for (let i = 1; i < positions.length; i++) {
                if (!((positions[i].x === positions[i - 1].x) && (positions[i].y === positions[i - 1].y))) {
                    newPositions.push(positions[i]);
                }
            }
            return newPositions;
        }
        updateAccuracyRangeInModel(accuracyInCm) {
            if (this.device.getModel().positionEstimate != null) {
                this.device.getModel().positionEstimate.accuracy = accuracyInCm;
            }
            if (this.deviceAccuracyRange !== null) {
                this.deviceAccuracyRange.updateAccuracyRange(this.device.getModel());
            }
        }
        moveDeviceToLastSubpathPosition(subpaths) {
            // Move the device to the corresponding position.
            let lastSubpath = subpaths[subpaths.length - 1];
            let lastKnownX = lastSubpath[lastSubpath.length - 1].x;
            let lastKnownY = lastSubpath[lastSubpath.length - 1].y;
            let floorSizeX = this.floorplanLayer.getFloorSize().x;
            let floorSizeY = this.floorplanLayer.getFloorSize().y;
            let relativeX = lastKnownX / floorSizeX;
            let relativeY = lastKnownY / floorSizeY;
            this.moveDeviceToPosition(relativeX, relativeY);
        }
        moveDeviceToPosition(x, y) {
            if (this.device.getModel().positionEstimate != null) {
                this.device.getModel().positionEstimate.x = x;
                this.device.getModel().positionEstimate.y = y;
            }
            this.device.getModel().x = x;
            this.device.getModel().y = y;
        }
        updateMeasurementTimeInModel(measurementTimeSec) {
            if (this.device.getModel().positionEstimate != null) {
                this.device.getModel().positionEstimate.measurementTimeSec = measurementTimeSec;
            }
        }
        // Animation
        onAnimationModeEnabled(animationModeEnabled) {
            this.animationModeEnabled = animationModeEnabled;
            if (!this.animationModeEnabled) {
                this.progress = 1.0;
                this.invalidated = true;
            }
        }
        onUpdateAnimationFrame(timeInSec) {
            this.progress = this.getProgressForTime(timeInSec);
            this.invalidated = true;
        }
        getProgressForTime(timeInSec) {
            let startTimeSec = this.model.startTimeSec;
            let endTimeSec = this.model.endTimeSec;
            // Constrain to borders
            timeInSec = Math.max(startTimeSec, Math.min(endTimeSec, timeInSec));
            // Get progress
            let progress = (timeInSec - startTimeSec) / (endTimeSec - startTimeSec);
            return progress;
        }
        // Updating
        update(lastFrametime) {
            super.update(lastFrametime);
            this.updateScale();
            this.invalidated = false;
        }
        updateScale() {
            let scaleFactor = this.device.getView().scale.x;
            // We rebuild the polyline path only on significant
            // scale changes to save performance.
            let scaleChange = Math.max(this.lastScaleFactor, scaleFactor) / Math.min(this.lastScaleFactor, scaleFactor) - 1.0;
            let minScaleChangeToTriggerRedraw = 2.0;
            if (scaleChange > minScaleChangeToTriggerRedraw || this.invalidated) {
                this.lastScaleFactor = scaleFactor;
                this.rescalePathView(scaleFactor);
            }
        }
        rescalePathView(scaleFactor) {
            let targetLineWidth = 2;
            let lineWidth = targetLineWidth * scaleFactor;
            this.redrawPathViewWithLineWidthAndProgress(lineWidth, this.progress);
        }
        // Updating model
        updateModel(model) {
            this.model = model;
            this.invalidated = true;
        }
        // Getters and setters
        getDevice() {
            return this.device;
        }
        setPathPostprocessingEnabled(enabled) {
            this.pathPostProcessingEnabled = enabled;
            this.invalidated = true;
        }
        isPathPostprocessingEnabled() {
            return this.pathPostProcessingEnabled;
        }
        getModel() {
            return this.model;
        }
    }
    exports.DeviceTrack = DeviceTrack;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceAccuracyRangeLayer/DeviceAccuracyRangeLayer", ["require", "exports", "src/app/relution/view/world/RelutionMapAttributeObjectLayer", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/AssetMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceAccuracyRangeLayer/DeviceAccuracyRange"], function (require, exports, RelutionMapAttributeObjectLayer_3, AssetMapObject_2, DeviceAccuracyRange_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeviceAccuracyRangeLayer = void 0;
    class DeviceAccuracyRangeLayer extends RelutionMapAttributeObjectLayer_3.RelutionMapAttributeObjectLayer {
        // Initialization
        constructor(environment, deviceLayer) {
            super(environment, deviceLayer);
        }
        // Device attribute object creation
        // @Override
        createAttributeObjectsForObject(device) {
            let ranges = [];
            if (device instanceof AssetMapObject_2.AssetMapObject) {
                let asset = device;
                let range = new DeviceAccuracyRange_1.DeviceAccuracyRange(this.getEnvironment(), this.getFloorplanLayer(), asset);
                ranges.push(range);
            }
            return ranges;
        }
    }
    exports.DeviceAccuracyRangeLayer = DeviceAccuracyRangeLayer;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceTrackLayer/DeviceTrackLayer", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceTrackLayer/DeviceTrack", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer"], function (require, exports, DeviceTrack_1, FloorplanRelatedLayer_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeviceTrackLayer = void 0;
    class DeviceTrackLayer extends FloorplanRelatedLayer_5.FloorplanRelatedLayer {
        // Initialization
        constructor(config, environment, deviceLayer, deviceAccuracyRangeLayer) {
            super(environment, deviceLayer.getFloorplanLayer());
            // Model
            this.positionEstimateModels = new Array();
            // View
            this.tracks = new Map();
            this.trackLayerConfig = config;
            this.deviceLayer = deviceLayer;
            this.deviceAccuracyRangeLayer = deviceAccuracyRangeLayer;
            this.deviceLayer.addObserver(this);
        }
        // Event-Handling: Beacon-Layer
        // @Override
        onObjectsLoaded(devices) {
            this.updatePositionEstimates(this.positionEstimateModels);
        }
        // @Override
        onObjectsUnloaded(devices) {
            this.updatePositionEstimates(this.positionEstimateModels);
        }
        // @Override
        onObjectMovedToMap(beacon) {
            this.updateDeviceVisibility(beacon);
        }
        // @Override
        onObjectMovedToStock(beacon) {
            this.updateDeviceVisibility(beacon);
        }
        // Loading model
        updatePositionEstimates(positionEstimateModels) {
            this.positionEstimateModels = positionEstimateModels;
            let devices = this.deviceLayer.getAllDevices();
            if (devices != null) {
                let addingPositionEstimateModels = this.getAddingPositionEstimateModels(positionEstimateModels);
                let updatingPositionEstimateModels = this.getUpdatingPositionEstimateModels(positionEstimateModels);
                let removingTracks = this.getRemovingPositionEstimateModels(positionEstimateModels);
                this.addTracksForModels(addingPositionEstimateModels);
                this.updateTracksForModels(updatingPositionEstimateModels);
                this.removeTracks(removingTracks);
            }
        }
        updatePositionEstimate(positionEstimateModel) {
            this.updatePositionEstimateModels(positionEstimateModel);
            let devices = this.deviceLayer.getAllDevices();
            if (devices != null) {
                const updatedModels = [positionEstimateModel];
                let addingPositionEstimateModels = this.getAddingPositionEstimateModels(updatedModels);
                let updatingPositionEstimateModels = this.getUpdatingPositionEstimateModels(updatedModels);
                this.addTracksForModels(addingPositionEstimateModels);
                this.updateTracksForModels(updatingPositionEstimateModels);
            }
        }
        updatePositionEstimateModels(positionEstimateModel) {
            let index = this.getIndexOfPositionEstimateModel(positionEstimateModel.deviceUuid);
            if (index != -1) {
                this.positionEstimateModels[index] = positionEstimateModel;
            }
            else {
                this.positionEstimateModels.push(positionEstimateModel);
            }
        }
        getIndexOfPositionEstimateModel(deviceUuid) {
            if (!this.positionEstimateModels || this.positionEstimateModels.length == 0) {
                return -1;
            }
            for (let i = 0; i < this.positionEstimateModels.length; i++) {
                let positionEstimateModel = this.positionEstimateModels[i];
                if (positionEstimateModel.deviceUuid === deviceUuid) {
                    return i;
                }
            }
            return -1;
        }
        getAddingPositionEstimateModels(positionEstimateModels) {
            let addingModels = [];
            for (let i = 0; i < positionEstimateModels.length; i++) {
                let positionEstimateModel = positionEstimateModels[i];
                if (!this.existsTrackForModel(positionEstimateModel)) {
                    // Do add if device does not exist (yet).
                    if (this.deviceLayer.getDeviceWithUuid(positionEstimateModel.deviceUuid) != null) {
                        addingModels.push(positionEstimateModel);
                    }
                }
            }
            return addingModels;
        }
        getUpdatingPositionEstimateModels(positionEstimateModels) {
            let updatingModels = [];
            for (let i = 0; i < positionEstimateModels.length; i++) {
                let positionEstimateModel = positionEstimateModels[i];
                if (this.existsTrackForModel(positionEstimateModel)) {
                    // Do not update, if device does not exist anymore.
                    if (this.deviceLayer.getDeviceWithUuid(positionEstimateModel.deviceUuid) != null) {
                        updatingModels.push(positionEstimateModel);
                    }
                }
            }
            return updatingModels;
        }
        getRemovingPositionEstimateModels(positionEstimateModels) {
            let removingTracks = [];
            this.tracks.forEach((track, deviceUuid) => {
                // Remove track, if position estimate model or device does not exist anymore.
                if ((!this.existsModelForTrack(track, positionEstimateModels))
                    || (this.deviceLayer.getDeviceWithUuid(deviceUuid) == null)) {
                    removingTracks.push(track);
                }
            });
            return removingTracks;
        }
        existsTrackForModel(positionEstimateModel) {
            let track = this.getTrackForModel(positionEstimateModel);
            return track != null;
        }
        getTrackForModel(positionEstimateModel) {
            return this.tracks.get(positionEstimateModel.deviceUuid) || null;
        }
        existsModelForTrack(deviceTrack, positionEstimateModels) {
            for (let i = 0; i < positionEstimateModels.length; i++) {
                let positionEstimateModel = positionEstimateModels[i];
                if (deviceTrack.getModel().deviceUuid === positionEstimateModel.deviceUuid) {
                    return true;
                }
            }
            return false;
        }
        updateTracksForModels(updatingPositionEstimateModels) {
            for (let i = 0; i < updatingPositionEstimateModels.length; i++) {
                let model = updatingPositionEstimateModels[i];
                let track = this.getTrackForModel(model);
                track.updateModel(model);
            }
        }
        removeTracks(removingTracks) {
            for (let i = 0; i < removingTracks.length; i++) {
                let track = removingTracks[i];
                this.removeTrack(track);
            }
        }
        addTracksForModels(positionEstimateModels) {
            for (let i = 0; i < positionEstimateModels.length; i++) {
                let positionEstimateModel = positionEstimateModels[i];
                let deviceUuid = positionEstimateModel.deviceUuid;
                let device = this.deviceLayer.getDeviceWithUuid(deviceUuid);
                if (device != null) {
                    this.addTrackForModel(positionEstimateModel, device);
                }
            }
        }
        addTrackForModel(positionEstimateModel, device) {
            let deviceAccuracyRanges = this.deviceAccuracyRangeLayer.getAttributeObjectsForObject(device);
            let deviceAccuracyRange = null;
            if (deviceAccuracyRanges.length !== 0) {
                deviceAccuracyRange = deviceAccuracyRanges[0];
            }
            let track = new DeviceTrack_1.DeviceTrack(this.getEnvironment(), this.getFloorplanLayer(), positionEstimateModel, device, deviceAccuracyRange);
            track.setPathPostprocessingEnabled(this.trackLayerConfig.pathPostprocessingEnabled);
            this.addChild(track);
            this.tracks.set(device.getModel().uuid, track);
        }
        getTrackOfDevice(device) {
            return this.tracks.get(device.getModel().uuid) || null;
        }
        updateDeviceVisibility(device) {
            let track = this.getTrackOfDevice(device);
            if (track != null) {
                track.getView().visible = device.isOnMap();
            }
        }
        removeTrack(track) {
            this.tracks.delete(track.getDevice().getModel().uuid);
            this.removeChild(track);
            track.destroy();
        }
        // Getters and setters
        setPathPostprocessingEnabled(enabled) {
            this.trackLayerConfig.pathPostprocessingEnabled = enabled;
            this.tracks.forEach((track, deviceUuid) => {
                track.setPathPostprocessingEnabled(enabled);
            });
        }
        isPathPostprocessingEnabled() {
            return this.trackLayerConfig.pathPostprocessingEnabled;
        }
        // @Override
        isEmpty() {
            return !(this.tracks.size > 0) && super.isEmpty();
        }
    }
    exports.DeviceTrackLayer = DeviceTrackLayer;
    (function (DeviceTrackLayer) {
        class Config {
            constructor() {
                /**
                 * True, if the paths shall be clustered and smoothed before rendering.
                 *
                 * Default: false
                 */
                this.pathPostprocessingEnabled = false;
            }
        }
        DeviceTrackLayer.Config = Config;
    })(DeviceTrackLayer = exports.DeviceTrackLayer || (exports.DeviceTrackLayer = {}));
});
define("src/app/relution/view/world/layers/deviceLayers/beaconConnectionsLayer/BeaconConnection", ["require", "exports", "src/engine/math/Vector2", "src/map/utils/DeviceUtils", "src/app/relution/view/world/RelutionMapAttributeObject"], function (require, exports, Vector2_22, DeviceUtils_8, RelutionMapAttributeObject_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BeaconConnection = void 0;
    class BeaconConnection extends RelutionMapAttributeObject_5.RelutionMapAttributeObject {
        // Initialization
        constructor(environment, sourceBeacon, targetBeacon, rssi) {
            super(environment, sourceBeacon, targetBeacon);
            // View: Updating
            this.lastScaleFactor = -1;
            this.lastScaleFactorForTranslation = -1;
            this.invalidated = true;
            this.initModel(sourceBeacon, targetBeacon, rssi);
            this.initView();
        }
        initModel(sourceBeacon, targetBeacon, rssi) {
            this.sourceBeacon = sourceBeacon;
            this.targetBeacon = targetBeacon;
            this.rssi = rssi;
        }
        initView() {
            this.container = this.getEnvironment().renderer.newDisplayObjectContainer();
            this.getView().addChild(this.container);
            this.initLineView();
            this.initRssiView();
            this.updateAppeareance();
        }
        initLineView() {
            this.lineView = this.getEnvironment().renderer.newSpriteObject();
            this.container.addChild(this.lineView);
            this.loadTexture();
            this.setPivot();
            this.drawLineWithLineWidth(0);
        }
        loadTexture() {
            this.lineView.texture = this.getEnvironment().renderer.getTexture("arrow_body");
        }
        setPivot() {
            this.lineView.pivot.x = this.lineView.width / 2;
            this.lineView.pivot.y = this.lineView.height / 2;
        }
        drawLineWithLineWidth(lineWidth) {
            // Precomputation
            let sourceVector = Vector2_22.Vector2.getVector2(this.targetBeacon.getView().position);
            let targetVector = Vector2_22.Vector2.getVector2(this.sourceBeacon.getView().position);
            let differenceVector = Vector2_22.Vector2.subtract(sourceVector, targetVector);
            // Scale
            let width = DeviceUtils_8.DeviceUtils.getPhysicalPixelsFromLogical(lineWidth);
            let distanceBetweenBeacons = differenceVector.getLength();
            this.lineView.scale.x = distanceBetweenBeacons / this.lineView.texture.width;
            this.lineView.scale.y = width / this.lineView.texture.height;
            // Rotation
            let baseVector = new Vector2_22.Vector2(1, 0);
            let rotation = -Vector2_22.Vector2.getAngleBetween(differenceVector, baseVector);
            // Sign
            let crossProduct = Vector2_22.Vector2.crossProduct(baseVector, differenceVector);
            if (crossProduct > 0) {
                this.lineView.rotation = -rotation;
            }
            else {
                this.lineView.rotation = rotation;
            }
            // Position
            let centerVector = Vector2_22.Vector2.add(sourceVector, targetVector).divide(2);
            this.lineView.x = centerVector.getX();
            this.lineView.y = centerVector.getY();
        }
        initRssiView() {
            let textStyle = this.getEnvironment().renderer.newTextStyle();
            textStyle.fontFamily = "Arial";
            textStyle.fontSize = DeviceUtils_8.DeviceUtils.getPhysicalPixelsFromLogical(13);
            textStyle.fill = BeaconConnection.TEXT_COLOR_NORMAL;
            textStyle.align = "center";
            this.rssiView = this.getEnvironment().renderer.newTextObject("" + this.rssi, 1, textStyle);
            this.rssiView.pivot.x = this.rssiView.width / 2;
            this.rssiView.pivot.y = this.rssiView.height / 2;
            this.rssiView.x = (this.sourceBeacon.getView().x + this.targetBeacon.getView().x) / 2;
            this.rssiView.y = (this.sourceBeacon.getView().y + this.targetBeacon.getView().y) / 2 - this.rssiView.height;
            this.container.addChild(this.rssiView);
        }
        // View
        updateAppeareance() {
            if (!this.sourceBeacon.isDeviceStatusGood() || !this.targetBeacon.isDeviceStatusGood()) {
                this.getView().alpha = 0.1;
                this.rssiView.style.fill = BeaconConnection.TEXT_COLOR_DISCONNECTED;
                this.lineView.tint = BeaconConnection.DISCONNECTED_COLOR;
            }
            else if (this.connectionInvalid()) {
                this.getView().alpha = 0.0;
                this.rssiView.style.fill = BeaconConnection.TEXT_COLOR_NORMAL;
                this.lineView.tint = BeaconConnection.NORMAL_COLOR;
            }
            else {
                this.getView().alpha = 1.0;
                this.rssiView.style.fill = BeaconConnection.TEXT_COLOR_NORMAL;
                this.lineView.tint = BeaconConnection.NORMAL_COLOR;
            }
        }
        connectionInvalid() {
            return this.connectionMissing(this.sourceBeacon, this.targetBeacon)
                || this.connectionMissing(this.targetBeacon, this.sourceBeacon);
        }
        connectionMissing(beacon1, beacon2) {
            return beacon1.getModel().connections.filter(connection => {
                return connection.target == beacon2.getModel().nodeId;
            }).length == 0;
        }
        updatePositioning() {
            this.invalidated = true;
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            this.updateScale();
            this.updateRotation();
            this.updateTranslation();
            this.invalidated = false;
        }
        updateScale() {
            let sourceBeacon = this.getSourceBeacon();
            let scaleFactor = sourceBeacon.getView().scale.x;
            if (this.lastScaleFactor !== scaleFactor || this.invalidated) {
                this.lastScaleFactor = scaleFactor;
                this.rescaleLine(scaleFactor);
                this.rescaleRssiView(scaleFactor);
            }
        }
        rescaleLine(scaleFactor) {
            let referenceLineWidth = 1.5; // In pixels
            let lineWidth = referenceLineWidth * scaleFactor;
            // this.lineView.scale.y = (1.0/this.lineView.height) * lineWidth;
            this.drawLineWithLineWidth(lineWidth);
        }
        rescaleRssiView(scaleFactor) {
            this.rssiView.scale.x = scaleFactor;
            this.rssiView.scale.y = scaleFactor;
        }
        updateRotation() {
            let camera = this.getScene().getCamera();
            let orientation = camera.getRotation();
            if (this.rssiView.rotation !== orientation || this.invalidated) {
                this.rssiView.rotation = orientation;
            }
        }
        updateTranslation() {
            let camera = this.getScene().getCamera();
            let scaleFactor = camera.getScaleX();
            if (this.lastScaleFactorForTranslation !== scaleFactor || this.invalidated) {
                this.lastScaleFactorForTranslation = scaleFactor;
                let sourceX = this.sourceBeacon.getView().x;
                let sourceY = this.sourceBeacon.getView().y;
                let targetX = this.targetBeacon.getView().x;
                let targetY = this.targetBeacon.getView().y;
                let centerX = sourceX + (targetX - sourceX) * 0.5;
                let centerY = sourceY + (targetY - sourceY) * 0.5;
                this.rssiView.x = centerX - (this.rssiView.width / 2);
                this.rssiView.y = centerY - (this.rssiView.height / 2);
            }
        }
        // Destruction
        // @Override
        destroy() {
            super.destroy();
            this.lineView.destroy();
            this.rssiView.destroy(false);
        }
        // Model Event-handling
        // @Override
        xChanged(deviceModel) {
            this.updatePositioning();
        }
        // @Override
        yChanged(deviceModel) {
            this.updatePositioning();
        }
        // @Override
        lastConnectionDateChanged(deviceMode) {
            this.updateAppeareance();
        }
        // Getters and setters
        getSourceBeacon() {
            return this.sourceBeacon;
        }
        getTargetBeacon() {
            return this.targetBeacon;
        }
        getRssi() {
            return this.rssi;
        }
        setRssi(rssi) {
            this.rssi = rssi;
        }
    }
    exports.BeaconConnection = BeaconConnection;
    // Constants
    BeaconConnection.NORMAL_COLOR = 0x566904;
    BeaconConnection.DISCONNECTED_COLOR = 0x000000;
    // View: Colors
    BeaconConnection.LINE_COLOR = 0x566904;
    BeaconConnection.TEXT_COLOR_NORMAL = 0x374203;
    BeaconConnection.TEXT_COLOR_DISCONNECTED = 0x000000;
});
define("src/app/relution/view/world/layers/deviceLayers/beaconConnectionsLayer/BeaconConnectionsLayer", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/beaconConnectionsLayer/BeaconConnection", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/BeaconMapObject", "src/app/relution/view/world/RelutionMapAttributeObjectLayer"], function (require, exports, BeaconConnection_1, BeaconMapObject_5, RelutionMapAttributeObjectLayer_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BeaconConnectionsLayer = void 0;
    class BeaconConnectionsLayer extends RelutionMapAttributeObjectLayer_4.RelutionMapAttributeObjectLayer {
        // Initialization
        constructor(environment, deviceLayer) {
            super(environment, deviceLayer);
            this.deviceLayer = deviceLayer;
        }
        // Device attribute object creation
        // @Override
        createAttributeObjectsForObject(device) {
            let objects = new Array();
            if (device instanceof BeaconMapObject_5.BeaconMapObject) {
                let beacon = device;
                let beaconModel = beacon.getModel();
                let connections = beaconModel.connections;
                if (connections) {
                    for (let j = 0; j < connections.length; j++) {
                        let connection = connections[j];
                        let rssi = connection.rssi;
                        let targetNodeId = connection.target;
                        if (targetNodeId != 0) {
                            this.deviceLayer.getAllBeacons()
                                .filter(neighbor => neighbor.getModel().siteUuid === beacon.getModel().siteUuid)
                                .filter(neighbor => neighbor.getModel().nodeId === targetNodeId)
                                .forEach(neighbor => {
                                if (neighbor != null) {
                                    if (this.connectionExists(neighbor, beacon)) {
                                        let existingConnection = this.getConnection(neighbor, beacon);
                                        let currentRssi = existingConnection.getRssi();
                                        let meanRssi = (currentRssi + rssi) / 2;
                                        existingConnection.setRssi(meanRssi);
                                    }
                                    else {
                                        let newConnection = new BeaconConnection_1.BeaconConnection(this.getEnvironment(), beacon, neighbor, rssi);
                                        objects.push(newConnection);
                                    }
                                }
                            });
                        }
                    }
                }
            }
            return objects;
        }
        connectionExists(sourceBeacon, targetBeacon) {
            let connection = this.getConnection(sourceBeacon, targetBeacon);
            return connection != null;
        }
        getConnection(sourceBeacon, targetBeacon) {
            for (let i = 0; i < this.getAttributeObjects().length; i++) {
                let connection = this.getAttributeObjects()[i];
                if (connection.getSourceBeacon() === sourceBeacon
                    && connection.getTargetBeacon() === targetBeacon) {
                    return connection;
                }
            }
            return null;
        }
    }
    exports.BeaconConnectionsLayer = BeaconConnectionsLayer;
});
define("src/app/relution/model/usercount/UserCountHeatmapDeviceModel", ["require", "exports", "src/app/relution/model/Model"], function (require, exports, Model_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UserCountHeatmapDeviceModel = void 0;
    class UserCountHeatmapDeviceModel extends Model_5.Model {
        // Getters and setters
        get deviceUuid() {
            return this._deviceUuid;
        }
        set deviceUuid(deviceUuid) {
            this._deviceUuid = deviceUuid;
            this.notifyObservers("deviceUuid");
        }
        get totalPacketsCount() {
            return this._totalPacketsCount;
        }
        set totalPacketsCount(totalPacketCount) {
            this._totalPacketsCount = totalPacketCount;
            this.notifyObservers("totalPacketsCount");
        }
        get nodeId() {
            return this._nodeId;
        }
        set nodeId(nodeId) {
            this._nodeId = nodeId;
            this.notifyObservers("nodeId");
        }
        get totalPackets() {
            return this._totalPackets;
        }
        set totalPackets(totalPackets) {
            this._totalPackets = totalPackets;
            this.notifyObservers("totalPackets");
        }
        get totalRssi() {
            return this._totalRssi;
        }
        set totalRssi(totalRssi) {
            this._totalRssi = totalRssi;
            this.notifyObservers("totalRssi");
        }
        // Derived attributes
        getRandomSeed() {
            return this._deviceUuid.valueOf() + this._totalPacketsCount + this._totalPackets + this._totalRssi;
        }
    }
    __decorate([
        (0, Model_5.ModelProperty)()
    ], UserCountHeatmapDeviceModel.prototype, "_deviceUuid", void 0);
    __decorate([
        (0, Model_5.ModelProperty)()
    ], UserCountHeatmapDeviceModel.prototype, "_totalPacketsCount", void 0);
    __decorate([
        (0, Model_5.ModelProperty)()
    ], UserCountHeatmapDeviceModel.prototype, "_nodeId", void 0);
    __decorate([
        (0, Model_5.ModelProperty)()
    ], UserCountHeatmapDeviceModel.prototype, "_totalPackets", void 0);
    __decorate([
        (0, Model_5.ModelProperty)()
    ], UserCountHeatmapDeviceModel.prototype, "_totalRssi", void 0);
    exports.UserCountHeatmapDeviceModel = UserCountHeatmapDeviceModel;
});
define("src/app/relution/model/usercount/UserCountHeatmapModel", ["require", "exports", "src/app/relution/model/Model", "src/app/relution/model/RelutionMapModel", "src/app/relution/model/usercount/UserCountHeatmapDeviceModel"], function (require, exports, Model_6, RelutionMapModel_4, UserCountHeatmapDeviceModel_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UserCountHeatmapModel = void 0;
    class UserCountHeatmapModel extends RelutionMapModel_4.RelutionMapModel {
        // Getters and setters
        set startTimeSec(startTimeSec) {
            this._startTimeSec = startTimeSec;
            this.notifyObservers("startTimeSec");
        }
        get startTimeSec() {
            return this._startTimeSec;
        }
        set endTimeSec(endTimeSec) {
            this._endTimeSec = endTimeSec;
            this.notifyObservers("endTimeSec");
        }
        get endTimeSec() {
            return this._endTimeSec;
        }
        set data(data) {
            this._data = data;
            this.notifyObservers("data");
        }
        get data() {
            return this._data;
        }
        // Derived attributes
        // Merges all heatmap data of an array to one object
        static createMergedHeatmapModel(heatmapData) {
            // start time
            let newStartTimeSec = this.getMergedStartTimeSec(heatmapData);
            // end time
            let newEndTimeSec = this.getMergedEndTimeSec(heatmapData);
            // data
            let newData = this.getMergedData(heatmapData);
            // result
            let newMergedHeatmapData = new UserCountHeatmapModel();
            newMergedHeatmapData._startTimeSec = newStartTimeSec;
            newMergedHeatmapData._endTimeSec = newEndTimeSec;
            newMergedHeatmapData._data = newData;
            return newMergedHeatmapData;
        }
        static getMergedStartTimeSec(heatmapData) {
            let minStartTime = Number.MAX_VALUE;
            for (let i = 0; i < heatmapData.length; i++) {
                let heatmapModel = heatmapData[i];
                if (heatmapModel.startTimeSec < minStartTime) {
                    minStartTime = heatmapModel.startTimeSec;
                }
            }
            return minStartTime;
        }
        static getMergedEndTimeSec(heatmapData) {
            let maxEndTime = -Number.MAX_VALUE;
            for (let i = 0; i < heatmapData.length; i++) {
                let heatmapModel = heatmapData[i];
                if (heatmapModel.endTimeSec > maxEndTime) {
                    maxEndTime = heatmapModel.endTimeSec;
                }
            }
            return maxEndTime;
        }
        static getMergedData(heatmapData) {
            // Get device uuids
            let deviceUuids = this.getMergedDeviceUuids(heatmapData);
            let newData = new Array();
            for (let i = 0; i < deviceUuids.length; i++) {
                // Result values
                let deviceUuid = deviceUuids[i];
                let totalPacketsCount = 0;
                let nodeId = 449;
                let totalPackets = 0;
                let totalRssi = 0;
                // Summing up values
                let numOccurencies = 0;
                for (let j = 0; j < heatmapData.length; j++) {
                    let heatmapModel = heatmapData[j];
                    let currentData = heatmapModel._data;
                    for (let k = 0; k < currentData.length; k++) {
                        let currentDevice = currentData[k];
                        if (currentDevice.deviceUuid === deviceUuid) {
                            totalPacketsCount += currentDevice.totalPacketsCount;
                            totalPackets += currentDevice.totalPackets;
                            totalRssi += currentDevice.totalRssi;
                            numOccurencies++;
                        }
                    }
                }
                if (numOccurencies !== 0) {
                    // Averaging
                    totalPacketsCount /= numOccurencies;
                    totalPackets /= numOccurencies;
                    totalRssi /= numOccurencies;
                    // Create merged heatmap device model
                    let mergedHeatmapDeviceModel = new UserCountHeatmapDeviceModel_1.UserCountHeatmapDeviceModel();
                    mergedHeatmapDeviceModel.deviceUuid = deviceUuid;
                    mergedHeatmapDeviceModel.totalPacketsCount = totalPacketsCount;
                    mergedHeatmapDeviceModel.nodeId = nodeId;
                    mergedHeatmapDeviceModel.totalPackets = totalPackets;
                    mergedHeatmapDeviceModel.totalRssi = totalRssi;
                    // Add it to the list
                    newData.push(mergedHeatmapDeviceModel);
                }
            }
            return newData;
        }
        static getMergedDeviceUuids(heatmapData) {
            let deviceUuids = new Array();
            for (let i = 0; i < heatmapData.length; i++) {
                let heatmapModel = heatmapData[i];
                let currentDeviceUuids = heatmapModel.getDeviceUuids();
                for (let j = 0; j < currentDeviceUuids.length; j++) {
                    let currentDeviceUuid = currentDeviceUuids[j];
                    // Remove duplicates
                    let index = deviceUuids.indexOf(currentDeviceUuid);
                    if (index < 0) {
                        deviceUuids.push(currentDeviceUuid);
                    }
                }
            }
            return deviceUuids;
        }
        getDeviceUuids() {
            let deviceUuids = new Array();
            for (let i = 0; i < this._data.length; i++) {
                let heatmapDeviceModel = this._data[i];
                deviceUuids.push(heatmapDeviceModel.deviceUuid);
            }
            return deviceUuids;
        }
    }
    __decorate([
        (0, Model_6.ModelProperty)()
    ], UserCountHeatmapModel.prototype, "_startTimeSec", void 0);
    __decorate([
        (0, Model_6.ModelProperty)()
    ], UserCountHeatmapModel.prototype, "_endTimeSec", void 0);
    __decorate([
        (0, Model_6.ModelProperty)({ clazz: UserCountHeatmapDeviceModel_1.UserCountHeatmapDeviceModel })
    ], UserCountHeatmapModel.prototype, "_data", void 0);
    exports.UserCountHeatmapModel = UserCountHeatmapModel;
});
define("src/app/relution/model/geofence/GeofenceModel", ["require", "exports", "src/app/relution/model/Model", "src/app/relution/model/RelutionMapObjectModel"], function (require, exports, Model_7, RelutionMapObjectModel_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PolygonGeofenceModel = exports.CircleGeofenceModel = exports.RectangleGeofenceModel = exports.GeofenceModel = void 0;
    let GeofenceModel = class GeofenceModel extends RelutionMapObjectModel_3.RelutionMapObjectModel {
        // Getters and setters
        get name() {
            return this._name;
        }
        set name(name) {
            this._name = name;
            this.notifyObservers("name");
        }
        get description() {
            return this._description;
        }
        set description(description) {
            this._description = description;
            this.notifyObservers("description");
        }
        get site() {
            return this._site;
        }
        set site(site) {
            this._site = site;
            this.notifyObservers("site");
        }
        get shape() {
            return this._shape;
        }
        set shape(shape) {
            this._shape = shape;
            this.notifyObservers("shape");
        }
        set type(shape) {
            this._shape = shape;
            this.notifyObservers("shape");
        }
        get timeThreshold() {
            return this._timeThreshold;
        }
        set timeThreshold(timeThreshold) {
            this._timeThreshold = timeThreshold;
            this.notifyObservers("timeThreshold");
        }
        get accuracyThreshold() {
            return this._accuracyThreshold;
        }
        set accuracyThreshold(accuracyThreshold) {
            this._accuracyThreshold = accuracyThreshold;
            this.notifyObservers("accuracyThreshold");
        }
    };
    __decorate([
        (0, Model_7.ModelProperty)()
    ], GeofenceModel.prototype, "_name", void 0);
    __decorate([
        (0, Model_7.ModelProperty)()
    ], GeofenceModel.prototype, "_description", void 0);
    __decorate([
        (0, Model_7.ModelProperty)()
    ], GeofenceModel.prototype, "_site", void 0);
    __decorate([
        (0, Model_7.ModelProperty)()
    ], GeofenceModel.prototype, "_shape", void 0);
    __decorate([
        (0, Model_7.ModelProperty)()
    ], GeofenceModel.prototype, "_timeThreshold", void 0);
    __decorate([
        (0, Model_7.ModelProperty)()
    ], GeofenceModel.prototype, "_accuracyThreshold", void 0);
    GeofenceModel = __decorate([
        (0, Model_7.ModelTypeInfo)("shape"),
        (0, Model_7.ModelSubTypes)(new Model_7.ModelType(() => RectangleGeofenceModel, "RECTANGLE"), new Model_7.ModelType(() => CircleGeofenceModel, "CIRCLE"), new Model_7.ModelType(() => PolygonGeofenceModel, "POLYGON"))
    ], GeofenceModel);
    exports.GeofenceModel = GeofenceModel;
    class RectangleGeofenceModel extends GeofenceModel {
        get min() {
            return this._min;
        }
        set min(min) {
            this._min = min;
            this.notifyObservers("min");
        }
        get max() {
            return this._max;
        }
        set max(max) {
            this._max = max;
            this.notifyObservers("max");
        }
    }
    __decorate([
        (0, Model_7.ModelProperty)()
    ], RectangleGeofenceModel.prototype, "_min", void 0);
    __decorate([
        (0, Model_7.ModelProperty)()
    ], RectangleGeofenceModel.prototype, "_max", void 0);
    exports.RectangleGeofenceModel = RectangleGeofenceModel;
    // tslint:disable-next-line:max-classes-per-file
    class CircleGeofenceModel extends GeofenceModel {
        get center() {
            return this._center;
        }
        set center(center) {
            this._center = center;
            this.notifyObservers("center");
        }
        get radius() {
            return this._radius;
        }
        set radius(radius) {
            this._radius = radius;
        }
    }
    __decorate([
        (0, Model_7.ModelProperty)()
    ], CircleGeofenceModel.prototype, "_center", void 0);
    __decorate([
        (0, Model_7.ModelProperty)()
    ], CircleGeofenceModel.prototype, "_radius", void 0);
    exports.CircleGeofenceModel = CircleGeofenceModel;
    // tslint:disable-next-line:max-classes-per-file
    class PolygonGeofenceModel extends GeofenceModel {
        get points() {
            return this._points;
        }
        set points(points) {
            this._points = points;
        }
    }
    __decorate([
        (0, Model_7.ModelProperty)()
    ], PolygonGeofenceModel.prototype, "_points", void 0);
    exports.PolygonGeofenceModel = PolygonGeofenceModel;
});
define("src/app/relution/model/geofence/GeofenceStateModel", ["require", "exports", "src/app/relution/model/Model", "src/app/relution/model/RelutionMapModel"], function (require, exports, Model_8, RelutionMapModel_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GeofenceStateModel = void 0;
    class GeofenceStateModel extends RelutionMapModel_5.RelutionMapModel {
        constructor() {
            super(...arguments);
            this._geofenceUuid = null;
            this._deviceUuid = "";
            this._state = "LEFT";
        }
        // Getters and setters
        set geofenceUuid(geofenceUuid) {
            this._geofenceUuid = geofenceUuid;
        }
        get geofenceUuid() {
            return this._geofenceUuid;
        }
        set deviceUuid(deviceUuid) {
            this._deviceUuid = deviceUuid;
        }
        get deviceUuid() {
            return this._deviceUuid;
        }
        set state(state) {
            this._state = state;
        }
        get state() {
            return this._state;
        }
    }
    __decorate([
        (0, Model_8.ModelProperty)()
    ], GeofenceStateModel.prototype, "_geofenceUuid", void 0);
    __decorate([
        (0, Model_8.ModelProperty)()
    ], GeofenceStateModel.prototype, "_deviceUuid", void 0);
    __decorate([
        (0, Model_8.ModelProperty)()
    ], GeofenceStateModel.prototype, "_state", void 0);
    exports.GeofenceStateModel = GeofenceStateModel;
});
define("src/app/relution/utils/ColorUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColorUtils = void 0;
    class ColorUtils {
        // see <https://graphicdesign.stackexchange.com/questions/98349/how-to-get-color-percentage-formula-used-in-adobe-xd>
        static transparentColor(color, alpha) {
            // decomposition
            let str = ('00000' + color.toString(16)).slice(-6);
            let r = parseInt(str.substring(0, 2), 16);
            let g = parseInt(str.substring(2, 4), 16);
            let b = parseInt(str.substring(4, 6), 16);
            // blending
            const beta = 1 - alpha;
            r += (255 - r) * beta;
            g += (255 - g) * beta;
            b += (255 - b) * beta;
            // recomposition
            r = Math.min(Math.round(r), 255);
            g = Math.min(Math.round(g), 255);
            b = Math.min(Math.round(b), 255);
            return ((r * 256) + g) * 256 + b;
        }
    }
    exports.ColorUtils = ColorUtils;
});
define("src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/GeofenceMapObject", ["require", "exports", "src/app/relution/view/world/RelutionMapObject", "src/map/utils/DateUtils", "src/app/relution/utils/ColorUtils"], function (require, exports, RelutionMapObject_8, DateUtils_2, ColorUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GeofenceMapObject = void 0;
    class GeofenceMapObject extends RelutionMapObject_8.RelutionMapObject {
        // Construction
        constructor(config, environment, floorplanLayer, model) {
            super(config, environment, floorplanLayer, model);
            // State model
            this.stateModel = null;
            // State
            this.invalidated = true;
            this.lastScaleFactor = -1;
        }
        // Model
        updateStateModel(model) {
            if (this.stateModel === null || (this.stateModel !== null && this.stateModel.state !== model.state)) {
                this.stateModel = model;
                this.redraw();
            }
        }
        getStateModel() {
            return this.stateModel;
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            let scaleFactor = 1.0;
            if (this.getScene() != null) {
                let camera = this.getScene().getCamera();
                scaleFactor = camera.getScaleX();
            }
            if (this.lastScaleFactor !== scaleFactor || this.invalidated) {
                this.lastScaleFactor = scaleFactor;
                this.invalidated = false;
                this.redraw();
            }
        }
        // Model
        // @Override
        getModel() {
            return super.getModel();
        }
        // Name
        // @Override
        getName() {
            return this.getModel().name;
        }
        // Popup info
        // @Override
        getPopupInfo() {
            let content;
            // General geofence information
            content = this.getLocalizedStringFor("popup_geofence_name") + ": "
                + this.getModel().name;
            // Thresholds
            content += "\n";
            content += this.getLocalizedStringFor("popup_geofence_time_threshold") + ": "
                + this.getFormattedTimeDifference(this.getModel().timeThreshold);
            content += "\n";
            content += this.getLocalizedStringFor("popup_geofence_accuracy_threshold") + ": "
                + (this.getModel().accuracyThreshold / 100).toFixed(1) + " m";
            return content;
        }
        getFormattedTimeDifference(timeDiffInMs) {
            let timeDiffArray = DateUtils_2.DateUtils.getFormattedTimeDifference(timeDiffInMs);
            let interval = timeDiffArray[0];
            let intervalType = timeDiffArray[1];
            let timeDiffString = ""
                + interval + " " + this.getLocalizedStringFor("popup_time_unit_" + intervalType);
            return timeDiffString;
        }
    }
    exports.GeofenceMapObject = GeofenceMapObject;
    // Configuration: Alpha
    GeofenceMapObject.DEFAULT_ALPHA = 0.5;
    // Configuration: Shape
    GeofenceMapObject.ENTERED_SHAPE_COLOR = ColorUtils_1.ColorUtils.transparentColor(0x00ACE9, GeofenceMapObject.DEFAULT_ALPHA);
    GeofenceMapObject.LEFT_SHAPE_COLOR = ColorUtils_1.ColorUtils.transparentColor(0x00ACE9, GeofenceMapObject.DEFAULT_ALPHA);
    GeofenceMapObject.UNKNOWN_SHAPE_COLOR = ColorUtils_1.ColorUtils.transparentColor(0x00ACE9, GeofenceMapObject.DEFAULT_ALPHA);
    // Configuration: Border
    GeofenceMapObject.DEFAULT_BORDER_COLOR = 0x000000;
    GeofenceMapObject.SELECTED_BORDER_COLOR = 0x000000;
    GeofenceMapObject.MOUSE_OVER_BORDER_COLOR = 0x000000;
    GeofenceMapObject.DEFAULT_BORDER_WIDTH_PX = 3;
    GeofenceMapObject.SELECTED_BORDER_WIDTH_PX = 5;
    GeofenceMapObject.MOUSE_OVER_BORDER_WIDTH_PX = 5;
    // Configuration: Edit points
    GeofenceMapObject.EDIT_POINT_RADIUS_IN_PX = 4;
    GeofenceMapObject.EDITABLE_POINT_TOLERANCE_IN_PX = 6;
    // Configuration: Length text
    GeofenceMapObject.TEXT_PADDING_PX = 5;
});
define("src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/geofences/RectangleGeofenceMapObject", ["require", "exports", "src/engine/math/Vector2", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/GeofenceMapObject", "src/app/relution/view/world/RelutionMapObject", "src/app/relution/model/geofence/GeofenceModel", "src/map/utils/DeviceUtils", "src/engine/general/AABB", "src/engine/utils/IntersectionUtils"], function (require, exports, Vector2_23, GeofenceMapObject_1, RelutionMapObject_9, GeofenceModel_1, DeviceUtils_9, AABB_6, IntersectionUtils_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RectangleGeofenceMapObject = void 0;
    let RectangleGeofenceMapObject = class RectangleGeofenceMapObject extends GeofenceMapObject_1.GeofenceMapObject {
        // Construction
        constructor(config, environment, floorplanLayer, model) {
            super(config, environment, floorplanLayer, model);
            // Editing:
            this.numberOfEditingPoints = 4;
            this.editing = true;
            this.editingMinX = false;
            this.editingMinY = false;
            this.editingMaxX = false;
            this.editingMaxY = false;
            this.editingPoints = Array();
            this.lengthTexts = new Array();
            // Movement: Given in rectangle local coordinates
            this.movingPointInLocalCoords = null;
            this.initRectangleModel();
            this.initRectangle();
            this.initEditingPoints();
            this.initLengthTexts();
        }
        initRectangleModel() {
            this.constrainRectangleModel();
        }
        initRectangle() {
            this.rectangle = this.getEnvironment().renderer.newGraphicsObject();
            this.getView().addChild(this.rectangle);
            this.rectangle.alpha = GeofenceMapObject_1.GeofenceMapObject.DEFAULT_ALPHA;
        }
        initEditingPoints() {
            for (let i = 0; i < this.numberOfEditingPoints; i++) {
                let editingPoint = this.getEnvironment().renderer.newGraphicsObject();
                editingPoint.clear();
                editingPoint.beginFill(GeofenceMapObject_1.GeofenceMapObject.MOUSE_OVER_BORDER_COLOR);
                editingPoint.drawCircle(0, 0, 1);
                editingPoint.endFill();
                this.editingPoints.push(editingPoint);
                this.getView().addChild(editingPoint);
            }
        }
        initLengthTexts() {
            let fontSize = DeviceUtils_9.DeviceUtils.getPhysicalPixelsFromLogical(12);
            let textStyle = this.getEnvironment().renderer.newTextStyle();
            textStyle.fill = GeofenceMapObject_1.GeofenceMapObject.MOUSE_OVER_BORDER_COLOR;
            textStyle.fontFamily = "Arial";
            textStyle.fontSize = fontSize;
            // We want the texts only be shown on the top and right site.
            let numberOfLengthTexts = this.numberOfEditingPoints / 2;
            for (let i = 0; i < numberOfLengthTexts; i++) {
                let lengthText = this.getEnvironment().renderer.newTextObject("", 2, textStyle);
                // Visibility
                lengthText.visible = false;
                this.lengthTexts.push(lengthText);
                this.getView().addChild(lengthText);
            }
        }
        // Model
        onModelUpdated(model) {
            this.constrainRectangleModel();
            this.redraw();
        }
        constrainRectangleModel() {
            if (this.getModel().min.x > this.getModel().max.x) {
                let helper = this.getModel().min.x;
                this.getModel().min.x = this.getModel().max.x;
                this.getModel().max.x = helper;
            }
            if (this.getModel().min.y > this.getModel().max.y) {
                let helper = this.getModel().min.y;
                this.getModel().min.y = this.getModel().max.y;
                this.getModel().max.y = helper;
            }
        }
        getModel() {
            return super.getModel();
        }
        // AABB
        // @Override
        getAabbReferenceView() {
            return this.rectangle;
        }
        // Intersection test
        // @Override
        intersectsAabb(aabb) {
            const polygonA = [
                new Vector2_23.Vector2(aabb.min.x, aabb.min.y),
                new Vector2_23.Vector2(aabb.max.x, aabb.min.y),
                new Vector2_23.Vector2(aabb.max.x, aabb.max.y),
                new Vector2_23.Vector2(aabb.min.x, aabb.max.y)
            ];
            const polygonB = [
                this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new Vector2_23.Vector2(this.getModel().min.x, this.getModel().min.y)),
                this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new Vector2_23.Vector2(this.getModel().max.x, this.getModel().min.y)),
                this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new Vector2_23.Vector2(this.getModel().max.x, this.getModel().max.y)),
                this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new Vector2_23.Vector2(this.getModel().min.x, this.getModel().max.y))
            ];
            return IntersectionUtils_2.IntersectionUtils.testPolygonPolygonIntersection(polygonA, polygonB);
        }
        // @Override
        intersectsPointInScreenPx(x, y) {
            return this.intersectsRectangle(x, y) || this.pointIsCloseToEditableArea(x, y);
        }
        intersectsRectangle(x, y) {
            let mouseInRelative = this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new Vector2_23.Vector2(x, y));
            return IntersectionUtils_2.IntersectionUtils.testPointAabbIntersection(mouseInRelative, new AABB_6.AABB(this.getModel().min, this.getModel().max));
        }
        // @Override
        pointIsCloseToEditableArea(x, y) {
            let mousePosition = new Vector2_23.Vector2(x, y);
            let editablePoints = this.getEditablePoints();
            let tolerance = GeofenceMapObject_1.GeofenceMapObject.EDITABLE_POINT_TOLERANCE_IN_PX;
            for (let i = 0; i < editablePoints.length; i++) {
                let editablePoint = editablePoints[i];
                let distance = Vector2_23.Vector2.getDistanceBetweenPoints(mousePosition, editablePoint);
                if (distance < tolerance) {
                    return true;
                }
            }
            return false;
        }
        getEditablePoints() {
            let editablePoints = new Array();
            let topLeft = this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new Vector2_23.Vector2(this.getModel().min.x, this.getModel().min.y));
            let topRight = this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new Vector2_23.Vector2(this.getModel().max.x, this.getModel().min.y));
            let bottomLeft = this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new Vector2_23.Vector2(this.getModel().min.x, this.getModel().max.y));
            let bottomRight = this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new Vector2_23.Vector2(this.getModel().max.x, this.getModel().max.y));
            editablePoints.push(topLeft);
            editablePoints.push(topRight);
            editablePoints.push(bottomLeft);
            editablePoints.push(bottomRight);
            return editablePoints;
        }
        getNamePosition(textBound) {
            return this.getCenter();
        }
        // Editing
        // @Override
        onEditStart(x, y) {
            let pointInRelative = this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new Vector2_23.Vector2(x, y));
            this.editing = true;
            if (Math.abs(pointInRelative.x - this.getModel().min.x) < Math.abs(pointInRelative.x - this.getModel().max.x)) {
                this.editingMinX = true;
                this.editingMaxX = false;
            }
            else {
                this.editingMinX = false;
                this.editingMaxX = true;
            }
            if (Math.abs(pointInRelative.y - this.getModel().min.y) < Math.abs(pointInRelative.y - this.getModel().max.y)) {
                this.editingMinY = true;
                this.editingMaxY = false;
            }
            else {
                this.editingMinY = false;
                this.editingMaxY = true;
            }
        }
        // @Override
        onEditMove(x, y) {
            if (this.editing === true) {
                // Get mouse position in relative coordinates
                let pointInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_23.Vector2(x, y));
                let pointInRelative = this.getFloorplanLayer().getRelativeCoordinatesFromTexels(pointInTx);
                // Constrain the mouse to the world borders.
                pointInRelative.x = Math.max(0, Math.min(1, pointInRelative.x));
                pointInRelative.y = Math.max(0, Math.min(1, pointInRelative.y));
                // Model update
                if (this.editingMinX) {
                    this.getModel().min.x = pointInRelative.x;
                }
                else if (this.editingMaxX) {
                    this.getModel().max.x = pointInRelative.x;
                }
                if (this.editingMinY) {
                    this.getModel().min.y = pointInRelative.y;
                }
                else if (this.editingMaxY) {
                    this.getModel().max.y = pointInRelative.y;
                }
                // Model constraints: Min must always be smaller than max.
                if (this.getModel().min.x > this.getModel().max.x) {
                    let helper = this.getModel().min.x;
                    this.getModel().min.x = this.getModel().max.x;
                    this.getModel().max.x = helper;
                    let helperEditing = this.editingMinX;
                    this.editingMinX = this.editingMaxX;
                    this.editingMaxX = helperEditing;
                }
                if (this.getModel().min.y > this.getModel().max.y) {
                    let helper = this.getModel().min.y;
                    this.getModel().min.y = this.getModel().max.y;
                    this.getModel().max.y = helper;
                    let helperEditing = this.editingMinY;
                    this.editingMinY = this.editingMaxY;
                    this.editingMaxY = helperEditing;
                }
                // View update
                this.redraw();
            }
        }
        // @Override
        onEditStop(x, y) {
            this.editing = false;
        }
        // Moving
        // @Override
        onMoveStarted(x, y) {
            let pointInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_23.Vector2(x, y));
            let minInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(this.getModel().min);
            this.movingPointInLocalCoords = new Vector2_23.Vector2(pointInTx.x - minInTx.x, pointInTx.y - minInTx.y);
        }
        // @Override
        onMoveChanged(x, y) {
            let diffInTx = this.movingPointInLocalCoords;
            if (diffInTx !== null) {
                let pointInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_23.Vector2(x, y));
                // Adjust min
                let oldMin = this.getModel().min;
                let oldMinInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(oldMin);
                let newMinInTx = new Vector2_23.Vector2(pointInTx.x - diffInTx.x, pointInTx.y - diffInTx.y);
                let newMinInRelative = this.getFloorplanLayer().getRelativeCoordinatesFromTexels(newMinInTx);
                this.getModel().min = newMinInRelative;
                // Adjust max
                let oldMax = this.getModel().max;
                let oldMaxInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(oldMax);
                let widthInTx = oldMaxInTx.x - oldMinInTx.x;
                let heightInTx = oldMaxInTx.y - oldMinInTx.y;
                let newMaxInTx = new Vector2_23.Vector2(newMinInTx.x + widthInTx, newMinInTx.y + heightInTx);
                let newMaxInRelative = this.getFloorplanLayer().getRelativeCoordinatesFromTexels(newMaxInTx);
                this.getModel().max = newMaxInRelative;
                // World constraints
                this.resolveCollisionsWithWorld();
                // Redrawing
                this.redraw();
            }
        }
        resolveCollisionsWithWorld() {
            if (this.getModel().min.x < 0) {
                let offset = 0 - this.getModel().min.x;
                this.getModel().min.x += offset;
                this.getModel().max.x += offset;
            }
            if (this.getModel().max.x > 1) {
                let offset = this.getModel().max.x - 1;
                this.getModel().min.x -= offset;
                this.getModel().max.x -= offset;
            }
            if (this.getModel().min.y < 0) {
                let offset = 0 - this.getModel().min.y;
                this.getModel().min.y += offset;
                this.getModel().max.y += offset;
            }
            if (this.getModel().max.y > 1) {
                let offset = this.getModel().max.y - 1;
                this.getModel().min.y -= offset;
                this.getModel().max.y -= offset;
            }
        }
        // @Override
        onMoveStopped(x, y) {
            this.movingPointInLocalCoords = null;
        }
        // Centering
        // @Override
        translateAndScaleToCameraCenter() {
            // Compute new coordinates
            let camera = this.getScene().getCamera();
            let paddingInRelative = 0.4;
            let topLeftInScreenCoords = new Vector2_23.Vector2(camera.getScreenWidth() * (0.0 + paddingInRelative), camera.getScreenHeight() * (0.0 + paddingInRelative));
            let bottomRightInScreenCoords = new Vector2_23.Vector2(camera.getScreenWidth() * (1.0 - paddingInRelative), camera.getScreenHeight() * (1.0 - paddingInRelative));
            let topLeftInRelativeCoords = this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(topLeftInScreenCoords);
            let bottomRightInRelativeCoords = this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(bottomRightInScreenCoords);
            // Update model
            this.getModel().min.x = topLeftInRelativeCoords.x;
            this.getModel().min.y = topLeftInRelativeCoords.y;
            this.getModel().max.x = bottomRightInRelativeCoords.x;
            this.getModel().max.y = bottomRightInRelativeCoords.y;
            this.constrainRectangleModel();
            // Update view
            this.redraw();
        }
        // Rendering
        // @Override
        redraw() {
            this.redrawRectangle();
            this.redrawEditingPoints();
            this.redrawLengthTexts();
        }
        redrawRectangle() {
            let camera = this.getScene().getCamera();
            // border lines
            let lineColor = GeofenceMapObject_1.GeofenceMapObject.DEFAULT_BORDER_COLOR;
            let lineWidth = GeofenceMapObject_1.GeofenceMapObject.DEFAULT_BORDER_WIDTH_PX;
            if (this.isSelected()) {
                lineColor = GeofenceMapObject_1.GeofenceMapObject.SELECTED_BORDER_COLOR;
                lineWidth = GeofenceMapObject_1.GeofenceMapObject.SELECTED_BORDER_WIDTH_PX;
            }
            else if (this.isMouseOver()) {
                lineColor = GeofenceMapObject_1.GeofenceMapObject.MOUSE_OVER_BORDER_COLOR;
                lineWidth = GeofenceMapObject_1.GeofenceMapObject.MOUSE_OVER_BORDER_WIDTH_PX;
            }
            const lineWidthInTx = camera.getPixelsInTexels(lineWidth);
            // Rectangle shape
            let min = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(this.getModel().min);
            let max = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(this.getModel().max);
            // Rectangle color
            let color = GeofenceMapObject_1.GeofenceMapObject.LEFT_SHAPE_COLOR;
            if (this.getStateModel() !== null) {
                if (this.getStateModel().state === "ENTERED") {
                    color = GeofenceMapObject_1.GeofenceMapObject.ENTERED_SHAPE_COLOR;
                }
                else if (this.getStateModel().state === "LEFT") {
                    color = GeofenceMapObject_1.GeofenceMapObject.LEFT_SHAPE_COLOR;
                }
                else if (this.getStateModel().state === "UNKNOWN") {
                    color = GeofenceMapObject_1.GeofenceMapObject.UNKNOWN_SHAPE_COLOR;
                }
            }
            // Draw rectangle
            this.rectangle.clear();
            this.rectangle.beginFill(color);
            this.rectangle.lineStyle(lineWidthInTx, lineColor);
            this.rectangle.drawRect(min.x, min.y, max.x - min.x, max.y - min.y);
            this.rectangle.endFill();
        }
        redrawEditingPoints() {
            if (this.isMouseOver() || this.isMouseAboveEditPoint()) {
                if (this.isEditModeActive()) {
                    this.makeEditPointsVisible(true);
                    this.repositionEditPoints();
                    this.rescaleEditPoints();
                }
            }
            else {
                this.makeEditPointsVisible(false);
            }
        }
        makeEditPointsVisible(visible) {
            for (let i = 0; i < this.editingPoints.length; i++) {
                let editingPoint = this.editingPoints[i];
                editingPoint.visible = visible;
            }
        }
        repositionEditPoints() {
            let topLeftInRelative = new Vector2_23.Vector2(this.getModel().min.x, this.getModel().min.y);
            let topRightInRelative = new Vector2_23.Vector2(this.getModel().max.x, this.getModel().min.y);
            let bottomLeftInRelative = new Vector2_23.Vector2(this.getModel().min.x, this.getModel().max.y);
            let bottomRightInRelative = new Vector2_23.Vector2(this.getModel().max.x, this.getModel().max.y);
            let topLeftInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(topLeftInRelative);
            let topRightInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(topRightInRelative);
            let bottomLeftInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(bottomLeftInRelative);
            let bottomRightInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(bottomRightInRelative);
            this.editingPoints[0].position = this.getEnvironment().renderer.newPointFromVector2(topLeftInTx);
            this.editingPoints[1].position = this.getEnvironment().renderer.newPointFromVector2(topRightInTx);
            this.editingPoints[2].position = this.getEnvironment().renderer.newPointFromVector2(bottomLeftInTx);
            this.editingPoints[3].position = this.getEnvironment().renderer.newPointFromVector2(bottomRightInTx);
        }
        rescaleEditPoints() {
            let camera = this.getScene().getCamera();
            let widthInPx = GeofenceMapObject_1.GeofenceMapObject.EDIT_POINT_RADIUS_IN_PX * 2;
            let widthInTx = camera.getPixelsInTexels(widthInPx);
            for (let i = 0; i < this.editingPoints.length; i++) {
                let editingPoint = this.editingPoints[i];
                editingPoint.width = widthInTx;
                editingPoint.height = widthInTx;
            }
        }
        redrawLengthTexts() {
            if (this.isMouseOver() && this.isEditModeActive()) {
                this.makeLengthTextsVisible(true);
                this.updateLengthTexts();
            }
            else {
                this.makeLengthTextsVisible(false);
            }
        }
        makeLengthTextsVisible(visible) {
            for (let i = 0; i < this.lengthTexts.length; i++) {
                let lengthText = this.lengthTexts[i];
                lengthText.visible = visible;
            }
        }
        updateLengthTexts() {
            let camera = this.getScene().getCamera();
            let scaleFactor = camera.getScaleX();
            let cameraOrientation = camera.getRotation();
            let points = this.getRectanglePointsInTx();
            for (let i = 0; i < this.lengthTexts.length; i++) {
                let lengthText = this.lengthTexts[i];
                let pointA = points[i];
                let pointB = points[(i + 1) % points.length];
                // Compute distance in meters
                let distanceInTx = Vector2_23.Vector2.getDistanceBetweenPoints(pointA, pointB);
                let distanceInCm = this.getFloorplanLayer().getCmFromTexels(distanceInTx);
                let distanceInM = distanceInCm / 100.0;
                // Text
                let newText = "" + distanceInM.toFixed(1) + " m";
                if (lengthText.text !== newText) {
                    lengthText.text = newText;
                }
                // Scale
                lengthText.scale.x = scaleFactor;
                lengthText.scale.y = scaleFactor;
                // Orientation
                lengthText.rotation = cameraOrientation;
                // Position
                let penetrationResolutionVector = this.getInterpenetrationResolutionVector(pointA, pointB, lengthText);
                lengthText.x = pointA.x + ((pointB.x - pointA.x) / 2) - lengthText.width / 2 + penetrationResolutionVector.x;
                lengthText.y = pointA.y + ((pointB.y - pointA.y) / 2) - lengthText.height / 2 + penetrationResolutionVector.y;
            }
        }
        getRectanglePointsInTx() {
            let points = [];
            let point1InRelative = new Vector2_23.Vector2(this.getModel().min.x, this.getModel().min.y);
            let point2InRelative = new Vector2_23.Vector2(this.getModel().max.x, this.getModel().min.y);
            let point3InRelative = new Vector2_23.Vector2(this.getModel().max.x, this.getModel().max.y);
            let point4InRelative = new Vector2_23.Vector2(this.getModel().min.x, this.getModel().max.y);
            let point1InTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point1InRelative);
            let point2InTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point2InRelative);
            let point3InTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point3InRelative);
            let point4InTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point4InRelative);
            points.push(point1InTx);
            points.push(point2InTx);
            points.push(point3InTx);
            points.push(point4InTx);
            return points;
        }
        getInterpenetrationResolutionVector(pointA, pointB, lengthText) {
            let edgeX = pointB.x - pointA.x;
            let edgeY = pointB.y - pointA.y;
            let normalX = edgeY;
            let normalY = -edgeX;
            let normalizedNormalVector = Vector2_23.Vector2.normalizePoint(new Vector2_23.Vector2(normalX, normalY));
            let depthInTx = 0;
            // Padding
            let camera = this.getScene().getCamera();
            let paddingInPx = GeofenceMapObject_1.GeofenceMapObject.TEXT_PADDING_PX;
            let paddingInTx = camera.getPixelsInTexels(paddingInPx);
            if (Math.abs(normalY) > Math.abs(normalX)) {
                depthInTx = lengthText.height / 2 + paddingInTx;
            }
            else {
                depthInTx = lengthText.width / 2 + paddingInTx;
            }
            let penetrationVector = new Vector2_23.Vector2(normalizedNormalVector.x * depthInTx, normalizedNormalVector.y * depthInTx);
            return penetrationVector;
        }
    };
    RectangleGeofenceMapObject = __decorate([
        (0, RelutionMapObject_9.RelutionModelBinding)(GeofenceModel_1.RectangleGeofenceModel)
    ], RectangleGeofenceMapObject);
    exports.RectangleGeofenceMapObject = RectangleGeofenceMapObject;
});
define("src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/geofences/CircleGeofenceMapObject", ["require", "exports", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/GeofenceMapObject", "src/app/relution/view/world/RelutionMapObject", "src/app/relution/model/geofence/GeofenceModel", "src/engine/math/Vector2", "src/map/utils/DeviceUtils", "src/engine/utils/IntersectionUtils"], function (require, exports, GeofenceMapObject_2, RelutionMapObject_10, GeofenceModel_2, Vector2_24, DeviceUtils_10, IntersectionUtils_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CircleGeofenceMapObject = void 0;
    let CircleGeofenceMapObject = class CircleGeofenceMapObject extends GeofenceMapObject_2.GeofenceMapObject {
        // Construction
        constructor(config, environment, floorplanLayer, model) {
            super(config, environment, floorplanLayer, model);
            // Movement: Given in rectangle local coordinates
            this.movingPointInLocalCoords = null;
            this.editingPoints = Array();
            this.initCircle();
            this.initEditingPoints();
            this.initLengthTexts();
        }
        initCircle() {
            this.circle = this.getEnvironment().renderer.newGraphicsObject();
            this.getView().addChild(this.circle);
            this.circle.alpha = GeofenceMapObject_2.GeofenceMapObject.DEFAULT_ALPHA;
        }
        initEditingPoints() {
            for (let i = 0; i < 4; i++) {
                let editingPoint = this.getEnvironment().renderer.newGraphicsObject();
                editingPoint.clear();
                editingPoint.beginFill(GeofenceMapObject_2.GeofenceMapObject.MOUSE_OVER_BORDER_COLOR);
                editingPoint.drawCircle(0, 0, 1);
                editingPoint.endFill();
                this.editingPoints.push(editingPoint);
                this.getView().addChild(editingPoint);
            }
        }
        initLengthTexts() {
            let fontSize = DeviceUtils_10.DeviceUtils.getPhysicalPixelsFromLogical(12);
            let textStyle = this.getEnvironment().renderer.newTextStyle();
            textStyle.fill = GeofenceMapObject_2.GeofenceMapObject.MOUSE_OVER_BORDER_COLOR;
            textStyle.fontFamily = "Arial";
            textStyle.fontSize = fontSize;
            this.lengthText = this.getEnvironment().renderer.newTextObject("", 2, textStyle);
            this.lengthText.visible = false;
            this.getView().addChild(this.lengthText);
            this.radiusIndicator = this.getEnvironment().renderer.newGraphicsObject();
            this.radiusIndicator.visible = false;
            this.getView().addChild(this.radiusIndicator);
        }
        // Intersection
        // @Override
        intersectsAabb(aabb) {
            const circleCenterPx = this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(this.getModel().center);
            const circleEndPointPx = this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new Vector2_24.Vector2(this.getModel().center.x + this.getModel().radius, this.getModel().center.y));
            const radiusInPx = Vector2_24.Vector2.getDistanceBetweenPoints(circleCenterPx, circleEndPointPx);
            return IntersectionUtils_3.IntersectionUtils.testAabbCircleIntersection(aabb, circleCenterPx, radiusInPx);
        }
        // @Override
        intersectsPointInScreenPx(x, y) {
            return this.intersectsCircle(x, y) || this.pointIsCloseToEditableArea(x, y);
        }
        intersectsCircle(x, y) {
            const mousePositionTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_24.Vector2(x, y));
            const circleCenterTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(this.getModel().center);
            const radiusInCm = this.getFloorplanLayer().getCmFromRelative(this.getModel().radius);
            const radiusInTx = this.getFloorplanLayer().getTexelsFromCm(radiusInCm);
            return IntersectionUtils_3.IntersectionUtils.testPointCircleIntersection(mousePositionTx, circleCenterTx, radiusInTx);
        }
        // Model
        onModelUpdated(model) {
            this.redraw();
        }
        redraw() {
            this.reDrawCircle();
            this.redrawEditingPoints();
            this.redrawLengthTexts();
        }
        reDrawCircle() {
            let camera = this.getScene().getCamera();
            // border lines
            let lineColor = GeofenceMapObject_2.GeofenceMapObject.DEFAULT_BORDER_COLOR;
            let lineWidth = GeofenceMapObject_2.GeofenceMapObject.DEFAULT_BORDER_WIDTH_PX;
            if (this.isSelected()) {
                lineColor = GeofenceMapObject_2.GeofenceMapObject.SELECTED_BORDER_COLOR;
                lineWidth = GeofenceMapObject_2.GeofenceMapObject.SELECTED_BORDER_WIDTH_PX;
            }
            else if (this.isMouseOver()) {
                lineColor = GeofenceMapObject_2.GeofenceMapObject.MOUSE_OVER_BORDER_COLOR;
                lineWidth = GeofenceMapObject_2.GeofenceMapObject.MOUSE_OVER_BORDER_WIDTH_PX;
            }
            const lineWidthInTx = camera.getPixelsInTexels(lineWidth);
            // Rectangle shape
            let center = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(this.getModel().center);
            let radius = this.getFloorplanLayer().getTexelsFromRelativeDistance(this.getModel().radius);
            // Rectangle color
            let color = GeofenceMapObject_2.GeofenceMapObject.LEFT_SHAPE_COLOR;
            if (this.getStateModel() !== null) {
                if (this.getStateModel().state === "ENTERED") {
                    color = GeofenceMapObject_2.GeofenceMapObject.ENTERED_SHAPE_COLOR;
                }
                else if (this.getStateModel().state === "LEFT") {
                    color = GeofenceMapObject_2.GeofenceMapObject.LEFT_SHAPE_COLOR;
                }
                else if (this.getStateModel().state === "UNKNOWN") {
                    color = GeofenceMapObject_2.GeofenceMapObject.UNKNOWN_SHAPE_COLOR;
                }
            }
            // Draw circle
            this.circle.clear();
            this.circle.beginFill(color);
            this.circle.lineStyle(lineWidthInTx, lineColor);
            this.circle.drawCircle(center.x, center.y, radius);
            this.circle.endFill();
        }
        redrawEditingPoints() {
            if (this.isMouseOver() || this.isMouseAboveEditPoint()) {
                if (this.isEditModeActive()) {
                    this.makeEditPointsVisible(true);
                    this.repositionEditPoints();
                    this.rescaleEditPoints();
                }
            }
            else {
                this.makeEditPointsVisible(false);
            }
        }
        makeEditPointsVisible(visible) {
            for (let i = 0; i < this.editingPoints.length; i++) {
                let editingPoint = this.editingPoints[i];
                editingPoint.visible = visible;
            }
        }
        repositionEditPoints() {
            const radius = this.getFloorplanLayer().getTexelsFromRelativeDistance(this.getModel().radius);
            const center = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(this.getModel().center);
            const pi = Math.PI;
            const top = new Vector2_24.Vector2(center.x + radius * Math.cos((3 / 2) * pi), center.y + radius * Math.sin((3 / 2) * pi));
            const left = new Vector2_24.Vector2(center.x + radius * Math.cos(pi), center.y + radius * Math.sin(pi));
            const bottom = new Vector2_24.Vector2(center.x + radius * Math.cos(pi / 2), center.y + radius * Math.sin(pi / 2));
            const right = new Vector2_24.Vector2(center.x + radius * Math.cos(pi * 2), center.y + radius * Math.sin(pi * 2));
            this.editingPoints[0].position = this.getEnvironment().renderer.newPointFromVector2(top);
            this.editingPoints[1].position = this.getEnvironment().renderer.newPointFromVector2(left);
            this.editingPoints[2].position = this.getEnvironment().renderer.newPointFromVector2(bottom);
            this.editingPoints[3].position = this.getEnvironment().renderer.newPointFromVector2(right);
        }
        rescaleEditPoints() {
            let camera = this.getScene().getCamera();
            let widthInPx = GeofenceMapObject_2.GeofenceMapObject.EDIT_POINT_RADIUS_IN_PX * 2;
            let widthInTx = camera.getPixelsInTexels(widthInPx);
            for (let i = 0; i < this.editingPoints.length; i++) {
                let editingPoint = this.editingPoints[i];
                editingPoint.width = widthInTx;
                editingPoint.height = widthInTx;
            }
        }
        redrawLengthTexts() {
            if (this.isMouseOver() && this.isEditModeActive()) {
                this.makeLengthTextsVisible(true);
                this.updateLengthTexts();
            }
            else {
                this.makeLengthTextsVisible(false);
            }
        }
        makeLengthTextsVisible(visible) {
            this.lengthText.visible = visible;
            this.radiusIndicator.visible = visible;
        }
        updateLengthTexts() {
            let camera = this.getScene().getCamera();
            let scaleFactor = camera.getScaleX();
            let cameraOrientation = camera.getRotation();
            let center = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(this.getModel().center);
            let sizeInM = this.getFloorplanLayer().getCmFromRelative(this.getModel().radius) / 100;
            // Text
            let newText = "" + sizeInM.toFixed(1) + " m";
            if (this.lengthText.text !== newText) {
                this.lengthText.text = newText;
            }
            // Scale
            this.lengthText.scale.x = scaleFactor;
            this.lengthText.scale.y = scaleFactor;
            // Orientation
            this.lengthText.rotation = cameraOrientation;
            // border lines
            let lineColor = GeofenceMapObject_2.GeofenceMapObject.DEFAULT_BORDER_COLOR;
            let lineWidth = GeofenceMapObject_2.GeofenceMapObject.DEFAULT_BORDER_WIDTH_PX;
            if (this.isSelected()) {
                lineColor = GeofenceMapObject_2.GeofenceMapObject.SELECTED_BORDER_COLOR;
                lineWidth = GeofenceMapObject_2.GeofenceMapObject.SELECTED_BORDER_WIDTH_PX;
            }
            else if (this.isMouseOver()) {
                lineColor = GeofenceMapObject_2.GeofenceMapObject.MOUSE_OVER_BORDER_COLOR;
                lineWidth = GeofenceMapObject_2.GeofenceMapObject.SELECTED_BORDER_WIDTH_PX;
            }
            const lineWidthInTx = camera.getPixelsInTexels(lineWidth);
            // geometry
            const rightEditPoint = new Vector2_24.Vector2(this.editingPoints[3].x, this.editingPoints[3].y);
            this.radiusIndicator.clear();
            this.radiusIndicator.beginFill(GeofenceMapObject_2.GeofenceMapObject.MOUSE_OVER_BORDER_COLOR);
            this.radiusIndicator.drawPolygon([
                this.getEnvironment().renderer.newPointFromVector2(center),
                this.getEnvironment().renderer.newPointFromVector2(rightEditPoint),
                this.getEnvironment().renderer.newPointFromVector2(new Vector2_24.Vector2(rightEditPoint.x, rightEditPoint.y + lineWidthInTx)),
                this.getEnvironment().renderer.newPointFromVector2(new Vector2_24.Vector2(center.x, center.y + lineWidthInTx))
            ]);
            this.radiusIndicator.endFill();
            // Position
            const indicatorCenter = new Vector2_24.Vector2((center.x + rightEditPoint.x) / 2, (center.y + rightEditPoint.y) / 2);
            this.lengthText.x = indicatorCenter.x - (this.lengthText.width / 2);
            this.lengthText.y = indicatorCenter.y - (this.lengthText.height / 2) - this.lengthText.height;
        }
        // Editing
        // @Override
        pointIsCloseToEditableArea(x, y) {
            const mousePositionPx = new Vector2_24.Vector2(x, y);
            let editablePoints = this.editingPoints;
            let tolerance = GeofenceMapObject_2.GeofenceMapObject.EDITABLE_POINT_TOLERANCE_IN_PX;
            for (let i = 0; i < editablePoints.length; i++) {
                let editablePoint = editablePoints[i];
                let posPx = this.getFloorplanLayer().getScreenPixelsFromTexels(new Vector2_24.Vector2(editablePoint.x, editablePoint.y));
                let distancePx = Vector2_24.Vector2.getDistanceBetweenPoints(mousePositionPx, posPx);
                if (distancePx < tolerance) {
                    return true;
                }
            }
            return false;
        }
        // @Override
        onEditStart(x, y) {
        }
        // @Override
        onEditMove(x, y) {
            let pointInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_24.Vector2(x, y));
            let centerInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(this.getModel().center);
            let newRadius = Vector2_24.Vector2.getDistanceBetweenPoints(pointInTx, centerInTx);
            this.getModel().radius = this.getFloorplanLayer().getRelativeFromCm(this.getFloorplanLayer().getCmFromTexels(newRadius));
            this.resolveCollisionsWithWorldScale();
            this.redraw();
        }
        // @Override
        onEditStop(x, y) {
        }
        // Moving
        // @Override
        onMoveStarted(x, y) {
            let pointInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_24.Vector2(x, y));
            let minInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(this.getModel().center);
            this.movingPointInLocalCoords = new Vector2_24.Vector2(pointInTx.x - minInTx.x, pointInTx.y - minInTx.y);
        }
        // @Override
        onMoveChanged(x, y) {
            let diffInTx = this.movingPointInLocalCoords;
            if (diffInTx !== null) {
                let pointInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_24.Vector2(x, y));
                // Adjust min
                let newCenterInTx = new Vector2_24.Vector2(pointInTx.x - diffInTx.x, pointInTx.y - diffInTx.y);
                this.getModel().center = this.getFloorplanLayer().getRelativeCoordinatesFromTexels(newCenterInTx);
                this.resolveCollisionsWithWorldMove();
                // Redrawing
                this.redraw();
            }
        }
        resolveCollisionsWithWorldMove() {
            const offset = this.getCollisionOffset();
            if (offset.left < 0) {
                this.getModel().center.x = this.getModel().center.x - offset.left;
            }
            if (offset.right > 1) {
                this.getModel().center.x = this.getModel().center.x - (offset.right - 1);
            }
            if (offset.top < 0) {
                this.getModel().center.y = this.getModel().center.y - offset.top;
            }
            if (offset.bottom > 1) {
                this.getModel().center.y = this.getModel().center.y - (offset.bottom - 1);
            }
        }
        resolveCollisionsWithWorldScale() {
            let offset = this.getCollisionOffset();
            if (offset.left < 0) {
                const old = this.getModel().radius;
                this.getModel().radius = this.getModel().radius + offset.left;
                offset = this.getCollisionOffset();
            }
            if (offset.right > 1) {
                this.getModel().radius = this.getModel().radius - offset.right - 1;
                offset = this.getCollisionOffset();
            }
            if (offset.top < 0) {
                this.getModel().radius = this.getModel().radius + offset.top;
                offset = this.getCollisionOffset();
            }
            if (offset.bottom > 1) {
                this.getModel().radius = this.getModel().radius - offset.bottom - 1;
            }
        }
        getCollisionOffset() {
            const relativeRadius = this.getModel().radius;
            const offsetLeft = this.getModel().center.x - relativeRadius;
            const offsetRight = this.getModel().center.x + relativeRadius;
            const offsetTop = this.getModel().center.y - relativeRadius;
            const offsetBottom = this.getModel().center.y + relativeRadius;
            return {
                left: offsetLeft,
                right: offsetRight,
                top: offsetTop,
                bottom: offsetBottom
            };
        }
        // @Override
        onMoveStopped(x, y) {
            this.movingPointInLocalCoords = null;
        }
        // Centering
        // @Override
        translateAndScaleToCameraCenter() {
        }
        // Getters and setters
        getModel() {
            return super.getModel();
        }
        getNamePosition(textBound) {
            return this.getCenter();
        }
    };
    CircleGeofenceMapObject = __decorate([
        (0, RelutionMapObject_10.RelutionModelBinding)(GeofenceModel_2.CircleGeofenceModel)
    ], CircleGeofenceMapObject);
    exports.CircleGeofenceMapObject = CircleGeofenceMapObject;
});
define("src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/geofences/PolygonGeofenceMapObject", ["require", "exports", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/GeofenceMapObject", "src/app/relution/view/world/RelutionMapObject", "src/app/relution/model/geofence/GeofenceModel", "src/engine/math/Vector2", "src/map/utils/DeviceUtils", "src/engine/utils/IntersectionUtils"], function (require, exports, GeofenceMapObject_3, RelutionMapObject_11, GeofenceModel_3, Vector2_25, DeviceUtils_11, IntersectionUtils_4) {
    "use strict";
    var PolygonGeofenceMapObject_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PolygonGeofenceMapObject = void 0;
    var VectorDirections;
    (function (VectorDirections) {
        VectorDirections[VectorDirections["E"] = 0] = "E";
        VectorDirections[VectorDirections["NE"] = 1] = "NE";
        VectorDirections[VectorDirections["N"] = 2] = "N";
        VectorDirections[VectorDirections["NW"] = 3] = "NW";
        VectorDirections[VectorDirections["W"] = 4] = "W";
        VectorDirections[VectorDirections["SW"] = 5] = "SW";
        VectorDirections[VectorDirections["S"] = 6] = "S";
        VectorDirections[VectorDirections["SE"] = 7] = "SE";
    })(VectorDirections || (VectorDirections = {}));
    let PolygonGeofenceMapObject = PolygonGeofenceMapObject_1 = class PolygonGeofenceMapObject extends GeofenceMapObject_3.GeofenceMapObject {
        // Construction
        constructor(config, environment, floorplanLayer, model) {
            super(config, environment, floorplanLayer, model);
            this.editingPoints = Array();
            this.lengthTexts = new Array();
            this.initPolygon();
            this.initEditingPoints();
            this.initLengthTexts();
        }
        static getVectorDirection(vec1, vec2) {
            const directionVector = Vector2_25.Vector2.subtract(vec2, vec1);
            const angle = Math.atan2(directionVector.y, directionVector.x);
            const dir = Math.round(8 * angle / (2 * Math.PI) + 8) % 8;
            return dir;
        }
        initPolygon() {
            this.polygon = this.getEnvironment().renderer.newGraphicsObject();
            this.getView().addChild(this.polygon);
            this.polygon.alpha = GeofenceMapObject_3.GeofenceMapObject.DEFAULT_ALPHA;
        }
        initEditingPoints() {
            this.getModel().points.forEach(() => {
                let editingPoint = this.getEnvironment().renderer.newGraphicsObject();
                editingPoint.clear();
                editingPoint.beginFill(GeofenceMapObject_3.GeofenceMapObject.MOUSE_OVER_BORDER_COLOR);
                editingPoint.drawCircle(0, 0, 1);
                editingPoint.endFill();
                this.editingPoints.push(editingPoint);
                this.getView().addChild(editingPoint);
            });
            this.repositionEditPoints();
        }
        initLengthTexts() {
            let fontSize = DeviceUtils_11.DeviceUtils.getPhysicalPixelsFromLogical(12);
            let textStyle = this.getEnvironment().renderer.newTextStyle();
            textStyle.fill = GeofenceMapObject_3.GeofenceMapObject.MOUSE_OVER_BORDER_COLOR;
            textStyle.fontFamily = "Arial";
            textStyle.fontSize = fontSize;
            // We want the texts only be shown on the top and right site.
            this.editingPoints.forEach(() => {
                const lengthText = this.getEnvironment().renderer.newTextObject("", 2, textStyle);
                lengthText.visible = false;
                this.lengthTexts.push(lengthText);
                this.getView().addChild(lengthText);
            });
        }
        // Intersection
        // @Override
        intersectsAabb(aabb) {
            const aabbPolygonRel = [
                this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new Vector2_25.Vector2(aabb.min.x, aabb.min.y)),
                this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new Vector2_25.Vector2(aabb.max.x, aabb.min.y)),
                this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new Vector2_25.Vector2(aabb.max.x, aabb.max.y)),
                this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new Vector2_25.Vector2(aabb.min.x, aabb.max.y))
            ];
            return IntersectionUtils_4.IntersectionUtils.testPolygonPolygonIntersection(aabbPolygonRel, this.getModel().points);
        }
        // @Override
        intersectsPointInScreenPx(x, y) {
            if (this.pointIsCloseToEditableArea(x, y)) {
                return true;
            }
            return this.intersectsPolygon(x, y);
        }
        intersectsPolygon(x, y) {
            const pointInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_25.Vector2(x, y));
            const pointInRel = this.getFloorplanLayer().getRelativeCoordinatesFromTexels(pointInTx);
            return IntersectionUtils_4.IntersectionUtils.testPointPolygonIntersection(pointInRel, this.getModel().points);
        }
        makeEditPointsVisible(visible) {
            for (let i = 0; i < this.editingPoints.length; i++) {
                let editingPoint = this.editingPoints[i];
                editingPoint.visible = visible;
            }
        }
        repositionEditPoints() {
            this.getModel().points.forEach((point, index) => {
                const texel = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point);
                this.editingPoints[index].position = this.getEnvironment().renderer.newPointFromVector2(texel);
            });
        }
        rescaleEditPoints() {
            let camera = this.getScene().getCamera();
            let widthInPx = GeofenceMapObject_3.GeofenceMapObject.EDIT_POINT_RADIUS_IN_PX * 2;
            let widthInTx = camera.getPixelsInTexels(widthInPx);
            for (let i = 0; i < this.editingPoints.length; i++) {
                let editingPoint = this.editingPoints[i];
                editingPoint.width = widthInTx;
                editingPoint.height = widthInTx;
            }
        }
        redrawLengthTexts() {
            if (this.isMouseOver() && this.isEditModeActive()) {
                this.makeLengthTextsVisible(true);
                this.updateLengthTexts();
            }
            else {
                this.makeLengthTextsVisible(false);
            }
        }
        makeLengthTextsVisible(visible) {
            for (let i = 0; i < this.lengthTexts.length; i++) {
                let lengthText = this.lengthTexts[i];
                lengthText.visible = visible;
            }
        }
        updateLengthTexts() {
            let camera = this.getScene().getCamera();
            let scaleFactor = camera.getScaleX();
            let cameraOrientation = camera.getRotation();
            this.editingPoints.forEach((point, index) => {
                const pointATexels = new Vector2_25.Vector2(point.x, point.y);
                const pointB = this.editingPoints[(index + 1) % this.editingPoints.length];
                const pointBTexels = new Vector2_25.Vector2(pointB.x, pointB.y);
                const lengthText = this.lengthTexts[index];
                // Compute distance in meters
                let distanceInTx = Vector2_25.Vector2.getDistanceBetweenPoints(pointATexels, pointBTexels);
                let distanceInCm = this.getFloorplanLayer().getCmFromTexels(distanceInTx);
                let distanceInM = distanceInCm / 100.0;
                // Text
                let newText = "" + distanceInM.toFixed(1) + " m";
                if (lengthText.text !== newText) {
                    lengthText.text = newText;
                }
                // Scale
                lengthText.scale.x = scaleFactor;
                lengthText.scale.y = scaleFactor;
                // Orientation
                lengthText.rotation = cameraOrientation;
                const direction = PolygonGeofenceMapObject_1.getVectorDirection(pointATexels, pointBTexels);
                const pivot = new Vector2_25.Vector2(0, 0);
                const addedVectors = Vector2_25.Vector2.add(pointATexels, pointBTexels);
                const center = new Vector2_25.Vector2(addedVectors.x / 2, addedVectors.y / 2);
                const position = new Vector2_25.Vector2(center.x, center.y);
                switch (direction) {
                    case VectorDirections.E: // <-
                    case VectorDirections.SE:
                    case VectorDirections.NE:
                        pivot.x = lengthText.width / 2;
                        pivot.y = lengthText.height;
                        position.x = center.x;
                        position.y = center.y - (lengthText.height / 2);
                        break;
                    case VectorDirections.N: // ^
                    case VectorDirections.NW:
                        pivot.x = 0;
                        pivot.y = lengthText.height / 2;
                        position.x = center.x + (lengthText.width / 2);
                        position.y = center.y;
                        break;
                    case VectorDirections.W: // ->
                        pivot.x = lengthText.width / 2;
                        pivot.y = 0;
                        position.x = center.x;
                        position.y = center.y + (lengthText.height / 2);
                        break;
                    case VectorDirections.S: // v
                    case VectorDirections.SW:
                        pivot.x = lengthText.width;
                        pivot.y = lengthText.height / 2;
                        position.x = center.x - (lengthText.width / 2);
                        position.y = center.y;
                        break;
                }
                // Position
                lengthText.x = position.x - pivot.x;
                lengthText.y = position.y - pivot.y;
            });
        }
        reDrawPolygon() {
            let camera = this.getScene().getCamera();
            // border lines
            let lineColor = GeofenceMapObject_3.GeofenceMapObject.DEFAULT_BORDER_COLOR;
            let lineWidth = GeofenceMapObject_3.GeofenceMapObject.DEFAULT_BORDER_WIDTH_PX;
            if (this.isSelected()) {
                lineColor = GeofenceMapObject_3.GeofenceMapObject.SELECTED_BORDER_COLOR;
                lineWidth = GeofenceMapObject_3.GeofenceMapObject.SELECTED_BORDER_WIDTH_PX;
            }
            else if (this.isMouseOver()) {
                lineColor = GeofenceMapObject_3.GeofenceMapObject.MOUSE_OVER_BORDER_COLOR;
                lineWidth = GeofenceMapObject_3.GeofenceMapObject.MOUSE_OVER_BORDER_WIDTH_PX;
            }
            const lineWidthInTx = camera.getPixelsInTexels(lineWidth);
            // Rectangle color
            let color = GeofenceMapObject_3.GeofenceMapObject.LEFT_SHAPE_COLOR;
            if (this.getStateModel() !== null) {
                if (this.getStateModel().state === "ENTERED") {
                    color = GeofenceMapObject_3.GeofenceMapObject.ENTERED_SHAPE_COLOR;
                }
                else if (this.getStateModel().state === "LEFT") {
                    color = GeofenceMapObject_3.GeofenceMapObject.LEFT_SHAPE_COLOR;
                }
                else if (this.getStateModel().state === "UNKNOWN") {
                    color = GeofenceMapObject_3.GeofenceMapObject.UNKNOWN_SHAPE_COLOR;
                }
            }
            const texels = this.getModel().points
                .map((point) => {
                const vector = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point);
                return this.getEnvironment().renderer.newPoint(vector.x, vector.y);
            });
            this.polygon.clear();
            this.polygon.beginFill(color);
            this.polygon.lineStyle(lineWidthInTx, lineColor);
            this.polygon.drawPolygon(texels).closePath();
            this.polygon.endFill();
        }
        redrawEditingPoints() {
            if (this.isMouseOver() || this.isMouseAboveEditPoint()) {
                if (this.isEditModeActive()) {
                    this.makeEditPointsVisible(true);
                    this.repositionEditPoints();
                    this.rescaleEditPoints();
                }
            }
            else {
                this.makeEditPointsVisible(false);
            }
        }
        getEditPointNearbyMouse(x, y) {
            const mousePosition = new Vector2_25.Vector2(x, y);
            const tolerance = GeofenceMapObject_3.GeofenceMapObject.EDITABLE_POINT_TOLERANCE_IN_PX;
            return this.editingPoints
                .find((point) => {
                const pos = this.getFloorplanLayer().getScreenPixelsFromTexels(new Vector2_25.Vector2(point.x, point.y));
                let distanceInPx = Vector2_25.Vector2.getDistanceBetweenPoints(mousePosition, pos);
                return distanceInPx <= tolerance;
            });
        }
        resolveCollisionsWithWorldMove() {
            let offset = new Vector2_25.Vector2(0, 0);
            this.getModel().points.forEach((point, index) => {
                if (point.x > 1 && point.x - 1 > offset.x) {
                    offset.x = point.x - 1;
                }
                else if (point.x < 0 && point.x < offset.x) {
                    offset.x = point.x;
                }
                if (point.y > 1 && point.y - 1 > offset.y) {
                    offset.y = point.y - 1;
                }
                else if (point.y < 0 && point.y < offset.y) {
                    offset.y = point.y;
                }
            });
            this.getModel().points.forEach((point, index) => {
                point.x -= offset.x;
                point.y -= offset.y;
            });
        }
        resolveCollisionsWithWorldEdit(point) {
            if (point.x > 1) {
                point.x = 1;
            }
            else if (point.x < 0) {
                point.x = 0;
            }
            if (point.y > 1) {
                point.y = 1;
            }
            else if (point.y < 0) {
                point.y = 0;
            }
        }
        // Model update
        onModelUpdated(model) {
            this.redraw();
        }
        redraw() {
            this.reDrawPolygon();
            this.redrawEditingPoints();
            this.redrawLengthTexts();
        }
        getModel() {
            return super.getModel();
        }
        // Editing
        getNamePosition(textBound) {
            return this.getCenter();
        }
        // @Override
        pointIsCloseToEditableArea(x, y) {
            return !!this.getEditPointNearbyMouse(x, y);
        }
        // @Override
        onEditStart(x, y) {
            this.activeEditPoint = this.getEditPointNearbyMouse(x, y);
        }
        // @Override
        onEditMove(x, y) {
            if (this.activeEditPoint) {
                const affectedPoint = this.getModelPoint(this.activeEditPoint);
                if (affectedPoint) {
                    const mousePosition = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_25.Vector2(x, y));
                    const relativePos = this.getFloorplanLayer().getRelativeCoordinatesFromTexels(mousePosition);
                    affectedPoint.x = relativePos.x;
                    affectedPoint.y = relativePos.y;
                    this.resolveCollisionsWithWorldEdit(affectedPoint);
                    this.redraw();
                }
            }
        }
        getModelPoint(editPoint) {
            const activeEditPointRel = this.getFloorplanLayer().getRelativeCoordinatesFromTexels(new Vector2_25.Vector2(editPoint.x, editPoint.y));
            let minPointDistance = Infinity;
            let minDistancePoint = null;
            for (let i = 0; i < this.getModel().points.length; i++) {
                const modelPoint = this.getModel().points[i];
                let distanceInRel = Vector2_25.Vector2.getDistanceBetweenPoints(modelPoint, activeEditPointRel);
                if (distanceInRel < minPointDistance) {
                    minPointDistance = distanceInRel;
                    minDistancePoint = modelPoint;
                }
            }
            return minDistancePoint;
        }
        // Moving
        // @Override
        onEditStop(x, y) {
        }
        // @Override
        onMoveStarted(x, y) {
            this.beforeMoveStartedCoords = [];
            this.getModel().points.forEach((point) => {
                let pointInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_25.Vector2(x, y));
                let minInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point);
                this.beforeMoveStartedCoords.push(new Vector2_25.Vector2(pointInTx.x - minInTx.x, pointInTx.y - minInTx.y));
            });
        }
        // @Override
        onMoveChanged(x, y) {
            if (this.beforeMoveStartedCoords) {
                this.getModel().points.forEach((point, index) => {
                    let diffInTx = this.beforeMoveStartedCoords[index];
                    let pointInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_25.Vector2(x, y));
                    let newPosTx = new Vector2_25.Vector2(pointInTx.x - diffInTx.x, pointInTx.y - diffInTx.y);
                    const relative = this.getFloorplanLayer().getRelativeCoordinatesFromTexels(newPosTx);
                    point.x = relative.x;
                    point.y = relative.y;
                });
                this.resolveCollisionsWithWorldMove();
                this.redraw();
            }
        }
        // Centering
        // @Override
        onMoveStopped(x, y) {
            this.beforeMoveStartedCoords = null;
        }
        // Redrawing
        // @Override
        translateAndScaleToCameraCenter() {
        }
    };
    PolygonGeofenceMapObject = PolygonGeofenceMapObject_1 = __decorate([
        (0, RelutionMapObject_11.RelutionModelBinding)(GeofenceModel_3.PolygonGeofenceModel)
    ], PolygonGeofenceMapObject);
    exports.PolygonGeofenceMapObject = PolygonGeofenceMapObject;
});
define("src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/GeofenceLayer", ["require", "exports", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/geofences/RectangleGeofenceMapObject", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/geofences/CircleGeofenceMapObject", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/geofences/PolygonGeofenceMapObject", "src/app/relution/model/geofence/GeofenceStateModel", "src/app/relution/view/world/RelutionMapObjectLayer"], function (require, exports, RectangleGeofenceMapObject_1, CircleGeofenceMapObject_1, PolygonGeofenceMapObject_2, GeofenceStateModel_1, RelutionMapObjectLayer_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GeofenceLayer = void 0;
    let GeofenceLayer = class GeofenceLayer extends RelutionMapObjectLayer_2.RelutionMapObjectLayer {
        // Loading geofence state models
        loadGeofenceStateModels(models) {
            this.resetAllGeofencesToLeftState();
            this.updateGeofenceStates(models);
        }
        resetAllGeofencesToLeftState() {
            for (let i = 0; i < this.getObjects().length; i++) {
                let geofence = this.getObjects()[i];
                let state = new GeofenceStateModel_1.GeofenceStateModel();
                state.geofenceUuid = geofence.getModel().uuid;
                geofence.updateStateModel(state);
            }
        }
        updateGeofenceStates(models) {
            for (let i = 0; i < models.length; i++) {
                let model = models[i];
                let geofence = this.getObjectWithUuid(model.geofenceUuid);
                geofence.updateStateModel(model);
            }
        }
    };
    GeofenceLayer = __decorate([
        (0, RelutionMapObjectLayer_2.RelutionMapObjectBinding)(CircleGeofenceMapObject_1.CircleGeofenceMapObject, PolygonGeofenceMapObject_2.PolygonGeofenceMapObject, RectangleGeofenceMapObject_1.RectangleGeofenceMapObject)
    ], GeofenceLayer);
    exports.GeofenceLayer = GeofenceLayer;
});
define("src/map/utils/Prando", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Prando = void 0;
    /* tslint:disable */
    //Taken from https://github.com/zeh/prando
    class Prando {
        constructor(seed = undefined) {
            if (typeof (seed) === "string") {
                // String seed
                this._seed = this.hashCode(seed);
            }
            else if (typeof (seed) === "number") {
                // Numeric seed
                this._seed = seed;
            }
            else {
                // Pseudo-random seed
                this._seed = Date.now() + Math.random();
            }
            this.reset();
        }
        // ================================================================================================================
        // PUBLIC INTERFACE -----------------------------------------------------------------------------------------------
        /**
         * Generates a pseudo-random number between a lower (inclusive) and a higher (exclusive) bounds.
         *
         * @param min - The minimum number that can be randomly generated.
         * @param pseudoMax - The maximum number that can be randomly generated (exclusive).
         * @return The generated pseudo-random number.
         */
        next(min = 0, pseudoMax = 1) {
            this.recalculate();
            return this.map(this._value, Prando.MIN, Prando.MAX, min, pseudoMax);
        }
        /**
         * Generates a pseudo-random integer number in a range (inclusive).
         *
         * @param min - The minimum number that can be randomly generated.
         * @param max - The maximum number that can be randomly generated.
         * @return The generated pseudo-random number.
         */
        nextInt(min = 10, max = 100) {
            this.recalculate();
            return Math.floor(this.map(this._value, Prando.MIN, Prando.MAX, min, max + 1));
        }
        /**
         * Generates a pseudo-random string sequence of a particular length from a specific character range.
         *
         * Note: keep in mind that creating a random string sequence does not guarantee uniqueness; there is always a
         * 1 in (char_length^string_length) chance of collision. For real unique string ids, always check for
         * pre-existing ids, or employ a robust GUID/UUID generator.
         *
         * @param length - Length of the strting to be generated.
         * @param chars - Characters that are used when creating the random string. Defaults to all alphanumeric chars (A-Z, a-z, 0-9).
         * @return The generated string sequence.
         */
        nextString(length = 16, chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789") {
            let str = "";
            while (str.length < length) {
                str += this.nextChar(chars);
            }
            return str;
        }
        /**
         * Generates a pseudo-random string of 1 character specific character range.
         *
         * @param chars - Characters that are used when creating the random string. Defaults to all alphanumeric chars (A-Z, a-z, 0-9).
         * @return The generated character.
         */
        nextChar(chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789") {
            this.recalculate();
            return chars.substr(this.nextInt(0, chars.length - 1), 1);
        }
        /**
         * Picks a pseudo-random item from an array. The array is left unmodified.
         *
         * Note: keep in mind that while the returned item will be random enough, picking one item from the array at a time
         * does not guarantee nor imply that a sequence of random non-repeating items will be picked. If you want to
         * *pick items in a random order* from an array, instead of *pick one random item from an array*, it's best to
         * apply a *shuffle* transformation to the array instead, then read it linearly.
         *
         * @param array - Array of any type containing one or more candidates for random picking.
         * @return An item from the array.
         */
        nextArrayItem(array) {
            this.recalculate();
            return array[this.nextInt(0, array.length - 1)];
        }
        /**
         * Generates a pseudo-random boolean.
         *
         * @return A value of true or false.
         */
        nextBoolean() {
            this.recalculate();
            return this._value > 0.5;
        }
        /**
         * Skips ahead in the sequence of numbers that are being generated. This is equivalent to
         * calling next() a specified number of times, but faster since it doesn't need to map the
         * new random numbers to a range and return it.
         *
         * @param iterations - The number of items to skip ahead.
         */
        skip(iterations = 1) {
            while (iterations-- > 0) {
                this.recalculate();
            }
        }
        /**
         * Reset the pseudo-random number sequence back to its starting seed. Further calls to next()
         * will then produce the same sequence of numbers it had produced before. This is equivalent to
         * creating a new Prando instance with the same seed as another Prando instance.
         *
         * Example:
         * let rng = new Prando(12345678);
         * console.log(rng.next()); // 0.6177754114889017
         * console.log(rng.next()); // 0.5784605181725837
         * rng.reset();
         * console.log(rng.next()); // 0.6177754114889017 again
         * console.log(rng.next()); // 0.5784605181725837 again
         */
        reset() {
            this._value = this._seed;
        }
        // ================================================================================================================
        // PRIVATE INTERFACE ----------------------------------------------------------------------------------------------
        recalculate() {
            // Xorshift*32
            // Based on George Marsaglia's work: http://www.jstatsoft.org/v08/i14/paper
            this._value ^= this._value << 13;
            this._value ^= this._value >> 17;
            this._value ^= this._value << 5;
        }
        map(val, minFrom, maxFrom, minTo, maxTo) {
            return ((val - minFrom) / (maxFrom - minFrom)) * (maxTo - minTo) + minTo;
        }
        hashCode(str) {
            let hash = 0;
            if (str) {
                let l = str.length;
                for (let i = 0; i < l; i++) {
                    hash = ((hash << 5) - hash) + str.charCodeAt(i);
                    hash |= 0;
                }
            }
            return hash;
        }
    }
    exports.Prando = Prando;
    Prando.MIN = -2147483648; // Int32 min
    Prando.MAX = 2147483647; // Int32 max
});
// tslint:disable
define("src/map/view/world/layers/heatmapLayer/canvas/CanvasHeatmap", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CanvasHeatmap = void 0;
    /**
    Copyright (c) 2015, Vladimir Agafonkin
    All rights reserved.
    
    Redistribution and use in source and binary forms, with or without modification, are
    permitted provided that the following conditions are met:
    
       1. Redistributions of source code must retain the above copyright notice, this list of
          conditions and the following disclaimer.
    
       2. Redistributions in binary form must reproduce the above copyright notice, this list
          of conditions and the following disclaimer in the documentation and/or other materials
          provided with the distribution.
    
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */
    /**
     * Canvas based heatmap implementation based on the SimpleHeat library:
     * https://github.com/mourner/simpleheat
     */
    class CanvasHeatmap {
        constructor(canvas) {
            this.defaultGradient = {
                0.4: 'blue',
                0.6: 'cyan',
                0.7: 'lime',
                0.8: 'yellow',
                1.0: 'red'
            };
            this._canvas = canvas = typeof canvas === 'string' ? document.getElementById(canvas) : canvas;
            this._ctx = canvas.getContext('2d');
            this._width = canvas.width;
            this._height = canvas.height;
            this._max = 1;
            this._data = [];
        }
        data(data) {
            this._data = data;
            return this;
        }
        max(max) {
            this._max = max;
            return this;
        }
        add(point) {
            this._data.push(point);
            return this;
        }
        clear() {
            this._data = [];
            return this;
        }
        radius(r, blur) {
            blur = blur === undefined ? 15 : blur;
            // create a grayscale blurred circle image that we'll use for drawing points
            var circle = this._circle = this._createCanvas(), ctx = circle.getContext('2d'), r2 = this._r = r + blur;
            circle.width = circle.height = r2 * 2;
            ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;
            ctx.shadowBlur = blur;
            ctx.shadowColor = 'black';
            ctx.beginPath();
            ctx.arc(-r2, -r2, r, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fill();
            return this;
        }
        resize() {
            this._width = this._canvas.width;
            this._height = this._canvas.height;
        }
        gradient(grad) {
            // create a 256x1 gradient that we'll use to turn a grayscale heatmap into a colored one
            var canvas = this._createCanvas(), ctx = canvas.getContext('2d'), gradient = ctx.createLinearGradient(0, 0, 0, 256);
            canvas.width = 1;
            canvas.height = 256;
            for (var i in grad) {
                gradient.addColorStop(+i, grad[i]);
            }
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1, 256);
            this._grad = ctx.getImageData(0, 0, 1, 256).data;
            return this;
        }
        draw(minOpacity) {
            if (!this._circle)
                this.radius(this.defaultRadius);
            if (!this._grad)
                this.gradient(this.defaultGradient);
            var ctx = this._ctx;
            ctx.clearRect(0, 0, this._width, this._height);
            // draw a grayscale heatmap by putting a blurred circle at each data point
            for (var i = 0, len = this._data.length, p; i < len; i++) {
                p = this._data[i];
                ctx.globalAlpha = Math.max(p[2] / this._max, minOpacity === undefined ? 0.05 : minOpacity);
                ctx.drawImage(this._circle, p[0] - this._r, p[1] - this._r);
            }
            // colorize the heatmap, using opacity value of each pixel to get the right color from our gradient
            var colored = ctx.getImageData(0, 0, this._width, this._height);
            this._colorize(colored.data, this._grad);
            ctx.putImageData(colored, 0, 0);
            return this;
        }
        _colorize(pixels, gradient) {
            for (var i = 0, len = pixels.length, j; i < len; i += 4) {
                j = pixels[i + 3] * 4; // get gradient color from opacity value
                if (j) {
                    pixels[i] = gradient[j];
                    pixels[i + 1] = gradient[j + 1];
                    pixels[i + 2] = gradient[j + 2];
                }
            }
        }
        _createCanvas() {
            if (typeof document !== 'undefined') {
                return document.createElement('canvas');
            }
            else {
                // create a new canvas instance in node.js
                // the canvas class needs to have a default constructor without any parameter
                return new this._canvas.constructor();
            }
        }
    }
    exports.CanvasHeatmap = CanvasHeatmap;
});
define("src/map/utils/MathUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MathUtils = void 0;
    class MathUtils {
        static getNormalDistributedSample(mean, standardDeviation, prng) {
            let erfc = function (x) {
                let z = Math.abs(x);
                let t = 1 / (1 + z / 2);
                let r = t * Math.exp(-z * z - 1.26551223 + t * (1.00002368 +
                    t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 +
                        t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 +
                            t * (-0.82215223 + t * 0.17087277)))))))));
                return x >= 0 ? r : 2 - r;
            };
            let ierfc = function (x) {
                if (x >= 2) {
                    return -100;
                }
                if (x <= 0) {
                    return 100;
                }
                let xx = (x < 1) ? x : 2 - x;
                let t = Math.sqrt(-2 * Math.log(xx / 2));
                let r = -0.70711 * ((2.30753 + t * 0.27061) /
                    (1 + t * (0.99229 + t * 0.04481)) - t);
                for (let j = 0; j < 2; j++) {
                    let err = erfc(r) - xx;
                    r += err / (1.12837916709551257 * Math.exp(-(r * r)) - r * err);
                }
                return (x < 1) ? r : -r;
            };
            let n = prng.next();
            return mean - standardDeviation * Math.sqrt(2) * ierfc(2 * n);
        }
    }
    exports.MathUtils = MathUtils;
});
define("src/app/relution/view/world/layers/deviceLayers/userCountHeatmapLayer/UserCountHeatmapLayer", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/BeaconMapObject", "src/map/utils/Prando", "src/app/relution/utils/RssiToDistance", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/map/view/world/layers/heatmapLayer/canvas/CanvasHeatmap", "src/map/utils/MathUtils", "src/app/relution/model/usercount/UserCountHeatmapModel"], function (require, exports, DeviceMapObject_5, BeaconMapObject_6, Prando_1, RssiToDistance_2, FloorplanRelatedLayer_6, CanvasHeatmap_1, MathUtils_1, UserCountHeatmapModel_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UserCountHeatmapLayer = void 0;
    class UserCountHeatmapLayer extends FloorplanRelatedLayer_6.FloorplanRelatedLayer {
        // Initialization
        constructor(config, environment, deviceLayer) {
            super(environment, deviceLayer.getFloorplanLayer());
            // Observers
            this.heatmapObservers = new Array();
            // Animation
            this.animationModeEnabled = false;
            this.lastAnimationUpdateTimeInMs = 0;
            this.updatingAnimationRequired = false;
            this.currentAnimationTimeInSec = 0;
            this.heatmapLayerConfig = config;
            this.deviceLayer = deviceLayer;
            this.deviceLayer.addObserver(this);
            this.initView();
        }
        // Observers
        addHeatmapObserver(observer) {
            this.heatmapObservers.push(observer);
        }
        removeHeatmapObserver(observer) {
            let index = this.heatmapObservers.indexOf(observer);
            if (index > -1) {
                this.heatmapObservers.splice(index, 1);
            }
        }
        notifyObservers(callback, args) {
            for (let i = 0; i < this.heatmapObservers.length; i++) {
                let observer = this.heatmapObservers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Event-Handling: Beacon-Layer
        // @Override
        onObjectsLoaded(devices) {
            if (this.heatmapData != null) {
                let drawingHeatmapModel = this.mergedHeatmapModel;
                this.reinitializeHeatmap(drawingHeatmapModel);
            }
        }
        reinitializeHeatmap(drawingHeatmapModel) {
            this.currentHeatmapModel = drawingHeatmapModel;
            // Notify observers
            this.notifyObservers("currentHeatmapModelChanged", [this]);
            // Redraw heatmap
            this.redrawHeatmap(drawingHeatmapModel);
        }
        getUserCount(device) {
            let userCount = -1;
            let heatmapModel = this.getCurrentHeatmapModel();
            if (heatmapModel != null) {
                let heatmapDeviceModel = this.getHeatmapModelForDevice(device, heatmapModel);
                if (heatmapDeviceModel != null) {
                    if (device instanceof BeaconMapObject_6.BeaconMapObject) {
                        if (heatmapModel != null) {
                            let avgNumUsers = heatmapDeviceModel.totalPacketsCount;
                            let avgNumUsersRounded = Math.round(avgNumUsers * 10) / 10;
                            if (isNaN(avgNumUsersRounded)) {
                                avgNumUsersRounded = 0;
                            }
                            userCount = avgNumUsersRounded;
                        }
                        else {
                            userCount = 0;
                        }
                    }
                }
            }
            return userCount;
        }
        getHeatmapModelForDevice(device, heatmapModel) {
            let heatmapData = heatmapModel.data;
            for (let i = 0; i < heatmapData.length; i++) {
                let heatmapDeviceModel = heatmapData[i];
                if (heatmapDeviceModel.deviceUuid === device.getModel().uuid) {
                    return heatmapDeviceModel;
                }
            }
            return null;
        }
        // @Override
        onObjectsUnloaded(devices) {
            // Nothing to do
        }
        // @Override
        onObjectMovedToMap(beacon) {
            // Nothing to do
        }
        // @Override
        onObjectMovedToStock(beacon) {
            // Nothing to do
        }
        // View
        initView() {
            // Init canvas
            this.heatmapCanvas = document.createElement("canvas");
            let floorWidth = this.getFloorplanLayer().getFloorSize().x;
            let floorHeight = this.getFloorplanLayer().getFloorSize().y;
            this.heatmapCanvas.width = this.heatmapLayerConfig.canvasWidth;
            this.heatmapCanvas.height = this.heatmapCanvas.width * (floorHeight / floorWidth);
            // Init Sprite
            let texture = this.getEnvironment().renderer.newTexture(this.heatmapCanvas);
            this.heatmapSprite = this.getEnvironment().renderer.newSpriteObject(texture);
            this.getView().addChild(this.heatmapSprite);
            // Scale
            this.heatmapSprite.width = this.getFloorplanLayer().getFloorSize().x;
            this.heatmapSprite.height = this.getFloorplanLayer().getFloorSize().y;
            // Position
            this.heatmapSprite.x = 0;
            this.heatmapSprite.y = 0;
        }
        // Drawing
        redrawHeatmap(drawingHeatmapModel) {
            this.drawHeatmap(drawingHeatmapModel);
            this.updateTexture();
        }
        // The new heatmap implementation
        drawHeatmap(drawingHeatmapModel) {
            // Create heatmap
            let heatmap = new CanvasHeatmap_1.CanvasHeatmap(this.heatmapCanvas);
            // Configure heatmap
            heatmap.clear();
            heatmap.max(1.0);
            let floorplanWidthInMeter = this.getFloorplanLayer().getFloorSize().x / this.getFloorplanLayer().getModel().pixelPerMeter;
            heatmap.radius(this.heatmapLayerConfig.heatpointRadiusInPixels);
            // Create heatpoints for each device
            let heatmapData = drawingHeatmapModel.data;
            for (let i = 0; i < heatmapData.length; i++) {
                let heatmapModel = heatmapData[i];
                let pnrg = new Prando_1.Prando(drawingHeatmapModel.startTimeSec + heatmapModel.getRandomSeed());
                this.drawHeatpoints(heatmap, heatmapModel, pnrg);
            }
            // Draw heatmap
            heatmap.draw();
        }
        drawHeatpoints(heatmap, heatmapModel, pnrg) {
            // Randomly draw heatpoints around the target beacon.
            let relativeNumOfMeasuredDevices = this.getRelativeNumberOfMeasuredDevices(heatmapModel);
            let numHeatpoints = relativeNumOfMeasuredDevices * 1000;
            for (let j = 0; j < numHeatpoints; j++) {
                // Noise for length
                // let mean = this.getMeanUserDistanceInMeter(heatmapModel);
                let mean = 0;
                let maxNoiseDistanceToBeaconInMeter = RssiToDistance_2.RssiToDistance.rssiToDistance(this.heatmapLayerConfig.maxReceivableRssi);
                let standardDeviationInMeter = maxNoiseDistanceToBeaconInMeter / 6;
                let noiseDistanceInMeter = MathUtils_1.MathUtils.getNormalDistributedSample(mean, standardDeviationInMeter, pnrg);
                let floorplanWidthInMeter = this.getFloorplanLayer().getFloorSize().x / this.getFloorplanLayer().getModel().pixelPerMeter;
                let noiseDistanceInCanvasPixels = (noiseDistanceInMeter / floorplanWidthInMeter) * this.heatmapCanvas.width;
                // Noise for direction
                let noiseAngle = 2 * Math.PI * pnrg.next();
                // Position
                let deviceModel = this.getDeviceModelForHeatmapModel(heatmapModel);
                if (deviceModel != null) {
                    let x = (deviceModel.x * this.heatmapCanvas.width) + noiseDistanceInCanvasPixels * Math.cos(noiseAngle);
                    let y = (deviceModel.y * this.heatmapCanvas.height) + noiseDistanceInCanvasPixels * Math.sin(noiseAngle);
                    // Add heatpoint
                    heatmap.add([x, y, 1]);
                }
            }
        }
        getRelativeNumberOfMeasuredDevices(heatmapModel) {
            let kMinExpectedNumDevices = 0;
            let kMaxExpectedNumDevices = this.heatmapLayerConfig.definitionOfManyDevices;
            // Actually the number of active devices are delivered and not "totalPacketsCount".
            let numActiveDevicesInTimeInterval = heatmapModel.totalPacketsCount;
            // The number of reports delivered in the selected time interval.
            let packetsInTimeInterval = heatmapModel.totalPackets;
            if (numActiveDevicesInTimeInterval <= 0 || packetsInTimeInterval <= 0) {
                return 0;
            }
            // Relative number of devices \in [0,infinity], where 1 means kMaxExpectedNumDevices.
            let relativeNumberOfDevices = (numActiveDevicesInTimeInterval - kMinExpectedNumDevices)
                / (kMaxExpectedNumDevices - kMinExpectedNumDevices);
            relativeNumberOfDevices = Math.min(Math.max(0, relativeNumberOfDevices), 1);
            return relativeNumberOfDevices;
        }
        getDeviceModelForHeatmapModel(heatmapModel) {
            let devices = this.deviceLayer.getAllDevices();
            for (let i = 0; i < devices.length; i++) {
                let deviceModel = devices[i].getModel();
                if (deviceModel.uuid === heatmapModel.deviceUuid) {
                    return deviceModel;
                }
            }
            return null;
        }
        updateTexture() {
            this.heatmapSprite.texture.load(this.heatmapCanvas);
        }
        // Model
        loadHeatmapData(heatmapData) {
            this.heatmapData = heatmapData;
            let devices = this.deviceLayer.getAllDevices();
            if (devices != null) {
                // Update merged heatmap data
                this.mergedHeatmapModel = UserCountHeatmapModel_1.UserCountHeatmapModel.createMergedHeatmapModel(this.heatmapData);
                // Redraw heatmap
                this.reinitializeHeatmap(this.mergedHeatmapModel);
            }
        }
        // Animation
        // @Override
        onAnimationModeEnabled(animationModeEnabled) {
            this.animationModeEnabled = animationModeEnabled;
            if (!this.animationModeEnabled) {
                if (this.heatmapData != null) {
                    this.reinitializeHeatmap(this.mergedHeatmapModel);
                }
            }
        }
        // @Override
        onUpdateAnimationFrame(timeInSec) {
            this.currentAnimationTimeInSec = timeInSec;
            this.updatingAnimationRequired = true;
        }
        getProgressForTime(timeInSec) {
            let startTimeSec = this.mergedHeatmapModel.startTimeSec;
            let endTimeSec = this.mergedHeatmapModel.endTimeSec;
            // Constrain to borders
            timeInSec = Math.max(startTimeSec, Math.min(endTimeSec, timeInSec));
            // Get progress
            let progress = (timeInSec - startTimeSec) / (endTimeSec - startTimeSec);
            return progress;
        }
        updateHeatmapAnimation(currentProgress) {
            // Redraw heatmap
            if (this.heatmapData != null) {
                let currentAnimatedHeatmapModel = this.getCurrentAnimatedHeatmapModel(currentProgress);
                if (currentAnimatedHeatmapModel != null) {
                    this.reinitializeHeatmap(currentAnimatedHeatmapModel);
                }
            }
        }
        getCurrentAnimatedHeatmapModel(currentProgress) {
            let startTimeInMs = this.mergedHeatmapModel.startTimeSec;
            let endTimeInMs = this.mergedHeatmapModel.endTimeSec;
            let progressTimeInMs = startTimeInMs + (currentProgress * (endTimeInMs - startTimeInMs));
            // Find the heatmap model that matches with the progress time
            for (let i = 0; i < this.heatmapData.length; i++) {
                let heatmapModel = this.heatmapData[i];
                if (heatmapModel.startTimeSec <= progressTimeInMs && heatmapModel.endTimeSec >= progressTimeInMs) {
                    return heatmapModel;
                }
            }
            return null;
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            this.updateAnimationIfNecessary();
        }
        updateAnimationIfNecessary() {
            if (this.updatingAnimationRequired && this.animationModeEnabled) {
                if (this.heatmapData != null) {
                    let timeSinceLastUpdateInMs = Date.now() - this.lastAnimationUpdateTimeInMs;
                    if (timeSinceLastUpdateInMs > 1000) {
                        let currentProgress = this.getProgressForTime(this.currentAnimationTimeInSec);
                        this.updateHeatmapAnimation(currentProgress);
                        this.lastAnimationUpdateTimeInMs = Date.now();
                        this.updatingAnimationRequired = false;
                    }
                }
            }
        }
        // Popup info
        // @Override
        onPopupContentRequested(relutionMapObject) {
            if (relutionMapObject instanceof DeviceMapObject_5.DeviceMapObject) {
                const userCount = this.getUserCount(relutionMapObject);
                if (userCount !== -1) {
                    return this.getLocalizedStringFor("popup_device_user_count") + ": " + userCount;
                }
            }
            return null;
        }
        // Getters and setters
        getMergedHeatmapModel() {
            return this.mergedHeatmapModel;
        }
        getCurrentHeatmapModel() {
            return this.currentHeatmapModel;
        }
    }
    exports.UserCountHeatmapLayer = UserCountHeatmapLayer;
    (function (UserCountHeatmapLayer) {
        class Config {
            constructor() {
                /**
                 * The width of the canvas in texels
                 */
                this.canvasWidth = 1024;
                /**
                 * The number of measured devices that are necessary
                 * to display the beacon as "hot".
                 */
                this.definitionOfManyDevices = 5;
                /**
                 * RSSI thrshold
                 */
                this.maxReceivableRssi = -80; // RSSI threshold
                /**
                 * The heatpoint radius given in texels
                 */
                this.heatpointRadiusInPixels = 2;
            }
        }
        UserCountHeatmapLayer.Config = Config;
    })(UserCountHeatmapLayer = exports.UserCountHeatmapLayer || (exports.UserCountHeatmapLayer = {}));
});
define("src/app/relution/view/world/layers/floorplanLayers/wallplanLayer/WallplanLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer"], function (require, exports, FloorplanRelatedLayer_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WallplanLayer = void 0;
    class WallplanLayer extends FloorplanRelatedLayer_7.FloorplanRelatedLayer {
        // Construction
        constructor(config, environment, floorplanLayer, texture) {
            super(environment, floorplanLayer);
            this.wallplanLayerConfig = config;
            if (texture !== null && texture !== undefined) {
                this.initWallplanSprite(texture);
            }
        }
        initWallplanSprite(texture) {
            // Add texture to sprite
            this.wallplanSprite = this.getEnvironment().renderer.newSpriteObject();
            this.wallplanSprite.texture = texture;
            // Scale
            this.wallplanSprite.width = this.getFloorplanLayer().getFloorSize().x;
            this.wallplanSprite.height = this.getFloorplanLayer().getFloorSize().y;
            // Alpha
            this.wallplanSprite.alpha = 0.5;
            // Add sprite to scene graph
            this.getView().addChild(this.wallplanSprite);
            if (this.wallplanLayerConfig.useMasking) {
                // Set inverse wallmap as mask
                this.wallplanMaskSprite = this.getEnvironment().renderer.newSpriteObject();
                this.wallplanMaskSprite.texture = texture;
                this.wallplanMaskSprite.width = this.wallplanSprite.width;
                this.wallplanMaskSprite.height = this.wallplanSprite.height;
                if (this.wallplanLayerConfig.useInverseMask) {
                    this.wallplanSprite.mask = this.wallplanMaskSprite;
                }
                else {
                    this.wallplanSprite.mask = this.wallplanMaskSprite;
                }
                this.getView().addChild(this.wallplanMaskSprite);
            }
        }
    }
    exports.WallplanLayer = WallplanLayer;
    (function (WallplanLayer) {
        class Config {
            constructor() {
                /**
                 * True, if the wallplan layer should be masked
                 * (pixel intensity will be used for the alpha channel, as well).
                 *
                 * Default: true
                 */
                this.useMasking = true;
                /**
                 * True, if an inverse mask should be used.
                 * Inverse means that the black pixel values will be invisible,
                 * while the white ones will be opaque.
                 *
                 * Default: true
                 */
                this.useInverseMask = true;
            }
        }
        WallplanLayer.Config = Config;
    })(WallplanLayer = exports.WallplanLayer || (exports.WallplanLayer = {}));
});
define("src/app/relution/model/device/DeviceTagModel", ["require", "exports", "src/app/relution/model/RelutionMapObjectModel", "src/app/relution/model/Model"], function (require, exports, RelutionMapObjectModel_4, Model_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeviceTagModel = void 0;
    class DeviceTagModel extends RelutionMapObjectModel_4.RelutionMapObjectModel {
        constructor() {
            // Attributes
            super(...arguments);
            /**
             * The device UUID
             */
            this._deviceUuid = null;
            /**
             * The device ID, e.g. ABBB2
             */
            this._deviceId = "";
            /**
             * True, if the user explicitly set the coordinates.
             * False, otherwise. In this case the coordinates must be ignored.
             */
            this._valid = false;
            /**
             * x in [0,1] relative to the floorplan
             */
            this._x = 0;
            /**
             * y in [0,1] relative to the floorplan
             */
            this._y = 0;
        }
        // Getters and setters
        get deviceUuid() {
            return this._deviceUuid;
        }
        set deviceUuid(deviceUuid) {
            this._deviceUuid = deviceUuid;
        }
        get deviceId() {
            return this._deviceId;
        }
        set deviceId(deviceId) {
            this._deviceId = deviceId;
            this.notifyObservers("deviceId");
        }
        get valid() {
            return this._valid;
        }
        set valid(valid) {
            this._valid = valid;
            this.notifyObservers("valid");
        }
        get x() {
            return this._x;
        }
        set x(x) {
            this._x = x;
            this.notifyObservers("x");
        }
        get y() {
            return this._y;
        }
        set y(y) {
            this._y = y;
            this.notifyObservers("y");
        }
    }
    __decorate([
        (0, RelutionMapObjectModel_4.ParentModel)(),
        (0, Model_9.ModelProperty)()
    ], DeviceTagModel.prototype, "_deviceUuid", void 0);
    __decorate([
        (0, Model_9.ModelProperty)()
    ], DeviceTagModel.prototype, "_deviceId", void 0);
    __decorate([
        (0, Model_9.ModelProperty)()
    ], DeviceTagModel.prototype, "_valid", void 0);
    __decorate([
        (0, Model_9.ModelProperty)()
    ], DeviceTagModel.prototype, "_x", void 0);
    __decorate([
        (0, Model_9.ModelProperty)()
    ], DeviceTagModel.prototype, "_y", void 0);
    exports.DeviceTagModel = DeviceTagModel;
});
define("src/map/view/hud/objects/ArrowObject", ["require", "exports", "src/engine/scene/SceneObject", "src/engine/math/Vector2", "src/map/utils/DeviceUtils"], function (require, exports, SceneObject_5, Vector2_26, DeviceUtils_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrowObject = void 0;
    class ArrowObject extends SceneObject_5.SceneObject {
        // Initialization
        constructor(config, environment) {
            super(environment);
            this.config = config;
            this.initView();
        }
        initView() {
            this.container = this.getEnvironment().renderer.newDisplayObjectContainer();
            this.initLineView(this.config.arrowBodyTextureName);
            this.initArrowHeadView(this.config.arrowHeadTextureName);
            this.getView().visible = false;
        }
        initLineView(arrowBodyTextureName) {
            this.lineView = this.getEnvironment().renderer.newSpriteObject();
            this.lineView.texture = this.getEnvironment().renderer.getTexture("" + arrowBodyTextureName);
            this.lineView.tint = this.config.bodyColor;
            this.getView().addChild(this.lineView);
        }
        initArrowHeadView(arrowHeadTextureName) {
            this.arrowHeadView = this.getEnvironment().renderer.newSpriteObject();
            this.arrowHeadView.texture = this.getEnvironment().renderer.getTexture("" + arrowHeadTextureName);
            this.arrowHeadView.tint = this.config.headColor;
            this.getView().addChild(this.arrowHeadView);
        }
        // View
        // @Override
        getView() {
            return this.container;
        }
        getWidth() {
            return this.lineView.texture.width;
        }
        getHeight() {
            return this.lineView.texture.height;
        }
        setBodyColor(bodyColor) {
            this.config.bodyColor = bodyColor;
            this.lineView.tint = this.config.bodyColor;
        }
        getBodyColor() {
            return this.config.bodyColor;
        }
        // Drawing
        draw(sourcePositionInWorldTx, targetPositionInWorldTx, arrowThickness) {
            // Precomputation
            let sourceVector = sourcePositionInWorldTx;
            let targetVector = targetPositionInWorldTx;
            let differenceVector = Vector2_26.Vector2.subtract(targetVector, sourceVector);
            let arrowLength = differenceVector.getLength();
            // Arrow construction
            this.constructArrow(arrowLength, arrowThickness);
            // Arrow transformation
            this.transformArrow(sourceVector, targetVector);
            // Set visible
            this.getView().visible = true;
        }
        constructArrow(arrowLength, arrowThickness) {
            let thickness = DeviceUtils_12.DeviceUtils.getPhysicalPixelsFromLogical(arrowThickness);
            this.constructLine(arrowLength, thickness);
            this.constructArrowHead();
        }
        constructLine(arrowLength, thickness) {
            // Pivot
            this.lineView.pivot.x = 0;
            this.lineView.pivot.y = this.lineView.texture.height / 2;
            // Scale
            this.lineView.scale.x = arrowLength / this.getWidth();
            this.lineView.scale.y = thickness / this.getHeight();
        }
        constructArrowHead() {
            // Pivot
            this.arrowHeadView.pivot.x = this.arrowHeadView.texture.width;
            this.arrowHeadView.pivot.y = this.arrowHeadView.texture.height / 2;
            // Scale
            let camera = this.getScene().getCamera();
            let arrowHeadWidthInPhysicalPx = DeviceUtils_12.DeviceUtils.getPhysicalPixelsFromLogical(this.config.arrowHeadLengthInLogicalPx);
            let worldHeadWidthPointSource = camera.getWorldCoordinateFromImagePoint(new Vector2_26.Vector2(0, 0));
            let worldHeadWidthPointTarget = camera.getWorldCoordinateFromImagePoint(new Vector2_26.Vector2(arrowHeadWidthInPhysicalPx, 0));
            let worldHeadWidthPoint = new Vector2_26.Vector2(worldHeadWidthPointTarget.x - worldHeadWidthPointSource.x, worldHeadWidthPointTarget.y - worldHeadWidthPointSource.y);
            let arrowHeadWidthInTexels = Vector2_26.Vector2.getLengthOfPoint(worldHeadWidthPoint);
            let maxArrowHeadWidthInTexels = this.lineView.width * this.config.maxArrowHeadLengthInPercent;
            arrowHeadWidthInTexels = Math.min(maxArrowHeadWidthInTexels, arrowHeadWidthInTexels);
            this.arrowHeadView.width = arrowHeadWidthInTexels;
            this.arrowHeadView.height = (this.arrowHeadView.texture.height / this.arrowHeadView.texture.width) * this.arrowHeadView.width;
            // Rotation
            this.arrowHeadView.rotation = 0;
            // Translation
            this.arrowHeadView.x = this.lineView.width;
            this.arrowHeadView.y = 0;
        }
        transformArrow(sourceVector, targetVector) {
            // Preparation
            let differenceVector = Vector2_26.Vector2.subtract(targetVector, sourceVector);
            // Pivot
            this.getView().pivot.x = this.lineView.width / 2;
            this.getView().pivot.y = 0;
            // Rotate
            let baseVector = new Vector2_26.Vector2(1, 0);
            let rotation = -Vector2_26.Vector2.getAngleBetween(differenceVector, baseVector);
            // Sign
            let crossProduct = Vector2_26.Vector2.crossProduct(baseVector, differenceVector);
            if (crossProduct > 0) {
                this.getView().rotation = -rotation;
            }
            else {
                this.getView().rotation = rotation;
            }
            // Position
            let centerVector = Vector2_26.Vector2.add(sourceVector, targetVector).divide(2);
            this.getView().position.x = centerVector.getX();
            this.getView().position.y = centerVector.getY();
        }
    }
    exports.ArrowObject = ArrowObject;
    (function (ArrowObject) {
        class Config {
            constructor() {
                this.arrowBodyTextureName = "arrow_body";
                this.arrowHeadTextureName = "arrow_head";
                this.arrowHeadLengthInLogicalPx = DeviceUtils_12.DeviceUtils.getPhysicalPixelsFromLogical(12);
                this.maxArrowHeadLengthInPercent = 0.2;
                this.bodyColor = 0x000000;
                this.headColor = 0x000000;
            }
        }
        ArrowObject.Config = Config;
    })(ArrowObject = exports.ArrowObject || (exports.ArrowObject = {}));
});
define("src/app/relution/view/world/layers/deviceLayers/deviceTaggingLayer/DeviceTagMapObject", ["require", "exports", "src/app/relution/model/device/DeviceModel", "src/app/relution/view/world/RelutionMapObject", "src/app/relution/model/device/DeviceTagModel", "src/map/view/hud/objects/ArrowObject", "src/map/utils/DeviceUtils", "src/engine/math/Vector2", "src/engine/utils/IntersectionUtils"], function (require, exports, DeviceModel_6, RelutionMapObject_12, DeviceTagModel_1, ArrowObject_1, DeviceUtils_13, Vector2_27, IntersectionUtils_5) {
    "use strict";
    var DeviceTagMapObject_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeviceTagMapObject = void 0;
    let DeviceTagMapObject = DeviceTagMapObject_1 = class DeviceTagMapObject extends RelutionMapObject_12.RelutionMapObject {
        // Construction
        constructor(config, environment, floorplanLayer, model, device) {
            super(config, environment, floorplanLayer, model, device);
            // State: Scaling
            this.lastDeviceScaleFactor = -1;
            this.invalidated = true;
            this.device = device;
            this.initTagView();
        }
        initTagView() {
            this.initArrowObject();
            this.initReferencePositionView();
            this.initEstimatedPositionView();
        }
        initReferencePositionView() {
            this.referencePositionView = this.getEnvironment().renderer.newSpriteObject();
            this.initPositionView(this.referencePositionView);
            this.referencePositionView.tint = DeviceTagMapObject_1.REFERENCE_POSITION_COLOR;
        }
        initEstimatedPositionView() {
            this.estimatedPositionView = this.getEnvironment().renderer.newSpriteObject();
            this.initPositionView(this.estimatedPositionView);
            this.estimatedPositionView.tint = DeviceTagMapObject_1.ESTIMATED_POSITION_COLOR;
        }
        initPositionView(spriteView) {
            this.getView().addChild(spriteView);
            // Texture
            spriteView.texture = this.getEnvironment().renderer.getTexture("asset_device_white");
            // Pivot
            spriteView.pivot.x = spriteView.width / 2;
            spriteView.pivot.y = spriteView.height;
            // Scale
            spriteView.width = this.device.getView().width;
            spriteView.height = this.device.getView().height;
            // Position
            this.syncPositionWithDevice();
            // Alpha
            spriteView.alpha = 0.0;
        }
        initArrowObject() {
            let arrowObjectConfig = new ArrowObject_1.ArrowObject.Config();
            arrowObjectConfig.arrowHeadLengthInLogicalPx = DeviceUtils_13.DeviceUtils.getPhysicalPixelsFromLogical(15);
            arrowObjectConfig.maxArrowHeadLengthInPercent = 0.2;
            arrowObjectConfig.bodyColor = DeviceTagMapObject_1.REFERENCE_POSITION_COLOR;
            arrowObjectConfig.headColor = arrowObjectConfig.bodyColor;
            this.arrowObject = new ArrowObject_1.ArrowObject(arrowObjectConfig, this.getEnvironment());
            this.arrowObject.getView().alpha = 0.0;
            this.addChild(this.arrowObject);
        }
        // Model
        // Tag model event handling
        // @Override
        onModelUpdated(model) {
            this.invalidated = true;
        }
        // Device model event handling
        // @Override
        xChanged(deviceModel) {
            if (deviceModel instanceof DeviceModel_6.DeviceModel) {
                this.syncPositionWithDevice();
                this.invalidated = true;
            }
        }
        // @Override
        yChanged(deviceModel) {
            if (deviceModel instanceof DeviceModel_6.DeviceModel) {
                this.syncPositionWithDevice();
                this.invalidated = true;
            }
        }
        syncPositionWithDevice() {
            // Tag view should only move, if currently no valid tags exist (user has not tagged the device yet).
            if (!this.getModel().valid) {
                this.getModel().x = this.device.getModel().getPosition().x;
                this.getModel().y = this.device.getModel().getPosition().y;
            }
        }
        // Rendering
        // @Override
        getAabbReferenceView() {
            return this.referencePositionView;
        }
        // @Override
        redraw() {
            this.invalidated = true;
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.getView().worldAlpha > 0) {
                this.updateScale();
                this.invalidated = false;
            }
        }
        updateScale() {
            let camera = this.getScene().getCamera();
            let scaleFactor = camera.getScaleX();
            if (this.lastDeviceScaleFactor !== scaleFactor || this.invalidated) {
                this.lastDeviceScaleFactor = scaleFactor;
                this.retransformEstimatedPositionView();
                this.retransformReferencePositionView();
                this.retransformArrowObject(scaleFactor);
            }
        }
        retransformEstimatedPositionView() {
            if (this.getModel().valid) {
                // Scale
                this.estimatedPositionView.width = this.device.getView().width;
                this.estimatedPositionView.height = this.device.getView().height;
                // Orientation
                this.estimatedPositionView.rotation = this.device.getView().rotation;
                // Position
                this.estimatedPositionView.x = this.device.getView().x;
                this.estimatedPositionView.y = this.device.getView().y;
                // Alpha
                this.estimatedPositionView.alpha = DeviceTagMapObject_1.ESTIMATED_POSITION_ALPHA;
            }
            else {
                // Alpha
                this.estimatedPositionView.alpha = 0.0;
            }
        }
        retransformReferencePositionView() {
            // Scale
            this.referencePositionView.width = this.device.getView().width;
            this.referencePositionView.height = this.device.getView().height;
            // Orientation
            this.referencePositionView.rotation = this.device.getView().rotation;
            // Position
            if (this.getModel().valid) {
                this.referencePositionView.x = this.getModel().x * this.getFloorplanLayer().getFloorSize().x;
                this.referencePositionView.y = this.getModel().y * this.getFloorplanLayer().getFloorSize().y;
            }
            else {
                this.referencePositionView.x = this.device.getView().x;
                this.referencePositionView.y = this.device.getView().y;
            }
            // Alpha
            if (this.getModel().valid) {
                this.referencePositionView.alpha = DeviceTagMapObject_1.REFERENCE_POSITION_ALPHA;
            }
            else {
                if (this.isMouseOver()) {
                    this.referencePositionView.alpha = 1.0;
                }
                else {
                    this.referencePositionView.alpha = 0.0;
                }
            }
        }
        retransformArrowObject(scaleFactor) {
            if (this.getModel().valid) {
                // Line width
                let lineWidth = DeviceTagMapObject_1.LINE_WIDTH_IN_PX * scaleFactor;
                // Start and end position
                let devicePosition = this.device.getModel().getPosition();
                let deviceTagPosition = new Vector2_27.Vector2(this.getModel().x, this.getModel().y);
                let sourcePosition = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(devicePosition);
                let targetPosition = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(deviceTagPosition);
                // Resolve interpenetration for sprite view
                targetPosition = this.resolveInterpenetration(sourcePosition, targetPosition, this.referencePositionView);
                // Resolve interpenetration for device view
                sourcePosition = this.resolveInterpenetration(targetPosition, sourcePosition, this.device.getView());
                // Padding
                let paddingInTx = this.getFloorplanLayer().getTexelWidthFromPixelWidth(DeviceTagMapObject_1.PADDING_IN_PX);
                this.addPaddingToArrowObject(sourcePosition, targetPosition, paddingInTx);
                // Rendering
                this.arrowObject.draw(sourcePosition, targetPosition, lineWidth);
                // Alpha
                this.arrowObject.getView().alpha = DeviceTagMapObject_1.ESTIMATED_POSITION_ALPHA;
            }
            else {
                this.arrowObject.getView().alpha = 0.0;
            }
        }
        resolveInterpenetration(sourcePosition, targetPosition, penetratedView) {
            // Tag corners
            let boundsInScreenPx = penetratedView.getBounds();
            let topLeft = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_27.Vector2(boundsInScreenPx.x + 0, boundsInScreenPx.y + 0));
            let topRight = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_27.Vector2(boundsInScreenPx.x + boundsInScreenPx.width, boundsInScreenPx.y + 0));
            let bottomRight = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_27.Vector2(boundsInScreenPx.x + boundsInScreenPx.width, boundsInScreenPx.y + boundsInScreenPx.height));
            let bottomLeft = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_27.Vector2(boundsInScreenPx.x + 0, boundsInScreenPx.y + boundsInScreenPx.height));
            // Top edge intersection test
            let intersectingPoint = null;
            intersectingPoint = IntersectionUtils_5.IntersectionUtils.getIntersectingPointOfTwoVectors(sourcePosition, targetPosition, topLeft, topRight);
            if (intersectingPoint !== null) {
                return intersectingPoint;
            }
            // Right edge intersection test
            intersectingPoint = IntersectionUtils_5.IntersectionUtils.getIntersectingPointOfTwoVectors(sourcePosition, targetPosition, topRight, bottomRight);
            if (intersectingPoint !== null) {
                return intersectingPoint;
            }
            // Bottom edge intersection test
            intersectingPoint = IntersectionUtils_5.IntersectionUtils.getIntersectingPointOfTwoVectors(sourcePosition, targetPosition, bottomRight, bottomLeft);
            if (intersectingPoint !== null) {
                return intersectingPoint;
            }
            // Left edge intersection test
            intersectingPoint = IntersectionUtils_5.IntersectionUtils.getIntersectingPointOfTwoVectors(sourcePosition, targetPosition, bottomLeft, topLeft);
            if (intersectingPoint !== null) {
                return intersectingPoint;
            }
            // Return the passed target position, if no intersection was found.
            return targetPosition;
        }
        addPaddingToArrowObject(sourcePosition, targetPosition, paddingInTx) {
            // Get normalized direction vector towards target position.
            let v = new Vector2_27.Vector2(targetPosition.x - sourcePosition.x, targetPosition.y - sourcePosition.y);
            v.normalize();
            // Add padding to source position
            sourcePosition.x = sourcePosition.x + v.getX() * paddingInTx;
            sourcePosition.y = sourcePosition.y + v.getY() * paddingInTx;
            // Add padding to target position
            targetPosition.x = targetPosition.x - v.getX() * paddingInTx;
            targetPosition.y = targetPosition.y - v.getY() * paddingInTx;
        }
        // Name
        // @Override
        getName() {
            return this.device.getName();
        }
        // Popup info
        // @Override
        getPopupInfo() {
            return this.device.getPopupInfo();
        }
        // Moving
        // @Override
        onMoveStarted(x, y) {
            this.getModel().valid = true;
            let mouseInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_27.Vector2(x, y));
            let viewPositionInTx = this.referencePositionView.position;
            this.movingPointInLocalTx = new Vector2_27.Vector2(mouseInTx.x - viewPositionInTx.x, mouseInTx.y - viewPositionInTx.y);
        }
        // @Override
        onMoveChanged(x, y) {
            let mouseInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_27.Vector2(x, y));
            let xInTx = mouseInTx.x - this.movingPointInLocalTx.x;
            let yInTx = mouseInTx.y - this.movingPointInLocalTx.y;
            this.updateModelPositionFromViewPosition(xInTx, yInTx);
        }
        // @Override
        onMoveStopped(x, y) {
            this.onMoveChanged(x, y);
        }
        updateModelPositionFromViewPosition(xInTx, yInTx) {
            this.getModel().x = xInTx / this.getFloorplanLayer().getFloorSize().x;
            this.getModel().y = yInTx / this.getFloorplanLayer().getFloorSize().y;
            this.invalidated = true;
        }
        // Getters and setters
        getDevice() {
            return this.device;
        }
        getNamePosition(textBound) {
            return new Vector2_27.Vector2(this.getCenter().x, textBound.height * -1);
        }
        // @Override
        getModel() {
            return super.getModel();
        }
    };
    // Constants
    DeviceTagMapObject.REFERENCE_POSITION_COLOR = 0x5555ff;
    DeviceTagMapObject.ESTIMATED_POSITION_COLOR = 0x5555ff;
    DeviceTagMapObject.REFERENCE_POSITION_ALPHA = 0.5;
    DeviceTagMapObject.ESTIMATED_POSITION_ALPHA = 1.0;
    DeviceTagMapObject.PADDING_IN_PX = DeviceUtils_13.DeviceUtils.getPhysicalPixelsFromLogical(3);
    DeviceTagMapObject.LINE_WIDTH_IN_PX = DeviceUtils_13.DeviceUtils.getPhysicalPixelsFromLogical(1);
    DeviceTagMapObject = DeviceTagMapObject_1 = __decorate([
        (0, RelutionMapObject_12.RelutionModelBinding)(DeviceTagModel_1.DeviceTagModel)
    ], DeviceTagMapObject);
    exports.DeviceTagMapObject = DeviceTagMapObject;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceTaggingLayer/DeviceTaggingLayer", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceTaggingLayer/DeviceTagMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/AssetMapObject", "src/app/relution/view/world/RelutionMapObjectLayer", "src/app/relution/model/device/DeviceTagModel"], function (require, exports, DeviceTagMapObject_2, AssetMapObject_3, RelutionMapObjectLayer_3, DeviceTagModel_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeviceTaggingLayer = void 0;
    /**
     * <h1> A layer that manages the tags of a device.</h1>
     *
     * <p>
     * This class inherits the {@link RelutionMapObjectLayer} base class, as device tags
     * can be moved, selected and hovered independently from the depending devices.
     * However, since device tags existentially depend on devices, the tags' life time
     * is coupled to the corresponding devices. Hence, a device tag is also a Relution map
     * attribute object depending on a device.
     * </p>
     */
    let DeviceTaggingLayer = class DeviceTaggingLayer extends RelutionMapObjectLayer_3.RelutionMapObjectLayer {
        // Construction
        constructor(config, environment, deviceLayer) {
            super(config, environment, deviceLayer.getFloorplanLayer(), deviceLayer);
            this.setModelFactory((parentModel) => {
                let device = deviceLayer.getDeviceWithUuid(parentModel.uuid);
                // Consider only tracked assets
                if (device instanceof AssetMapObject_3.AssetMapObject && !device.getModel().onMap) {
                    let model = new DeviceTagModel_2.DeviceTagModel();
                    model.deviceId = device.getModel().deviceId;
                    return model;
                }
                else {
                    return null;
                }
            });
            this.setObjectFactory((model, config) => {
                let device = deviceLayer.getDeviceWithUuid(model.parentUuid);
                if (device !== null) {
                    return new DeviceTagMapObject_2.DeviceTagMapObject(config, environment, this.getFloorplanLayer(), model, device);
                }
                else {
                    return null;
                }
            });
        }
    };
    DeviceTaggingLayer = __decorate([
        (0, RelutionMapObjectLayer_3.RelutionMapObjectBinding)(DeviceTagMapObject_2.DeviceTagMapObject)
    ], DeviceTaggingLayer);
    exports.DeviceTaggingLayer = DeviceTaggingLayer;
});
define("src/app/relution/view/world/layers/floorplanLayers/floorplanOverlayLayer/FloorplanOverlayLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer"], function (require, exports, FloorplanRelatedLayer_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FloorplanOverlayLayer = void 0;
    class FloorplanOverlayLayer extends FloorplanRelatedLayer_8.FloorplanRelatedLayer {
        // Construction
        constructor(environment, floorplanLayer, name, texture) {
            super(environment, floorplanLayer);
            if (texture !== null && texture !== undefined) {
                this.name = name;
                this.initSprite(texture);
            }
        }
        initSprite(texture) {
            // Add texture to sprite
            this.sprite = this.getEnvironment().renderer.newSpriteObject();
            this.sprite.texture = texture;
            // Scale
            this.sprite.width = this.getFloorplanLayer().getFloorSize().x;
            this.sprite.height = this.getFloorplanLayer().getFloorSize().y;
            // Alpha
            this.sprite.alpha = 0.5;
            // Add sprite to scene graph
            this.getView().addChild(this.sprite);
        }
        // Getters and setters
        getName() {
            return this.name;
        }
    }
    exports.FloorplanOverlayLayer = FloorplanOverlayLayer;
});
define("src/app/relution/view/world/layers/objectLayers/objectInfoLayer/RelutionMapObjectInfo", ["require", "exports", "src/map/utils/DeviceUtils", "src/app/relution/view/world/RelutionMapAttributeObject", "src/engine/math/Vector2"], function (require, exports, DeviceUtils_14, RelutionMapAttributeObject_6, Vector2_28) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RelutionMapObjectInfo = void 0;
    class RelutionMapObjectInfo extends RelutionMapAttributeObject_6.RelutionMapAttributeObject {
        // Initialization
        constructor(environment, mapObject) {
            super(environment, mapObject);
            // View: Updating
            this.invalidated = true;
            this.lastScaleFactor = -1;
            this.lastOrientation = -1;
            this.lastScaleFactorForTranslation = -1;
            this.initModel(mapObject);
            this.initView();
        }
        initModel(mapObject) {
            this.mapObject = mapObject;
            this.mapObject.getModel().addObserver(this);
        }
        initView() {
            this.container = this.getEnvironment().renderer.newDisplayObjectContainer();
            this.getView().addChild(this.container);
        }
        // Localization Event-Handling
        // @Override
        initialize() {
            super.initialize();
            this.updateTitle();
        }
        // @Override
        onLocalizationChanged() {
            this.updateTitle();
            return false;
        }
        updateTitle() {
            // Remove old title view
            if (this.titleView != null) {
                this.getView().removeChild(this.titleView);
                this.titleView = null;
            }
            // Create new title view
            let fontSize = DeviceUtils_14.DeviceUtils.getPhysicalPixelsFromLogical(16);
            let textStyle = this.getEnvironment().renderer.newTextStyle();
            textStyle.fill = 0x000000;
            textStyle.fontFamily = "Arial";
            textStyle.fontSize = fontSize;
            textStyle.dropShadow = true;
            textStyle.dropShadowAlpha = 0.8;
            textStyle.dropShadowAngle = Math.PI / 6;
            textStyle.dropShadowBlur = 8;
            textStyle.dropShadowColor = "#ffffff";
            textStyle.dropShadowDistance = 0;
            this.titleView = this.getEnvironment().renderer.newTextObject("", 1, textStyle);
            this.getView().addChild(this.titleView);
            // Set text
            this.titleView.text = "" + this.mapObject.getName();
            // Pivot
            this.titleView.pivot.x = this.titleView.width / 2;
            this.titleView.pivot.y = this.titleView.height / 2;
            // Redraw
            this.invalidated = true;
        }
        // View
        syncPosition() {
            let worldCamera = this.getScene().getCamera();
            let objectBoundsInImage = this.mapObject.getAabbInImageCoordinates();
            let textBounds = this.titleView.getBounds();
            let textPos = this.mapObject.getNamePosition(textBounds);
            let textPositionInImage = new Vector2_28.Vector2(objectBoundsInImage.min.x + textPos.getX(), objectBoundsInImage.min.y + textPos.getY());
            let textPositionInWorld = worldCamera.getWorldCoordinateFromImagePoint(textPositionInImage);
            this.titleView.position = this.getEnvironment().renderer.newPointFromVector2(textPositionInWorld);
        }
        // Model Event-Handling
        // @Override
        xChanged(model) {
            this.syncPosition();
        }
        // @Override
        yChanged(model) {
            this.syncPosition();
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.getView().alpha > 0) {
                this.updateScale();
                this.updateRotation();
                this.updateTranslation();
                this.invalidated = false;
            }
        }
        updateScale() {
            let camera = this.getScene().getCamera();
            let scaleFactor = camera.getScaleX();
            if (this.lastScaleFactor !== scaleFactor || this.invalidated) {
                this.lastScaleFactor = scaleFactor;
                this.titleView.scale.x = scaleFactor;
                this.titleView.scale.y = scaleFactor;
            }
        }
        updateRotation() {
            let camera = this.getScene().getCamera();
            let mapObjectOrientation = camera.getRotation();
            if (this.lastOrientation !== mapObjectOrientation || this.invalidated) {
                this.lastOrientation = mapObjectOrientation;
                this.titleView.rotation = mapObjectOrientation;
                this.syncPosition();
            }
        }
        updateTranslation() {
            let camera = this.getScene().getCamera();
            let scaleFactor = camera.getScaleX();
            if (this.lastScaleFactorForTranslation !== scaleFactor || this.invalidated) {
                this.lastScaleFactorForTranslation = scaleFactor;
                this.syncPosition();
            }
        }
        // Getters and setters
        getRelutionMapObject() {
            return this.mapObject;
        }
    }
    exports.RelutionMapObjectInfo = RelutionMapObjectInfo;
});
define("src/app/relution/view/world/layers/objectLayers/objectInfoLayer/RelutionMapObjectInfoLayer", ["require", "exports", "src/map/view/Layer", "src/app/relution/view/world/RelutionMapAttributeObjectLayer", "src/map/utils/DeviceUtils", "src/app/relution/view/world/layers/objectLayers/objectInfoLayer/RelutionMapObjectInfo"], function (require, exports, Layer_5, RelutionMapAttributeObjectLayer_5, DeviceUtils_15, RelutionMapObjectInfo_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RelutionMapObjectInfoLayer = void 0;
    class RelutionMapObjectInfoLayer extends RelutionMapAttributeObjectLayer_5.RelutionMapAttributeObjectLayer {
        // Initialization
        constructor(config, environment, mapObjectLayer) {
            super(environment, mapObjectLayer);
            this.config = config;
            this.initInfoContainerLayer();
            // We want all map attribute objects to be added to the container,
            // to have better control over attribute objects' visibility.
            this.setTargetLayer(this.infoContainerLayer);
        }
        initInfoContainerLayer() {
            this.infoContainerLayer = new Layer_5.Layer(this.getEnvironment());
            this.addChild(this.infoContainerLayer);
            // Set the info container layer visible by default.
            this.infoContainerLayer.getView().alpha = 1.0;
        }
        // Life cycle management
        // @Override
        onObjectsUnloaded(objects) {
            super.onObjectsUnloaded(objects);
            // We set the hovering object to null, as it has been removed from the scene
            // and has been destroyed already.
            this.hoveringInfo = null;
        }
        // Attribute object creation
        // @Override
        createAttributeObjectsForObject(mapObject) {
            let objects = [];
            let info = new RelutionMapObjectInfo_1.RelutionMapObjectInfo(this.getEnvironment(), mapObject);
            info.getView().alpha = this.isInfoOfObjectTypeVisible(mapObject) ? 1.0 : 0.0;
            objects.push(info);
            return objects;
        }
        // Input Event-Handling: Desktop
        // @Override
        onMouseMove(x, y) {
            if (this.config.showInfoOnMouseOver) {
                this.showOrHideInfo(x, y);
            }
            return false;
        }
        // Input Event-Handling: Mobile
        // @Override
        onTap(x, y, numTaps) {
            if (this.config.showInfoOnTapOnMobileDevices) {
                if (DeviceUtils_15.DeviceUtils.isMobileDevice() && numTaps === 1) {
                    return this.showOrHideInfo(x, y);
                }
            }
            return false;
        }
        // Input Event-Handling: General
        showOrHideInfo(x, y) {
            let infoOfCollidingObject = this.getInfoOfCollidingObject(x, y);
            if (infoOfCollidingObject != null) {
                this.setInfoVisible(infoOfCollidingObject);
                return true;
            }
            else {
                this.setInfoVisible(null);
                return false;
            }
        }
        getInfoOfCollidingObject(x, y) {
            for (let i = 0; i < this.getAttributeObjects().length; i++) {
                let info = this.getAttributeObjects()[i];
                let mapObject = info.getRelutionMapObject();
                if (mapObject.intersectsPointInScreenPx(x, y)) {
                    return info;
                }
            }
            return null;
        }
        setInfoVisible(info) {
            // If another object is currently hovered, move it back to the container layer.
            if (this.hoveringInfo != null) {
                this.infoContainerLayer.addChild(this.hoveringInfo);
                this.hoveringInfo = null;
            }
            if (info != null) {
                // Set the new info appear.
                this.hoveringInfo = info;
                this.addChild(info);
            }
        }
        // Modes
        toggleInfoVisibility(objectType, visible) {
            // 1. Update map
            this.config.objectTypeInfoVisibilities.set(objectType, visible);
            // 1. Update views
            for (let i = 0; i < this.getAttributeObjects().length; i++) {
                let info = this.getAttributeObjects()[i];
                let mapObject = info.getRelutionMapObject();
                if (mapObject instanceof objectType) {
                    info.getView().alpha = this.isInfoOfObjectTypeVisible(mapObject) ? 1.0 : 0.0;
                }
            }
        }
        isInfoOfObjectTypeVisible(mapObject) {
            let visible = true;
            // To set the map object to visible, all object types this object is compatible with, must be visible. If an object
            // type is not contained in the map, we assume it to be visible.
            this.config.objectTypeInfoVisibilities.forEach((objectTypeVisible, objectType) => {
                if (mapObject instanceof objectType && !objectTypeVisible) {
                    visible = false;
                }
            });
            return visible;
        }
        // Getters and setters
        getInfoContainerLayer() {
            return this.infoContainerLayer;
        }
    }
    exports.RelutionMapObjectInfoLayer = RelutionMapObjectInfoLayer;
    (function (RelutionMapObjectInfoLayer) {
        class Config {
            constructor() {
                /**
                 * If true, the map object infos will be shown, whenever
                 * the mouse cursor hovers a map object.
                 *
                 * Default: false
                 */
                this.showInfoOnMouseOver = false;
                /**
                 * True, if an info should appear, whenever the user
                 * taps on the map object.
                 *
                 * Default: false
                 */
                this.showInfoOnTapOnMobileDevices = false;
                /**
                 * Maps the map object types (the object type's constructor function) to a boolean,
                 * indicating whether the infos depending on map objects of the object type should be visible or not.
                 *
                 * <p>
                 * Note, that if an object type is not contained in this map, the infos for the corresponding object type
                 * is considered to be enabled. Hence, if setting the visibility of type "Beacon" to true, beacons will be visible.
                 * If setting the visibility of "Device" to false, beacons and all other devices will not be visible. To make
                 * an object visible, the visibilities of all object types the object is substitable must be set to true or not
                 * contained in this map.
                 * </p>
                 *
                 * Default: Empty map (infos of all object types are visible).
                 */
                this.objectTypeInfoVisibilities = new Map();
            }
        }
        RelutionMapObjectInfoLayer.Config = Config;
    })(RelutionMapObjectInfoLayer = exports.RelutionMapObjectInfoLayer || (exports.RelutionMapObjectInfoLayer = {}));
});
define("src/app/relution/view/world/layers/deviceLayers/singleDeviceEditLayer/SingleDeviceEditLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceMapObject", "src/engine/animation/Animation", "src/engine/animation/LinearInterpolator", "src/engine/math/Vector2", "src/engine/input/GestureRecognizer"], function (require, exports, FloorplanRelatedLayer_9, DeviceMapObject_6, Animation_7, LinearInterpolator_6, Vector2_29, GestureRecognizer_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SingleDeviceEditLayer = void 0;
    /**
     * A layer that makes it possible to set the position of a specified device.
     */
    class SingleDeviceEditLayer extends FloorplanRelatedLayer_9.FloorplanRelatedLayer {
        // Initialization
        constructor(config, environment, deviceLayer) {
            super(environment, deviceLayer.getFloorplanLayer());
            // Observers
            this.observers = new Array();
            this.touchStartPoint = null;
            this.invalidated = true;
            this.lastCameraScale = -1;
            this.config = config;
            this.deviceLayer = deviceLayer;
            this.initView();
            this.deviceLayer.addObserver(this);
        }
        initView() {
            this.initBlueDotView();
            this.initTapView();
        }
        initBlueDotView() {
            this.blueDotView = this.getEnvironment().renderer.newGraphicsObject();
            this.blueDotView.beginFill(SingleDeviceEditLayer.BLUE_DOT_COLOR);
            this.blueDotView.drawCircle(0, 0, SingleDeviceEditLayer.BLUE_DOT_SIZE_IN_WORLD_TX);
            this.blueDotView.endFill();
            this.blueDotView.visible = false;
            this.blueDotView.alpha = 0.0;
            this.getView().addChild(this.blueDotView);
            this.blueDotAnimation = new Animation_7.Animation(new LinearInterpolator_6.LinearInterpolator());
            this.startBlueDotAnimation();
        }
        startBlueDotAnimation() {
            const startValue = 0.0;
            const endValue = 1.0;
            const durationInMs = 750;
            const delayInMs = 500;
            this.blueDotAnimation.start(startValue, endValue, durationInMs, delayInMs);
        }
        initTapView() {
            this.tapView = this.getEnvironment().renderer.newGraphicsObject();
            this.tapView.beginFill(0x000000);
            this.tapView.drawCircle(0, 0, SingleDeviceEditLayer.TAP_VIEW_RESOLUTION_IN_PX);
            this.tapView.endFill();
            this.tapView.alpha = 0.0;
            this.tapView.scale.x = 1.0;
            this.tapView.scale.y = 1.0;
            this.getView().addChild(this.tapView);
            this.tapViewAnimation = new Animation_7.Animation(new LinearInterpolator_6.LinearInterpolator());
        }
        startTapViewAnimation() {
            // Reset tap view
            if (this.tapViewAnimation.isCurrentlyAnimating()) {
                this.tapViewAnimation.stop();
            }
            // Reset scale
            let camera = this.getScene().getCamera();
            let scaleFactor = camera.getScaleX();
            this.retransformTapView(scaleFactor);
            // Reset alpha
            this.tapView.alpha = SingleDeviceEditLayer.MAX_TAP_VIEW_ALPHA;
            // Start animation
            const startValue = 0.0;
            const endValue = 1.0;
            const durationInMs = 250;
            const delayInMs = 0;
            this.tapViewAnimation.start(startValue, endValue, durationInMs, delayInMs);
        }
        // Observers
        addObserver(observer) {
            this.observers.push(observer);
        }
        removeObserver(observer) {
            let index = this.observers.indexOf(observer);
            if (index > -1) {
                this.observers.splice(index, 1);
            }
        }
        notifyObserversAboutPositionChange(device) {
            for (let i = 0; i < this.observers.length; i++) {
                const observer = this.observers[i];
                observer.onDevicePositionChanged(device);
            }
        }
        // Beacon event handling
        onObjectMovedToMap(object) {
            this.handleObjectSceneChange(object);
        }
        onObjectMovedToStock(object) {
            this.handleObjectSceneChange(object);
        }
        onObjectSetToMap(object) {
            this.handleObjectSceneChange(object);
        }
        onObjectSetToStock(object) {
            this.handleObjectSceneChange(object);
        }
        handleObjectSceneChange(object) {
            if (object.getModel().uuid === this.config.editableDeviceUuid) {
                if (object instanceof DeviceMapObject_6.DeviceMapObject) {
                    const device = object;
                    device.getModel().removeObserver(this);
                    this.updateAppearance();
                }
            }
        }
        // Tap event handling
        // @Override
        onTap(x, y, numTaps) {
            super.onTap(x, y, numTaps);
            if (numTaps === 1) {
                if (this.config.enabled) {
                    if (this.config.editableDeviceUuid !== null) {
                        const device = this.deviceLayer.getDeviceWithUuid(this.config.editableDeviceUuid);
                        if (device !== null) {
                            const deviceModel = device.getModel();
                            const positionInRelativeCoords = this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new Vector2_29.Vector2(x, y));
                            deviceModel.x = Math.max(Math.min(positionInRelativeCoords.x, 1.0), 0.0);
                            deviceModel.y = Math.max(Math.min(positionInRelativeCoords.y, 1.0), 0.0);
                            this.deviceLayer.moveObjectToMap(device);
                            device.addToMap();
                            device.invalidate();
                            this.updateAppearance();
                            this.notifyObserversAboutPositionChange(device);
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        // Touch event handling
        // @Override
        onTouchStart(x, y, touchIndex) {
            super.onTouchStart(x, y, touchIndex);
            if (this.config.enabled) {
                this.touchStartPoint = new Vector2_29.Vector2(x, y);
            }
            return false;
        }
        // @Override
        onTouchMove(x, y, touchIndex) {
            super.onTouchMove(x, y, touchIndex);
            return false;
        }
        // @Override
        onTouchEnd(x, y, touchIndex) {
            super.onTouchEnd(x, y, touchIndex);
            if (this.config.enabled && this.touchStartPoint !== null) {
                const touchPointInScreenPx = new Vector2_29.Vector2(x, y);
                const tapViewToleranceInPx = GestureRecognizer_2.GestureRecognizer.MAX_TAP_DISTANCE_PX;
                if (Vector2_29.Vector2.getDistanceBetweenPoints(this.touchStartPoint, new Vector2_29.Vector2(x, y)) < tapViewToleranceInPx) {
                    const touchPointInWorldTx = this.getFloorplanLayer().getTexelsFromScreenPixels(touchPointInScreenPx);
                    this.tapView.x = touchPointInWorldTx.x;
                    this.tapView.y = touchPointInWorldTx.y;
                    this.startTapViewAnimation();
                }
                this.touchStartPoint = null;
            }
            return false;
        }
        // Frame events
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.config.enabled) {
                if (this.getView().alpha > 0) {
                    this.updateBlueDotAnimation(lastFrametime);
                    this.updateTapViewAnimation(lastFrametime);
                    this.updateScale();
                    this.invalidated = false;
                }
            }
        }
        updateBlueDotAnimation(lastFrametime) {
            if (this.blueDotAnimation.isCurrentlyAnimating()) {
                const value = this.blueDotAnimation.getValue(lastFrametime);
                const maxAlpha = this.editableDeviceIsOnMap() ? 0.5 : 0.0;
                this.blueDotView.alpha = maxAlpha - (value * maxAlpha);
                this.blueDotView.scale.x = value;
                this.blueDotView.scale.y = value;
            }
            else {
                this.startBlueDotAnimation();
            }
        }
        updateTapViewAnimation(lastFrametime) {
            if (this.tapViewAnimation.isCurrentlyAnimating()) {
                const value = this.tapViewAnimation.getValue(lastFrametime);
                const maxAlpha = SingleDeviceEditLayer.MAX_TAP_VIEW_ALPHA;
                this.tapView.alpha = maxAlpha - (value * maxAlpha);
                this.invalidated = true;
            }
        }
        updateScale() {
            let camera = this.getScene().getCamera();
            let scaleFactor = camera.getScaleX();
            if (this.lastCameraScale !== scaleFactor || this.invalidated) {
                this.lastCameraScale = scaleFactor;
                this.retransformTapView(scaleFactor);
            }
        }
        retransformTapView(scaleFactor) {
            const value = this.tapViewAnimation.getLastValue();
            this.tapView.scale.x = (1.0 - value) * scaleFactor;
            this.tapView.scale.y = (1.0 - value) * scaleFactor;
        }
        // Model Event-Handling
        // @Override
        xChanged(deviceModel) {
            if (deviceModel.uuid === this.config.editableDeviceUuid) {
                this.updateAppearance();
            }
        }
        // @Override
        yChanged(deviceModel) {
            if (deviceModel.uuid === this.config.editableDeviceUuid) {
                this.updateAppearance();
            }
        }
        // Appearance
        updateAppearance() {
            if (this.config.enabled && this.config.editableDeviceUuid !== null) {
                if (this.editableDeviceIsOnMap()) {
                    this.highlightEditableDevice();
                }
                this.tapView.visible = true;
            }
            else {
                this.unhighlightEditableDevice();
                this.tapView.visible = false;
            }
        }
        editableDeviceIsOnMap() {
            const device = this.deviceLayer.getDeviceWithUuid(this.config.editableDeviceUuid);
            if (device !== null) {
                return device.getModel().isOnMap() && !device.getModel().hasUnknownPosition();
            }
            else {
                return false;
            }
        }
        highlightEditableDevice() {
            const device = this.deviceLayer.getDeviceWithUuid(this.config.editableDeviceUuid);
            if (device !== null) {
                this.blueDotView.x = device.getView().x;
                this.blueDotView.y = device.getView().y;
                this.blueDotView.visible = true;
                device.setHighlighted(true);
            }
        }
        unhighlightEditableDevice() {
            this.blueDotView.visible = false;
            const allDevices = this.deviceLayer.getAllDevices();
            for (let i = 0; i < allDevices.length; i++) {
                const device = allDevices[i];
                device.setHighlighted(false);
            }
        }
        // Getters and setters
        setEditModeActive(enabled, editableDeviceUuid) {
            this.config.enabled = enabled;
            this.config.editableDeviceUuid = editableDeviceUuid;
            this.updateAppearance();
        }
        isEditModeActive() {
            return this.config.enabled;
        }
        getEditableDeviceUuid() {
            return this.config.editableDeviceUuid;
        }
    }
    exports.SingleDeviceEditLayer = SingleDeviceEditLayer;
    // Constants
    // Constants: Colors
    SingleDeviceEditLayer.BLUE_DOT_COLOR = 0x95b5ff;
    // Constants: Size
    SingleDeviceEditLayer.BLUE_DOT_SIZE_IN_WORLD_TX = 150;
    SingleDeviceEditLayer.TAP_VIEW_RESOLUTION_IN_PX = 20;
    SingleDeviceEditLayer.MAX_TAP_VIEW_ALPHA = 0.1;
    (function (SingleDeviceEditLayer) {
        class Config {
            constructor() {
                /**
                 * True, if the single device edit layer should be enabled by default
                 *
                 * Default: false
                 */
                this.enabled = false;
                /**
                 * The UUID of the editable device, if the single device edit mode is enabled by default.
                 *
                 * Default: null, as this mode is disabled by default.
                 */
                this.editableDeviceUuid = null;
            }
        }
        SingleDeviceEditLayer.Config = Config;
    })(SingleDeviceEditLayer = exports.SingleDeviceEditLayer || (exports.SingleDeviceEditLayer = {}));
});
define("src/app/relution/view/world/layers/overlayLayers/tapeMeasureLayer/TapeMeasureWorldLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/map/utils/DeviceUtils", "src/engine/math/Vector2", "src/engine/input/GestureRecognizer", "src/engine/general/AABB"], function (require, exports, FloorplanRelatedLayer_10, DeviceUtils_16, Vector2_30, GestureRecognizer_3, AABB_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TapeMeasureWorldLayer = void 0;
    /**
     * A layer containing a rectangular tape measure making it possible to measure
     * distances between two points on the floorplan.
     *
     * <p>
     * Creating and modifying the rectangle is only possible in the tape measure
     * edit mode. Creating the tape measure rectangle can be done by tapping on two
     * points on the map subsequently. A third tap will remove the rectangle.
     * Modifying an already created tape measure is possible by dragging the corner
     * points (also called edit points).
     * </p>
     */
    class TapeMeasureWorldLayer extends FloorplanRelatedLayer_10.FloorplanRelatedLayer {
        // Construction
        constructor(config, environment, floorplanLayer) {
            super(environment, floorplanLayer);
            // View: Creating rectangle
            this.isFirstEditPointSet = false;
            this.isSecondEditPointSet = false;
            this.tapStartPoint = null;
            // View: Resizing rectangle
            this.numberOfEditingPoints = 4;
            this.editing = false;
            this.editTouchIndex = -1;
            this.editingMinX = false;
            this.editingMinY = false;
            this.editingMaxX = false;
            this.editingMaxY = false;
            this.editingPoints = Array();
            this.measureTexts = new Array();
            this.axisAlignedMeasureTexts = new Array();
            this.diagonalMeasureText = null;
            // State
            this.invalidated = true;
            this.lastScaleFactor = -1;
            this.config = config;
            this.initModel();
            this.initView();
        }
        initModel() {
            this.model = new TapeMeasureWorldLayer.Model();
        }
        initView() {
            this.initRectangle();
            this.initEditingPoints();
            this.initMeasureTexts();
            this.getView().visible = false;
        }
        initRectangle() {
            this.rectangle = this.getEnvironment().renderer.newGraphicsObject();
            this.getView().addChild(this.rectangle);
        }
        initEditingPoints() {
            for (let i = 0; i < this.numberOfEditingPoints; i++) {
                let editingPoint = this.getEnvironment().renderer.newGraphicsObject();
                editingPoint.clear();
                editingPoint.beginFill(TapeMeasureWorldLayer.CORNER_COLOR);
                editingPoint.drawCircle(0, 0, 1);
                editingPoint.endFill();
                this.editingPoints.push(editingPoint);
                this.getView().addChild(editingPoint);
            }
        }
        initMeasureTexts() {
            let fontSize = DeviceUtils_16.DeviceUtils.getPhysicalPixelsFromLogical(12);
            let textStyle = this.getEnvironment().renderer.newTextStyle();
            textStyle.fill = TapeMeasureWorldLayer.TEXT_COLOR;
            textStyle.fontFamily = "Arial";
            textStyle.fontSize = fontSize;
            // We want the texts only be shown on the top and right site.
            let numberOfMeasureTexts = this.numberOfEditingPoints / 2;
            for (let i = 0; i < numberOfMeasureTexts; i++) {
                const measureText = this.addMeasureText(textStyle);
                this.axisAlignedMeasureTexts.push(measureText);
            }
            this.diagonalMeasureText = this.addMeasureText(textStyle);
        }
        addMeasureText(textStyle) {
            let measureText = this.getEnvironment().renderer.newTextObject("", 2, textStyle);
            measureText.visible = false;
            this.measureTexts.push(measureText);
            this.getView().addChild(measureText);
            return measureText;
        }
        // Creating and editing the measure rectangle
        // @Override
        onTouchStart(x, y, touchIndex) {
            super.onTouchStart(x, y, touchIndex);
            if (!this.isVisibleInWorld()) {
                return false;
            }
            else {
                if (this.isEditModeActive()) {
                    return this.handleTouchStart(x, y, touchIndex);
                }
                else {
                    return false;
                }
            }
        }
        handleTouchStart(x, y, touchIndex) {
            if (this.hasCreatedRectangle() && this.pointIsCloseToEditableArea(x, y)) {
                this.onEditCornerStart(x, y, touchIndex);
                return true;
            }
            else {
                this.tapStartPoint = new Vector2_30.Vector2(x, y);
            }
        }
        pointIsCloseToEditableArea(x, y) {
            let mousePosition = new Vector2_30.Vector2(x, y);
            let editablePoints = this.getEditablePoints();
            for (let i = 0; i < editablePoints.length; i++) {
                let editablePoint = editablePoints[i];
                let distance = Vector2_30.Vector2.getDistanceBetweenPoints(mousePosition, editablePoint);
                const toleranceInPx = DeviceUtils_16.DeviceUtils.isMobileDevice()
                    ? DeviceUtils_16.DeviceUtils.getPhysicalPixelsFromLogical(TapeMeasureWorldLayer.EDITABLE_POINT_MOBILE_TOLERANCE_IN_PX)
                    : TapeMeasureWorldLayer.EDITABLE_POINT_DESKTOP_TOLERANCE_IN_PX;
                if (distance < toleranceInPx) {
                    return true;
                }
            }
            return false;
        }
        getEditablePoints() {
            let editablePoints = new Array();
            let topLeft = this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new Vector2_30.Vector2(this.model.min.x, this.model.min.y));
            let topRight = this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new Vector2_30.Vector2(this.model.max.x, this.model.min.y));
            let bottomLeft = this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new Vector2_30.Vector2(this.model.min.x, this.model.max.y));
            let bottomRight = this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new Vector2_30.Vector2(this.model.max.x, this.model.max.y));
            editablePoints.push(topLeft);
            editablePoints.push(topRight);
            editablePoints.push(bottomLeft);
            editablePoints.push(bottomRight);
            return editablePoints;
        }
        onEditCornerStart(x, y, touchIndex) {
            let pointInRelative = this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new Vector2_30.Vector2(x, y));
            this.editing = true;
            this.editTouchIndex = touchIndex;
            if (Math.abs(pointInRelative.x - this.model.min.x) < Math.abs(pointInRelative.x - this.model.max.x)) {
                this.editingMinX = true;
                this.editingMaxX = false;
            }
            else {
                this.editingMinX = false;
                this.editingMaxX = true;
            }
            if (Math.abs(pointInRelative.y - this.model.min.y) < Math.abs(pointInRelative.y - this.model.max.y)) {
                this.editingMinY = true;
                this.editingMaxY = false;
            }
            else {
                this.editingMinY = false;
                this.editingMaxY = true;
            }
        }
        // @Override
        onTouchMove(x, y, touchIndex) {
            super.onTouchMove(x, y, touchIndex);
            if (!this.isVisibleInWorld()) {
                return false;
            }
            else {
                if (this.isEditModeActive()) {
                    this.onEditCornerMove(x, y, touchIndex);
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        onEditCornerMove(x, y, touchIndex) {
            if (this.editTouchIndex === touchIndex) {
                if (this.editing === true) {
                    // Get mouse position in relative coordinates
                    let pointInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_30.Vector2(x, y));
                    let pointInRelative = this.getFloorplanLayer().getRelativeCoordinatesFromTexels(pointInTx);
                    // Constrain the mouse to the world borders.
                    pointInRelative.x = Math.max(0, Math.min(1, pointInRelative.x));
                    pointInRelative.y = Math.max(0, Math.min(1, pointInRelative.y));
                    // Model update
                    if (this.editingMinX) {
                        this.model.min.x = pointInRelative.x;
                    }
                    else if (this.editingMaxX) {
                        this.model.max.x = pointInRelative.x;
                    }
                    if (this.editingMinY) {
                        this.model.min.y = pointInRelative.y;
                    }
                    else if (this.editingMaxY) {
                        this.model.max.y = pointInRelative.y;
                    }
                    // Model constraints: Min must always be smaller than max.
                    this.normalizeModel();
                    // View update
                    this.redraw();
                }
            }
        }
        normalizeModel() {
            if (this.model.min.x > this.model.max.x) {
                let helper = this.model.min.x;
                this.model.min.x = this.model.max.x;
                this.model.max.x = helper;
                let helperEditing = this.editingMinX;
                this.editingMinX = this.editingMaxX;
                this.editingMaxX = helperEditing;
            }
            if (this.model.min.y > this.model.max.y) {
                let helper = this.model.min.y;
                this.model.min.y = this.model.max.y;
                this.model.max.y = helper;
                let helperEditing = this.editingMinY;
                this.editingMinY = this.editingMaxY;
                this.editingMaxY = helperEditing;
            }
            this.model.min.x = Math.max(0.0, Math.min(1.0, this.model.min.x));
            this.model.min.y = Math.max(0.0, Math.min(1.0, this.model.min.y));
            this.model.max.x = Math.max(0.0, Math.min(1.0, this.model.max.x));
            this.model.max.y = Math.max(0.0, Math.min(1.0, this.model.max.y));
        }
        // @Override
        onTouchEnd(x, y, touchIndex) {
            super.onTouchEnd(x, y, touchIndex);
            if (!this.isVisibleInWorld()) {
                return false;
            }
            else {
                if (this.isEditModeActive()) {
                    if (this.editing) {
                        this.onEditCornerStop(x, y, touchIndex);
                    }
                    else {
                        this.handleTapIfDetected(x, y);
                    }
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        onEditCornerStop(x, y, touchIndex) {
            this.editing = false;
            this.editTouchIndex = -1;
        }
        handleTapIfDetected(x, y) {
            if (this.tapStartPoint !== null) {
                const tapViewToleranceInPx = GestureRecognizer_3.GestureRecognizer.MAX_TAP_DISTANCE_PX * 2;
                if (Vector2_30.Vector2.getDistanceBetweenPoints(new Vector2_30.Vector2(x, y), this.tapStartPoint) < tapViewToleranceInPx) {
                    this.handleTap(x, y);
                }
                this.tapStartPoint = null;
            }
        }
        handleTap(x, y) {
            if (this.isCreatingRectangle()) {
                this.isSecondEditPointSet = true;
                this.setSecondEditPoint(x, y);
                this.normalizeModel();
            }
            else if (this.hasCreatedRectangle()) {
                this.isFirstEditPointSet = false;
                this.isSecondEditPointSet = false;
                this.getView().visible = false;
            }
            else {
                this.isFirstEditPointSet = true;
                this.setFirstEditPoint(x, y);
            }
        }
        isCreatingRectangle() {
            return this.isFirstEditPointSet && !this.isSecondEditPointSet;
        }
        hasCreatedRectangle() {
            return this.isFirstEditPointSet && this.isSecondEditPointSet;
        }
        setFirstEditPoint(x, y) {
            const pointInRelativeCoords = this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new Vector2_30.Vector2(x, y));
            this.model.min.x = pointInRelativeCoords.x;
            this.model.min.y = pointInRelativeCoords.y;
            this.model.max.x = pointInRelativeCoords.x;
            this.model.max.y = pointInRelativeCoords.y;
            this.getView().visible = true;
            this.invalidated = true;
        }
        setSecondEditPoint(x, y) {
            const pointInRelativeCoords = this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new Vector2_30.Vector2(x, y));
            this.model.max.x = pointInRelativeCoords.x;
            this.model.max.y = pointInRelativeCoords.y;
            this.getView().visible = true;
            this.invalidated = true;
        }
        // Mouse movement
        onMouseMove(x, y) {
            super.onMouseMove(x, y);
            if (this.isFirstEditPointSet && !this.isSecondEditPointSet) {
                this.setSecondEditPoint(x, y);
            }
            return false;
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            let scaleFactor = 1.0;
            if (this.getScene() != null) {
                let camera = this.getScene().getCamera();
                scaleFactor = camera.getScaleX();
            }
            if (this.lastScaleFactor !== scaleFactor || this.invalidated) {
                this.lastScaleFactor = scaleFactor;
                this.invalidated = false;
                this.redraw();
            }
        }
        redraw() {
            this.redrawRectangle();
            this.redrawEditingPoints();
            this.redrawMeasureTexts();
        }
        redrawRectangle() {
            let camera = this.getScene().getCamera();
            // Line width
            let lineWidhtInPx = 1.0;
            let lineWidthInTx = camera.getPixelsInTexels(lineWidhtInPx);
            // Line color
            let lineColor = TapeMeasureWorldLayer.BORDER_COLOR;
            // Rectangle shape
            let min = this.getEnvironment().renderer.newPointFromVector2(this.getFloorplanLayer().getTexelsFromRelativeCoordinates(this.model.min));
            let max = this.getEnvironment().renderer.newPointFromVector2(this.getFloorplanLayer().getTexelsFromRelativeCoordinates(this.model.max));
            // Rectangle color
            let color = TapeMeasureWorldLayer.SHAPE_COLOR;
            const alpha = 0.1;
            // Draw rectangle
            this.rectangle.clear();
            this.rectangle.beginFill(color, alpha);
            this.rectangle.lineStyle(lineWidthInTx, lineColor);
            this.rectangle.drawRect(min.x, min.y, max.x - min.x, max.y - min.y);
            this.rectangle.drawPolygon([min, max]);
            this.rectangle.endFill();
        }
        redrawEditingPoints() {
            if (this.isEditModeActive()) {
                this.makeEditPointsVisible(true);
                this.repositionEditPoints();
                this.rescaleEditPoints();
            }
            else {
                this.makeEditPointsVisible(false);
            }
        }
        makeEditPointsVisible(visible) {
            for (let i = 0; i < this.editingPoints.length; i++) {
                let editingPoint = this.editingPoints[i];
                editingPoint.visible = visible;
            }
        }
        repositionEditPoints() {
            let topLeftInRelative = new Vector2_30.Vector2(this.model.min.x, this.model.min.y);
            let topRightInRelative = new Vector2_30.Vector2(this.model.max.x, this.model.min.y);
            let bottomLeftInRelative = new Vector2_30.Vector2(this.model.min.x, this.model.max.y);
            let bottomRightInRelative = new Vector2_30.Vector2(this.model.max.x, this.model.max.y);
            let topLeftInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(topLeftInRelative);
            let topRightInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(topRightInRelative);
            let bottomLeftInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(bottomLeftInRelative);
            let bottomRightInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(bottomRightInRelative);
            this.editingPoints[0].position = this.getEnvironment().renderer.newPointFromVector2(topLeftInTx);
            this.editingPoints[1].position = this.getEnvironment().renderer.newPointFromVector2(topRightInTx);
            this.editingPoints[2].position = this.getEnvironment().renderer.newPointFromVector2(bottomLeftInTx);
            this.editingPoints[3].position = this.getEnvironment().renderer.newPointFromVector2(bottomRightInTx);
        }
        rescaleEditPoints() {
            let camera = this.getScene().getCamera();
            let widthInPx = TapeMeasureWorldLayer.EDIT_POINT_RADIUS_IN_PX * 2;
            let widthInTx = camera.getPixelsInTexels(widthInPx);
            for (let i = 0; i < this.editingPoints.length; i++) {
                let editingPoint = this.editingPoints[i];
                editingPoint.width = widthInTx;
                editingPoint.height = widthInTx;
            }
        }
        redrawMeasureTexts() {
            this.makeMeasureTextsVisible(true);
            this.updateMeasureTexts();
        }
        makeMeasureTextsVisible(visible) {
            for (let i = 0; i < this.measureTexts.length; i++) {
                let measureText = this.measureTexts[i];
                measureText.visible = visible;
            }
        }
        updateMeasureTexts() {
            let camera = this.getScene().getCamera();
            let scaleFactor = camera.getScaleX();
            let cameraOrientation = camera.getRotation();
            let points = this.getRectanglePointsInTx();
            this.updateAxisAlignedMeasureTexts(points, scaleFactor, cameraOrientation);
            this.updateDiagonalMeasureText(points, scaleFactor, cameraOrientation);
            this.avoidOverlappingMeasureTexts();
        }
        getRectanglePointsInTx() {
            let points = [];
            const minX = Math.min(this.model.min.x, this.model.max.x);
            const maxX = Math.max(this.model.min.x, this.model.max.x);
            const minY = Math.min(this.model.min.y, this.model.max.y);
            const maxY = Math.max(this.model.min.y, this.model.max.y);
            let point1InRelative = new Vector2_30.Vector2(minX, minY);
            let point2InRelative = new Vector2_30.Vector2(maxX, minY);
            let point3InRelative = new Vector2_30.Vector2(maxX, maxY);
            let point4InRelative = new Vector2_30.Vector2(minX, maxY);
            let point1InTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point1InRelative);
            let point2InTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point2InRelative);
            let point3InTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point3InRelative);
            let point4InTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point4InRelative);
            points.push(point1InTx);
            points.push(point2InTx);
            points.push(point3InTx);
            points.push(point4InTx);
            return points;
        }
        updateAxisAlignedMeasureTexts(points, scaleFactor, cameraOrientation) {
            for (let i = 0; i < this.axisAlignedMeasureTexts.length; i++) {
                let measureText = this.axisAlignedMeasureTexts[i];
                let pointA = points[i];
                let pointB = points[(i + 1) % points.length];
                this.updateMeasureText(measureText, pointA, pointB, scaleFactor, cameraOrientation);
            }
        }
        updateDiagonalMeasureText(points, scaleFactor, cameraOrientation) {
            let point1 = points[0]; // min
            let point2 = points[2]; // max
            this.updateMeasureText(this.diagonalMeasureText, point1, point2, scaleFactor, cameraOrientation);
        }
        updateMeasureText(measureText, pointA, pointB, scaleFactor, cameraOrientation) {
            // Compute distance in meters
            let distanceInTx = Vector2_30.Vector2.getDistanceBetweenPoints(pointA, pointB);
            let distanceInCm = this.getFloorplanLayer().getCmFromTexels(distanceInTx);
            let distanceInM = distanceInCm / 100.0;
            // Text
            let newText = "" + distanceInM.toFixed(2) + " m";
            if (measureText.text !== newText) {
                measureText.text = newText;
            }
            // Scale
            measureText.scale.x = scaleFactor;
            measureText.scale.y = scaleFactor;
            // Orientation
            measureText.rotation = cameraOrientation;
            // Position
            let penetrationResolutionVector = this.getInterpenetrationResolutionVector(pointA, pointB, measureText);
            measureText.x = pointA.x + ((pointB.x - pointA.x) / 2) - measureText.width / 2 + penetrationResolutionVector.x;
            measureText.y = pointA.y + ((pointB.y - pointA.y) / 2) - measureText.height / 2 + penetrationResolutionVector.y;
        }
        getInterpenetrationResolutionVector(pointA, pointB, measureText) {
            let edgeX = pointB.x - pointA.x;
            let edgeY = pointB.y - pointA.y;
            let normalX = edgeY;
            let normalY = -edgeX;
            let normalizedNormalVector = Vector2_30.Vector2.normalizePoint(new Vector2_30.Vector2(normalX, normalY));
            let depthInTx = 0;
            // Padding
            let camera = this.getScene().getCamera();
            let paddingInPx = TapeMeasureWorldLayer.TEXT_PADDING_PX;
            let paddingInTx = camera.getPixelsInTexels(paddingInPx);
            if (Math.abs(normalX) > 0) {
                depthInTx = measureText.width / 2 + paddingInTx;
            }
            else {
                depthInTx = measureText.height / 2 + paddingInTx;
            }
            let penetrationVector = new Vector2_30.Vector2(normalizedNormalVector.x * depthInTx, normalizedNormalVector.y * depthInTx);
            return penetrationVector;
        }
        avoidOverlappingMeasureTexts() {
            // Show width and height texts only, if thery are not colliding with diagonal text.
            if (this.diagonalTextOveralpsAxisAlignedMeasureTexts()) {
                for (let i = 0; i < this.axisAlignedMeasureTexts.length; i++) {
                    const axisAlignedMeasureText = this.axisAlignedMeasureTexts[i];
                    axisAlignedMeasureText.visible = false;
                }
            }
        }
        diagonalTextOveralpsAxisAlignedMeasureTexts() {
            const diagonalMeasureTextAabbInScreenPx = this.getMeasureTextBounds(this.diagonalMeasureText);
            for (let i = 0; i < this.axisAlignedMeasureTexts.length; i++) {
                const axisAlignedMeasureText = this.axisAlignedMeasureTexts[i];
                const axisAlignedTextAabbInScreenPx = this.getMeasureTextBounds(axisAlignedMeasureText);
                if (diagonalMeasureTextAabbInScreenPx.intersects(axisAlignedTextAabbInScreenPx)) {
                    return true;
                }
            }
        }
        getMeasureTextBounds(measureText) {
            let minPoint = this.getEnvironment().renderer.newPoint(0 - measureText.anchor.x, 0 - measureText.anchor.y);
            const minInScreenCoords = measureText.toGlobal(minPoint, minPoint);
            let maxPoint = this.getEnvironment().renderer.newPoint(0 - measureText.anchor.x + measureText.width, 0 - measureText.anchor.y + measureText.height);
            const maxInScreenCoords = measureText.toGlobal(maxPoint, maxPoint);
            return new AABB_7.AABB(Vector2_30.Vector2.getVector2(minInScreenCoords), Vector2_30.Vector2.getVector2(maxInScreenCoords));
        }
        // Getters and setters
        setEditModeActive(enabled) {
            this.config.editModeEnabled = enabled;
            this.invalidated = true;
        }
        isEditModeActive() {
            return this.config.editModeEnabled;
        }
    }
    exports.TapeMeasureWorldLayer = TapeMeasureWorldLayer;
    // Constants
    // Constants: Color
    TapeMeasureWorldLayer.CORNER_COLOR = 0xbb00bb;
    TapeMeasureWorldLayer.TEXT_COLOR = TapeMeasureWorldLayer.CORNER_COLOR;
    TapeMeasureWorldLayer.BORDER_COLOR = TapeMeasureWorldLayer.CORNER_COLOR;
    TapeMeasureWorldLayer.SHAPE_COLOR = TapeMeasureWorldLayer.CORNER_COLOR;
    // Constants: Edit points
    TapeMeasureWorldLayer.EDIT_POINT_RADIUS_IN_PX = 4;
    TapeMeasureWorldLayer.EDITABLE_POINT_MOBILE_TOLERANCE_IN_PX = 12;
    TapeMeasureWorldLayer.EDITABLE_POINT_DESKTOP_TOLERANCE_IN_PX = 6;
    // Constants: Length text
    TapeMeasureWorldLayer.TEXT_PADDING_PX = 5;
    (function (TapeMeasureWorldLayer) {
        class Config {
            constructor() {
                /**
                 * True, if editing the tape measure should be enabled by default.
                 *
                 * Default: false
                 */
                this.editModeEnabled = false;
            }
        }
        TapeMeasureWorldLayer.Config = Config;
        class Model {
            constructor() {
                this._min = new Vector2_30.Vector2(0.0, 0.0);
                this._max = new Vector2_30.Vector2(0.0, 0.0);
            }
            get min() {
                return this._min;
            }
            set min(min) {
                this._min = min;
            }
            get max() {
                return this._max;
            }
            set max(max) {
                this._max = max;
            }
        }
        TapeMeasureWorldLayer.Model = Model;
    })(TapeMeasureWorldLayer = exports.TapeMeasureWorldLayer || (exports.TapeMeasureWorldLayer = {}));
});
define("src/app/relution/model/sensor/SensorHeatpointModel", ["require", "exports", "src/app/relution/model/Model", "src/app/relution/model/RelutionMapModel"], function (require, exports, Model_10, RelutionMapModel_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SensorHeatpointModel = void 0;
    /**
     * A model representing a heatpoint in the sensor heatmap.
     */
    class SensorHeatpointModel extends RelutionMapModel_6.RelutionMapModel {
        // Getters and setters
        get deviceUuid() {
            return this._deviceUuid;
        }
        set deviceUuid(deviceUuid) {
            this._deviceUuid = deviceUuid;
            this.notifyObservers("deviceUuid");
        }
        get intensity() {
            return this._intensity;
        }
        set intensity(intensity) {
            this._intensity = intensity;
            this.notifyObservers("intensity");
        }
        get radiusInCm() {
            return this._radiusInCm;
        }
        set radiusInCm(radiusInCm) {
            this._radiusInCm = radiusInCm;
            this.notifyObservers("radiusInCm");
        }
        get description() {
            return this._description;
        }
        set description(description) {
            this._description = description;
            this.notifyObservers("description");
        }
    }
    __decorate([
        (0, Model_10.ModelProperty)()
    ], SensorHeatpointModel.prototype, "_deviceUuid", void 0);
    __decorate([
        (0, Model_10.ModelProperty)()
    ], SensorHeatpointModel.prototype, "_intensity", void 0);
    __decorate([
        (0, Model_10.ModelProperty)()
    ], SensorHeatpointModel.prototype, "_radiusInCm", void 0);
    __decorate([
        (0, Model_10.ModelProperty)()
    ], SensorHeatpointModel.prototype, "_description", void 0);
    exports.SensorHeatpointModel = SensorHeatpointModel;
});
define("src/map/view/world/layers/heatmapLayer/HeatmapLayerImpl", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HeatmapLayerImpl = void 0;
    var HeatmapLayerImpl;
    (function (HeatmapLayerImpl) {
        class Config {
        }
        HeatmapLayerImpl.Config = Config;
    })(HeatmapLayerImpl = exports.HeatmapLayerImpl || (exports.HeatmapLayerImpl = {}));
});
define("src/map/view/world/layers/heatmapLayer/webgl/Shader", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Shader = void 0;
    class Shader {
        constructor(gl, vertexShader, fragmentShader) {
            this.gl = gl;
            this.program = this.gl.createProgram();
            this.vs = this.gl.createShader(this.gl.VERTEX_SHADER);
            this.fs = this.gl.createShader(this.gl.FRAGMENT_SHADER);
            this.gl.attachShader(this.program, this.vs);
            this.gl.attachShader(this.program, this.fs);
            this.compileShader(this.vs, vertexShader);
            this.compileShader(this.fs, fragmentShader);
            this.link();
            this.valueCache = {};
            this.uniformCache = {};
            this.attribCache = {};
        }
        attribLocation(name) {
            let location;
            location = this.attribCache[name];
            if (location === void 0) {
                location = this.attribCache[name] = this.gl.getAttribLocation(this.program, name);
            }
            return location;
        }
        compileShader(shader, source) {
            this.gl.shaderSource(shader, source);
            this.gl.compileShader(shader);
            if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                throw new Error("Shader Compile Error: " + (this.gl.getShaderInfoLog(shader)));
            }
        }
        link() {
            this.gl.linkProgram(this.program);
            if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
                throw new Error("Shader Link Error: " + (this.gl.getProgramInfoLog(this.program)));
            }
        }
        use() {
            this.gl.useProgram(this.program);
            return this;
        }
        uniformLoc(name) {
            let location;
            location = this.uniformCache[name];
            if (location === void 0) {
                location = this.uniformCache[name] = this.gl.getUniformLocation(this.program, name);
            }
            return location;
        }
        int(name, value) {
            let cached;
            let loc;
            cached = this.valueCache[name];
            if (cached !== value) {
                this.valueCache[name] = value;
                loc = this.uniformLoc(name);
                if (loc) {
                    this.gl.uniform1i(loc, value);
                }
            }
            return this;
        }
        vec2(name, a, b) {
            let loc;
            loc = this.uniformLoc(name);
            if (loc) {
                this.gl.uniform2f(loc, a, b);
            }
            return this;
        }
        float(name, value) {
            let cached;
            let loc;
            cached = this.valueCache[name];
            if (cached !== value) {
                this.valueCache[name] = value;
                loc = this.uniformLoc(name);
                if (loc) {
                    this.gl.uniform1f(loc, value);
                }
            }
            return this;
        }
    }
    exports.Shader = Shader;
    Shader.vertexShaderBlit = `
        attribute vec4 position;
        varying vec2 texcoord;
        void main(){
            texcoord = position.xy*0.5+0.5;
            gl_Position = position;
        }
    `;
    Shader.fragmentShaderBlit = `
        #ifdef GL_FRAGMENT_PRECISION_HIGH
            precision highp int;
            precision highp float;
        #else
            precision mediump int;
            precision mediump float;
        #endif
        uniform sampler2D source;
        varying vec2 texcoord;
    `;
});
define("src/map/view/world/layers/heatmapLayer/webgl/shaders/HeatmapShader", ["require", "exports", "src/map/view/world/layers/heatmapLayer/webgl/Shader"], function (require, exports, Shader_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HeatmapShader = void 0;
    class HeatmapShader extends Shader_1.Shader {
        constructor(gl, getColorFun, output) {
            super(gl, HeatmapShader.vs, HeatmapShader.getFragmentShader(getColorFun, output));
        }
        static getFragmentShader(getColorFun, output) {
            return Shader_1.Shader.fragmentShaderBlit + (`
            float linstep(float low, float high, float value){
                return clamp((value-low)/(high-low), 0.0, 1.0);
            }

            float fade(float low, float high, float value){
                float mid = (low+high)*0.5;
                float range = (high-low)*0.5;
                float x = 1.0 - clamp(abs(mid-value)/range, 0.0, 1.0);
                return smoothstep(0.0, 1.0, x);
            }

            ` + getColorFun + `
            ` + output + `

            void main(){
                float intensity = smoothstep(0.0, 1.0, texture2D(source, texcoord).r);
                vec3 color = getColor(intensity);
                gl_FragColor = alphaFun(color, intensity);
            }
        `);
        }
    }
    exports.HeatmapShader = HeatmapShader;
    HeatmapShader.vs = Shader_1.Shader.vertexShaderBlit;
});
define("src/map/view/world/layers/heatmapLayer/webgl/TextureObject", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextureObject = void 0;
    class TextureObject {
        constructor(gl, params) {
            let _ref;
            let _ref1;
            this.gl = gl;
            if (params == null) {
                params = {};
            }
            this.channels = this.gl[((_ref = params.channels) != null ? _ref : "rgba").toUpperCase()];
            if (typeof params.type === "number") {
                this.type = params.type;
            }
            else {
                this.type = this.gl[((_ref1 = params.type) != null ? _ref1 : "unsigned_byte").toUpperCase()];
            }
            switch (this.channels) {
                case this.gl.RGBA:
                    this.chancount = 4;
                    break;
                case this.gl.RGB:
                    this.chancount = 3;
                    break;
                case this.gl.LUMINANCE_ALPHA:
                    this.chancount = 2;
                    break;
                default:
                    this.chancount = 1;
            }
            this.target = this.gl.TEXTURE_2D;
            this.handle = this.gl.createTexture();
        }
        destroy() {
            return this.gl.deleteTexture(this.handle);
        }
        bind(unit) {
            if (unit == null) {
                unit = 0;
            }
            if (unit > 15) {
                throw new Error("Texture unit too large: " + unit);
            }
            this.gl.activeTexture(this.gl.TEXTURE0 + unit);
            this.gl.bindTexture(this.target, this.handle);
            return this;
        }
        setSize(width, height) {
            this.width = width;
            this.height = height;
            this.gl.texImage2D(this.target, 0, this.channels, this.width, this.height, 0, this.channels, this.type, null);
            return this;
        }
        upload(data) {
            this.width = data.width;
            this.height = data.height;
            this.gl.texImage2D(this.target, 0, this.channels, this.channels, this.type, data);
            return this;
        }
        linear() {
            this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
            return this;
        }
        nearest() {
            this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
            this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
            return this;
        }
        clampToEdge() {
            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            return this;
        }
        repeat() {
            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);
            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);
            return this;
        }
    }
    exports.TextureObject = TextureObject;
});
define("src/map/view/world/layers/heatmapLayer/webgl/shaders/ClampShader", ["require", "exports", "src/map/view/world/layers/heatmapLayer/webgl/Shader"], function (require, exports, Shader_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClampShader = void 0;
    class ClampShader extends Shader_2.Shader {
        constructor(gl) {
            super(gl, ClampShader.vs, ClampShader.fs);
        }
    }
    exports.ClampShader = ClampShader;
    ClampShader.vs = Shader_2.Shader.vertexShaderBlit;
    ClampShader.fs = Shader_2.Shader.fragmentShaderBlit + `
        uniform float low, high;
        void main(){
            gl_FragColor = vec4(clamp(texture2D(source, texcoord).rgb, low, high), 1.0);
        }
    `;
});
define("src/map/view/world/layers/heatmapLayer/webgl/shaders/MultiplyShader", ["require", "exports", "src/map/view/world/layers/heatmapLayer/webgl/Shader"], function (require, exports, Shader_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultiplyShader = void 0;
    class MultiplyShader extends Shader_3.Shader {
        constructor(gl) {
            super(gl, MultiplyShader.vs, MultiplyShader.fs);
        }
    }
    exports.MultiplyShader = MultiplyShader;
    MultiplyShader.vs = Shader_3.Shader.vertexShaderBlit;
    MultiplyShader.fs = Shader_3.Shader.fragmentShaderBlit + `
        uniform float value;
        void main(){
            gl_FragColor = vec4(texture2D(source, texcoord).rgb*value, 1.0);
        }
    `;
});
define("src/map/view/world/layers/heatmapLayer/webgl/shaders/BlurShader", ["require", "exports", "src/map/view/world/layers/heatmapLayer/webgl/Shader"], function (require, exports, Shader_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlurShader = void 0;
    class BlurShader extends Shader_4.Shader {
        constructor(gl) {
            super(gl, BlurShader.vs, BlurShader.fs);
        }
    }
    exports.BlurShader = BlurShader;
    BlurShader.vs = Shader_4.Shader.vertexShaderBlit;
    BlurShader.fs = Shader_4.Shader.fragmentShaderBlit + `
        uniform vec2 viewport;
        void main(){
            vec4 result = vec4(0.0);
            for(int x=-1; x<=1; x++){
                for(int y=-1; y<=1; y++){
                    vec2 off = vec2(x,y)/viewport;
                    //float factor = 1.0 - smoothstep(0.0, 1.5, length(off));
                    float factor = 1.0;
                    result += vec4(texture2D(source, texcoord+off).rgb*factor, factor);
                }
            }
            gl_FragColor = vec4(result.rgb/result.w, 1.0);
        }`;
});
define("src/map/view/world/layers/heatmapLayer/webgl/shaders/HeightsShader", ["require", "exports", "src/map/view/world/layers/heatmapLayer/webgl/Shader"], function (require, exports, Shader_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HeightsShader = void 0;
    class HeightsShader extends Shader_5.Shader {
        constructor(gl) {
            super(gl, HeightsShader.vs, HeightsShader.fs);
        }
    }
    exports.HeightsShader = HeightsShader;
    HeightsShader.vs = `
        attribute vec4 position, intensity;
        varying vec2 off, dim;
        varying float vIntensity;
        uniform vec2 viewport;

        void main(){
            dim = abs(position.zw);
            off = position.zw;
            vec2 pos = position.xy + position.zw;
            vIntensity = intensity.x;
            gl_Position = vec4((pos/viewport)*2.0-1.0, 0.0, 1.0);
        }
    `;
    HeightsShader.fs = `
        #ifdef GL_FRAGMENT_PRECISION_HIGH
            precision highp int;
            precision highp float;
        #else
            precision mediump int;
            precision mediump float;
        #endif
        varying vec2 off, dim;
        varying float vIntensity;
        void main(){
            float falloff = (1.0 - smoothstep(0.0, 1.0, length(off/dim)));
            float intensity = falloff*vIntensity;
            gl_FragColor = vec4(intensity);
        }
    `;
});
define("src/map/view/world/layers/heatmapLayer/webgl/Framebuffer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Framebuffer = void 0;
    class Framebuffer {
        constructor(gl) {
            this.gl = gl;
            this.buffer = this.gl.createFramebuffer();
        }
        bind() {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.buffer);
            return this;
        }
        unbind(defaultFramebuffer) {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, defaultFramebuffer);
            return this;
        }
        check() {
            let result;
            result = this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER);
            switch (result) {
                case this.gl.FRAMEBUFFER_UNSUPPORTED:
                    throw new Error("Framebuffer is unsupported");
                case this.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    throw new Error("Framebuffer incomplete attachment");
                case this.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    throw new Error("Framebuffer incomplete dimensions");
                case this.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    throw new Error("Framebuffer incomplete missing attachment");
            }
            return this;
        }
        color(texture) {
            this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, texture.target, texture.handle, 0);
            this.check();
            return this;
        }
        depth(buffer) {
            this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, buffer.id);
            this.check();
            return this;
        }
        destroy() {
            return this.gl.deleteFramebuffer(this.buffer);
        }
    }
    exports.Framebuffer = Framebuffer;
});
define("src/map/view/world/layers/heatmapLayer/webgl/Node", ["require", "exports", "src/map/view/world/layers/heatmapLayer/webgl/TextureObject", "src/map/view/world/layers/heatmapLayer/webgl/Framebuffer"], function (require, exports, TextureObject_1, Framebuffer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Node = void 0;
    class Node {
        constructor(gl, width, height, defaultFbo) {
            this.gl = gl;
            this.width = width;
            this.height = height;
            this.defaultFbo = defaultFbo;
            let floatExt = this.gl.getFloatExtension({
                require: ["renderable"]
            });
            this.texture = new TextureObject_1.TextureObject(this.gl, {
                type: floatExt.type
            }).bind(0).setSize(this.width, this.height).nearest().clampToEdge();
            this.fbo = new Framebuffer_1.Framebuffer(this.gl).bind().color(this.texture).unbind(this.defaultFbo);
        }
        use() {
            this.fbo.bind();
            this.gl.viewport(0, 0, this.width, this.height);
            return this;
        }
        bind(unit) {
            return this.texture.bind(unit);
        }
        end() {
            return this.fbo.unbind(this.defaultFbo);
        }
        resize(width, height) {
            this.width = width;
            this.height = height;
            return this.texture.bind(0).setSize(this.width, this.height);
        }
    }
    exports.Node = Node;
});
define("src/map/view/world/layers/heatmapLayer/webgl/Heights", ["require", "exports", "src/map/view/world/layers/heatmapLayer/webgl/shaders/ClampShader", "src/map/view/world/layers/heatmapLayer/webgl/shaders/MultiplyShader", "src/map/view/world/layers/heatmapLayer/webgl/shaders/BlurShader", "src/map/view/world/layers/heatmapLayer/webgl/shaders/HeightsShader", "src/map/view/world/layers/heatmapLayer/webgl/Node"], function (require, exports, ClampShader_1, MultiplyShader_1, BlurShader_1, HeightsShader_1, Node_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Heights = void 0;
    class Heights {
        constructor(heatmap, gl, width, height, maxPointCount = 1024 * 10) {
            let i;
            let _i;
            let _ref;
            this.heatmap = heatmap;
            this.gl = gl;
            this.width = width;
            this.height = height;
            this.shader = new HeightsShader_1.HeightsShader(this.gl);
            this.clampShader = new ClampShader_1.ClampShader(this.gl);
            this.multiplyShader = new MultiplyShader_1.MultiplyShader(this.gl);
            this.blurShader = new BlurShader_1.BlurShader(this.gl);
            this.nodeBack = new Node_1.Node(this.gl, this.width, this.height, this.heatmap.framebuffer);
            this.nodeFront = new Node_1.Node(this.gl, this.width, this.height, this.heatmap.framebuffer);
            this.vertexBuffer = this.gl.createBuffer();
            this.vertexSize = 8;
            this.maxPointCount = maxPointCount;
            this.vertexBufferData = new Float32Array(this.maxPointCount * this.vertexSize * 6);
            this.vertexBufferViews = [];
            for (i = _i = 0, _ref = this.maxPointCount; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                this.vertexBufferViews.push(new Float32Array(this.vertexBufferData.buffer, 0, i * this.vertexSize * 6));
            }
            this.bufferIndex = 0;
            this.pointCount = 0;
        }
        resize(width, height) {
            this.width = width;
            this.height = height;
            this.nodeBack.resize(this.width, this.height);
            return this.nodeFront.resize(this.width, this.height);
        }
        uploadHeightPoints() {
            if (this.pointCount > 0) {
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vertexBufferViews[this.pointCount], this.gl.STREAM_DRAW);
            }
        }
        renderPointsToHeightMap() {
            this.nodeFront.use();
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
            this.gl.enable(this.gl.BLEND);
            let positionLoc = this.shader.attribLocation("position");
            let intensityLoc = this.shader.attribLocation("intensity");
            this.gl.enableVertexAttribArray(1);
            this.gl.vertexAttribPointer(positionLoc, 4, this.gl.FLOAT, false, 8 * 4, 0 * 4);
            this.gl.vertexAttribPointer(intensityLoc, 4, this.gl.FLOAT, false, 8 * 4, 4 * 4);
            this.shader.use().vec2("viewport", this.width, this.height);
            this.gl.drawArrays(this.gl.TRIANGLES, 0, this.pointCount * 6);
            this.gl.disableVertexAttribArray(1);
            this.pointCount = 0;
            this.bufferIndex = 0;
            this.nodeFront.end();
            this.gl.disable(this.gl.BLEND);
        }
        clear() {
            this.nodeFront.use();
            this.gl.clearColor(0, 0, 0, 1);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
            return this.nodeFront.end();
        }
        clamp(min, max) {
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.heatmap.quad);
            this.gl.vertexAttribPointer(0, 4, this.gl.FLOAT, false, 0, 0);
            this.nodeFront.bind(0);
            this.nodeBack.use();
            this.clampShader.use().int("source", 0).float("low", min).float("high", max);
            this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
            this.nodeBack.end();
            return this.swap();
        }
        multiply(value) {
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.heatmap.quad);
            this.gl.vertexAttribPointer(0, 4, this.gl.FLOAT, false, 0, 0);
            this.nodeFront.bind(0);
            this.nodeBack.use();
            this.multiplyShader.use().int("source", 0).float("value", value);
            this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
            this.nodeBack.end();
            return this.swap();
        }
        blur() {
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.heatmap.quad);
            this.gl.vertexAttribPointer(0, 4, this.gl.FLOAT, false, 0, 0);
            this.nodeFront.bind(0);
            this.nodeBack.use();
            this.blurShader.use().int("source", 0).vec2("viewport", this.width, this.height);
            this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
            this.nodeBack.end();
            return this.swap();
        }
        swap() {
            let tmp;
            tmp = this.nodeFront;
            this.nodeFront = this.nodeBack;
            return this.nodeBack = tmp;
        }
        addVertex(x, y, xs, ys, intensity) {
            this.vertexBufferData[this.bufferIndex++] = x;
            this.vertexBufferData[this.bufferIndex++] = y;
            this.vertexBufferData[this.bufferIndex++] = xs;
            this.vertexBufferData[this.bufferIndex++] = ys;
            this.vertexBufferData[this.bufferIndex++] = intensity;
            this.vertexBufferData[this.bufferIndex++] = intensity;
            this.vertexBufferData[this.bufferIndex++] = intensity;
            return this.vertexBufferData[this.bufferIndex++] = intensity;
        }
        addPoint(x, y, size, intensity) {
            let s;
            if (size == null) {
                size = 50;
            }
            if (intensity == null) {
                intensity = 0.2;
            }
            if (this.pointCount >= this.maxPointCount - 1) {
                this.uploadHeightPoints();
                this.pointCount = 0;
                this.bufferIndex = 0;
            }
            y = this.height - y;
            s = size / 2;
            this.addVertex(x, y, -s, -s, intensity);
            this.addVertex(x, y, +s, -s, intensity);
            this.addVertex(x, y, -s, +s, intensity);
            this.addVertex(x, y, -s, +s, intensity);
            this.addVertex(x, y, +s, -s, intensity);
            this.addVertex(x, y, +s, +s, intensity);
            return this.pointCount += 1;
        }
    }
    exports.Heights = Heights;
});
define("src/map/view/world/layers/heatmapLayer/webgl/WebGlHeatmap", ["require", "exports", "src/map/view/world/layers/heatmapLayer/webgl/shaders/HeatmapShader", "src/map/utils/Logger", "src/map/view/world/layers/heatmapLayer/webgl/TextureObject", "src/map/view/world/layers/heatmapLayer/webgl/Heights"], function (require, exports, HeatmapShader_1, Logger_4, TextureObject_2, Heights_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebGlHeatmap = void 0;
    let glExtensionsAdded = false;
    class WebGlHeatmap {
        constructor(_arg, config = new WebGlHeatmap.Config()) {
            let alphaEnd;
            let alphaRange;
            let alphaStart;
            let error;
            let getColorFun;
            let gradientTexture;
            let image;
            let intensityToAlpha;
            let output;
            let quad;
            let textureGradient;
            let _ref;
            let _ref1;
            _ref = _arg != null ? _arg : {};
            this.gl = _ref.gl;
            this.framebuffer = _ref.framebuffer;
            this.width = _ref.width;
            this.height = _ref.height;
            intensityToAlpha = _ref.intensityToAlpha;
            gradientTexture = _ref.gradientTexture;
            alphaRange = _ref.alphaRange;
            if (!glExtensionsAdded) {
                const glClass = this.gl instanceof WebGL2RenderingContext ? window.WebGL2RenderingContext : window.WebGLRenderingContext;
                nukeVendorPrefix(glClass);
                textureFloatShims(glClass);
                glExtensionsAdded = true;
            }
            if (window.WebGLDebugUtils != null) {
                Logger_4.Logger.logDebug("debugging mode");
                this.gl = WebGLDebugUtils.makeDebugContext(this.gl, function (err, funcName, args) {
                    throw new Error(WebGLDebugUtils.glEnumToString(err) + " was caused by call to: " + funcName);
                });
            }
            this.gl.enableVertexAttribArray(0);
            this.gl.blendFunc(this.gl.ONE, this.gl.ONE);
            if (gradientTexture) {
                textureGradient = this.gradientTexture = new TextureObject_2.TextureObject(this.gl, {
                    channels: "rgba"
                }).bind(0).setSize(2, 2).nearest().clampToEdge();
                if (typeof gradientTexture === "string") {
                    image = new Image();
                    image.onload = function () {
                        return textureGradient.bind().upload(image);
                    };
                    image.src = gradientTexture;
                }
                else {
                    if (gradientTexture.width > 0 && gradientTexture.height > 0) {
                        textureGradient.upload(gradientTexture);
                    }
                    else {
                        gradientTexture.onload = function () {
                            return textureGradient.upload(gradientTexture);
                        };
                    }
                }
                getColorFun = `
                uniform sampler2D gradientTexture;
                vec3 getColor(float intensity){
                    return texture2D(gradientTexture, vec2(intensity, 0.0)).rgb;
                }
            `;
            }
            else {
                textureGradient = null;
                getColorFun = `
                vec3 getColor(float intensity){
                    vec3 blue = vec3(0.0, 0.0, 1.0);
                    vec3 cyan = vec3(0.0, 1.0, 1.0);
                    vec3 green = vec3(0.0, 1.0, 0.0);
                    vec3 yellow = vec3(1.0, 1.0, 0.0);
                    vec3 red = vec3(1.0, 0.0, 0.0);

                    vec3 color = (
                        fade(-0.25, 0.25, intensity)*blue +
                        fade(0.0, 0.5, intensity)*cyan +
                        fade(0.25, 0.75, intensity)*green +
                        fade(0.5, 1.0, intensity)*yellow +
                        smoothstep(0.75, 1.0, intensity)*red
                    );
                    return color;
                }
            `;
            }
            if (intensityToAlpha == null) {
                intensityToAlpha = true;
            }
            if (intensityToAlpha) {
                _ref1 = alphaRange != null ? alphaRange : [0, 1], alphaStart = _ref1[0], alphaEnd = _ref1[1];
                output = `
                vec4 alphaFun(vec3 color, float intensity){
                    float alpha = smoothstep(` + (alphaStart.toFixed(8)) + `, ` + (alphaEnd.toFixed(8)) + `, intensity);
                    return vec4(color*alpha, alpha);
                }
            `;
            }
            else {
                output = `
                vec4 alphaFun(vec3 color, float intensity){
                    return vec4(color, 1.0);
                }
            `;
            }
            this.shader = new HeatmapShader_1.HeatmapShader(this.gl, getColorFun, output);
            this.gl.viewport(0, 0, this.width, this.height);
            this.quad = this.gl.createBuffer();
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quad);
            quad = new Float32Array([-1, -1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, 1, 0, 1, 1, -1, 0, 1, 1, 1, 0, 1]);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, quad, this.gl.STATIC_DRAW);
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
            this.heights = new Heights_1.Heights(this, this.gl, this.width, this.height, config.maxNumOfHeatpoints);
        }
        adjustSize(targetWidth, targetHeight) {
            let canvasWidth = targetWidth || 2;
            let canvasHeight = targetHeight || 2;
            if (this.width !== canvasWidth || this.height !== canvasHeight) {
                this.gl.viewport(0, 0, canvasWidth, canvasHeight);
                this.width = canvasWidth;
                this.height = canvasHeight;
                return this.heights.resize(this.width, this.height);
            }
        }
        renderColorizedHeightMap() {
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quad);
            this.gl.vertexAttribPointer(0, 4, this.gl.FLOAT, false, 0, 0);
            this.heights.nodeFront.bind(0);
            if (this.gradientTexture) {
                this.gradientTexture.bind(1);
            }
            this.shader.use().int("source", 0).int("gradientTexture", 1);
            return this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
        }
        uploadHeightPoints() {
            return this.heights.uploadHeightPoints();
        }
        renderPointsToHeightMap() {
            return this.heights.renderPointsToHeightMap();
        }
        clear() {
            return this.heights.clear();
        }
        clamp(min, max) {
            if (min == null) {
                min = 0;
            }
            if (max == null) {
                max = 1;
            }
            return this.heights.clamp(min, max);
        }
        multiply(value) {
            if (value == null) {
                value = 0.95;
            }
            return this.heights.multiply(value);
        }
        blur() {
            return this.heights.blur();
        }
        addPoint(x, y, size, intensity) {
            return this.heights.addPoint(x, y, size, intensity);
        }
        addPoints(items) {
            let item;
            let _i;
            let _len;
            let _results;
            _results = [];
            for (_i = 0, _len = items.length; _i < _len; _i++) {
                item = items[_i];
                _results.push(this.addPoint(item.x, item.y, item.size, item.intensity));
            }
            return _results;
        }
    }
    exports.WebGlHeatmap = WebGlHeatmap;
    (function (WebGlHeatmap) {
        class Config {
            constructor() {
                /**
                 * The maximum number of heatpoints that can be loaded into the GPU memory.
                 *
                 * <p>
                 * Whenever the number of added heatpoints exceeds this threshold, the vertex buffer containing
                 * the heatpoint coordinates and intensities will be flushed and only the heatpoints added after the flush will be
                 * loaded to the GPU afterwards. This will lead to a "starvation" of all flushed vertices
                 * when applying the multipy shader several times, as the multiply shader will decrease the intensity of all heatpoints
                 * for each execution of the multiply shader program by the multiplication factor.
                 * </p>
                 *
                 * <p>Must be a power of 2</p>
                 *
                 * <p>Default: 8192</p>
                 */
                this.maxNumOfHeatpoints = 8192;
            }
        }
        WebGlHeatmap.Config = Config;
    })(WebGlHeatmap = exports.WebGlHeatmap || (exports.WebGlHeatmap = {}));
    /* tslint:disable */
    // Generated by CoffeeScript 1.8.0
    var __indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {
        if (i in this && this[i] === item)
            return i;
    } return -1; };
    let nukeVendorPrefix = function (webGlContextClass) {
        var getExtension, getSupportedExtensions, vendorRe, vendors;
        if (webGlContextClass != null) {
            vendors = ['WEBKIT', 'MOZ', 'MS', 'O'];
            vendorRe = /^WEBKIT_(.*)|MOZ_(.*)|MS_(.*)|O_(.*)/;
            getExtension = webGlContextClass.prototype.getExtension;
            webGlContextClass.prototype.getExtension = function (name) {
                var extobj, match, vendor, _i, _len;
                match = name.match(vendorRe);
                if (match !== null) {
                    name = match[1];
                }
                extobj = getExtension.call(this, name);
                if (extobj === null) {
                    for (_i = 0, _len = vendors.length; _i < _len; _i++) {
                        vendor = vendors[_i];
                        extobj = getExtension.call(this, vendor + '_' + name);
                        if (extobj !== null) {
                            return extobj;
                        }
                    }
                    return null;
                }
                else {
                    return extobj;
                }
            };
            getSupportedExtensions = webGlContextClass.prototype.getSupportedExtensions;
            return webGlContextClass.prototype.getSupportedExtensions = function () {
                var extension, match, result, supported, _i, _len;
                supported = getSupportedExtensions.call(this);
                result = [];
                for (_i = 0, _len = supported.length; _i < _len; _i++) {
                    extension = supported[_i];
                    match = extension.match(vendorRe);
                    if (match !== null) {
                        extension = match[1];
                    }
                    if (__indexOf.call(result, extension) < 0) {
                        result.push(extension);
                    }
                }
                return result;
            };
        }
    };
    let textureFloatShims = function (webGlContextClass) {
        var checkColorBuffer, checkFloatLinear, checkSupport, checkTexture, createSourceCanvas, getExtension, getSupportedExtensions, name, shimExtensions, shimLookup, unshimExtensions, unshimLookup, _i, _len;
        createSourceCanvas = function () {
            var canvas, ctx, imageData;
            canvas = document.createElement('canvas');
            canvas.width = 2;
            canvas.height = 2;
            ctx = canvas.getContext('2d');
            imageData = ctx.getImageData(0, 0, 2, 2);
            imageData.data.set(new Uint8ClampedArray([0, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255]));
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        };
        createSourceCanvas();
        checkFloatLinear = function (gl, sourceType) {
            var buffer, cleanup, fragmentShader, framebuffer, positionLoc, program, readBuffer, result, source, sourceCanvas, sourceLoc, target, vertexShader, vertices;
            program = gl.createProgram();
            vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.attachShader(program, vertexShader);
            gl.shaderSource(vertexShader, 'attribute vec2 position;\nvoid main(){\n    gl_Position = vec4(position, 0.0, 1.0);\n}');
            gl.compileShader(vertexShader);
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                throw gl.getShaderInfoLog(vertexShader);
            }
            fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.attachShader(program, fragmentShader);
            gl.shaderSource(fragmentShader, 'uniform sampler2D source;\nvoid main(){\n    gl_FragColor = texture2D(source, vec2(1.0, 1.0));\n}');
            gl.compileShader(fragmentShader);
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                throw gl.getShaderInfoLog(fragmentShader);
            }
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                throw gl.getProgramInfoLog(program);
            }
            gl.useProgram(program);
            cleanup = function () {
                gl.deleteShader(fragmentShader);
                gl.deleteShader(vertexShader);
                gl.deleteProgram(program);
                gl.deleteBuffer(buffer);
                gl.deleteTexture(source);
                gl.deleteTexture(target);
                gl.deleteFramebuffer(framebuffer);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.useProgram(null);
                gl.bindTexture(gl.TEXTURE_2D, null);
                return gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            };
            target = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, target);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target, 0);
            sourceCanvas = createSourceCanvas();
            source = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, source);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, sourceType, sourceCanvas);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            vertices = new Float32Array([1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1]);
            buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            positionLoc = gl.getAttribLocation(program, 'position');
            sourceLoc = gl.getUniformLocation(program, 'source');
            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
            gl.uniform1i(sourceLoc, 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            readBuffer = new Uint8Array(4 * 4);
            gl.readPixels(0, 0, 2, 2, gl.RGBA, gl.UNSIGNED_BYTE, readBuffer);
            result = Math.abs(readBuffer[0] - 127) < 10;
            cleanup();
            return result;
        };
        checkTexture = function (gl, targetType) {
            var target;
            target = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, target);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, targetType, null);
            if (gl.getError() === 0) {
                gl.deleteTexture(target);
                return true;
            }
            else {
                gl.deleteTexture(target);
                return false;
            }
        };
        checkColorBuffer = function (gl, targetType) {
            var check, framebuffer, target;
            target = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, target);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, targetType, null);
            framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target, 0);
            check = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            gl.deleteTexture(target);
            gl.deleteFramebuffer(framebuffer);
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            if (check === gl.FRAMEBUFFER_COMPLETE) {
                return true;
            }
            else {
                return false;
            }
        };
        shimExtensions = [];
        shimLookup = {};
        unshimExtensions = [];
        checkSupport = function () {
            var canvas, extobj, gl, halfFloatExt, halfFloatTexturing, singleFloatExt, singleFloatTexturing;
            canvas = document.createElement('canvas');
            gl = null;
            try {
                gl = canvas.getContext('experimental-webgl');
                if (gl === null) {
                    gl = canvas.getContext('webgl');
                }
            }
            catch (_error) { }
            if (gl != null) {
                singleFloatExt = gl.getExtension('OES_texture_float');
                if (singleFloatExt === null) {
                    if (checkTexture(gl, gl.FLOAT)) {
                        singleFloatTexturing = true;
                        shimExtensions.push('OES_texture_float');
                        shimLookup.OES_texture_float = {
                            shim: true
                        };
                    }
                    else {
                        singleFloatTexturing = false;
                        unshimExtensions.push('OES_texture_float');
                    }
                }
                else {
                    if (checkTexture(gl, gl.FLOAT)) {
                        singleFloatTexturing = true;
                        shimExtensions.push('OES_texture_float');
                    }
                    else {
                        singleFloatTexturing = false;
                        unshimExtensions.push('OES_texture_float');
                    }
                }
                if (singleFloatTexturing) {
                    extobj = gl.getExtension('WEBGL_color_buffer_float');
                    if (extobj === null) {
                        if (checkColorBuffer(gl, gl.FLOAT)) {
                            shimExtensions.push('WEBGL_color_buffer_float');
                            shimLookup.WEBGL_color_buffer_float = {
                                shim: true,
                                RGBA32F_EXT: 0x8814,
                                RGB32F_EXT: 0x8815,
                                FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211,
                                UNSIGNED_NORMALIZED_EXT: 0x8C17
                            };
                        }
                        else {
                            unshimExtensions.push('WEBGL_color_buffer_float');
                        }
                    }
                    else {
                        if (checkColorBuffer(gl, gl.FLOAT)) {
                            shimExtensions.push('WEBGL_color_buffer_float');
                        }
                        else {
                            unshimExtensions.push('WEBGL_color_buffer_float');
                        }
                    }
                    extobj = gl.getExtension('OES_texture_float_linear');
                    if (extobj === null) {
                        if (checkFloatLinear(gl, gl.FLOAT)) {
                            shimExtensions.push('OES_texture_float_linear');
                            shimLookup.OES_texture_float_linear = {
                                shim: true
                            };
                        }
                        else {
                            unshimExtensions.push('OES_texture_float_linear');
                        }
                    }
                    else {
                        if (checkFloatLinear(gl, gl.FLOAT)) {
                            shimExtensions.push('OES_texture_float_linear');
                        }
                        else {
                            unshimExtensions.push('OES_texture_float_linear');
                        }
                    }
                }
                halfFloatExt = gl.getExtension('OES_texture_half_float');
                if (halfFloatExt === null) {
                    if (checkTexture(gl, 0x8D61)) {
                        halfFloatTexturing = true;
                        shimExtensions.push('OES_texture_half_float');
                        halfFloatExt = shimLookup.OES_texture_half_float = {
                            HALF_FLOAT_OES: 0x8D61,
                            shim: true
                        };
                    }
                    else {
                        halfFloatTexturing = false;
                        unshimExtensions.push('OES_texture_half_float');
                    }
                }
                else {
                    if (checkTexture(gl, halfFloatExt.HALF_FLOAT_OES)) {
                        halfFloatTexturing = true;
                        shimExtensions.push('OES_texture_half_float');
                    }
                    else {
                        halfFloatTexturing = false;
                        unshimExtensions.push('OES_texture_half_float');
                    }
                }
                if (halfFloatTexturing) {
                    extobj = gl.getExtension('EXT_color_buffer_half_float');
                    if (extobj === null) {
                        if (checkColorBuffer(gl, halfFloatExt.HALF_FLOAT_OES)) {
                            shimExtensions.push('EXT_color_buffer_half_float');
                            shimLookup.EXT_color_buffer_half_float = {
                                shim: true,
                                RGBA16F_EXT: 0x881A,
                                RGB16F_EXT: 0x881B,
                                FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211,
                                UNSIGNED_NORMALIZED_EXT: 0x8C17
                            };
                        }
                        else {
                            unshimExtensions.push('EXT_color_buffer_half_float');
                        }
                    }
                    else {
                        if (checkColorBuffer(gl, halfFloatExt.HALF_FLOAT_OES)) {
                            shimExtensions.push('EXT_color_buffer_half_float');
                        }
                        else {
                            unshimExtensions.push('EXT_color_buffer_half_float');
                        }
                    }
                    extobj = gl.getExtension('OES_texture_half_float_linear');
                    if (extobj === null) {
                        if (checkFloatLinear(gl, halfFloatExt.HALF_FLOAT_OES)) {
                            shimExtensions.push('OES_texture_half_float_linear');
                            return shimLookup.OES_texture_half_float_linear = {
                                shim: true
                            };
                        }
                        else {
                            return unshimExtensions.push('OES_texture_half_float_linear');
                        }
                    }
                    else {
                        if (checkFloatLinear(gl, halfFloatExt.HALF_FLOAT_OES)) {
                            return shimExtensions.push('OES_texture_half_float_linear');
                        }
                        else {
                            return unshimExtensions.push('OES_texture_half_float_linear');
                        }
                    }
                }
            }
        };
        if (webGlContextClass != null) {
            checkSupport();
            unshimLookup = {};
            for (_i = 0, _len = unshimExtensions.length; _i < _len; _i++) {
                name = unshimExtensions[_i];
                unshimLookup[name] = true;
            }
            getExtension = webGlContextClass.prototype.getExtension;
            webGlContextClass.prototype.getExtension = function (name) {
                var extobj;
                extobj = shimLookup[name];
                if (extobj === void 0) {
                    if (unshimLookup[name]) {
                        return null;
                    }
                    else {
                        return getExtension.call(this, name);
                    }
                }
                else {
                    return extobj;
                }
            };
            getSupportedExtensions = webGlContextClass.prototype.getSupportedExtensions;
            webGlContextClass.prototype.getSupportedExtensions = function () {
                var extension, result, supported, _j, _k, _len1, _len2;
                supported = getSupportedExtensions.call(this);
                result = [];
                for (_j = 0, _len1 = supported.length; _j < _len1; _j++) {
                    extension = supported[_j];
                    if (unshimLookup[extension] === void 0) {
                        result.push(extension);
                    }
                }
                for (_k = 0, _len2 = shimExtensions.length; _k < _len2; _k++) {
                    extension = shimExtensions[_k];
                    if (__indexOf.call(result, extension) < 0) {
                        result.push(extension);
                    }
                }
                return result;
            };
            return webGlContextClass.prototype.getFloatExtension = function (spec) {
                var candidate, candidates, half, halfFramebuffer, halfLinear, halfTexture, i, importance, preference, result, single, singleFramebuffer, singleLinear, singleTexture, use, _j, _k, _l, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2;
                if (spec.prefer == null) {
                    spec.prefer = ['half'];
                }
                if (spec.require == null) {
                    spec.require = [];
                }
                if (spec.throws == null) {
                    spec.throws = true;
                }
                singleTexture = this.getExtension('OES_texture_float');
                halfTexture = this.getExtension('OES_texture_half_float');
                singleFramebuffer = this.getExtension('WEBGL_color_buffer_float');
                halfFramebuffer = this.getExtension('EXT_color_buffer_half_float');
                singleLinear = this.getExtension('OES_texture_float_linear');
                halfLinear = this.getExtension('OES_texture_half_float_linear');
                single = {
                    texture: singleTexture !== null || webGlContextClass === WebGL2RenderingContext,
                    filterable: singleLinear !== null,
                    renderable: singleFramebuffer !== null,
                    score: 0,
                    precision: 'single',
                    half: false,
                    single: true,
                    type: this.FLOAT
                };
                half = {
                    texture: halfTexture !== null || webGlContextClass === WebGL2RenderingContext,
                    filterable: halfLinear !== null,
                    renderable: halfFramebuffer !== null,
                    score: 0,
                    precision: 'half',
                    half: true,
                    single: false,
                    type: (_ref = halfTexture != null ? halfTexture.HALF_FLOAT_OES : void 0) != null ? _ref : null
                };
                candidates = [];
                if (single.texture) {
                    candidates.push(single);
                }
                if (half.texture) {
                    candidates.push(half);
                }
                result = [];
                for (_j = 0, _len1 = candidates.length; _j < _len1; _j++) {
                    candidate = candidates[_j];
                    use = true;
                    _ref1 = spec.require;
                    for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                        name = _ref1[_k];
                        if (candidate[name] === false) {
                            use = false;
                        }
                    }
                    if (use) {
                        result.push(candidate);
                    }
                }
                for (_l = 0, _len3 = result.length; _l < _len3; _l++) {
                    candidate = result[_l];
                    _ref2 = spec.prefer;
                    for (i = _m = 0, _len4 = _ref2.length; _m < _len4; i = ++_m) {
                        preference = _ref2[i];
                        importance = Math.pow(2, spec.prefer.length - i - 1);
                        if (candidate[preference]) {
                            candidate.score += importance;
                        }
                    }
                }
                result.sort(function (a, b) {
                    if (a.score === b.score) {
                        return 0;
                    }
                    else if (a.score < b.score) {
                        return 1;
                    }
                    else if (a.score > b.score) {
                        return -1;
                    }
                });
                if (result.length === 0) {
                    if (spec.throws) {
                        throw 'No floating point texture support that is ' + spec.require.join(', ');
                    }
                    else {
                        return null;
                    }
                }
                else {
                    result = result[0];
                    return {
                        filterable: result.filterable,
                        renderable: result.renderable,
                        type: result.type,
                        precision: result.precision
                    };
                }
            };
        }
    };
});
define("src/engine/rendering/WebGlRenderer", ["require", "exports", "src/engine/rendering/Renderer"], function (require, exports, Renderer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebGlRenderer = void 0;
    /**
     * A renderer that uses WebGL for rendering.
     */
    class WebGlRenderer extends Renderer_1.Renderer {
    }
    exports.WebGlRenderer = WebGlRenderer;
});
define("src/map/view/world/layers/heatmapLayer/webgl/WebGlHeatmapLayer", ["require", "exports", "src/map/utils/Logger", "src/map/view/Layer", "src/map/view/world/layers/heatmapLayer/HeatmapLayerImpl", "src/map/view/world/layers/heatmapLayer/webgl/WebGlHeatmap", "src/engine/rendering/WebGlRenderer"], function (require, exports, Logger_5, Layer_6, HeatmapLayerImpl_1, WebGlHeatmap_1, WebGlRenderer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebGlHeatmapLayer = void 0;
    /**
     * A WebGL shader based heatmap layer.
     *
     * <p>This layer renders a heatmap to a texture of a sprite object using a shader program
     * that is based on:</p>
     *
     * <a href="https://github.com/pyalot/webgl-heatmap">WebGL Heatmap</a>
     */
    class WebGlHeatmapLayer extends Layer_6.Layer {
        // Construction
        constructor(environment, config) {
            super(environment);
            // Rendering
            this.heatmap = null;
            // State
            this.pointsToAdd = new Array();
            this.clampMin = 0;
            this.clampMax = 1;
            this.multiplicationFactor = 1.0;
            this.dirty = true;
            this.dirtyClear = false;
            this.config = config;
            // Create canvas with floor size
            let canvas = document.createElement("canvas");
            canvas.width = config.textureWidth;
            canvas.height = config.textureHeight;
            // Create Texture objects
            let texture = this.getEnvironment().renderer.newTexture(canvas);
            this.spriteObject = this.getEnvironment().renderer.newSpriteObject(texture);
            this.spriteObject.width = config.floorWidth;
            this.spriteObject.height = config.floorHeight;
            this.getView().addChild(this.spriteObject);
        }
        // Configuration
        // @Override
        addPoint(x, y, radius, intensity) {
            y = this.spriteObject.texture.height - y;
            let point = { x: x, y: y, size: radius * 4, intensity: intensity };
            this.pointsToAdd.push(point);
            this.dirty = true;
        }
        // @Override
        addPoints(points) {
            for (let i = 0; i < points.length; i++) {
                let point = points[i];
                this.addPoint(point.x, point.y, point.radius, point.intensity);
            }
            this.dirty = true;
        }
        // @Override
        clear() {
            this.pointsToAdd = [0, 0, 0, 0];
            this.dirtyClear = true;
            this.dirty = true;
        }
        // @Override
        clamp(min, max) {
            this.clampMin = min;
            this.clampMax = max;
            this.dirty = true;
        }
        // @Override
        multiply(value) {
            this.multiplicationFactor = value;
            this.dirty = true;
        }
        // Rendering
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.dirty === true) {
                const renderer = this.getEnvironment().renderer;
                if (renderer instanceof WebGlRenderer_1.WebGlRenderer) {
                    this.renderHeatmapToTexture(renderer);
                    this.getEnvironment().renderer.dirty = true;
                    this.dirty = false;
                    this.dirtyClear = false;
                }
            }
        }
        renderHeatmapToTexture(renderer) {
            try {
                // Prepare the renderer for rendering to texture.
                const previousState = renderer.getWebGlState();
                renderer.resetWebGlState();
                try {
                    // Initialize heatmap if necessary
                    if (this.heatmap === null) {
                        this.initHeatmap(renderer);
                    }
                    // Upload heat points
                    this.uploadHeatpoints();
                    // Render the heatmap to the sprite's texture.
                    this.renderHeatmap(renderer.gl);
                }
                catch (e) {
                    throw e;
                }
                finally {
                    // Reset renderer to previous state (rendering to screen framebuffer again)
                    renderer.restoreWebGlState(previousState);
                }
            }
            catch (e) {
                Logger_5.Logger.logDebug("An error occurred while rendering the heatmap to texture. " + e.message);
            }
        }
        initHeatmap(renderer) {
            try {
                let gl = renderer.gl;
                // Create framebuffer that will be used to render to texture.
                this.webGlFramebuffer = gl.createFramebuffer();
                // Bind the framebuffer
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.webGlFramebuffer);
                // Change viewport back to fit the texture size
                gl.viewport(0, 0, this.spriteObject.texture.width, this.spriteObject.texture.height);
                // Force the renderer to load the native WebGL texture object to the GPU.
                renderer.flushTexture(this.spriteObject.texture);
                // Get the sprite's native WebGL texture.
                this.webGlTexture = renderer.getWebGlTexture(this.spriteObject.texture);
                // Bind sprite texture to framebuffer
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.webGlTexture, 0);
                this.heatmap = new WebGlHeatmap_1.WebGlHeatmap({
                    gl: renderer.gl,
                    framebuffer: this.webGlFramebuffer,
                    width: this.spriteObject.texture.width,
                    height: this.spriteObject.texture.height
                }, this.config.heatmapShader);
            }
            catch (error) {
                Logger_5.Logger.logDebug("Failed to create WebGL heatmap. " + error.message);
            }
        }
        uploadHeatpoints() {
            // Add points
            if (this.pointsToAdd.length > 0) {
                this.heatmap.addPoints(this.pointsToAdd);
                this.pointsToAdd = [];
            }
            // Load height points into GPU.
            this.heatmap.uploadHeightPoints();
        }
        renderHeatmap(gl) {
            this.renderPointsToHeightMap();
            this.renderHeightMapToTexture(gl);
        }
        renderPointsToHeightMap() {
            // Clear framebuffer if necessary
            if (this.dirtyClear === true) {
                this.heatmap.clear();
            }
            // Draw heat points to height map
            this.heatmap.renderPointsToHeightMap();
            // Multiply if necessary
            this.heatmap.multiply(this.multiplicationFactor);
            // Clamp if necessary
            this.heatmap.clamp(this.clampMin, this.clampMax);
        }
        renderHeightMapToTexture(gl) {
            // Bind to the sprite texture's framebuffer
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.webGlFramebuffer);
            // Change viewport to fit the texture size
            gl.viewport(0, 0, this.spriteObject.texture.width, this.spriteObject.texture.height);
            // Draw the height map on a quad fitting the texture's framebuffer size.
            this.heatmap.renderColorizedHeightMap();
        }
    }
    exports.WebGlHeatmapLayer = WebGlHeatmapLayer;
    (function (WebGlHeatmapLayer) {
        class Config extends HeatmapLayerImpl_1.HeatmapLayerImpl.Config {
            constructor() {
                super(...arguments);
                /**
                 * The configuration for the WebGL heatmap implementation
                 */
                this.heatmapShader = new WebGlHeatmap_1.WebGlHeatmap.Config();
            }
        }
        WebGlHeatmapLayer.Config = Config;
    })(WebGlHeatmapLayer = exports.WebGlHeatmapLayer || (exports.WebGlHeatmapLayer = {}));
});
define("src/map/view/world/layers/heatmapLayer/canvas/CanvasHeatmapLayer", ["require", "exports", "src/map/view/Layer", "src/map/view/world/layers/heatmapLayer/HeatmapLayerImpl", "src/map/view/world/layers/heatmapLayer/canvas/CanvasHeatmap"], function (require, exports, Layer_7, HeatmapLayerImpl_2, CanvasHeatmap_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CanvasHeatmapLayer = void 0;
    class CanvasHeatmapLayer extends Layer_7.Layer {
        // Construction
        constructor(environment, config) {
            super(environment);
            // State
            this.clampMin = 0;
            this.clampMax = 1;
            this.dirty = false;
            // Create canvas with floor size
            this.canvas = document.createElement("canvas");
            this.canvas.width = config.textureWidth;
            this.canvas.height = config.textureHeight;
            // Create TextObjectures
            let texture = this.getEnvironment().renderer.newTexture(this.canvas);
            this.sprite = this.getEnvironment().renderer.newSpriteObject(texture);
            this.sprite.width = config.floorWidth;
            this.sprite.height = config.floorHeight;
            this.getView().addChild(this.sprite);
            // Create heatmap
            this.heatmap = new CanvasHeatmap_2.CanvasHeatmap(this.canvas);
        }
        // Configuration
        // @Override
        addPoint(x, y, radius, intensity) {
            this.heatmap.radius(radius);
            this.heatmap.add([x, y, intensity]);
            this.dirty = true;
        }
        // @Override
        addPoints(points) {
            for (let i = 0; i < points.length; i++) {
                let point = points[i];
                this.addPoint(point.x, point.y, point.radius, point.intensity);
            }
            this.dirty = true;
        }
        // @Override
        clear() {
            this.heatmap.clear();
            this.dirty = true;
        }
        // @Override
        clamp(min, max) {
            this.clampMin = min;
            this.clampMax = max;
            this.dirty = true;
        }
        // @Override
        multiply(value) {
            // Not implemented yet.
            this.dirty = true;
        }
        // Rendering
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.dirty === true) {
                this.dirty = false;
                this.heatmap.max(1.0 / this.clampMax);
                this.heatmap.draw(this.clampMin);
                this.sprite.texture.load(this.canvas);
            }
        }
    }
    exports.CanvasHeatmapLayer = CanvasHeatmapLayer;
    (function (CanvasHeatmapLayer) {
        class Config extends HeatmapLayerImpl_2.HeatmapLayerImpl.Config {
        }
        CanvasHeatmapLayer.Config = Config;
    })(CanvasHeatmapLayer = exports.CanvasHeatmapLayer || (exports.CanvasHeatmapLayer = {}));
});
define("src/engine/utils/PlatformUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlatformUtils = void 0;
    class PlatformUtils {
        /**
         * Returns true, if the platform and browser supports WebGL.
         *
         * @return {boolean} true, if webGL is supported.
         */
        static isWebGLSupported() {
            let contextOptions = { stencil: true, failIfMajorPerformanceCaveat: true };
            try {
                if (!window.WebGLRenderingContext && !window.WebGL2RenderingContext) {
                    return false;
                }
                let canvas = document.createElement('canvas');
                let gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);
                let success = !!(gl && gl.getContextAttributes().stencil);
                if (gl) {
                    let loseContext = gl.getExtension('WEBGL_lose_context');
                    if (loseContext) {
                        loseContext.loseContext();
                    }
                }
                gl = null;
                return success;
            }
            catch (e) {
                return false;
            }
        }
    }
    exports.PlatformUtils = PlatformUtils;
});
define("src/map/view/world/layers/heatmapLayer/HeatmapLayer", ["require", "exports", "src/map/view/Layer", "src/map/view/world/layers/heatmapLayer/webgl/WebGlHeatmapLayer", "src/map/view/world/layers/heatmapLayer/canvas/CanvasHeatmapLayer", "src/engine/utils/PlatformUtils"], function (require, exports, Layer_8, WebGlHeatmapLayer_1, CanvasHeatmapLayer_1, PlatformUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HeatmapLayer = void 0;
    /**
     * A WebGL based heatmap with canvas fallback.
     */
    class HeatmapLayer extends Layer_8.Layer {
        // Construction
        constructor(environment, floorplanLayer, config = new HeatmapLayer.Config) {
            super(environment);
            this.scaleFactor = 1.0;
            this.config = config;
            this.floorplanLayer = floorplanLayer;
            if (this.useWebGl()) {
                this.heatmapLayerImpl = this.createWebGlHeatmapLayer();
            }
            else {
                this.heatmapLayerImpl = this.createCanvasHeatmapLayer();
            }
            this.addChild(this.heatmapLayerImpl);
        }
        useWebGl() {
            return !this.config.alwaysPreferCanvasMode && PlatformUtils_1.PlatformUtils.isWebGLSupported();
        }
        createWebGlHeatmapLayer() {
            this.configMandatoryFields(this.config.webGlHeatmapLayer);
            let heatmapLayerImpl = new WebGlHeatmapLayer_1.WebGlHeatmapLayer(this.getEnvironment(), this.config.webGlHeatmapLayer);
            return heatmapLayerImpl;
        }
        createCanvasHeatmapLayer() {
            this.configMandatoryFields(this.config.canvasHeatmapLayer);
            let heatmapLayerImpl = new CanvasHeatmapLayer_1.CanvasHeatmapLayer(this.getEnvironment(), this.config.canvasHeatmapLayer);
            return heatmapLayerImpl;
        }
        configMandatoryFields(implConfig) {
            implConfig.floorWidth = this.floorplanLayer.getFloorSize().x;
            implConfig.floorHeight = this.floorplanLayer.getFloorSize().y;
            implConfig.textureWidth = Math.min(this.config.maxTextureWidthInPx, implConfig.floorWidth);
            implConfig.textureHeight = implConfig.textureWidth * (implConfig.floorHeight / implConfig.floorWidth);
            this.scaleFactor = implConfig.textureWidth / implConfig.floorWidth;
        }
        // Configuration
        /**
         * Adds a height point to the heatmap
         * @param x The x coordinate in centimeters
         * @param y The y coordinate in centimeters
         * @param radius The radius of the height point (in centimeters)
         * @param intensity The intensity \in [0,1]
         */
        addPoint(x, y, radius, intensity) {
            let transformedPoint = this.getTransformedPoint({ x: x, y: y, radius: radius, intensity: intensity });
            this.heatmapLayerImpl.addPoints([transformedPoint]);
        }
        /**
         * Adds multiple {x,y,radius,intensity} data points at once to the heatmap
         * @param items
         */
        addPoints(points) {
            let transformedPoints = [];
            for (let i = 0; i < points.length; i++) {
                let point = points[i];
                let transformedPoint = this.getTransformedPoint(point);
                transformedPoints.push(transformedPoint);
            }
            this.heatmapLayerImpl.addPoints(transformedPoints);
        }
        /**
         * Removes all height points from the heatmap.
         */
        clear() {
            this.heatmapLayerImpl.clear();
        }
        /**
         * Clamps the height point intensities to [min, max]
         * @param min
         * @param max
         */
        clamp(min, max) {
            this.heatmapLayerImpl.clamp(min, max);
        }
        /**
         * Multiply all values in the heatmap by a number (useful for decay)
         * @param value multiplication factor
         */
        multiply(value) {
            this.heatmapLayerImpl.multiply(value);
        }
        // Helper methods
        getTransformedPoint(point) {
            let xInTexture = this.floorplanLayer.getTexelsFromCm(point.x) * this.scaleFactor;
            let yInTexture = this.floorplanLayer.getTexelsFromCm(point.y) * this.scaleFactor;
            let radiusInTexture = this.floorplanLayer.getTexelsFromCm(point.radius) * this.scaleFactor;
            let intensity = point.intensity;
            return { x: xInTexture, y: yInTexture, radius: radiusInTexture, intensity: intensity };
        }
    }
    exports.HeatmapLayer = HeatmapLayer;
    (function (HeatmapLayer) {
        class Config {
            constructor() {
                /**
                 * The maximum width the texture of the heatmap layer can take.
                 *
                 * Default: 4096 texels
                 */
                this.maxTextureWidthInPx = 4096;
                /**
                 * True, if the canvas implementation of the heatmap layer should
                 * always be preferred instead of the WebGL shader implementation.
                 *
                 * Default: false
                 */
                this.alwaysPreferCanvasMode = false;
                /**
                 * The configuration for the WebGL implementation
                 */
                this.webGlHeatmapLayer = new WebGlHeatmapLayer_1.WebGlHeatmapLayer.Config();
                /**
                 * The configuration for the Canvas implementation
                 */
                this.canvasHeatmapLayer = new CanvasHeatmapLayer_1.CanvasHeatmapLayer.Config();
            }
        }
        HeatmapLayer.Config = Config;
    })(HeatmapLayer = exports.HeatmapLayer || (exports.HeatmapLayer = {}));
});
define("src/app/relution/view/world/layers/deviceLayers/sensorHeatmapLayer/SensorHeatmapLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/map/view/world/layers/heatmapLayer/HeatmapLayer", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceMapObject", "src/engine/math/Vector2"], function (require, exports, FloorplanRelatedLayer_11, HeatmapLayer_1, DeviceMapObject_7, Vector2_31) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SensorHeatmapLayer = void 0;
    /**
     * A layer that renders sensor heatpoints around the devices by using a list of
     * [[SensorHeatpointModel]] instances that can be injected into this layer.
     *
     * <p>
     * Whenever the models are injected, the heatmap will be redrawn. Internally
     * this layer makes use of the [[HeatmapLayer]] provided in the FruityMaps core.
     * Hence, it supports WebGL acceleration using a WebGL heatmap shader and falls
     * back to canvas rendering. Notice, however, that in canvas mode the heatmap
     * should not be updated in real-time. Instead, throttle the sensor data before
     * injecting it.
     * </p>
     */
    class SensorHeatmapLayer extends FloorplanRelatedLayer_11.FloorplanRelatedLayer {
        // Construction
        constructor(config, environment, deviceLayer) {
            super(environment, deviceLayer.getFloorplanLayer());
            // Model
            this.models = new Array();
            this.dirty = true;
            this.config = config;
            this.deviceLayer = deviceLayer;
            this.deviceLayer.addObserver({
                onObjectSetToMap: function (object) {
                    this.dirty = true;
                },
                onObjectSetToStock: function (object) {
                    this.dirty = true;
                },
                onObjectMovedToMap: function (object) {
                    this.dirty = true;
                },
                onObjectMovedToStock: function (object) {
                    this.dirty = true;
                }
            });
            this.initHeatmapLayer();
        }
        initHeatmapLayer() {
            this.heatmapLayer = new HeatmapLayer_1.HeatmapLayer(this.getEnvironment(), this.getFloorplanLayer(), new HeatmapLayer_1.HeatmapLayer.Config());
            this.addChild(this.heatmapLayer);
            this.heatmapLayer.getView().alpha = this.config.alphaTransparency;
        }
        // Model update
        updateModels(models) {
            this.models = models;
            this.dirty = true;
        }
        // View update
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.dirty) {
                this.dirty = false;
                this.redrawHeatmap();
            }
        }
        triggerRedrawHeatmap() {
            this.redrawHeatmap();
        }
        redrawHeatmap() {
            this.heatmapLayer.clear();
            for (let i = 0; i < this.models.length; i++) {
                const model = this.models[i];
                this.drawHeatpoint(model);
            }
        }
        drawHeatpoint(model) {
            // Position
            const device = this.deviceLayer.getDeviceWithUuid(model.deviceUuid);
            if (device !== null) {
                const deviceModel = device.getModel();
                if (deviceModel.isOnMap() && !deviceModel.hasUnknownPosition() && deviceModel.visible) {
                    const x = deviceModel.getPosition().x;
                    const y = deviceModel.getPosition().y;
                    let devicePositionInRelative = new Vector2_31.Vector2(x, y);
                    const floorSize = this.getFloorplanLayer().getFloorSize();
                    let floorWidthInTx = floorSize.x;
                    let floorHeightInTx = floorSize.y;
                    let floorWidthInCm = this.getFloorplanLayer().getCmFromTexels(floorWidthInTx);
                    let floorHeightInCm = floorWidthInCm * (floorHeightInTx / floorWidthInTx);
                    let mouseInCm = new Vector2_31.Vector2(devicePositionInRelative.x * floorWidthInCm, devicePositionInRelative.y * floorHeightInCm);
                    // Intensity
                    const intensity = model.intensity;
                    // Radius
                    const radiusInCm = model.radiusInCm;
                    // Draw
                    this.heatmapLayer.addPoint(mouseInCm.x, mouseInCm.y, radiusInCm, intensity);
                    this.heatmapLayer.clamp(0, 1);
                    this.heatmapLayer.multiply(0.995);
                }
            }
        }
        // Popup info
        // @Override
        onPopupContentRequested(relutionMapObject) {
            if (relutionMapObject instanceof DeviceMapObject_7.DeviceMapObject) {
                const heatpointModel = this.getHeatpointModelForDevice(relutionMapObject);
                if (heatpointModel !== null) {
                    return this.getLocalizedStringFor("popup_device_sensor_description") + ": " + heatpointModel.description;
                }
            }
            return null;
        }
        // Getters and setters
        getModels() {
            return this.models;
        }
        // Helper methods
        getHeatpointModelForDevice(device) {
            for (let i = 0; i < this.models.length; i++) {
                const heatpointModel = this.models[i];
                if (heatpointModel.deviceUuid === device.getModel().uuid) {
                    return heatpointModel;
                }
            }
            return null;
        }
        // @Override
        isEmpty() {
            var _a;
            return !(((_a = this.models) === null || _a === void 0 ? void 0 : _a.length) > 0);
        }
    }
    exports.SensorHeatmapLayer = SensorHeatmapLayer;
    (function (SensorHeatmapLayer) {
        class Config {
            constructor() {
                /**
                 * The alpha transparency of the heatmap layer in the range [0,1].
                 *
                 * <p>Default: 0.5</p>
                 */
                this.alphaTransparency = 0.5;
            }
        }
        SensorHeatmapLayer.Config = Config;
    })(SensorHeatmapLayer = exports.SensorHeatmapLayer || (exports.SensorHeatmapLayer = {}));
});
define("src/app/relution/model/floor/FloorElementModel", ["require", "exports", "src/app/relution/model/RelutionMapObjectModel", "src/app/relution/model/Model"], function (require, exports, RelutionMapObjectModel_5, Model_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ZoneModel = exports.RoomModel = exports.FloorElementModel = void 0;
    class FloorElementModel extends RelutionMapObjectModel_5.RelutionMapObjectModel {
        // Getters and setters
        get name() {
            return this._name;
        }
        set name(name) {
            this._name = name;
            this.notifyObservers("name");
        }
        get description() {
            return this._description;
        }
        set description(description) {
            this._description = description;
            this.notifyObservers("description");
        }
        get points() {
            return this._points;
        }
        set points(points) {
            this._points = points;
        }
        /**
         * Returns a flag indicating, whether the occupancy fields contain valid values.
         */
        get occupancyAvailable() {
            return this._occupancyAvailable;
        }
        set occupancyAvailable(occupancyAvailable) {
            this._occupancyAvailable = occupancyAvailable;
            this.notifyObservers("occupancyAvailable");
        }
        /**
         * Returns the average occupancy value of the floor element
         * given in the range [0.0, 1.0].
         */
        get occupancyValue() {
            return this._occupancyValue;
        }
        set occupancyValue(occupancyValue) {
            this._occupancyValue = occupancyValue;
            this.notifyObservers("occupancyValue");
        }
        /**
         * Returns the RGB value used as background color to indicate occupancy,
         * e.g. 0xff0000.
         */
        get occupancyColor() {
            return this._occupancyColor;
        }
        set occupancyColor(occupancyColor) {
            this._occupancyColor = occupancyColor;
            this.notifyObservers("occupancyColor");
        }
        /**
         * Returns the alpha transparency value used to indicate occupancy
         * (given in the range [0.0, 1.0]).
         */
        get occupancyAlpha() {
            return this._occupancyAlpha;
        }
        set occupancyAlpha(occupancyAlpha) {
            this._occupancyAlpha = occupancyAlpha;
            this.notifyObservers("occupancyAlpha");
        }
    }
    __decorate([
        (0, Model_11.ModelProperty)()
    ], FloorElementModel.prototype, "_name", void 0);
    __decorate([
        (0, Model_11.ModelProperty)()
    ], FloorElementModel.prototype, "_description", void 0);
    __decorate([
        (0, Model_11.ModelProperty)()
    ], FloorElementModel.prototype, "_points", void 0);
    __decorate([
        (0, Model_11.ModelProperty)()
    ], FloorElementModel.prototype, "_occupancyAvailable", void 0);
    __decorate([
        (0, Model_11.ModelProperty)()
    ], FloorElementModel.prototype, "_occupancyValue", void 0);
    __decorate([
        (0, Model_11.ModelProperty)()
    ], FloorElementModel.prototype, "_occupancyColor", void 0);
    __decorate([
        (0, Model_11.ModelProperty)()
    ], FloorElementModel.prototype, "_occupancyAlpha", void 0);
    exports.FloorElementModel = FloorElementModel;
    class RoomModel extends FloorElementModel {
    }
    exports.RoomModel = RoomModel;
    class ZoneModel extends FloorElementModel {
    }
    exports.ZoneModel = ZoneModel;
});
define("src/app/relution/view/world/layers/floorplanLayers/floorElementLayer/FloorElementMapObject", ["require", "exports", "src/app/relution/view/world/RelutionMapObject", "src/app/relution/model/floor/FloorElementModel", "src/engine/math/Vector2", "src/map/utils/DeviceUtils", "src/engine/utils/IntersectionUtils", "src/app/relution/utils/ColorUtils"], function (require, exports, RelutionMapObject_13, FloorElementModel_1, Vector2_32, DeviceUtils_17, IntersectionUtils_6, ColorUtils_2) {
    "use strict";
    var FloorElementMapObject_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FloorElementMapObject = void 0;
    var VectorDirections;
    (function (VectorDirections) {
        VectorDirections[VectorDirections["E"] = 0] = "E";
        VectorDirections[VectorDirections["NE"] = 1] = "NE";
        VectorDirections[VectorDirections["N"] = 2] = "N";
        VectorDirections[VectorDirections["NW"] = 3] = "NW";
        VectorDirections[VectorDirections["W"] = 4] = "W";
        VectorDirections[VectorDirections["SW"] = 5] = "SW";
        VectorDirections[VectorDirections["S"] = 6] = "S";
        VectorDirections[VectorDirections["SE"] = 7] = "SE";
    })(VectorDirections || (VectorDirections = {}));
    let FloorElementMapObject = FloorElementMapObject_1 = class FloorElementMapObject extends RelutionMapObject_13.RelutionMapObject {
        // Construction
        constructor(config, environment, floorplanLayer, model) {
            super(config, environment, floorplanLayer, model);
            this.editingPoints = Array();
            this.lengthTexts = new Array();
            // State
            this.invalidated = true;
            this.lastScaleFactor = -1;
            this.initPolygon();
            this.initEditingPoints();
            this.initLengthTexts();
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            let scaleFactor = 1.0;
            if (this.getScene() != null) {
                let camera = this.getScene().getCamera();
                scaleFactor = camera.getScaleX();
            }
            if (this.lastScaleFactor !== scaleFactor || this.invalidated) {
                this.lastScaleFactor = scaleFactor;
                this.invalidated = false;
                this.redraw();
            }
        }
        // Model
        // @Override
        getModel() {
            return super.getModel();
        }
        // Name
        // @Override
        getName() {
            return this.getModel().name;
        }
        // Popup info
        // @Override
        getPopupInfo() {
            // General information
            let i18nKey;
            const model = this.getModel();
            if (model instanceof FloorElementModel_1.RoomModel) {
                i18nKey = "room";
            }
            else if (model instanceof FloorElementModel_1.ZoneModel) {
                i18nKey = "zone";
            }
            let content;
            content = this.getLocalizedStringFor(`popup_${i18nKey}_name`) + ": "
                + model.name;
            if (this.getModel().occupancyAvailable && this.getModel().occupancyValue !== null && this.getModel().occupancyValue != undefined) {
                content += "\n";
                content += this.getLocalizedStringFor("popup_floor_element_occupancy_average") + ": "
                    + (this.getModel().occupancyValue * 100).toFixed(0) + "%";
            }
            return content;
        }
        static getVectorDirection(vec1, vec2) {
            const directionVector = Vector2_32.Vector2.subtract(vec2, vec1);
            const angle = Math.atan2(directionVector.y, directionVector.x);
            const dir = Math.round(8 * angle / (2 * Math.PI) + 8) % 8;
            return dir;
        }
        initPolygon() {
            this.polygon = this.getEnvironment().renderer.newGraphicsObject();
            this.getView().addChild(this.polygon);
            this.polygon.alpha = 0; // Initialize with zero alpha
        }
        initEditingPoints() {
            this.getModel().points.forEach(() => {
                let editingPoint = this.getEnvironment().renderer.newGraphicsObject();
                editingPoint.clear();
                editingPoint.beginFill(FloorElementMapObject_1.MOUSE_OVER_BORDER_COLOR);
                editingPoint.drawCircle(0, 0, 1);
                editingPoint.endFill();
                this.editingPoints.push(editingPoint);
                this.getView().addChild(editingPoint);
            });
            this.repositionEditPoints();
        }
        initLengthTexts() {
            let fontSize = DeviceUtils_17.DeviceUtils.getPhysicalPixelsFromLogical(12);
            let textStyle = this.getEnvironment().renderer.newTextStyle();
            textStyle.fill = FloorElementMapObject_1.MOUSE_OVER_BORDER_COLOR;
            textStyle.fontFamily = "Arial";
            textStyle.fontSize = fontSize;
            // We want the texts only be shown on the top and right site.
            this.editingPoints.forEach(() => {
                const lengthText = this.getEnvironment().renderer.newTextObject("", 2, textStyle);
                lengthText.visible = false;
                this.lengthTexts.push(lengthText);
                this.getView().addChild(lengthText);
            });
        }
        // Intersection
        // @Override
        intersectsAabb(aabb) {
            const aabbPolygonRel = [
                this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new Vector2_32.Vector2(aabb.min.x, aabb.min.y)),
                this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new Vector2_32.Vector2(aabb.max.x, aabb.min.y)),
                this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new Vector2_32.Vector2(aabb.max.x, aabb.max.y)),
                this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new Vector2_32.Vector2(aabb.min.x, aabb.max.y))
            ];
            return IntersectionUtils_6.IntersectionUtils.testPolygonPolygonIntersection(aabbPolygonRel, this.getModel().points);
        }
        // @Override
        intersectsPointInScreenPx(x, y) {
            if (this.pointIsCloseToEditableArea(x, y)) {
                return true;
            }
            return this.intersectsPolygon(x, y);
        }
        intersectsPolygon(x, y) {
            const pointInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_32.Vector2(x, y));
            const pointInRel = this.getFloorplanLayer().getRelativeCoordinatesFromTexels(pointInTx);
            return IntersectionUtils_6.IntersectionUtils.testPointPolygonIntersection(pointInRel, this.getModel().points);
        }
        makeEditPointsVisible(visible) {
            for (let i = 0; i < this.editingPoints.length; i++) {
                let editingPoint = this.editingPoints[i];
                editingPoint.visible = visible;
            }
        }
        repositionEditPoints() {
            this.getModel().points.forEach((point, index) => {
                const texel = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point);
                this.editingPoints[index].position = this.getEnvironment().renderer.newPointFromVector2(texel);
            });
        }
        rescaleEditPoints() {
            let camera = this.getScene().getCamera();
            let widthInPx = FloorElementMapObject_1.EDIT_POINT_RADIUS_IN_PX * 2;
            let widthInTx = camera.getPixelsInTexels(widthInPx);
            for (let i = 0; i < this.editingPoints.length; i++) {
                let editingPoint = this.editingPoints[i];
                editingPoint.width = widthInTx;
                editingPoint.height = widthInTx;
            }
        }
        redrawLengthTexts() {
            if (this.isMouseOver() && this.isEditModeActive()) {
                this.makeLengthTextsVisible(true);
                this.updateLengthTexts();
            }
            else {
                this.makeLengthTextsVisible(false);
            }
        }
        makeLengthTextsVisible(visible) {
            for (let i = 0; i < this.lengthTexts.length; i++) {
                let lengthText = this.lengthTexts[i];
                lengthText.visible = visible;
            }
        }
        updateLengthTexts() {
            let camera = this.getScene().getCamera();
            let scaleFactor = camera.getScaleX();
            let cameraOrientation = camera.getRotation();
            this.editingPoints.forEach((point, index) => {
                const pointATexels = new Vector2_32.Vector2(point.x, point.y);
                const pointB = this.editingPoints[(index + 1) % this.editingPoints.length];
                const pointBTexels = new Vector2_32.Vector2(pointB.x, pointB.y);
                const lengthText = this.lengthTexts[index];
                // Compute distance in meters
                let distanceInTx = Vector2_32.Vector2.getDistanceBetweenPoints(pointATexels, pointBTexels);
                let distanceInCm = this.getFloorplanLayer().getCmFromTexels(distanceInTx);
                let distanceInM = distanceInCm / 100.0;
                // Text
                let newText = "" + distanceInM.toFixed(1) + " m";
                if (lengthText.text !== newText) {
                    lengthText.text = newText;
                }
                // Scale
                lengthText.scale.x = scaleFactor;
                lengthText.scale.y = scaleFactor;
                // Orientation
                lengthText.rotation = cameraOrientation;
                const direction = FloorElementMapObject_1.getVectorDirection(pointATexels, pointBTexels);
                const pivot = new Vector2_32.Vector2(0, 0);
                const addedVectors = Vector2_32.Vector2.add(pointATexels, pointBTexels);
                const center = new Vector2_32.Vector2(addedVectors.x / 2, addedVectors.y / 2);
                const position = new Vector2_32.Vector2(center.x, center.y);
                switch (direction) {
                    case VectorDirections.E: // <-
                    case VectorDirections.SE:
                    case VectorDirections.NE:
                        pivot.x = lengthText.width / 2;
                        pivot.y = lengthText.height;
                        position.x = center.x;
                        position.y = center.y - (lengthText.height / 2);
                        break;
                    case VectorDirections.N: // ^
                    case VectorDirections.NW:
                        pivot.x = 0;
                        pivot.y = lengthText.height / 2;
                        position.x = center.x + (lengthText.width / 2);
                        position.y = center.y;
                        break;
                    case VectorDirections.W: // ->
                        pivot.x = lengthText.width / 2;
                        pivot.y = 0;
                        position.x = center.x;
                        position.y = center.y + (lengthText.height / 2);
                        break;
                    case VectorDirections.S: // v
                    case VectorDirections.SW:
                        pivot.x = lengthText.width;
                        pivot.y = lengthText.height / 2;
                        position.x = center.x - (lengthText.width / 2);
                        position.y = center.y;
                        break;
                }
                // Position
                lengthText.x = position.x - pivot.x;
                lengthText.y = position.y - pivot.y;
            });
        }
        reDrawPolygon() {
            const camera = this.getScene().getCamera();
            // border lines
            let lineColor = FloorElementMapObject_1.DEFAULT_BORDER_COLOR;
            let lineWidth = FloorElementMapObject_1.DEFAULT_BORDER_WIDTH_PX;
            if (this.isSelected()) {
                lineColor = FloorElementMapObject_1.SELECTED_BORDER_COLOR;
                lineWidth = FloorElementMapObject_1.SELECTED_BORDER_WIDTH_PX;
            }
            else if (this.isMouseOver()) {
                lineColor = FloorElementMapObject_1.MOUSE_OVER_BORDER_COLOR;
                lineWidth = FloorElementMapObject_1.MOUSE_OVER_BORDER_WIDTH_PX;
            }
            const lineWidthInTx = camera.getPixelsInTexels(lineWidth);
            // color
            let color = FloorElementMapObject_1.UNKNOWN_SHAPE_COLOR;
            if (this.getModel().occupancyAvailable && this.getModel().occupancyColor !== undefined && this.getModel().occupancyColor !== null) {
                color = this.getModel().occupancyColor;
            }
            else {
                if (this.getModel() instanceof FloorElementModel_1.RoomModel) {
                    color = FloorElementMapObject_1.ROOM_SHAPE_COLOR;
                }
                else if (this.getModel() instanceof FloorElementModel_1.ZoneModel) {
                    color = FloorElementMapObject_1.ZONE_SHAPE_COLOR;
                }
            }
            // alpha
            let alpha = FloorElementMapObject_1.DEFAULT_ALPHA;
            if (this.getModel().occupancyAvailable && this.getModel().occupancyAlpha !== undefined && this.getModel().occupancyAlpha !== null) {
                alpha = this.getModel().occupancyAlpha;
            }
            else {
                if (this.getModel() instanceof FloorElementModel_1.RoomModel) {
                    alpha = FloorElementMapObject_1.ROOM_ALPHA;
                }
                else if (this.getModel() instanceof FloorElementModel_1.ZoneModel) {
                    alpha = FloorElementMapObject_1.ZONE_ALPHA;
                }
            }
            // geometry
            const texels = this.getModel().points
                .map((point) => {
                const vector = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point);
                return this.getEnvironment().renderer.newPoint(vector.x, vector.y);
            });
            this.polygon.clear();
            this.polygon.beginFill(color);
            this.polygon.lineStyle(lineWidthInTx, lineColor);
            this.polygon.drawPolygon(texels).closePath();
            this.polygon.endFill();
            this.polygon.alpha = alpha;
        }
        redrawEditingPoints() {
            if (this.isMouseOver() || this.isMouseAboveEditPoint()) {
                if (this.isEditModeActive()) {
                    this.makeEditPointsVisible(true);
                    this.repositionEditPoints();
                    this.rescaleEditPoints();
                }
            }
            else {
                this.makeEditPointsVisible(false);
            }
        }
        getEditPointNearbyMouse(x, y) {
            const mousePosition = new Vector2_32.Vector2(x, y);
            const tolerance = FloorElementMapObject_1.EDITABLE_POINT_TOLERANCE_IN_PX;
            return this.editingPoints
                .find((point) => {
                const pos = this.getFloorplanLayer().getScreenPixelsFromTexels(new Vector2_32.Vector2(point.x, point.y));
                let distanceInPx = Vector2_32.Vector2.getDistanceBetweenPoints(mousePosition, pos);
                return distanceInPx <= tolerance;
            });
        }
        resolveCollisionsWithWorldMove() {
            let offset = new Vector2_32.Vector2(0, 0);
            this.getModel().points.forEach((point, index) => {
                if (point.x > 1 && point.x - 1 > offset.x) {
                    offset.x = point.x - 1;
                }
                else if (point.x < 0 && point.x < offset.x) {
                    offset.x = point.x;
                }
                if (point.y > 1 && point.y - 1 > offset.y) {
                    offset.y = point.y - 1;
                }
                else if (point.y < 0 && point.y < offset.y) {
                    offset.y = point.y;
                }
            });
            this.getModel().points.forEach((point, index) => {
                point.x -= offset.x;
                point.y -= offset.y;
            });
        }
        resolveCollisionsWithWorldEdit(point) {
            if (point.x > 1) {
                point.x = 1;
            }
            else if (point.x < 0) {
                point.x = 0;
            }
            if (point.y > 1) {
                point.y = 1;
            }
            else if (point.y < 0) {
                point.y = 0;
            }
        }
        // Model update
        onModelUpdated(model) {
            this.redraw();
        }
        redraw() {
            this.reDrawPolygon();
            this.redrawEditingPoints();
            this.redrawLengthTexts();
        }
        // Editing
        getNamePosition(textBound) {
            return this.getCenter();
        }
        // @Override
        pointIsCloseToEditableArea(x, y) {
            return !!this.getEditPointNearbyMouse(x, y);
        }
        // @Override
        onEditStart(x, y) {
            this.activeEditPoint = this.getEditPointNearbyMouse(x, y);
        }
        // @Override
        onEditMove(x, y) {
            if (this.activeEditPoint) {
                const affectedPoint = this.getModelPoint(this.activeEditPoint);
                if (affectedPoint) {
                    const mousePosition = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_32.Vector2(x, y));
                    const relativePos = this.getFloorplanLayer().getRelativeCoordinatesFromTexels(mousePosition);
                    affectedPoint.x = relativePos.x;
                    affectedPoint.y = relativePos.y;
                    this.resolveCollisionsWithWorldEdit(affectedPoint);
                    this.redraw();
                }
            }
        }
        getModelPoint(editPoint) {
            const activeEditPointRel = this.getFloorplanLayer().getRelativeCoordinatesFromTexels(new Vector2_32.Vector2(editPoint.x, editPoint.y));
            let minPointDistance = Infinity;
            let minDistancePoint = null;
            for (let i = 0; i < this.getModel().points.length; i++) {
                const modelPoint = this.getModel().points[i];
                let distanceInRel = Vector2_32.Vector2.getDistanceBetweenPoints(modelPoint, activeEditPointRel);
                if (distanceInRel < minPointDistance) {
                    minPointDistance = distanceInRel;
                    minDistancePoint = modelPoint;
                }
            }
            return minDistancePoint;
        }
        // Moving
        // @Override
        onEditStop(x, y) {
        }
        // @Override
        onMoveStarted(x, y) {
            this.beforeMoveStartedCoords = [];
            this.getModel().points.forEach((point) => {
                let pointInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_32.Vector2(x, y));
                let minInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point);
                this.beforeMoveStartedCoords.push(new Vector2_32.Vector2(pointInTx.x - minInTx.x, pointInTx.y - minInTx.y));
            });
        }
        // @Override
        onMoveChanged(x, y) {
            if (this.beforeMoveStartedCoords) {
                this.getModel().points.forEach((point, index) => {
                    let diffInTx = this.beforeMoveStartedCoords[index];
                    let pointInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new Vector2_32.Vector2(x, y));
                    let newPosTx = new Vector2_32.Vector2(pointInTx.x - diffInTx.x, pointInTx.y - diffInTx.y);
                    const relative = this.getFloorplanLayer().getRelativeCoordinatesFromTexels(newPosTx);
                    point.x = relative.x;
                    point.y = relative.y;
                });
                this.resolveCollisionsWithWorldMove();
                this.redraw();
            }
        }
        // Centering
        // @Override
        onMoveStopped(x, y) {
            this.beforeMoveStartedCoords = null;
        }
        // Redrawing
        // @Override
        translateAndScaleToCameraCenter() {
        }
    };
    // Configuration: Alpha
    FloorElementMapObject.DEFAULT_ALPHA = 0.5;
    FloorElementMapObject.ROOM_ALPHA = FloorElementMapObject_1.DEFAULT_ALPHA;
    FloorElementMapObject.ZONE_ALPHA = FloorElementMapObject_1.DEFAULT_ALPHA;
    // Configuration: Shape
    FloorElementMapObject.ROOM_SHAPE_COLOR = ColorUtils_2.ColorUtils.transparentColor(0xFFED00, FloorElementMapObject_1.ROOM_ALPHA);
    FloorElementMapObject.ZONE_SHAPE_COLOR = ColorUtils_2.ColorUtils.transparentColor(0xF40083, FloorElementMapObject_1.ZONE_ALPHA);
    FloorElementMapObject.UNKNOWN_SHAPE_COLOR = ColorUtils_2.ColorUtils.transparentColor(0xF97641, FloorElementMapObject_1.DEFAULT_ALPHA);
    // Configuration: Border
    FloorElementMapObject.DEFAULT_BORDER_COLOR = 0x000000;
    FloorElementMapObject.SELECTED_BORDER_COLOR = 0x000000;
    FloorElementMapObject.MOUSE_OVER_BORDER_COLOR = 0x000000;
    FloorElementMapObject.DEFAULT_BORDER_WIDTH_PX = 3;
    FloorElementMapObject.SELECTED_BORDER_WIDTH_PX = 5;
    FloorElementMapObject.MOUSE_OVER_BORDER_WIDTH_PX = 5;
    // Configuration: Edit points
    FloorElementMapObject.EDIT_POINT_RADIUS_IN_PX = 4;
    FloorElementMapObject.EDITABLE_POINT_TOLERANCE_IN_PX = 6;
    // Configuration: Length text
    FloorElementMapObject.TEXT_PADDING_PX = 5;
    FloorElementMapObject = FloorElementMapObject_1 = __decorate([
        (0, RelutionMapObject_13.RelutionModelBinding)(FloorElementModel_1.FloorElementModel)
    ], FloorElementMapObject);
    exports.FloorElementMapObject = FloorElementMapObject;
});
define("src/app/relution/view/world/layers/floorplanLayers/floorElementLayer/FloorElementLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/floorElementLayer/FloorElementMapObject", "src/app/relution/view/world/RelutionMapObjectLayer"], function (require, exports, FloorElementMapObject_2, RelutionMapObjectLayer_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FloorElementLayer = void 0;
    let FloorElementLayer = class FloorElementLayer extends RelutionMapObjectLayer_4.RelutionMapObjectLayer {
    };
    FloorElementLayer = __decorate([
        (0, RelutionMapObjectLayer_4.RelutionMapObjectBinding)(FloorElementMapObject_2.FloorElementMapObject)
    ], FloorElementLayer);
    exports.FloorElementLayer = FloorElementLayer;
});
define("src/app/relution/view/world/Floor", ["require", "exports", "src/map/view/Layer", "src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/FloorplanLayer", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceLayer", "src/app/relution/view/world/layers/deviceLayers/beaconRangeLayer/BeaconRangeLayer", "src/app/relution/view/world/layers/deviceLayers/deviceTrackLayer/DeviceTrackLayer", "src/app/relution/view/world/layers/deviceLayers/beaconConnectionsLayer/BeaconConnectionsLayer", "src/map/utils/Logger", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/GeofenceLayer", "src/app/relution/view/world/RelutionMapObjectLayer", "src/app/relution/view/world/layers/deviceLayers/userCountHeatmapLayer/UserCountHeatmapLayer", "src/app/relution/view/world/layers/floorplanLayers/wallplanLayer/WallplanLayer", "src/app/relution/view/world/layers/deviceLayers/deviceAccuracyRangeLayer/DeviceAccuracyRangeLayer", "src/app/relution/view/world/layers/deviceLayers/deviceTaggingLayer/DeviceTaggingLayer", "src/app/relution/view/world/layers/floorplanLayers/floorplanOverlayLayer/FloorplanOverlayLayer", "src/app/relution/view/world/layers/objectLayers/objectInfoLayer/RelutionMapObjectInfoLayer", "src/app/relution/view/world/layers/deviceLayers/singleDeviceEditLayer/SingleDeviceEditLayer", "src/app/relution/view/world/layers/overlayLayers/tapeMeasureLayer/TapeMeasureWorldLayer", "src/app/relution/view/world/layers/deviceLayers/sensorHeatmapLayer/SensorHeatmapLayer", "src/app/relution/view/world/layers/floorplanLayers/floorElementLayer/FloorElementLayer"], function (require, exports, Layer_9, FloorplanLayer_1, DeviceLayer_2, BeaconRangeLayer_1, DeviceTrackLayer_1, BeaconConnectionsLayer_1, Logger_6, GeofenceLayer_1, RelutionMapObjectLayer_5, UserCountHeatmapLayer_1, WallplanLayer_1, DeviceAccuracyRangeLayer_1, DeviceTaggingLayer_1, FloorplanOverlayLayer_1, RelutionMapObjectInfoLayer_1, SingleDeviceEditLayer_1, TapeMeasureWorldLayer_1, SensorHeatmapLayer_1, FloorElementLayer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Floor = void 0;
    /**
     * Represents a floor in the Relution Map.
     * A floor contains multiple layer containers. Each of them consists of layers
     * referring to different kinds of Relution map objects.
     */
    class Floor extends Layer_9.Layer {
        // Construction
        /**
         *
         * @param config
         * @param floorName Should be a unique string
         * @param floorModel
         */
        constructor(environment, floorName, floorModel, config = new Floor.Config()) {
            super(environment);
            // Observation
            this.observers = new Array();
            this.floorplanResourceName = null;
            this.floorplanTexture = null;
            this.wallplanResourceName = null;
            this.wallplanTexture = null;
            this.floorplanOverlayResourceNameToTexture = new Map();
            this.floorplanOverlayLayers = new Map();
            // View: Relution map object layers
            this.relutionMapObjectLayers = new Array();
            this.relutionMapObjectInfoLayers = new Array();
            this.config = config;
            this.initModel(floorName, floorModel);
        }
        initModel(floorName, floorModel) {
            this.floorName = floorName;
            this.floorModel = floorModel;
        }
        // Loading
        /**
         * Loads the floor's floorplan as a texture to the GPU memory.
         * @param loadedCallback Will be called, when the texture has been successfully loaded into GPU memory.
         */
        load(loadedCallback) {
            if (this.getEnvironment().renderer.isLoadingResources()) {
                // TODO: loading the floorplan should be done by FruityMap.preloadResources()!
                setTimeout(() => {
                    this.load(loadedCallback);
                }, 1000);
                return;
            }
            let resources = new Array();
            this.floorplanResourceName = "floorplan_" + this.floorName;
            resources.push({ resourceName: this.floorplanResourceName, url: this.floorModel.floorplanImageUrl });
            if (this.floorModel.wallplanImageUrl !== null && this.floorModel.wallplanImageUrl !== undefined) {
                this.wallplanResourceName = "wallplan_" + this.floorName;
                resources.push({ resourceName: this.wallplanResourceName, url: this.floorModel.wallplanImageUrl });
            }
            this.floorModel.floorplanOverlayNameToImageUrl.forEach((overlayImageUrl, overlayName) => {
                let overlayResourceName = overlayName + "_" + this.floorName;
                resources.push({ resourceName: overlayResourceName, url: overlayImageUrl });
                this.floorplanOverlayResourceNameToTexture.set(overlayResourceName, null);
            });
            this.getEnvironment().renderer.loadResources(resources, () => {
                if (this.floorplanLoaded() && this.wallplanLoaded() && this.overlayLayersLoaded()) {
                    this.floorplanTexture = this.getEnvironment().renderer.getTexture("" + this.floorplanResourceName);
                    if (this.wallplanResourceName !== null) {
                        this.wallplanTexture = this.getEnvironment().renderer.getTexture("" + this.wallplanResourceName);
                    }
                    for (let resourceName of Array.from(this.floorplanOverlayResourceNameToTexture.keys())) {
                        let texture = this.getEnvironment().renderer.getTexture("" + resourceName);
                        this.floorplanOverlayResourceNameToTexture.set(resourceName, texture);
                    }
                    this.initWorldLayers();
                    loadedCallback(this);
                }
            });
        }
        floorplanLoaded() {
            return this.floorplanResourceName !== null && this.getEnvironment().renderer.getTexture("" + this.floorplanResourceName) !== undefined;
        }
        wallplanLoaded() {
            return this.wallplanResourceName === null ||
                (this.wallplanResourceName !== null && this.getEnvironment().renderer.getTexture("" + this.wallplanResourceName) !== undefined);
        }
        overlayLayersLoaded() {
            for (let resourceName of Array.from(this.floorplanOverlayResourceNameToTexture.keys())) {
                if (this.getEnvironment().renderer.getTexture("" + resourceName) === undefined) {
                    return false;
                }
            }
            return true;
        }
        initWorldLayers() {
            this.loadMapLayers(this.floorModel);
            this.loadRoomLayers();
            this.loadZoneLayers();
            this.loadGeofenceLayers();
            this.loadDeviceLayers();
            this.loadOverlayLayers();
        }
        loadMapLayers(floorModel) {
            this.floorplanLayerContainer = new Layer_9.Layer(this.getEnvironment());
            this.floorplanLayerContainer.setVisible(true);
            // Init layers
            this.initFloorplanLayer(floorModel);
            this.initOverlayLayers();
            this.initWallplanLayer();
            // Add layers
            this.addLayer(this.floorplanLayerContainer);
            this.floorplanLayerContainer.addLayer(this.floorplanLayer);
            this.floorplanOverlayLayers.forEach((floorplanOverlayLayer, overlayName) => {
                this.floorplanLayerContainer.addLayer(floorplanOverlayLayer);
            });
            this.floorplanLayerContainer.addLayer(this.wallplanLayer);
            // Set default visibility
            this.floorplanLayer.setVisible(true);
        }
        initFloorplanLayer(floorModel) {
            this.floorplanLayer = new FloorplanLayer_1.FloorplanLayer(this.config.floorplanLayer, this.getEnvironment(), floorModel, this.floorplanTexture);
            this.floorplanLayer.setIsInBackground(true);
        }
        initOverlayLayers() {
            this.floorplanOverlayResourceNameToTexture.forEach((texture, resourceName) => {
                let overlayName = this.getOverlayNameForResourceWithName(resourceName);
                if (overlayName !== null) {
                    let floorplanOverlayLayer = new FloorplanOverlayLayer_1.FloorplanOverlayLayer(this.getEnvironment(), this.floorplanLayer, overlayName, texture);
                    this.floorplanOverlayLayers.set(overlayName, floorplanOverlayLayer);
                }
            });
        }
        getOverlayNameForResourceWithName(resourceName) {
            for (let overlayName of Array.from(this.floorModel.floorplanOverlayNameToImageUrl.keys())) {
                if (resourceName.indexOf(overlayName) > -1) {
                    return overlayName;
                }
            }
            return null;
        }
        initWallplanLayer() {
            this.wallplanLayer = new WallplanLayer_1.WallplanLayer(this.config.wallplanLayer, this.getEnvironment(), this.floorplanLayer, this.wallplanTexture);
        }
        loadRoomLayers() {
            this.roomLayerContainer = new Layer_9.Layer(this.getEnvironment());
            this.roomLayerContainer.setVisible(true);
            // Init layers
            this.initRoomLayer();
            this.initRoomInfoLayer();
            // Add layers
            this.addLayer(this.roomLayerContainer);
            this.roomLayerContainer.addLayer(this.roomLayer);
            this.roomLayerContainer.addVisiblityObserver({
                visibilityChanged: (layer) => this.roomInfoLayer.getInfoContainerLayer().setVisible(layer.isVisible())
            });
            // Set default visibility
            this.roomLayer.setVisible(true);
        }
        initRoomLayer() {
            this.roomLayer = new FloorElementLayer_1.FloorElementLayer(this.config.roomLayer, this.getEnvironment(), this.floorplanLayer);
            this.roomLayer.addObserver(this);
            this.relutionMapObjectLayers.push(this.roomLayer);
        }
        initRoomInfoLayer() {
            this.roomInfoLayer = new RelutionMapObjectInfoLayer_1.RelutionMapObjectInfoLayer(this.config.objectInfoLayer, this.getEnvironment(), this.roomLayer);
            this.relutionMapObjectInfoLayers.push(this.roomInfoLayer);
        }
        loadZoneLayers() {
            this.zoneLayerContainer = new Layer_9.Layer(this.getEnvironment());
            this.zoneLayerContainer.setVisible(true);
            // Init layers
            this.initZoneLayer();
            this.initZoneInfoLayer();
            // Add layers
            this.addLayer(this.zoneLayerContainer);
            this.zoneLayerContainer.addLayer(this.zoneLayer);
            this.zoneLayerContainer.addVisiblityObserver({
                visibilityChanged: (layer) => this.zoneInfoLayer.getInfoContainerLayer().setVisible(layer.isVisible())
            });
            // Set default visibility
            this.zoneLayer.setVisible(true);
        }
        initZoneLayer() {
            this.zoneLayer = new FloorElementLayer_1.FloorElementLayer(this.config.zoneLayer, this.getEnvironment(), this.floorplanLayer);
            this.zoneLayer.addObserver(this);
            this.relutionMapObjectLayers.push(this.zoneLayer);
        }
        initZoneInfoLayer() {
            this.zoneInfoLayer = new RelutionMapObjectInfoLayer_1.RelutionMapObjectInfoLayer(this.config.objectInfoLayer, this.getEnvironment(), this.zoneLayer);
            this.relutionMapObjectInfoLayers.push(this.zoneInfoLayer);
        }
        loadGeofenceLayers() {
            this.geofenceLayerContainer = new Layer_9.Layer(this.getEnvironment());
            this.geofenceLayerContainer.setVisible(true);
            // Init layers
            this.initGeofenceLayer();
            this.initGeofenceInfoLayer();
            // Add layers
            this.addLayer(this.geofenceLayerContainer);
            this.geofenceLayerContainer.addLayer(this.geofenceLayer);
            // Set default visibility
            this.geofenceLayer.setVisible(true);
        }
        initGeofenceLayer() {
            this.geofenceLayer = new GeofenceLayer_1.GeofenceLayer(this.config.geofenceLayer, this.getEnvironment(), this.floorplanLayer);
            this.geofenceLayer.addObserver(this);
            this.relutionMapObjectLayers.push(this.geofenceLayer);
        }
        initGeofenceInfoLayer() {
            this.geofenceInfoLayer = new RelutionMapObjectInfoLayer_1.RelutionMapObjectInfoLayer(this.config.objectInfoLayer, this.getEnvironment(), this.geofenceLayer);
            this.relutionMapObjectInfoLayers.push(this.geofenceInfoLayer);
        }
        loadDeviceLayers() {
            this.deviceLayerContainer = new Layer_9.Layer(this.getEnvironment());
            this.deviceLayerContainer.setVisible(true);
            // Init layers
            this.initDeviceLayer();
            this.initDeviceAccuracyRangeLayer();
            this.initBeaconRangeLayer();
            this.initDeviceTrackLayer();
            this.initBeaconConnectionsLayer();
            this.initDeviceTaggingLayer();
            this.initDeviceInfoLayer();
            this.initUserCountHeatmapLayer();
            this.initSensorHeatmapLayer();
            this.initSingleDeviceEditLayer();
            // Add layers
            this.addLayer(this.deviceLayerContainer);
            this.deviceLayerContainer.addLayer(this.userCountHeatmapLayer);
            this.deviceLayerContainer.addLayer(this.sensorHeatmapLayer);
            this.deviceLayerContainer.addLayer(this.beaconRangeLayer);
            this.deviceLayerContainer.addLayer(this.deviceAccuracyRangeLayer);
            this.deviceLayerContainer.addLayer(this.deviceTrackLayer);
            this.deviceLayerContainer.addLayer(this.beaconConnectionsLayer);
            this.deviceLayerContainer.addLayer(this.deviceLayer);
            this.deviceLayerContainer.addLayer(this.deviceTaggingLayer);
            this.deviceLayerContainer.addLayer(this.singleDeviceEditLayer);
            // Set default visibility
            this.userCountHeatmapLayer.setVisible(true);
            this.sensorHeatmapLayer.setVisible(true);
            this.beaconRangeLayer.setVisible(true);
            this.deviceAccuracyRangeLayer.setVisible(true);
            this.deviceTrackLayer.setVisible(true);
            this.beaconConnectionsLayer.setVisible(true);
            this.deviceLayer.setVisible(true);
            this.deviceTaggingLayer.setVisible(true);
            this.deviceInfoLayer.setVisible(true);
            this.singleDeviceEditLayer.setVisible(true);
        }
        initDeviceLayer() {
            this.deviceLayer = new DeviceLayer_2.DeviceLayer(this.getEnvironment(), this.floorplanLayer, this.config.deviceLayer);
            this.deviceLayer.addObserver(this);
            this.relutionMapObjectLayers.push(this.deviceLayer);
        }
        initDeviceAccuracyRangeLayer() {
            this.deviceAccuracyRangeLayer = new DeviceAccuracyRangeLayer_1.DeviceAccuracyRangeLayer(this.getEnvironment(), this.deviceLayer);
        }
        initBeaconRangeLayer() {
            this.beaconRangeLayer = new BeaconRangeLayer_1.BeaconRangeLayer(this.getEnvironment(), this.deviceLayer);
        }
        initDeviceTrackLayer() {
            this.deviceTrackLayer = new DeviceTrackLayer_1.DeviceTrackLayer(this.config.deviceTrackLayer, this.getEnvironment(), this.deviceLayer, this.deviceAccuracyRangeLayer);
        }
        initBeaconConnectionsLayer() {
            this.beaconConnectionsLayer = new BeaconConnectionsLayer_1.BeaconConnectionsLayer(this.getEnvironment(), this.deviceLayer);
        }
        initDeviceInfoLayer() {
            this.deviceInfoLayer = new RelutionMapObjectInfoLayer_1.RelutionMapObjectInfoLayer(this.config.objectInfoLayer, this.getEnvironment(), this.deviceLayer);
            this.relutionMapObjectInfoLayers.push(this.deviceInfoLayer);
        }
        initDeviceTaggingLayer() {
            this.deviceTaggingLayer = new DeviceTaggingLayer_1.DeviceTaggingLayer(this.config.deviceTaggingLayer, this.getEnvironment(), this.deviceLayer);
            this.deviceTaggingLayer.addObserver(this);
            this.relutionMapObjectLayers.push(this.deviceTaggingLayer);
        }
        initUserCountHeatmapLayer() {
            this.userCountHeatmapLayer = new UserCountHeatmapLayer_1.UserCountHeatmapLayer(this.config.userCountHeatmapLayer, this.getEnvironment(), this.deviceLayer);
        }
        initSensorHeatmapLayer() {
            this.sensorHeatmapLayer = new SensorHeatmapLayer_1.SensorHeatmapLayer(this.config.sensorHeatmapLayer, this.getEnvironment(), this.deviceLayer);
        }
        initSingleDeviceEditLayer() {
            this.singleDeviceEditLayer = new SingleDeviceEditLayer_1.SingleDeviceEditLayer(this.config.singleDeviceEditLayer, this.getEnvironment(), this.deviceLayer);
        }
        loadOverlayLayers() {
            this.overlayLayerContainer = new Layer_9.Layer(this.getEnvironment());
            this.overlayLayerContainer.setVisible(true);
            // Init layers
            this.initInfoLayerContainer();
            this.initTapeMeasureLayer();
            // Add layers
            this.addLayer(this.overlayLayerContainer);
            this.overlayLayerContainer.addLayer(this.infoLayerContainer);
            this.overlayLayerContainer.addLayer(this.tapeMeasureLayer);
            // Set default visibility
            this.infoLayerContainer.setVisible(true);
            this.tapeMeasureLayer.setVisible(true);
        }
        initInfoLayerContainer() {
            this.infoLayerContainer = new Layer_9.Layer(this.getEnvironment());
            this.infoLayerContainer.addLayer(this.deviceInfoLayer);
            this.infoLayerContainer.addLayer(this.roomInfoLayer);
            this.infoLayerContainer.addLayer(this.zoneInfoLayer);
            this.infoLayerContainer.addLayer(this.geofenceInfoLayer);
        }
        initTapeMeasureLayer() {
            this.tapeMeasureLayer = new TapeMeasureWorldLayer_1.TapeMeasureWorldLayer(this.config.tapeMeasureLayer, this.getEnvironment(), this.floorplanLayer);
        }
        // Observation
        addObserver(observer) {
            this.observers.push(observer);
        }
        removeObserver(observer) {
            let index = this.observers.indexOf(observer);
            if (index !== -1) {
                this.observers.splice(index, 1);
            }
        }
        notifyObservers(callback, args) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Generic Relution map object API
        /**
         * Returns a list of all Relution map objects ordered in the rendering order.
         */
        getAllVisibleObjects() {
            // We iterate in reverse order to test intersection of beacon on higher
            // levels at first.
            let allVisibleObjects = new Array();
            for (let i = this.relutionMapObjectLayers.length - 1; i >= 0; i--) {
                let relutionMapObjectLayer = this.relutionMapObjectLayers[i];
                if (relutionMapObjectLayer.isVisibleInWorld()) {
                    let objects = relutionMapObjectLayer.getAllVisibleObjects();
                    for (let j = objects.length - 1; j >= 0; j--) {
                        let object = objects[j];
                        allVisibleObjects.push(object);
                    }
                }
            }
            return allVisibleObjects;
        }
        /**
         * Returns the colliding object at position (x,y) given in screen pixels.
         * @param x \in [0, screenWidth]
         * @param y \in [0, screenHeight]
         * @param condition An additional condition the object is required to fulfill to be selected as the colliding object.
         */
        getCollidingObject(x, y, condition) {
            for (let i = this.relutionMapObjectLayers.length - 1; i >= 0; i--) {
                let relutionMapObjectLayer = this.relutionMapObjectLayers[i];
                let object = relutionMapObjectLayer.getCollidingObject(x, y, condition);
                if (object !== null) {
                    return object;
                }
            }
            return null;
        }
        // Devices
        /**
         * Loads a new list of devices into the map.
         * This will destroy all devices that currently exist and recreate them.
         * @param models
         */
        loadDevices(models) {
            this.loadObjects(this.deviceLayer, models);
        }
        /**
         * Updates the list of devices in the map.
         * If device's already exist, their state will be updated.
         * If devices are not in the list anymore, they will be removed from the scene graph.
         * If devices have been added to the list, the will be added to the scene graph.
         * @param models
         */
        updateDevices(models) {
            this.updateObjects(this.deviceLayer, models);
        }
        /**
         * Adds or updates the model of device with UUID {@link model#UUID}
         *
         * @param model the device model to be updated.
         */
        updateDevice(model) {
            this.updateObject(this.deviceLayer, model);
        }
        getDeviceWithUuid(uuid) {
            return this.getObjectWithUuid(this.deviceLayer, uuid);
        }
        toggleDeviceVisibility(uuid) {
            this.toggleObjectVisibility(this.deviceLayer, uuid);
        }
        setDeviceWithUuidSelected(uuid) {
            this.setObjectWithUuidSelected(this.deviceLayer, uuid);
        }
        setDeviceWithUuidUnselected(uuid) {
            this.setObjectWithUuidUnselected(this.deviceLayer, uuid);
        }
        moveDeviceWithUuidToMap(uuid) {
            this.moveObjectWithUuidToMap(this.deviceLayer, uuid);
        }
        moveDeviceWithUuidToStock(uuid) {
            this.moveObjectWithUuidToStock(this.deviceLayer, uuid);
        }
        /**
         * Returns the models of the device layer
         */
        getDeviceModels() {
            return this.getModelsFromObjectLayer(this.deviceLayer);
        }
        // Tracks
        /**
         * Loads the asset tracking position estimates to the map
         * @param positionEstimateModels
         */
        loadTracks(positionEstimateModels) {
            this.deviceTrackLayer.updatePositionEstimates(positionEstimateModels);
        }
        /**
         * Adds or updates the position estimate track of the device with
         * UUID {@link positionEstimateModel#deviceUuid}.
         *
         * @param positionEstimateModel the position estimate model of the device
         */
        updateTrack(positionEstimateModel) {
            this.deviceTrackLayer.updatePositionEstimate(positionEstimateModel);
        }
        // User count heatmap
        /**
         * Loads the user count measurements to the map.
         * @param userCountHeatmapData
         */
        loadUserCountHeatmapData(userCountHeatmapData) {
            this.userCountHeatmapLayer.loadHeatmapData(userCountHeatmapData);
        }
        // Sensor heatmap
        /**
         * Loads the sensor heatpoint models to the map.
         * @param sensorHeatpointModels a list of heatpoint models
         */
        updateSensorHeatpoints(sensorHeatpointModels) {
            this.sensorHeatmapLayer.updateModels(sensorHeatpointModels);
        }
        // Device tags
        /**
         * Updates the models of the device tags. Use the {@link getDeviceTagModels} method
         * to fetch the tag models of all devices, modify them, and reinject them using this function.
         * @param tagModels
         */
        updateDeviceTags(tagModels) {
            this.deviceTaggingLayer.updateModels(tagModels);
        }
        /**
         * Returns the models of the device tagging layer
         */
        getDeviceTagModels() {
            return this.getModelsFromObjectLayer(this.deviceTaggingLayer);
        }
        // Rooms
        loadRooms(models) {
            this.loadObjects(this.roomLayer, models);
        }
        updateRooms(models) {
            this.updateObjects(this.roomLayer, models);
        }
        getRoomWithUuid(uuid) {
            return this.getObjectWithUuid(this.roomLayer, uuid);
        }
        toggleRoomVisibility(uuid) {
            this.toggleObjectVisibility(this.roomLayer, uuid);
        }
        setRoomWithUuidSelected(uuid) {
            this.setObjectWithUuidSelected(this.roomLayer, uuid);
        }
        setRoomWithUuidUnselected(uuid) {
            this.setObjectWithUuidUnselected(this.roomLayer, uuid);
        }
        /**
         * Returns the models of the room layer
         */
        getRoomModels() {
            return this.getModelsFromObjectLayer(this.roomLayer);
        }
        // Zones
        loadZones(models) {
            this.loadObjects(this.zoneLayer, models);
        }
        updateZones(models) {
            this.updateObjects(this.zoneLayer, models);
        }
        getZoneWithUuid(uuid) {
            return this.getObjectWithUuid(this.zoneLayer, uuid);
        }
        toggleZoneVisibility(uuid) {
            this.toggleObjectVisibility(this.zoneLayer, uuid);
        }
        setZoneWithUuidSelected(uuid) {
            this.setObjectWithUuidSelected(this.zoneLayer, uuid);
        }
        setZoneWithUuidUnselected(uuid) {
            this.setObjectWithUuidUnselected(this.zoneLayer, uuid);
        }
        /**
         * Returns the models of the zone layer
         */
        getZoneModels() {
            return this.getModelsFromObjectLayer(this.zoneLayer);
        }
        // Geofences
        loadGeofences(models) {
            this.loadObjects(this.geofenceLayer, models);
        }
        updateGeofences(models) {
            this.updateObjects(this.geofenceLayer, models);
        }
        getGeofenceWithUuid(uuid) {
            return this.getObjectWithUuid(this.geofenceLayer, uuid);
        }
        toggleGeofenceVisibility(uuid) {
            this.toggleObjectVisibility(this.geofenceLayer, uuid);
        }
        setGeofenceWithUuidSelected(uuid) {
            this.setObjectWithUuidSelected(this.geofenceLayer, uuid);
        }
        setGeofenceWithUuidUnselected(uuid) {
            this.setObjectWithUuidUnselected(this.geofenceLayer, uuid);
        }
        /**
         * Returns the models of the geofence layer
         */
        getGeofenceModels() {
            return this.getModelsFromObjectLayer(this.geofenceLayer);
        }
        // Relution map objects
        loadObjects(layer, models) {
            layer.loadModels(models);
        }
        updateObjects(layer, models) {
            if (layer.getObjects().length === 0) {
                this.loadObjects(layer, models);
            }
            else {
                layer.updateModels(models);
            }
        }
        updateObject(layer, model) {
            layer.updateModel(model);
        }
        getObjectWithUuid(layer, uuid) {
            return layer.getObjectWithUuid(uuid);
        }
        toggleObjectVisibility(layer, uuid) {
            layer.toggleObjectVisibility(uuid);
        }
        supportsObjectTypeVisibility(objectType, filter) {
            return this.relutionMapObjectLayers.some(relutionMapObjectLayer => relutionMapObjectLayer.supportsObjectTypeVisibility(objectType, filter));
        }
        toggleObjectTypeVisibility(objectType, visible) {
            for (let i = 0; i < this.relutionMapObjectLayers.length; i++) {
                let relutionMapObjectLayer = this.relutionMapObjectLayers[i];
                relutionMapObjectLayer.toggleObjectTypeVisibility(objectType, visible);
            }
        }
        setObjectWithUuidSelected(layer, uuid) {
            let object = layer.getObjectWithUuid(uuid);
            if (object != null) {
                // Remove observer, because we do not want to call the callback,
                // when the object is moved to the map via this interface.
                layer.removeObserver(this);
                // Select object
                object.setSelected(true);
                // Add observer again
                layer.addObserver(this);
            }
            else {
                Logger_6.Logger.logDebug("Object with uuid " + uuid + " does not exist");
            }
        }
        setObjectWithUuidUnselected(layer, uuid) {
            let object = layer.getObjectWithUuid(uuid);
            if (object != null) {
                // Remove observer, because we do not want to call the callback,
                // when the object is moved to the map via this interface.
                layer.removeObserver(this);
                // Select object
                object.setSelected(false);
                // Add observer again
                layer.addObserver(this);
            }
            else {
                Logger_6.Logger.logDebug("Object with uuid " + uuid + " does not exist");
            }
        }
        moveObjectWithUuidToMap(layer, uuid) {
            let object = layer.getObjectWithUuid(uuid);
            if (object != null) {
                if (object.isMovableToStock()) {
                    // Remove observer, because we do not want to call the callback,
                    // when the object is moved to the map via this interface.
                    layer.removeObserver(this);
                    // Move object to map
                    layer.moveObjectToMap(object);
                    // Add the observer again
                    layer.addObserver(this);
                }
                else {
                    Logger_6.Logger.logDebug("Object with UUID " + uuid + " is not movable to/from stock.");
                }
            }
            else {
                Logger_6.Logger.logDebug("Object with uuid " + uuid + " does not exist");
            }
        }
        moveObjectWithUuidToStock(layer, uuid) {
            let object = layer.getObjectWithUuid(uuid);
            if (object != null) {
                if (object.isMovableToStock()) {
                    // Remove observer, because we do not want to call the callback,
                    // when the object is moved to the map via this interface.
                    layer.removeObserver(this);
                    // Move object to stock
                    layer.moveObjectToStock(object);
                    // Add the observer again
                    layer.addObserver(this);
                }
                else {
                    Logger_6.Logger.logDebug("Object with UUID " + uuid + " is not movable to/from stock.");
                }
            }
            else {
                Logger_6.Logger.logDebug("Object with uuid " + uuid + " does not exist");
            }
        }
        getModelsFromObjectLayer(relutionMapObjectLayer) {
            let models = [];
            let objects = relutionMapObjectLayer.getObjects();
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                let model = object.getModel();
                models.push(model);
            }
            return models;
        }
        toggleObjectInfoVisibility(objectType, visible) {
            for (let i = 0; i < this.relutionMapObjectInfoLayers.length; i++) {
                let infoLayer = this.relutionMapObjectInfoLayers[i];
                infoLayer.toggleInfoVisibility(objectType, visible);
            }
        }
        // Event-Handling: Device layer
        // @Override
        onObjectMovedToMap(beacon) {
            this.notifyObservers("onObjectMovedToMap", [beacon]);
        }
        // @Override
        onObjectMovedToStock(beacon) {
            this.notifyObservers("onObjectMovedToStock", [beacon]);
        }
        // @Override
        onObjectSelected(object) {
            this.notifyObservers("onObjectSelected", [object]);
        }
        // @Override
        onObjectUnselected(object) {
            this.notifyObservers("onObjectUnselected", [object]);
        }
        // Floor information
        getHeightInMeter() {
            return this.floorModel.floorBaseInMeter;
        }
        getAvgBeaconHeightInMeter() {
            let deviceLayer = this.getDeviceLayer();
            let beaconsOnMap = deviceLayer.getBeaconsOnMap();
            let sumOfHeightInMeter = 0.0;
            for (let i = 0; i < beaconsOnMap.length; i++) {
                let beaconOnMap = beaconsOnMap[i];
                let deviceModel = beaconOnMap.getModel();
                let height = deviceModel.z;
                sumOfHeightInMeter += height;
            }
            let avgHeightInMeter = sumOfHeightInMeter / beaconsOnMap.length;
            return avgHeightInMeter;
        }
        // Getters and setters
        getFloorName() {
            return this.floorName;
        }
        getMapLayerContainer() {
            return this.floorplanLayerContainer;
        }
        getFloorplanLayer() {
            return this.floorplanLayer;
        }
        getWallplanLayer() {
            return this.wallplanLayer;
        }
        getRelutionMapObjectLayers() {
            return this.relutionMapObjectLayers;
        }
        getRoomLayerContainer() {
            return this.roomLayerContainer;
        }
        getRoomLayer() {
            return this.roomLayer;
        }
        getZoneLayerContainer() {
            return this.zoneLayerContainer;
        }
        getZoneLayer() {
            return this.zoneLayer;
        }
        getGeofenceLayerContainer() {
            return this.geofenceLayerContainer;
        }
        getGeofenceLayer() {
            return this.geofenceLayer;
        }
        getDeviceLayerContainer() {
            return this.deviceLayerContainer;
        }
        getDeviceLayer() {
            return this.deviceLayer;
        }
        getBeaconRangeLayer() {
            return this.beaconRangeLayer;
        }
        getDeviceAccuracyLayer() {
            return this.deviceAccuracyRangeLayer;
        }
        getDeviceTrackLayer() {
            return this.deviceTrackLayer;
        }
        getBeaconConnectionsLayer() {
            return this.beaconConnectionsLayer;
        }
        getDeviceTaggingLayer() {
            return this.deviceTaggingLayer;
        }
        getDeviceInfoLayer() {
            return this.deviceInfoLayer;
        }
        getUserCountHeatmapLayer() {
            return this.userCountHeatmapLayer;
        }
        getSensorHeatmapLayer() {
            return this.sensorHeatmapLayer;
        }
        getSingleDeviceEditLayer() {
            return this.singleDeviceEditLayer;
        }
        getInfoLayerContainer() {
            return this.infoLayerContainer;
        }
        getTapeMeasureLayer() {
            return this.tapeMeasureLayer;
        }
        getObjectLayers() {
            return this.relutionMapObjectLayers;
        }
        /**
         * Returns the floorplan overlay layer if exists, or null if an overlay layer
         * with the given name does not exist.
         * @param overlayName
         */
        getFloorplanOverlayLayerWithName(overlayName) {
            let layer = this.floorplanOverlayLayers.get(overlayName);
            return layer === undefined ? null : layer;
        }
        getLayerByName(layerName) {
            if (layerName === "wallplan") {
                return this.getWallplanLayer();
            }
            else if (layerName === "devices") {
                return this.getDeviceLayerContainer();
            }
            else if (layerName === "ranges") {
                return this.getBeaconRangeLayer();
            }
            else if (layerName === "accuracy") {
                return this.getDeviceAccuracyLayer();
            }
            else if (layerName === "info") {
                return this.getInfoLayerContainer();
            }
            else if (layerName === "connections") {
                return this.getBeaconConnectionsLayer();
            }
            else if (layerName === "tracking") {
                return this.getDeviceTrackLayer();
            }
            else if (layerName === "userCountHeatmap") {
                return this.getUserCountHeatmapLayer();
            }
            else if (layerName === "sensorHeatmap") {
                return this.getSensorHeatmapLayer();
            }
            else if (layerName === "room") {
                return this.getRoomLayerContainer();
            }
            else if (layerName === "zone") {
                return this.getZoneLayerContainer();
            }
            else if (layerName === "geofence") {
                return this.getGeofenceLayerContainer();
            }
            else if (layerName === "tagging") {
                return this.getDeviceTaggingLayer();
            }
            else if (layerName === "tapeMeasure") {
                return this.getTapeMeasureLayer();
            }
            else {
                return this.getFloorplanOverlayLayerWithName(layerName);
            }
        }
        supportsLayerVisibility(layerName) {
            const layer = this.getLayerByName(layerName);
            return layer && !layer.isEmpty();
        }
    }
    exports.Floor = Floor;
    (function (Floor) {
        class Config {
            constructor() {
                // Map layers
                this.floorplanLayer = new FloorplanLayer_1.FloorplanLayer.Config();
                this.wallplanLayer = new WallplanLayer_1.WallplanLayer.Config();
                // Object layers
                this.objectInfoLayer = new RelutionMapObjectInfoLayer_1.RelutionMapObjectInfoLayer.Config();
                // FloorElement layers
                this.roomLayer = new RelutionMapObjectLayer_5.RelutionMapObjectLayer.Config();
                this.zoneLayer = new RelutionMapObjectLayer_5.RelutionMapObjectLayer.Config();
                // Geofence layers
                this.geofenceLayer = new RelutionMapObjectLayer_5.RelutionMapObjectLayer.Config();
                // Device layers
                this.deviceLayer = new DeviceLayer_2.DeviceLayer.Config();
                this.deviceTrackLayer = new DeviceTrackLayer_1.DeviceTrackLayer.Config();
                this.deviceTaggingLayer = new RelutionMapObjectLayer_5.RelutionMapObjectLayer.Config();
                this.userCountHeatmapLayer = new UserCountHeatmapLayer_1.UserCountHeatmapLayer.Config();
                this.sensorHeatmapLayer = new SensorHeatmapLayer_1.SensorHeatmapLayer.Config();
                this.singleDeviceEditLayer = new SingleDeviceEditLayer_1.SingleDeviceEditLayer.Config();
                // Overlay layers
                this.tapeMeasureLayer = new TapeMeasureWorldLayer_1.TapeMeasureWorldLayer.Config();
            }
        }
        Floor.Config = Config;
    })(Floor = exports.Floor || (exports.Floor = {}));
});
define("src/app/relution/view/world/Building", ["require", "exports", "src/map/view/Layer", "src/app/relution/view/world/Floor"], function (require, exports, Layer_10, Floor_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Building = void 0;
    /**
     * Represents a building in the Relution Map.
     * A building consists of one or more floors. Only one floor is visible at each time.
     * The floors are ordered from bottom to top. <code>Ctrl+Up</code> fades to an upper floor,
     * whereas <code>Ctrl+Down</code> fades to a lower floor.
     */
    class Building extends Layer_10.Layer {
        // Construction
        /**
         * Creates a building with one floor passed as an argument.
         * @param floor
         */
        constructor(config, environment, floor) {
            super(environment);
            // Configuration
            this.config = new Building.Config();
            // Observation
            this.floorObservers = new Array();
            this.relutionMapObjectObservers = new Array();
            // View: Floors
            this.floors = new Array();
            this.currentFloor = null;
            // Modes
            this.deviceEditingEnabled = false;
            this.singleDeviceEditModeEnabled = false;
            this.geofenceEditingEnabled = false;
            this.roomEditingEnabled = false;
            this.zoneEditingEnabled = false;
            this.taggingModeEnabled = false;
            this.tapeMeasureEditModeEnabled = false;
            this.config = config;
            this.initLayerVisibility();
            this.initObjectTypeVisibility();
            this.initFloors(floor);
        }
        initLayerVisibility() {
            this.layerNameToVisible = {};
            this.layerNameToVisible["wallplan"] = false;
            this.layerNameToVisible["devices"] = true;
            this.layerNameToVisible["help"] = true;
            this.layerNameToVisible["ranges"] = false;
            this.layerNameToVisible["info"] = false;
            this.layerNameToVisible["connections"] = false;
            this.layerNameToVisible["tracking"] = true;
            this.layerNameToVisible["userCountHeatmap"] = false;
            this.layerNameToVisible["sensorHeatmap"] = false;
            this.layerNameToVisible["geofence"] = false;
            this.layerNameToVisible["room"] = false;
            this.layerNameToVisible["zone"] = false;
            this.layerNameToVisible["tagging"] = false;
            this.layerNameToVisible["tapeMeasure"] = false;
            this.config.layerVisibilities.forEach((visible, layerName) => {
                this.layerNameToVisible[layerName] = visible;
            });
        }
        initObjectTypeVisibility() {
            this.relutionMapObjectTypesToVisible = this.config.objectTypeVisibilities;
            this.relutionMapObjectInfosToVisible = this.config.objectTypeInfoVisibilities;
        }
        initFloors(floor) {
            this.addFloor(floor);
            this.setCurrentFloor(floor);
        }
        // Floor management
        /**
         * Adds a floor to the list of all floors. This floor will be considered
         * as the top floor in the building.
         * @param floor
         */
        addFloor(floor) {
            if (this.floors.indexOf(floor) == -1) {
                this.floors.push(floor);
                this.addLayerAtIndex(floor, 0);
                this.initFloor(floor);
                this.notifyFloorObservers("floorAdded", [floor]);
            }
        }
        /**
         * Adds floors to the list of all floors. These floors will be considered
         * to be the top floors in the building. The floor list must be ordered from bottom to top.
         * @param floors
         */
        addFloors(floors) {
            for (let i = 0; i < floors.length; i++) {
                let floor = floors[i];
                this.addFloor(floor);
            }
        }
        initFloor(floor) {
            floor.setVisible(false);
            this.setEditModeActive(this.isEditModeActive());
            this.setDeviceEditingEnabled(this.isDeviceEditingEnabled());
        }
        /**
         * Removes the floor from the list of all floors.
         * @param floor
         */
        removeFloor(floor) {
            let index = this.floors.indexOf(floor);
            if (index !== -1) {
                this.floors.splice(index, 1);
                this.notifyFloorObservers("floorRemoved", [floor]);
            }
        }
        /**
         * Sorts all floors by height in an ascending order (bottom -> top).
         * The height of a floor is specified in "floorBaseInMeter" attribute the floor model.
         * The bottom most floor will be set as the active one.
         */
        sortFloorsByHeight() {
            // Sort floors list
            this.floors.sort((floorA, floorB) => {
                let heightA = floorA.getHeightInMeter();
                let heightB = floorB.getHeightInMeter();
                if (heightA < heightB) {
                    return -1;
                }
                else if (heightA > heightB) {
                    return +1;
                }
                else {
                    return 0;
                }
            });
            // Sort scene graph
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                this.setLayerAtIndex(floor, i);
            }
            // Make bottom most layer the active one
            this.setCurrentFloor(this.floors[0]);
        }
        // Floor change
        /**
         * Changes the active floor to the floor "floor".
         * @param floor The floor that should be set to the active one.
         * @param changeVisibility Should be set to true, if the current floor should be visible.
         * This should only be set to false, if a fading animation is used to smoothly fade into
         * this floor (See @code animateToFloor).
         */
        setCurrentFloor(floor, changeVisibility = true) {
            let floorBefore = this.currentFloor;
            let floorAfter = floor;
            if (this.currentFloor !== null) {
                this.leaveFloor(this.currentFloor, changeVisibility);
            }
            this.currentFloor = floor;
            if (this.currentFloor !== null) {
                this.enterFloor(this.currentFloor, changeVisibility);
            }
            this.notifyFloorObservers("floorChanged", [floorBefore, floorAfter]);
        }
        /**
         * Animates to the floor "floor" and makes this floor the active floor.
         * @param floor
         */
        animateToFloor(floor) {
            // Set current floor, without changing the visibility
            this.setCurrentFloor(floor, false);
            // Fade in floor
            floor.animateVisible(true, () => {
                // Guarantee that only the current floor is visible
                this.makeAllInactiveFloorsInvisible();
                floor.setVisible(true);
            });
        }
        /**
         * Fades to the upper floor and makes this floor the active floor.
         */
        changeToUpperFloor() {
            let indexOfCurrentFloor = this.floors.indexOf(this.getCurrentFloor());
            let indexOfUpperFloor = indexOfCurrentFloor + 1;
            if (indexOfUpperFloor >= 0 && indexOfUpperFloor < this.floors.length) {
                let upperFloor = this.floors[indexOfUpperFloor];
                this.animateToFloor(upperFloor);
            }
        }
        /**
         * Fades to the lower floor and makes this floor the active floor.
         */
        changeToLowerFloor() {
            let indexOfCurrentFloor = this.floors.indexOf(this.getCurrentFloor());
            let indexOfUpperFloor = indexOfCurrentFloor - 1;
            if (indexOfUpperFloor >= 0 && indexOfUpperFloor < this.floors.length) {
                let upperFloor = this.floors[indexOfUpperFloor];
                this.animateToFloor(upperFloor);
            }
        }
        // Floor access
        /**
         * Returns the list of all floors ordered from bottom to top.
         */
        getFloors() {
            return this.floors;
        }
        /**
         * Returns floor with the name "floorName".
         * @param floorName
         */
        getFloorWithName(floorName) {
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                if (floor.getFloorName() === floorName) {
                    return floor;
                }
            }
            return null;
        }
        /**
         * Returns the floor's index in the list of floors.
         * @param floor
         */
        getFloorIndex(floor) {
            for (let i = 0; i < this.floors.length; i++) {
                let currentFloor = this.floors[i];
                if (currentFloor === floor) {
                    return i;
                }
            }
            return -1;
        }
        /**
         * Returns the floor that is currently active.
         */
        getCurrentFloor() {
            return this.currentFloor;
        }
        enterFloor(floor, changeVisibility) {
            if (changeVisibility) {
                this.makeAllInactiveFloorsInvisible();
                floor.setVisible(true);
            }
            // Move floor to the top in the scene graph.
            // This is necessary. Otherwise the invisible floors
            // might receive the interaction events first.
            this.setChildIndex(floor, this.getChildren().length);
            this.configureFloorOnEnter();
            this.registerAsObserver();
        }
        makeAllInactiveFloorsInvisible() {
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                if (floor !== this.currentFloor) {
                    floor.setVisible(false);
                }
            }
        }
        configureFloorOnEnter() {
            // 1. Make layers visible/invisible and register as observer to the layers
            this.syncLayerVisibilitiesForCurrentFloor();
            this.addLayerVisibilityObservers();
            // 2. Make Relution map object types visible and register as observer
            this.syncObjectTypeVisibilitiesForCurrentFloor();
            this.syncObjectInfoVisibilitiesForCurrentFloor();
        }
        leaveFloor(floor, changeVisibility) {
            if (changeVisibility) {
                floor.setVisible(false);
            }
            this.configureFloorOnLeft();
            this.unregisterAsObserver();
        }
        configureFloorOnLeft() {
            this.removeLayerVisibilityObservers();
        }
        registerAsObserver() {
            this.getCurrentFloor().addObserver(this);
        }
        unregisterAsObserver() {
            if (this.getCurrentFloor() !== undefined) {
                this.getCurrentFloor().removeObserver(this);
            }
        }
        // Floor observation
        /**
         * Adds an observer to the list of all observers.
         * Can be used to get informed about floor changes.
         * @param observer
         */
        addFloorObserver(observer) {
            this.floorObservers.push(observer);
        }
        /**
         * Removes an observer from the list of all observers.
         * @param observer
         */
        removeFloorObserver(observer) {
            let index = this.floorObservers.indexOf(observer);
            if (index !== -1) {
                this.floorObservers.splice(index, 1);
            }
        }
        notifyFloorObservers(callback, args) {
            for (let i = 0; i < this.floorObservers.length; i++) {
                let observer = this.floorObservers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Relution map objects
        // Relution map objects: Observation
        /**
         * Adds a RelutionMapObject observer to the list of all RelutionMapObject observers.
         * Should be used to get informed about RelutionMapObject state changes (e.g. selection changes etc.).
         * @param observer
         */
        addRelutionMapObjectObserver(observer) {
            this.relutionMapObjectObservers.push(observer);
        }
        /**
         * Removes a RelutionMapObject observer to the list of all RelutionMapObject observers.
         * @param observer
         */
        removeRelutionMapObjectObserver(observer) {
            let index = this.relutionMapObjectObservers.indexOf(observer);
            if (index !== -1) {
                this.relutionMapObjectObservers.splice(index, 1);
            }
        }
        notifyRelutionMapObjectObservers(callback, args) {
            for (let i = 0; i < this.relutionMapObjectObservers.length; i++) {
                let observer = this.relutionMapObjectObservers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Relution map objects: Object type toggling
        supportsObjectTypeVisibility(objectType, filter) {
            return this.floors.some(floor => floor.supportsObjectTypeVisibility(objectType, filter));
        }
        toggleRelutionMapObjectTypeVisibility(objectType, visible, notifyObservers = true) {
            // 1. Set optional parameter value, if necessary.
            if (visible === undefined) {
                visible = this.relutionMapObjectTypesToVisible.get(objectType) === undefined ? true : !this.relutionMapObjectTypesToVisible.get(objectType);
            }
            // 2. Update visibility map
            this.relutionMapObjectTypesToVisible.set(objectType, visible);
            // 3. Update relution map object type visibility on all floors
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                floor.toggleObjectTypeVisibility(objectType, visible);
            }
            // 4. Notify observers
            if (notifyObservers) {
                this.notifyRelutionMapObjectObservers("onObjectTypeVisibilityChanged", [objectType, visible]);
            }
        }
        syncObjectTypeVisibilitiesForCurrentFloor() {
            this.relutionMapObjectTypesToVisible.forEach((visible, objectType) => {
                this.getCurrentFloor().toggleObjectTypeVisibility(objectType, visible);
            });
        }
        // Relution map objects: Info toggling
        /**
         * Sets the info labels of all Relution map objects conforming to the {@code objectType} type to {@link visible}.
         * @param objectType the constructor function of a subclass of {@link RelutionMapObject}, e.g. Device or Geofence
         * @param visible true, if all objects of the given type and its subtypes should be permanently visible.
         */
        toggleRelutionMapObjectInfoVisibility(objectType, visible) {
            // 1. Set optional parameter value, if necessary.
            if (visible === undefined) {
                visible = this.relutionMapObjectInfosToVisible.get(objectType) === undefined ? true : !this.relutionMapObjectInfosToVisible.get(objectType);
            }
            // 2. Update visibility map
            this.relutionMapObjectInfosToVisible.set(objectType, visible);
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                floor.toggleObjectInfoVisibility(objectType, visible);
            }
        }
        syncObjectInfoVisibilitiesForCurrentFloor() {
            this.relutionMapObjectInfosToVisible.forEach((visible, objectType) => {
                this.getCurrentFloor().toggleObjectInfoVisibility(objectType, visible);
            });
        }
        // Layers
        syncLayerVisibilitiesForCurrentFloor() {
            this.layerNameToLayer = {
                wallplan: this.getCurrentFloor().getWallplanLayer(),
                devices: this.getCurrentFloor().getDeviceLayerContainer(),
                ranges: this.getCurrentFloor().getBeaconRangeLayer(),
                info: this.getCurrentFloor().getInfoLayerContainer(),
                connections: this.getCurrentFloor().getBeaconConnectionsLayer(),
                tracking: this.getCurrentFloor().getDeviceTrackLayer(),
                userCountHeatmap: this.getCurrentFloor().getUserCountHeatmapLayer(),
                sensorHeatmap: this.getCurrentFloor().getSensorHeatmapLayer(),
                geofence: this.getCurrentFloor().getGeofenceLayerContainer(),
                room: this.getCurrentFloor().getRoomLayerContainer(),
                zone: this.getCurrentFloor().getZoneLayerContainer(),
                tagging: this.getCurrentFloor().getDeviceTaggingLayer(),
                tapeMeasure: this.getCurrentFloor().getTapeMeasureLayer()
            };
            let layerNames = Object.keys(this.layerNameToLayer);
            for (let i = 0; i < layerNames.length; i++) {
                let layerName = layerNames[i];
                let layer = this.layerNameToLayer[layerName];
                let visible = this.layerNameToVisible[layerName];
                if (layer != null) {
                    layer.setVisible(visible);
                }
            }
        }
        addLayerVisibilityObservers() {
            let layerNames = Object.keys(this.layerNameToLayer);
            for (let i = 0; i < layerNames.length; i++) {
                let layerName = layerNames[i];
                let layer = this.layerNameToLayer[layerName];
                if (layer != null) {
                    layer.addVisiblityObserver(this);
                }
            }
        }
        removeLayerVisibilityObservers() {
            let layerNames = Object.keys(this.layerNameToLayer);
            for (let i = 0; i < layerNames.length; i++) {
                let layerName = layerNames[i];
                let layer = this.layerNameToLayer[layerName];
                if (layer != null) {
                    layer.removeVisibilityObserver(this);
                }
            }
        }
        supportsLayerVisibility(layerName) {
            return this.floors.some(floor => floor.supportsLayerVisibility(layerName));
        }
        toggleLayerVisibility(layerName, enabled) {
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                const layer = floor.getLayerByName(layerName);
                if (!layer) {
                    console.log("toggleLayerVisibility: layer not found", layerName);
                    continue;
                }
                this.toggleVisibilityForLayer(layer, enabled);
            }
        }
        toggleVisibilityForLayer(layer, enabled) {
            if (enabled == null) {
                layer.animateVisible(!layer.isVisible());
            }
            else {
                layer.animateVisible(enabled);
            }
        }
        // @Override
        visibilityChanged(layer) {
            let layerName = this.getLayerNameForLayer(layer);
            let layerVisible = layer.isVisible();
            this.layerNameToVisible[layerName] = layerVisible;
            this.notifyRelutionMapObjectObservers("onLayerVisibilityChanged", [layerName, layerVisible]);
        }
        getLayerNameForLayer(layer) {
            let layerNames = Object.keys(this.layerNameToLayer);
            for (let i = 0; i < layerNames.length; i++) {
                let layerName = layerNames[i];
                let currentLayer = this.layerNameToLayer[layerName];
                if (currentLayer && currentLayer === layer) {
                    return layerName;
                }
            }
        }
        getLayerWithName(layerName) {
            if (this.layerNameToLayer.hasOwnProperty(layerName)) {
                return this.layerNameToLayer[layerName];
            }
            else {
                return null;
            }
        }
        // Event handling
        // Event-Handling: Relution map objects
        // @Override
        onObjectMovedToMap(beacon) {
            this.notifyRelutionMapObjectObservers("onObjectMovedToMap", [beacon]);
        }
        // @Override
        onObjectMovedToStock(beacon) {
            this.notifyRelutionMapObjectObservers("onObjectMovedToStock", [beacon]);
        }
        // @Override
        onObjectSelected(object) {
            this.notifyRelutionMapObjectObservers("onObjectSelected", [object]);
        }
        // @Override
        onObjectUnselected(object) {
            this.notifyRelutionMapObjectObservers("onObjectUnselected", [object]);
        }
        // Modes
        isEditModeActive() {
            return this.floors[0].getDeviceLayer().isEditModeActive();
        }
        setEditModeActive(editModeActive) {
            this.setMapLayerContainerClearlyVisible(editModeActive);
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                floor.getDeviceLayer().setEditModeActive(editModeActive);
            }
        }
        isDeviceEditingEnabled() {
            return this.deviceEditingEnabled;
        }
        setDeviceEditingEnabled(enabled) {
            this.deviceEditingEnabled = enabled;
            this.setMapLayerContainerClearlyVisible(enabled);
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                floor.getDeviceLayer().setEditModeActive(enabled);
            }
        }
        isSingleDeviceEditModeEnabled() {
            return this.singleDeviceEditModeEnabled;
        }
        setSingleDeviceEditModeEnabled(enabled, editableDeviceUuid) {
            this.singleDeviceEditModeEnabled = enabled;
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                floor.getSingleDeviceEditLayer().setEditModeActive(enabled, editableDeviceUuid);
            }
        }
        isGeofenceEditingEnabled() {
            return this.geofenceEditingEnabled;
        }
        setGeofenceEditingEnabled(enabled) {
            this.geofenceEditingEnabled = enabled;
            this.setMapLayerContainerClearlyVisible(enabled);
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                floor.getGeofenceLayer().setEditModeActive(enabled);
            }
        }
        isRoomEditingEnabled() {
            return this.roomEditingEnabled;
        }
        setRoomEditingEnabled(enabled) {
            this.roomEditingEnabled = enabled;
            this.setMapLayerContainerClearlyVisible(enabled);
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                floor.getRoomLayer().setEditModeActive(enabled);
            }
        }
        isZoneEditingEnabled() {
            return this.zoneEditingEnabled;
        }
        setZoneEditingEnabled(enabled) {
            this.zoneEditingEnabled = enabled;
            this.setMapLayerContainerClearlyVisible(enabled);
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                floor.getZoneLayer().setEditModeActive(enabled);
            }
        }
        setMapLayerContainerClearlyVisible(clearlyVisible) {
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                if (clearlyVisible) {
                    floor.getMapLayerContainer().animateAlphaToValue(1.0);
                }
                else {
                    floor.getMapLayerContainer().animateVisible(true);
                }
            }
        }
        isTaggingModeEnabled() {
            return this.taggingModeEnabled;
        }
        setTaggingModeEnabled(enabled) {
            this.taggingModeEnabled = enabled;
            this.setMapLayerContainerClearlyVisible(enabled);
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                floor.getDeviceTaggingLayer().setEditModeActive(enabled);
            }
        }
        isTapeMeasureEditModeEnabled() {
            return this.tapeMeasureEditModeEnabled;
        }
        setTapeMeasureEditModeEnabled(enabled) {
            this.tapeMeasureEditModeEnabled = enabled;
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                floor.getTapeMeasureLayer().setEditModeActive(enabled);
            }
        }
        // Destruction
        // @Override
        destroy() {
            this.unregisterAsObserver();
            this.removeLayerVisibilityObservers();
        }
        // Getters and setters
        getConfig() {
            return this.config;
        }
    }
    exports.Building = Building;
    (function (Building) {
        class Config {
            constructor() {
                /**
                 * The default floor configuration.
                 */
                this.floor = new Floor_1.Floor.Config();
                /**
                 * Maps {@link RelutionMapObject} subclasses (more specifically the class's constructor function) to a boolean,
                 * indicating whether objects compatible with this type should be visible or not.
                 *
                 * <p>
                 * Note, that if an object type is not contained in this map, the object type is treated as set to visible (true).
                 * If setting the visibility of type {@link Beacon} to true, all beacons will be visible.
                 * If setting the visibility of the base class {@link Device} to false, beacons and all other devices will not be visible.
                 *
                 * Hence, to make an object visible, the visibilities of all object types compatible with the object must be set to true or not
                 * contained in this map.
                 * </p>
                 *
                 * <p>
                 * Note, that the object type visibility can be set independently to the layer visibility. To make the object visible, the layer
                 * must be visible, as well!
                 * </p>
                 *
                 * Default: Empty map (all object types are visible)
                 */
                this.objectTypeVisibilities = new Map();
                /**
                 * Maps {@link RelutionMapObject} subclasses (more specifically the class's constructor function) to a boolean,
                 * indicating whether the infos depending on map objects of the object type should be visible or not.
                 *
                 * <p>
                 * Note, that if an object type is not contained in this map, the infos for the corresponding object type
                 * is considered to be enabled. Hence, if setting the visibility of type "Beacon" to true, beacons will be visible.
                 * If setting the visibility of "Device" to false, beacons and all other devices will not be visible. To make
                 * an object visible, the visibilities of all object types the object is substitable must be set to true or not
                 * contained in this map.
                 * </p>
                 *
                 * Default: Empty map (infos of all object types are visible).
                 */
                this.objectTypeInfoVisibilities = new Map();
                /**
                 * Overrides the default visibility configuration for the layers specified by their names.
                 * Maps the layer name (string) to its visibility (boolean).
                 */
                this.layerVisibilities = new Map();
            }
        }
        Building.Config = Config;
    })(Building = exports.Building || (exports.Building = {}));
});
define("src/app/relution/view/hud/selectionLayer/SelectionLayer", ["require", "exports", "src/map/view/Layer", "src/map/utils/DeviceUtils", "src/engine/input/GestureRecognizer", "src/engine/general/AABB", "src/app/relution/utils/MouseUtils", "src/engine/math/Vector2"], function (require, exports, Layer_11, DeviceUtils_18, GestureRecognizer_4, AABB_8, MouseUtils_2, Vector2_33) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectionLayer = void 0;
    /**
     * A layer that makes relution world objects selectable.
     *
     * @export
     * @class SelectionLayer
     * @extends {Layer}
     */
    class SelectionLayer extends Layer_11.Layer {
        // Initialization
        constructor(config, environment, building) {
            super(environment);
            this.startX = 0;
            this.startY = 0;
            this.currentX = 0;
            this.currentY = 0;
            this.userIsSelecting = false;
            this.onlyTapSelectionCurrentlyAllowed = false;
            // Observing
            this.observers = new Array();
            this.selectionLayerConfig = config;
            this.initModel(building);
            this.initView();
        }
        initModel(building) {
            this.building = building;
        }
        initView() {
            this.selectionRectangle = this.getEnvironment().renderer.newGraphicsObject();
            this.selectionRectangle.visible = false;
            this.selectionRectangle.alpha = 0.25;
            this.getView().addChild(this.selectionRectangle);
        }
        // Observing
        addObserver(observer) {
            this.observers.push(observer);
        }
        removeObserver(observer) {
            if (!observer || !this.observers || !this.observers.length) {
                return false;
            }
            let index = this.observers.indexOf(observer);
            if (index !== -1) {
                this.observers.splice(index, 1);
            }
        }
        notifyObservers(callback, args) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Key Event-Handling
        // @Override
        onKeyUp(keyCode) {
            if (this.selectionLayerConfig.enabled) {
                if (keyCode === SelectionLayer.DEL_KEY_CODE) {
                    if (this.isDeleteSelectedBeaconsAllowed()) {
                        this.deleteSelectedBeacons();
                    }
                }
            }
            return false;
        }
        deleteSelectedBeacons() {
            let beacons = this.building.getCurrentFloor().getDeviceLayer().getVisibleBeaconsOnMap();
            for (let i = 0; i < beacons.length; i++) {
                let beacon = beacons[i];
                if (beacon.isSelected()) {
                    this.building.getCurrentFloor().getDeviceLayer().moveObjectToStock(beacon);
                }
            }
        }
        // Mouse Event-Handling
        // @Override
        onMouseMove(x, y) {
            if (this.selectionLayerConfig.enabled) {
                this.showOrHideHandMouseCursor(x, y);
            }
            return false;
        }
        showOrHideHandMouseCursor(x, y) {
            let object = this.building.getCurrentFloor().getCollidingObject(x, y);
            if (object != null) {
                if (MouseUtils_2.MouseUtils.isDefaultCursorStyle()) {
                    MouseUtils_2.MouseUtils.changeToHandCursorStyle();
                }
            }
            else {
                if (MouseUtils_2.MouseUtils.isHandCursorStyle()) {
                    MouseUtils_2.MouseUtils.changeToDefaultCursorStyle();
                }
            }
        }
        // @Override
        onTouchStart(x, y) {
            if (this.selectionLayerConfig.enabled) {
                if (!DeviceUtils_18.DeviceUtils.isMobileDevice() && !GestureRecognizer_4.GestureRecognizer.isCtrlPressed()) {
                    if (this.selectionCanBeStartedFromPoint(x, y)) {
                        this.onSelectionRectangleStart(x, y);
                        this.onlyTapSelectionCurrentlyAllowed = false;
                        return true;
                    }
                    else {
                        this.onSelectionRectangleStart(x, y);
                        this.onlyTapSelectionCurrentlyAllowed = true;
                        return false;
                    }
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        onSelectionRectangleStart(x, y) {
            this.userIsSelecting = true;
            this.startX = x;
            this.startY = y;
            this.currentX = x;
            this.currentY = y;
            this.redrawSelectionRectangle();
            this.selectionRectangle.visible = true;
        }
        selectionCanBeStartedFromPoint(x, y) {
            let object = this.building.getCurrentFloor().getCollidingObject(x, y);
            if (object !== null) {
                let objectLayer = this.getLayerForObject(object);
                return !objectLayer.isEditModeActive();
            }
            else {
                return true;
            }
        }
        getLayerForObject(object) {
            for (let i = 0; i < this.building.getCurrentFloor().getObjectLayers().length; i++) {
                let layer = this.building.getCurrentFloor().getObjectLayers()[i];
                if (layer.existsObject(object)) {
                    return layer;
                }
            }
            return null;
        }
        // @Override
        onTouchMove(x, y) {
            if (this.selectionLayerConfig.enabled) {
                if (this.userIsSelecting) {
                    if (!this.onlyTapSelectionCurrentlyAllowed) {
                        this.onSelectionRectangleMove(x, y);
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        onSelectionRectangleMove(x, y) {
            this.currentX = x;
            this.currentY = y;
            this.redrawSelectionRectangle();
        }
        // @Override
        onTouchEnd(x, y) {
            if (this.selectionLayerConfig.enabled) {
                if (this.userIsSelecting) {
                    if (this.onlyTapSelectionCurrentlyAllowed) {
                        // If only tap selection was allowed, check if coordinates have
                        // changed since start. Select the object only, if the coordinates
                        // have not changed.
                        if (this.isTapSelection(x, y)) {
                            this.onSelectionRectangleStop(x, y);
                        }
                        return false;
                    }
                    else {
                        this.onSelectionRectangleStop(x, y);
                        return true;
                    }
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        isTapSelection(x, y) {
            return this.startX === x && this.startY === y;
        }
        onSelectionRectangleStop(x, y) {
            this.currentX = x;
            this.currentY = y;
            let intersectingObjects = this.getIntersectingObjectsOnMap();
            if (!GestureRecognizer_4.GestureRecognizer.isShiftPressed()) {
                this.unselectAllObjectsExcept(intersectingObjects);
            }
            this.selectObjects(intersectingObjects);
            this.resetSelectionRectangle();
        }
        redrawSelectionRectangle() {
            this.selectionRectangle.clear();
            this.selectionRectangle.beginFill(0x0000ff);
            // Draw border
            this.selectionRectangle.lineStyle(2, 0x0000ff);
            // Draw rectangle
            let width = this.currentX - this.startX;
            let height = this.currentY - this.startY;
            // To avoid obscure graphic effects, we do not draw
            // anything, if width or height is zero.
            if (!(width === 0 || height === 0)) {
                this.selectionRectangle.drawRect(this.startX, this.startY, width, height);
            }
            this.selectionRectangle.endFill();
        }
        unselectAllObjectsExcept(objectsNotToUnselect) {
            let visibleObjects = this.building.getCurrentFloor().getAllVisibleObjects();
            for (let i = 0; i < visibleObjects.length; i++) {
                let object = visibleObjects[i];
                if (objectsNotToUnselect.indexOf(object) < 0) {
                    object.setSelected(false);
                }
            }
        }
        getIntersectingObjectsOnMap() {
            if (this.selectionRectangleIsPoint()) {
                return this.getObjectsIntersectingWithSelectionPoint();
            }
            else {
                return this.getObjectsIntersectingWithSelectionRectangle();
            }
        }
        selectionRectangleIsPoint() {
            let selectionRectangle = this.getSelectionRectangle();
            return selectionRectangle.min.x === selectionRectangle.max.x && selectionRectangle.min.y === selectionRectangle.max.y;
        }
        getObjectsIntersectingWithSelectionPoint() {
            let intersectingObjects = new Array();
            let selectionRectangle = this.getSelectionRectangle();
            let collidingObject = this.building.getCurrentFloor().getCollidingObject(selectionRectangle.min.x, selectionRectangle.min.y);
            if (collidingObject !== null) {
                intersectingObjects.push(collidingObject);
            }
            return intersectingObjects;
        }
        getObjectsIntersectingWithSelectionRectangle() {
            let intersectingObjects = new Array();
            let visibleObjects = this.building.getCurrentFloor().getAllVisibleObjects();
            for (let i = 0; i < visibleObjects.length; i++) {
                let object = visibleObjects[i];
                if (object.isSelectable()) {
                    if (this.selectionIntersectsObject(object)) {
                        intersectingObjects.push(object);
                    }
                }
            }
            return intersectingObjects;
        }
        selectObjects(objects) {
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                object.setSelected(true);
            }
        }
        selectionIntersectsObject(object) {
            // TODO: Test the intersection with the whole scene using a bounding volume hierarchy.
            let selectionAabb = this.getSelectionRectangle();
            return object.intersectsAabb(selectionAabb);
        }
        getSelectionRectangle() {
            let minPosX = Math.min(this.startX, this.currentX);
            let minPosY = Math.min(this.startY, this.currentY);
            let maxPosX = Math.max(this.startX, this.currentX);
            let maxPosY = Math.max(this.startY, this.currentY);
            return new AABB_8.AABB(new Vector2_33.Vector2(minPosX, minPosY), new Vector2_33.Vector2(maxPosX, maxPosY));
        }
        resetSelectionRectangle() {
            this.startX = 0;
            this.startY = 0;
            this.currentX = 0;
            this.currentY = 0;
            this.redrawSelectionRectangle();
            this.selectionRectangle.visible = false;
            this.userIsSelecting = false;
        }
        // Tap Event-Handling
        // @Override
        onTap(x, y, numTaps) {
            if (this.selectionLayerConfig.enabled) {
                if (numTaps === 1) {
                    this.onSelectionRectangleStart(x, y);
                    this.onSelectionRectangleMove(x, y);
                    this.onSelectionRectangleStop(x, y);
                    return this.notifyObserversOnObjectTap(x, y, "onObjectClicked");
                }
                else if (numTaps === 2) {
                    if (this.isObjectDoubleClickAllowed()) {
                        return this.notifyObserversOnObjectTap(x, y, "onObjectDoubleClicked");
                    }
                }
            }
            else {
                return false;
            }
        }
        notifyObserversOnObjectTap(x, y, callbackName) {
            let collidingObject = this.building.getCurrentFloor().getCollidingObject(x, y);
            if (collidingObject) {
                this.notifyObservers(callbackName, [collidingObject]);
                return true;
            }
            else {
                return false;
            }
        }
        // Configuration
        isEnabled() {
            return this.selectionLayerConfig.enabled;
        }
        setEnabled(enabled) {
            this.selectionLayerConfig.enabled = enabled;
        }
        isDeleteSelectedBeaconsAllowed() {
            return this.selectionLayerConfig.deleteSelectedBeaconsAllowed;
        }
        setDeleteSelectedBeaconsAllowed(allowed) {
            this.selectionLayerConfig.deleteSelectedBeaconsAllowed = allowed;
        }
        isObjectDoubleClickAllowed() {
            return this.selectionLayerConfig.objectDoubleClickAllowed;
        }
        setObjectDoubleClickAllowed(allowed) {
            this.selectionLayerConfig.objectDoubleClickAllowed = allowed;
        }
    }
    exports.SelectionLayer = SelectionLayer;
    // Controller
    SelectionLayer.DEL_KEY_CODE = 46;
    (function (SelectionLayer) {
        class Config {
            constructor() {
                /**
                 * True, if this layer shall be enabled
                 *
                 * Default: true
                 */
                this.enabled = true;
                /**
                 * True, if the selected beacons may be removed from the map (e.g. using the delete key).
                 *
                 * Default: false
                 */
                this.deleteSelectedBeaconsAllowed = false;
                /**
                 * True, if double clicking yields a call on all registered observers.
                 *
                 * Default: true
                 */
                this.objectDoubleClickAllowed = true;
            }
        }
        SelectionLayer.Config = Config;
    })(SelectionLayer = exports.SelectionLayer || (exports.SelectionLayer = {}));
});
define("src/app/relution/view/hud/popupLayer/PopupLayer", ["require", "exports", "src/map/view/Layer", "src/engine/animation/Animation", "src/map/utils/DeviceUtils", "src/engine/animation/LinearInterpolator", "src/engine/input/GestureRecognizer", "src/engine/math/Vector2"], function (require, exports, Layer_12, Animation_8, DeviceUtils_19, LinearInterpolator_7, GestureRecognizer_5, Vector2_34) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PopupLayer = void 0;
    class PopupLayer extends Layer_12.Layer {
        // Initialization
        constructor(config, environment, building) {
            super(environment);
            this.hoveringObject = null;
            // View: Size
            this.paddingWidthInPx = 10;
            this.paddingHeightInPx = 10;
            // View: Mobile Tap
            this.tapWorldPositionInTx = null;
            // View: Updating
            this.lastPopupUpdateInMs = -1;
            // Observing
            this.observers = new Array();
            this.config = config;
            this.initModel(building);
            this.initView();
        }
        initModel(building) {
            this.building = building;
            this.building.addFloorObserver(this);
            this.observeObjectLayers(this.building.getCurrentFloor());
        }
        observeObjectLayers(currentFloor) {
            let objectLayers = currentFloor.getObjectLayers();
            for (let i = 0; i < objectLayers.length; i++) {
                let objectLayer = objectLayers[i];
                objectLayer.addObserver(this);
            }
        }
        unobserveObjectLayers(leftFloor) {
            let objectLayers = leftFloor.getObjectLayers();
            for (let i = 0; i < objectLayers.length; i++) {
                let objectLayer = objectLayers[i];
                objectLayer.removeObserver(this);
            }
        }
        initView() {
            this.initBackgroundView();
            this.initContentView();
            this.initBlendAnimation();
            this.setPopupVisible(false);
        }
        initBackgroundView() {
            this.backgroundView = this.getEnvironment().renderer.newGraphicsObject();
            this.getView().addChild(this.backgroundView);
        }
        initContentView() {
            let fontSize = DeviceUtils_19.DeviceUtils.getPhysicalPixelsFromLogical(12);
            let textStyle = this.getEnvironment().renderer.newTextStyle();
            textStyle.fill = 0x000000;
            textStyle.fontFamily = "Arial";
            textStyle.fontSize = fontSize;
            this.contentView = this.getEnvironment().renderer.newTextObject("", 2, textStyle);
            this.getView().addChild(this.contentView);
            // Translation
            this.contentView.x = this.paddingWidthInPx;
            this.contentView.y = this.paddingHeightInPx;
        }
        initBlendAnimation() {
            this.blendAnimation = new Animation_8.Animation(new LinearInterpolator_7.LinearInterpolator());
        }
        // Observing
        addObserver(observer) {
            this.observers.push(observer);
        }
        removeObserver(observer) {
            if (!observer || !this.observers || !this.observers.length) {
                return false;
            }
            let index = this.observers.indexOf(observer);
            if (index !== -1) {
                this.observers.splice(index, 1);
            }
        }
        notifyObservers(callback, args) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Redrawing
        redrawBackgroundViewToFitWithContent() {
            let width = this.contentView.width + this.paddingWidthInPx * 2;
            let height = this.contentView.height + this.paddingHeightInPx * 2;
            this.redrawBackgroundView(width, height);
        }
        redrawBackgroundView(width, height) {
            this.backgroundView.clear();
            this.backgroundView.beginFill(0xffffff);
            this.backgroundView.lineStyle(1, 0x000000);
            this.backgroundView.drawRect(0, 0, width, height);
            this.backgroundView.endFill();
        }
        // Input Event-Handling
        // @Override
        onMouseStart(x, y) {
            super.onMouseStart(x, y);
            return false;
        }
        // @Override
        onMouseMove(x, y) {
            super.onMouseMove(x, y);
            return this.handleMouseMove(x, y);
        }
        handleMouseMove(x, y) {
            const lastHoveringObject = this.hoveringObject;
            this.updatePopupIfNecessary(x, y);
            if (this.hoveringObject !== null) {
                this.movePopupToObject();
            }
            if (lastHoveringObject || this.hoveringObject) {
                // when both are null do not send bare mouse moves
                this.notifyObservers("onObjectHovering", [this.hoveringObject, x, y]);
            }
            return false;
        }
        updatePopupIfNecessary(x, y) {
            let collidingObject = this.building.getCurrentFloor().getCollidingObject(x, y, (object) => {
                return object.isPopupInfoSupported();
            });
            if (collidingObject !== null) {
                if (this.hoveringObject !== collidingObject) {
                    this.hoveringObject = collidingObject;
                    this.preparePopupForObject(this.hoveringObject);
                    this.setPopupVisible(true);
                }
            }
            else {
                if (this.hoveringObject !== null) {
                    this.hoveringObject = null;
                    this.setPopupVisible(false);
                }
            }
        }
        // @Override
        onTouchMove(x, y, touchIndex) {
            super.onTouchMove(x, y, touchIndex);
            if (this.popupIsVisible()) {
                if (this.hoveringObject != null) {
                    this.movePopupToObject();
                }
            }
            return false;
        }
        // @Override
        onMouseOut(x, y) {
            super.onMouseOut(x, y);
            return false;
        }
        preparePopupForObject(object) {
            this.fillPopupContentForObject(object);
            this.redrawBackgroundViewToFitWithContent();
            this.movePopupToObject();
        }
        fillPopupContentForObject(object) {
            let content = this.getContentForObject(object);
            this.contentView.text = "" + content;
        }
        movePopupToObject() {
            if (DeviceUtils_19.DeviceUtils.isMobileDevice()) {
                if (this.config.showPopupsOnTapForMobileDevices) {
                    this.movePopupToObjectMobile();
                }
            }
            else {
                this.movePopupToObjectDesktop();
            }
        }
        movePopupToObjectMobile() {
            let worldCamera = this.building.getCurrentFloor().getScene().getCamera();
            let positionInScreenPx = worldCamera.getImageCoordinateFromWorldPoint(this.tapWorldPositionInTx);
            // Set the position.
            this.getView().x = positionInScreenPx.x;
            this.getView().y = positionInScreenPx.y;
        }
        movePopupToObjectDesktop() {
            let positionInScreenPx = new Vector2_34.Vector2(GestureRecognizer_5.GestureRecognizer.getMousePositionX(), GestureRecognizer_5.GestureRecognizer.getMousePositionY());
            // Rectangle should not go out of the screen.
            let worldCamera = this.building.getCurrentFloor().getScene().getCamera();
            if (positionInScreenPx.x + this.backgroundView.width > worldCamera.getScreenWidth()) {
                positionInScreenPx.x -= this.backgroundView.width;
            }
            if (positionInScreenPx.y + this.backgroundView.height > worldCamera.getScreenHeight()) {
                positionInScreenPx.y -= this.backgroundView.height;
            }
            // Set the position.
            this.getView().x = positionInScreenPx.x;
            this.getView().y = positionInScreenPx.y;
        }
        // Content
        /**
         * Returns the content of the popup display, given a Relution map object.
         *
         * <p>
         * Can be overridden, if the content should deviate from the [[RelutionMapObject#getPopupInfo]] result.
         * </p>
         * @param object the Relution map object, which a popup is currently displayed for.
         */
        getContentForObject(object) {
            let content = object.getPopupInfo();
            const resultMap = this.building.getScene().visit("onPopupContentRequested", [object]);
            resultMap.forEach((decoratedPopupContent, visitedObject) => {
                if (typeof decoratedPopupContent === "string") {
                    content += "\n";
                    content += decoratedPopupContent;
                }
            });
            return content;
        }
        // Tapping
        // @Override
        onTap(x, y, numTaps) {
            const handled = super.onTap(x, y, numTaps);
            if (this.config.showPopupsOnTapForMobileDevices) {
                if (DeviceUtils_19.DeviceUtils.isMobileDevice()) {
                    if (numTaps === 1) {
                        let worldCamera = this.building.getCurrentFloor().getScene().getCamera();
                        this.tapWorldPositionInTx = worldCamera.getWorldCoordinateFromImagePoint(new Vector2_34.Vector2(x, y));
                        // Act like a mouse move event on desktop browsers.
                        this.onMouseMove(x, y);
                    }
                }
            }
            return handled;
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            this.updateAnimation(lastFrametime);
            this.updatePopupIfVisible(lastFrametime);
        }
        updateAnimation(lastFrametime) {
            if (this.blendAnimation.isCurrentlyAnimating()) {
                let currentAlpha = this.blendAnimation.getValue(lastFrametime);
                this.getView().alpha = currentAlpha;
            }
        }
        updatePopupIfVisible(lastFrametime) {
            if (this.hoveringObject != null) {
                let nowInMs = Date.now();
                if (nowInMs - this.lastPopupUpdateInMs > 1000) {
                    this.lastPopupUpdateInMs = nowInMs;
                    this.preparePopupForObject(this.hoveringObject);
                }
                this.movePopupToObject();
            }
        }
        // Floor Event handling
        // @Override
        floorChanged(floorBefore, floorAfter) {
            this.unobserveObjectLayers(floorBefore);
            this.observeObjectLayers(floorAfter);
        }
        // Event handling: Relution Map object layer changes
        // @Override
        onObjectsLoaded(objects) {
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                object.getModel().addObserver(this);
            }
        }
        onObjectsUnloaded(objects) {
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                object.getModel().removeObserver(this);
            }
        }
        // Event handling: Relution object model changed
        // @Override
        modelChanged(model) {
            if (this.hoveringObject != null) {
                if (this.hoveringObject.getModel() === model) {
                    this.preparePopupForObject(this.hoveringObject);
                }
            }
        }
        // Event handling: Resizing
        // @Override
        onResize() {
            super.onResize();
            this.movePopupToObject();
        }
        // Getters and setters
        popupIsVisible() {
            return this.getView().alpha > 0;
        }
        setPopupVisible(visible) {
            let startValue = this.getView().alpha;
            let endValue = 0;
            if (visible) {
                endValue = PopupLayer.MAX_ALPHA;
            }
            else {
                endValue = 0.0;
            }
            let durationInMs = 1;
            let delayInMs = 0.0;
            this.blendAnimation.start(startValue, endValue, durationInMs, delayInMs);
        }
        setEnabled(enabled) {
            this.getRenderView().visible = enabled;
        }
        isEnabled() {
            return this.getRenderView().visible;
        }
    }
    exports.PopupLayer = PopupLayer;
    PopupLayer.MAX_ALPHA = 0.8;
    (function (PopupLayer) {
        class Config {
            constructor() {
                /**
                 * True, if a popup should appear on mobile devices, whenever the user taps on
                 * a Relution Map object.
                 *
                 * Default: true
                 */
                this.showPopupsOnTapForMobileDevices = true;
            }
        }
        PopupLayer.Config = Config;
    })(PopupLayer = exports.PopupLayer || (exports.PopupLayer = {}));
});
define("src/app/relution/view/world/RelutionMapWorld", ["require", "exports", "src/map/view/Layer", "src/app/relution/view/world/Building"], function (require, exports, Layer_13, Building_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RelutionMapWorld = void 0;
    class RelutionMapWorld extends Layer_13.Layer {
        constructor(config, environment, world, floor) {
            super(environment);
            this.config = config;
            this.world = world;
            this.building = new Building_1.Building(config.building, environment, floor);
            this.addLayer(this.building);
        }
        getBuilding() {
            return this.building;
        }
        getCamera() {
            let worldCamera = this.getScene().getCamera();
            return worldCamera;
        }
        getWorld() {
            return this.world;
        }
    }
    exports.RelutionMapWorld = RelutionMapWorld;
    (function (RelutionMapWorld) {
        class Config {
            constructor() {
                this.building = new Building_1.Building.Config();
            }
        }
        RelutionMapWorld.Config = Config;
    })(RelutionMapWorld = exports.RelutionMapWorld || (exports.RelutionMapWorld = {}));
});
define("src/engine/animation/EaseIn", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EaseIn = void 0;
    class EaseIn {
        constructor(baseInterpolator) {
            this.baseInterpolator = baseInterpolator;
        }
        getInterpolationValue(timeProgress) {
            let t = timeProgress;
            let easedT = Math.pow(t, 3);
            return this.baseInterpolator.getInterpolationValue(easedT);
        }
    }
    exports.EaseIn = EaseIn;
});
define("src/engine/animation/EaseOut", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EaseOut = void 0;
    // Can be used as a decorator for arbitrary interpolators
    class EaseOut {
        constructor(baseInterpolator) {
            this.baseInterpolator = baseInterpolator;
        }
        getInterpolationValue(timeProgress) {
            let t = timeProgress;
            let alpha = 10;
            let easedT = 1 - Math.pow(1 - t, alpha);
            return this.baseInterpolator.getInterpolationValue(easedT);
        }
    }
    exports.EaseOut = EaseOut;
});
define("src/map/view/hud/layers/navigationLayer/NavigationLayer", ["require", "exports", "src/map/view/Layer", "src/engine/input/GestureRecognizer", "src/map/utils/DeviceUtils", "src/engine/animation/EaseIn", "src/engine/animation/EaseOut", "src/engine/animation/LinearInterpolator", "src/engine/math/Vector2"], function (require, exports, Layer_14, GestureRecognizer_6, DeviceUtils_20, EaseIn_1, EaseOut_1, LinearInterpolator_8, Vector2_35) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NavigationLayer = void 0;
    class NavigationLayer extends Layer_14.Layer {
        // Initialization
        constructor(config, environment, camera) {
            super(environment);
            // Navigation: Panning
            this.panning = false;
            this.lastPanXs = new Array();
            this.lastPanYs = new Array();
            this.lastPanTimestamps = new Array();
            this.panDelayInMs = 100;
            // Navigation: Pinching
            this.pinching = false;
            this.currentFocus = new Vector2_35.Vector2();
            this.currentScaleFactor = 1;
            // Navigation: Rotation
            this.rotating = false;
            this.currentRotation = 0;
            this.currentRotationTimestampInMs = 0;
            // Configuration
            this.interactionEnabled = true;
            this.config = config;
            // The camera to move
            this.camera = camera;
            this.camera.setWorldDimensionsToFitChildren();
            if (this.config.initialFrustum !== null) {
                this.camera.setFrustum(this.config.initialFrustum);
            }
            else {
                this.camera.showWholeWorld();
            }
            // Glass view
            this.navigationView = this.getEnvironment().renderer.newGraphicsObject();
            this.relayoutNavigationView();
            this.navigationView.alpha = 0;
            this.getView().addChild(this.navigationView);
        }
        relayoutNavigationView() {
            this.navigationView.clear();
            this.navigationView.beginFill(0xffffff);
            this.navigationView.drawRect(0, 0, this.camera.getScreenWidth(), this.camera.getScreenHeight());
            this.navigationView.endFill();
        }
        onMouseWheel(delta, mouseX, mouseY) {
            if (this.isRotationKeyDown()) {
                // Rotate, when ctrl is pressed
                let rotationAngleInRad = 2 * Math.PI / 360; // 1 degree in rad
                const scalingFactor = 1.00;
                if (delta > 0) {
                    // Wheel up
                    rotationAngleInRad = -rotationAngleInRad;
                    this.onRotatingStart(rotationAngleInRad, mouseX, mouseY, 1, scalingFactor);
                    this.onRotatingMove(rotationAngleInRad, mouseX, mouseY, 1, scalingFactor);
                    this.onRotatingEnd(rotationAngleInRad, mouseX, mouseY, 1, scalingFactor);
                }
                else {
                    // Wheel down
                    rotationAngleInRad = +rotationAngleInRad;
                    this.onRotatingStart(rotationAngleInRad, mouseX, mouseY, 1, scalingFactor);
                    this.onRotatingMove(rotationAngleInRad, mouseX, mouseY, 1, scalingFactor);
                    this.onRotatingEnd(rotationAngleInRad, mouseX, mouseY, 1, scalingFactor);
                }
            }
            else if (this.isZoomingKeyDown()) {
                // Zoom, when ctrl is not pressed.
                const scalingFactor = 1.0 + (Math.abs(delta) * 0.08);
                if (delta > 0) {
                    // Wheel up
                    this.onPinchingStart(mouseX, mouseY, 1, scalingFactor);
                    this.onPinchingMove(mouseX, mouseY, 1, scalingFactor);
                    this.onPinchingEnd(mouseX, mouseY, 1, scalingFactor);
                }
                else {
                    // Wheel down
                    this.onPinchingStart(mouseX, mouseY, 1, 1.0 / scalingFactor);
                    this.onPinchingMove(mouseX, mouseY, 1, 1.0 / scalingFactor);
                    this.onPinchingEnd(mouseX, mouseY, 1, 1.0 / scalingFactor);
                }
            }
            return true;
        }
        isRotationKeyDown() {
            return GestureRecognizer_6.GestureRecognizer.isAltPressed();
        }
        isZoomingKeyDown() {
            return GestureRecognizer_6.GestureRecognizer.isCtrlPressed();
        }
        // @Override
        onTouchMove(x, y, touchIndex) {
            // If user is currently navigating using this layer, low level events
            // should not be delegated to lower layers. Instead
            // they will be blocked here.
            if (this.panning || this.pinching || this.rotating) {
                this.onTouchEnd(x, y, touchIndex);
                return true;
            }
            else {
                return false;
            }
        }
        // @Override
        onPanningStart(x, y) {
            if (this.config.panningEnabled) {
                // Panning will only be considered, if no the navigation layer
                // is not disabled and no other key is pressed.
                if (this.isInteractionEnabled()) {
                    if (DeviceUtils_20.DeviceUtils.isMobileDevice() || this.isPanningKeyDown()) {
                        this.panning = true;
                        this.lastPanXs = new Array();
                        this.lastPanYs = new Array();
                        this.lastPanTimestamps = new Array();
                        this.lastPanXs.push(x);
                        this.lastPanYs.push(y);
                        this.lastPanTimestamps.push(Date.now());
                        this.camera.setBordersEnabled(false);
                        return true;
                    }
                    else {
                        return false;
                    }
                }
            }
            return false;
        }
        // @Override
        onPanningMove(x, y) {
            if (this.config.panningEnabled) {
                if (this.isInteractionEnabled()) {
                    if (DeviceUtils_20.DeviceUtils.isMobileDevice() || this.isPanningKeyDown()) {
                        if (this.lastPanXs.length >= 1 && this.lastPanYs.length >= 1 && this.lastPanTimestamps.length >= 1) {
                            this.lastPanXs.push(x);
                            this.lastPanYs.push(y);
                            this.lastPanTimestamps.push(Date.now());
                            let currentX = this.lastPanXs[this.lastPanXs.length - 1];
                            let currentY = this.lastPanYs[this.lastPanYs.length - 1];
                            let lastX = this.lastPanXs[this.lastPanXs.length - 2];
                            let lastY = this.lastPanYs[this.lastPanYs.length - 2];
                            let velocity = new Vector2_35.Vector2(-(currentX - lastX), -(currentY - lastY));
                            this.camera.translate(velocity);
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        return false;
                    }
                }
            }
            return false;
        }
        // @Override
        onPanningEnd(x, y) {
            if (this.config.panningEnabled) {
                if (this.isInteractionEnabled()) {
                    if (DeviceUtils_20.DeviceUtils.isMobileDevice() || this.isPanningKeyDown()) {
                        this.panning = false;
                        if (this.lastPanXs.length >= 1 && this.lastPanYs.length >= 1 && this.lastPanTimestamps.length >= 1) {
                            // Take current position as first reference
                            let currentX = this.lastPanXs[this.lastPanXs.length - 1];
                            let currentY = this.lastPanYs[this.lastPanYs.length - 1];
                            let currentTimestamp = this.lastPanTimestamps[this.lastPanTimestamps.length - 1];
                            // If last pan update is too old, user has stopped moving.
                            // So velocity should be set to zero.
                            if (Date.now() - currentTimestamp <= this.panDelayInMs) {
                                // Take the position "panDelay" milliseconds ago, as second reference
                                let i = this.lastPanTimestamps.length - 1;
                                while (currentTimestamp - this.lastPanTimestamps[i] < this.panDelayInMs && i > 0) {
                                    i--;
                                }
                                let lastX = this.lastPanXs[i];
                                let lastY = this.lastPanYs[i];
                                let lastTimestamp = this.lastPanTimestamps[i];
                                // Add translation impulse
                                let durationInMs = currentTimestamp - lastTimestamp;
                                if (durationInMs > 0) {
                                    let referenceDurationInMs = 10;
                                    let velocity = new Vector2_35.Vector2(-(currentX - lastX) * (referenceDurationInMs / durationInMs), -(currentY - lastY) * (referenceDurationInMs / durationInMs));
                                    this.addTranslationImpulse(velocity);
                                }
                            }
                            this.camera.setBordersEnabled(true);
                            this.lastPanXs = new Array();
                            this.lastPanYs = new Array();
                            this.lastPanTimestamps = new Array();
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        return false;
                    }
                }
            }
            return false;
        }
        isPanningKeyDown() {
            return GestureRecognizer_6.GestureRecognizer.isCtrlPressed();
        }
        onPinchingStart(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            if (this.config.pinchingEnabled) {
                if (this.isInteractionEnabled()) {
                    this.pinching = true;
                    this.currentFocus = new Vector2_35.Vector2(pinchFocusX, pinchFocusY);
                    this.currentScaleTimestampInMs = Date.now();
                    this.camera.setBordersEnabled(false);
                    return true;
                }
            }
            return false;
        }
        onPinchingMove(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            if (this.config.pinchingEnabled) {
                if (this.isInteractionEnabled()) {
                    this.currentScaleFactor = 1 / scaleFactor;
                    this.camera.scale(this.currentScaleFactor, this.currentScaleFactor, this.currentFocus);
                    this.currentScaleTimestampInMs = Date.now();
                    return true;
                }
            }
            return false;
        }
        onPinchingEnd(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            if (this.config.pinchingEnabled) {
                if (this.isInteractionEnabled()) {
                    this.pinching = false;
                    this.addScaleImpulse(this.currentScaleFactor);
                    this.camera.setBordersEnabled(true);
                    return true;
                }
            }
            return false;
        }
        onRotatingStart(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            if (this.config.rotatingEnabled) {
                if (this.isInteractionEnabled()) {
                    this.rotating = true;
                    this.currentFocus = new Vector2_35.Vector2(pinchFocusX, pinchFocusY);
                    this.currentScaleTimestampInMs = Date.now();
                    this.currentRotationTimestampInMs = Date.now();
                    this.camera.setBordersEnabled(false);
                    return true;
                }
            }
            return false;
        }
        onRotatingMove(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            if (this.config.rotatingEnabled) {
                if (this.isInteractionEnabled()) {
                    this.currentScaleFactor = 1 / scaleFactor;
                    this.camera.scale(this.currentScaleFactor, this.currentScaleFactor, this.currentFocus);
                    this.currentScaleTimestampInMs = Date.now();
                    this.currentRotation = -rotation;
                    this.camera.rotate(this.currentRotation, this.currentFocus);
                    this.currentRotationTimestampInMs = Date.now();
                    return true;
                }
            }
            return false;
        }
        onRotatingEnd(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            if (this.config.rotatingEnabled) {
                if (this.isInteractionEnabled()) {
                    this.rotating = false;
                    this.addScaleImpulse(this.currentScaleFactor);
                    this.addRotationImpulse(this.currentRotation);
                    this.camera.setBordersEnabled(true);
                    return true;
                }
            }
            return false;
        }
        addScaleImpulse(scaleFactor) {
            let timestamp = Date.now();
            let timeDifferenceInMs = timestamp - this.currentScaleTimestampInMs;
            let referenceTimeDifferenceInMs = 60;
            let weight = 0;
            if (timeDifferenceInMs !== 0) {
                weight = Math.min(timeDifferenceInMs / referenceTimeDifferenceInMs, 1);
            }
            scaleFactor = scaleFactor - ((scaleFactor - 1) * weight);
            this.camera.addScaleImpulse(scaleFactor, this.currentFocus);
        }
        addRotationImpulse(rotation) {
            let timestamp = Date.now();
            let timeDifferenceInMs = timestamp - this.currentRotationTimestampInMs;
            let referenceTimeDifferenceInMs = 10;
            let weight = 1;
            if (timeDifferenceInMs !== 0) {
                weight = Math.min(referenceTimeDifferenceInMs / timeDifferenceInMs, 1);
            }
            rotation = rotation * weight;
            this.camera.addRotationImpulse(rotation, this.currentFocus);
        }
        addTranslationImpulse(translation) {
            // Decrease velocity if last pan move event was emitted a long time ago.
            this.camera.addTranslationImpulse(translation);
        }
        onTap(x, y, numTaps) {
            if (this.config.doubleTapZoomEnabled) {
                // Double tap to zoom in
                if (numTaps === 2) {
                    if (this.camera.getScaleX() > 1.0) {
                        // By default: Zoom in.
                        this.onPinchingStart(x, y, 0, 1.1);
                        this.onPinchingMove(x, y, 0, 1.1);
                        this.onPinchingEnd(x, y, 0, 1.1);
                    }
                    else {
                        // If zoom level has reached image resolution (1 pixel = 1 texel), zoom out again.
                        let interpolator = new EaseIn_1.EaseIn(new EaseOut_1.EaseOut(new LinearInterpolator_8.LinearInterpolator()));
                        let endObb = this.camera.getDefaultWorldBordersInWorldCoordinates();
                        let durationInMs = 1 * 1000;
                        let delayInMs = 0.0;
                        this.camera.startAnimation(interpolator, endObb, durationInMs, delayInMs);
                    }
                    return false;
                }
            }
            return false;
        }
        // Resizing
        // @Override
        onResize() {
            super.onResize();
            this.relayoutNavigationView();
        }
        //// Configuration
        isInteractionEnabled() {
            return this.interactionEnabled;
        }
        setInteractionEnabled(enabled) {
            this.interactionEnabled = enabled;
        }
        setDoubleTapZoomingEnabled(enabled) {
            this.config.doubleTapZoomEnabled = enabled;
        }
        isDoubleTapZoomingEnabled() {
            return this.config.doubleTapZoomEnabled;
        }
    }
    exports.NavigationLayer = NavigationLayer;
    (function (NavigationLayer) {
        class Config {
            constructor() {
                /**
                 * True, if panning is enabled.
                 *
                 * Default: true
                 */
                this.panningEnabled = true;
                /**
                 * True, if pinching is enabled.
                 *
                 * Default: true
                 */
                this.pinchingEnabled = true;
                /**
                 * True, if rotating is enabled.
                 *
                 * Default: true
                 */
                this.rotatingEnabled = true;
                /**
                 * True, if double tapping triggers a zoom in.
                 *
                 * Default: true
                 */
                this.doubleTapZoomEnabled = true;
                /**
                 * Focuses the camera to the specified oriented bounding box
                 * right after initialization. If null, the camera
                 * will show the whole map. The frustum coordinates
                 * are given in the world coordinate system:
                 * [[0, floorplanWidth], [0, floorplanHeight]]
                 *
                 * Default: null (displaying the whole world)
                 */
                this.initialFrustum = null;
            }
        }
        NavigationLayer.Config = Config;
    })(NavigationLayer = exports.NavigationLayer || (exports.NavigationLayer = {}));
});
define("src/map/view/hud/objects/ButtonObject", ["require", "exports", "src/engine/scene/SceneObject"], function (require, exports, SceneObject_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ButtonObject = void 0;
    class ButtonObject extends SceneObject_6.SceneObject {
        // Initialization
        constructor(environment, normalTextureName, hoverColor = 0xffffff) {
            super(environment);
            this.hovering = false;
            this.clicking = false;
            // Observer
            this.buttonObservers = new Array();
            this.normalTextureName = normalTextureName;
            this.hoverColor = hoverColor;
            this.initView();
        }
        initView() {
            // Texture
            this.spriteView = this.getEnvironment().renderer.newSpriteObject();
            this.loadTexture();
            this.colorizeTexture();
        }
        loadTexture() {
            this.spriteView.texture = this.getEnvironment().renderer.getTexture("" + this.normalTextureName);
        }
        colorizeTexture() {
            if (this.isHovering()) {
                this.spriteView.tint = this.hoverColor;
            }
            else {
                this.spriteView.tint = 0xffffff;
            }
        }
        // Observers
        addObserver(observer) {
            this.buttonObservers.push(observer);
        }
        notifyObservers(callback, args) {
            for (let i = 0; i < this.buttonObservers.length; i++) {
                let observer = this.buttonObservers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // View
        // @Override
        getView() {
            return this.spriteView;
        }
        // Event-Handling: User
        // @Override
        onMouseMove(x, y) {
            if (this.pointInside(x, y)) {
                if (!this.isHovering()) {
                    this.hovering = true;
                    this.colorizeTexture();
                }
            }
            else {
                if (this.isHovering()) {
                    this.hovering = false;
                    this.colorizeTexture();
                }
            }
            return false;
        }
        // @Override
        onTouchStart(x, y) {
            if (this.pointInside(x, y)) {
                this.clicking = true;
                this.notifyObservers("onButtonPressed", [this]);
                return true;
            }
            else {
                return false;
            }
        }
        // @Override
        onTouchEnd(x, y) {
            if (this.clicking) {
                if (this.pointInside(x, y)) {
                    this.notifyObservers("onButtonClicked", [this]);
                }
                this.clicking = false;
            }
            return false;
        }
        // @Override
        onTap(x, y, numTaps) {
            // Block taps
            if (this.pointInside(x, y)) {
                return true;
            }
            else {
                return false;
            }
        }
        // @Override
        onPanningStart(x, y) {
            // Disable panning when button is in click state.
            return this.clicking;
        }
        // @Override
        onPanningMove(x, y) {
            // Disable panning when button is in click state.
            return this.clicking;
        }
        // @Override
        onPanningEnd(x, y) {
            // Disable panning when button is in click state.
            return this.clicking;
        }
        pointInside(x, y) {
            let bounds = this.getView().getBounds();
            let minX = bounds.x;
            let minY = bounds.y;
            let maxX = bounds.x + bounds.width;
            let maxY = bounds.y + bounds.height;
            return ((x >= minX) && (x < maxX) && (y >= minY) && (y < maxY));
        }
        // Getters and setters
        isClicking() {
            return this.clicking;
        }
        isHovering() {
            return this.hovering;
        }
    }
    exports.ButtonObject = ButtonObject;
});
define("src/map/view/hud/layers/controlLayer/ZoomObject", ["require", "exports", "src/engine/scene/SceneObject", "src/map/view/hud/objects/ButtonObject", "src/engine/math/Vector2"], function (require, exports, SceneObject_7, ButtonObject_1, Vector2_36) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ZoomObject = void 0;
    class ZoomObject extends SceneObject_7.SceneObject {
        // Initialization
        constructor(environment, worldCamera, buttonSizeInPx) {
            super(environment);
            this.scaleFactor = 1.02;
            this.buttonSizeInPx = buttonSizeInPx;
            this.initModel(worldCamera);
            this.initView();
        }
        initModel(worldCamera) {
            this.worldCamera = worldCamera;
        }
        initView() {
            this.container = this.getEnvironment().renderer.newDisplayObjectContainer();
            this.initPlusButton();
            this.initMinusButton();
        }
        initPlusButton() {
            this.plusButton = new ButtonObject_1.ButtonObject(this.getEnvironment(), "plus_normal", ZoomObject.HOVER_COLOR);
            this.addChild(this.plusButton);
            // Scale
            this.plusButton.getView().width = this.buttonSizeInPx;
            this.plusButton.getView().height = this.buttonSizeInPx;
            // Position
            this.plusButton.getView().x = 0;
            this.plusButton.getView().y = 0;
            // Observer
            this.plusButton.addObserver(this);
        }
        initMinusButton() {
            this.minusButton = new ButtonObject_1.ButtonObject(this.getEnvironment(), "minus_normal", ZoomObject.HOVER_COLOR);
            this.addChild(this.minusButton);
            // Scale
            this.minusButton.getView().width = this.buttonSizeInPx;
            this.minusButton.getView().height = this.buttonSizeInPx;
            // Position
            this.minusButton.getView().x = 0;
            // -> height-1 to avoid two borders.
            this.minusButton.getView().y = this.plusButton.getView().height;
            // Observer
            this.minusButton.addObserver(this);
        }
        // View
        // @Override
        getView() {
            return this.container;
        }
        // Event-Handling: Button
        // @Override
        onButtonClicked(button) {
            if (this.plusButton === button) {
                this.scaleCameraWithScaleFactor(1.0 / this.scaleFactor);
            }
            else if (this.minusButton === button) {
                this.scaleCameraWithScaleFactor(this.scaleFactor);
            }
        }
        scaleCameraWithScaleFactor(scalingFactor) {
            let screenWidth = this.worldCamera.getScreenWidth();
            let screenHeight = this.worldCamera.getScreenHeight();
            this.worldCamera.addScaleImpulse(scalingFactor, new Vector2_36.Vector2(screenWidth / 2, screenHeight / 2));
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.plusButton.isClicking()) {
                this.scaleCameraWithScaleFactor(1.0 / this.scaleFactor);
            }
            else if (this.minusButton.isClicking()) {
                this.scaleCameraWithScaleFactor(this.scaleFactor);
            }
        }
    }
    exports.ZoomObject = ZoomObject;
    // Constants
    ZoomObject.HOVER_COLOR = 0xe4e4e4;
});
define("src/map/view/hud/layers/controlLayer/PanObject", ["require", "exports", "src/engine/scene/SceneObject", "src/map/view/hud/objects/ButtonObject", "src/engine/math/Vector2"], function (require, exports, SceneObject_8, ButtonObject_2, Vector2_37) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PanObject = void 0;
    class PanObject extends SceneObject_8.SceneObject {
        // Initialization
        constructor(environment, worldCamera, buttonSizeInPx) {
            super(environment);
            // Configuration
            this.translationImpulse = 5;
            this.buttonSizeInPx = buttonSizeInPx;
            this.initModel(worldCamera);
            this.initView();
        }
        initModel(worldCamera) {
            this.worldCamera = worldCamera;
        }
        initView() {
            this.container = this.getEnvironment().renderer.newDisplayObjectContainer();
            this.upButton = this.initButton("pan_up", PanObject.HOVER_COLOR, this.buttonSizeInPx * 1.5, this.buttonSizeInPx * 0.0);
            this.downButton = this.initButton("pan_down", PanObject.HOVER_COLOR, this.buttonSizeInPx * 1.5, this.buttonSizeInPx * 3.0);
            this.leftButton = this.initButton("pan_left", PanObject.HOVER_COLOR, this.buttonSizeInPx * 0.0, this.buttonSizeInPx * 1.5);
            this.rightButton = this.initButton("pan_right", PanObject.HOVER_COLOR, this.buttonSizeInPx * 3.0, this.buttonSizeInPx * 1.5);
        }
        initButton(imageName, hoverColor, x, y) {
            let button = new ButtonObject_2.ButtonObject(this.getEnvironment(), imageName, hoverColor);
            this.addChild(button);
            // Scale
            button.getView().width = this.buttonSizeInPx;
            button.getView().height = this.buttonSizeInPx;
            // Position
            button.getView().x = x;
            button.getView().y = y;
            // Observer
            button.addObserver(this);
            return button;
        }
        // View
        // @Override
        getView() {
            return this.container;
        }
        // Event-Handling: Button
        // @Override
        onButtonClicked(button) {
            if (this.upButton === button) {
                this.worldCamera.addTranslationImpulse(new Vector2_37.Vector2(0, -this.translationImpulse));
            }
            else if (this.downButton === button) {
                this.worldCamera.addTranslationImpulse(new Vector2_37.Vector2(0, +this.translationImpulse));
            }
            else if (this.leftButton === button) {
                this.worldCamera.addTranslationImpulse(new Vector2_37.Vector2(-this.translationImpulse, 0));
            }
            else if (this.rightButton === button) {
                this.worldCamera.addTranslationImpulse(new Vector2_37.Vector2(+this.translationImpulse, 0));
            }
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.upButton.isClicking()) {
                this.worldCamera.addTranslationImpulse(new Vector2_37.Vector2(0, -this.translationImpulse));
            }
            else if (this.downButton.isClicking()) {
                this.worldCamera.addTranslationImpulse(new Vector2_37.Vector2(0, +this.translationImpulse));
            }
            else if (this.leftButton.isClicking()) {
                this.worldCamera.addTranslationImpulse(new Vector2_37.Vector2(-this.translationImpulse, 0));
            }
            else if (this.rightButton.isClicking()) {
                this.worldCamera.addTranslationImpulse(new Vector2_37.Vector2(+this.translationImpulse, 0));
            }
        }
        // Getters and setters
        getWidth() {
            return this.buttonSizeInPx * 3;
        }
        getHeight() {
            return this.buttonSizeInPx * 3;
        }
    }
    exports.PanObject = PanObject;
    // Constants
    PanObject.HOVER_COLOR = 0xe4e4e4;
});
define("src/map/view/hud/layers/controlLayer/Compass", ["require", "exports", "src/engine/scene/SceneObject", "src/engine/animation/Animation", "src/engine/animation/EaseOut", "src/engine/animation/LinearInterpolator", "src/map/utils/DeviceUtils", "src/map/view/hud/objects/ButtonObject", "src/engine/math/Vector2"], function (require, exports, SceneObject_9, Animation_9, EaseOut_2, LinearInterpolator_9, DeviceUtils_21, ButtonObject_3, Vector2_38) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Compass = void 0;
    class Compass extends SceneObject_9.SceneObject {
        // Initialization
        constructor(environment, worldCamera) {
            super(environment);
            this.initWorldCamera(worldCamera);
            this.initCameraReset();
            this.initContainer();
            this.initCompassButton();
        }
        initWorldCamera(worldCamera) {
            this.worldCamera = worldCamera;
        }
        initCameraReset() {
            this.resetAnimation = new Animation_9.Animation(new EaseOut_2.EaseOut(new LinearInterpolator_9.LinearInterpolator()));
            this.alphaAnimation = new Animation_9.Animation(new EaseOut_2.EaseOut(new LinearInterpolator_9.LinearInterpolator()));
        }
        initContainer() {
            this.container = this.getEnvironment().renderer.newDisplayObjectContainer();
        }
        initCompassButton() {
            this.compassButton = new ButtonObject_3.ButtonObject(this.getEnvironment(), "compass");
            this.addChild(this.compassButton);
            // Alpha
            this.compassButton.getView().alpha = 0.0;
            // Scale
            const oldWidth = this.compassButton.getView().width;
            const oldHeight = this.compassButton.getView().height;
            this.compassButton.getView().width = DeviceUtils_21.DeviceUtils.getPhysicalPixelsFromLogical(48);
            this.compassButton.getView().height = this.compassButton.getView().width * (oldHeight / oldWidth);
            // Adjust anchor
            this.compassButton.getView().anchor.x = 0.5;
            this.compassButton.getView().anchor.y = 0.5;
            // Adjust position
            this.compassButton.getView().x = this.compassButton.getView().width / 2;
            this.compassButton.getView().y = this.compassButton.getView().height / 2;
            // Observer
            this.compassButton.addObserver(this);
        }
        // View
        getView() {
            return this.container;
        }
        // Event-Handling: Button
        // @Override
        onButtonClicked(button) {
            if (this.compassButton === button) {
                this.resetWorldCamera();
            }
        }
        resetWorldCamera() {
            let startValue = this.worldCamera.getRotation();
            let stopValue = 0.0;
            let durationInMs = 2 * 1000;
            let delayInMs = 0.0;
            this.resetAnimation.start(startValue, stopValue, durationInMs, delayInMs);
        }
        // Updating
        // @Override
        update(lastFrametime) {
            this.updateOrientation();
            this.updateAlpha(lastFrametime);
            this.updateResetAnimation(lastFrametime);
        }
        updateOrientation() {
            let worldOrientation = this.worldCamera.getRotation();
            this.compassButton.getView().rotation = -worldOrientation;
        }
        updateAlpha(lastFrametime) {
            this.startAlphaAnimationIfNecessary();
            this.updateAlphaAnimation(lastFrametime);
        }
        startAlphaAnimationIfNecessary() {
            if (this.compassButton.getView().rotation === 0 && this.compassButton.getView().alpha !== 0) {
                if (!this.alphaAnimation.isCurrentlyAnimating()) {
                    let startValue = 1.0;
                    let endValue = 0.0;
                    let durationInMs = 1000;
                    let delayInMs = 0.0;
                    this.alphaAnimation.start(startValue, endValue, durationInMs, delayInMs);
                }
            }
            else if (this.compassButton.getView().rotation !== 0 && this.compassButton.getView().alpha === 0) {
                if (!this.alphaAnimation.isCurrentlyAnimating()) {
                    let startValue = 0.0;
                    let endValue = 1.0;
                    let durationInMs = 1000;
                    let delayInMs = 0.0;
                    this.alphaAnimation.start(startValue, endValue, durationInMs, delayInMs);
                }
            }
        }
        updateAlphaAnimation(lastFrametime) {
            if (this.alphaAnimation.isCurrentlyAnimating()) {
                let currentAlpha = this.alphaAnimation.getValue(lastFrametime);
                this.compassButton.getView().alpha = currentAlpha;
            }
        }
        updateResetAnimation(lastFrametime) {
            if (this.resetAnimation.isCurrentlyAnimating()) {
                let lastOrientation = this.worldCamera.getRotation();
                let currentOrientation = this.resetAnimation.getValue(lastFrametime);
                let rotation = currentOrientation - lastOrientation;
                let focusPoint = new Vector2_38.Vector2(this.worldCamera.getScreenWidth() / 2, this.worldCamera.getScreenHeight() / 2);
                this.worldCamera.rotate(rotation, focusPoint);
            }
        }
    }
    exports.Compass = Compass;
});
define("src/map/view/hud/layers/controlLayer/ControlLayer", ["require", "exports", "src/map/view/Layer", "src/map/view/hud/layers/controlLayer/ZoomObject", "src/map/view/hud/layers/controlLayer/PanObject", "src/map/view/hud/layers/controlLayer/Compass", "src/map/utils/DeviceUtils"], function (require, exports, Layer_15, ZoomObject_1, PanObject_1, Compass_1, DeviceUtils_22) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ControlLayer = void 0;
    class ControlLayer extends Layer_15.Layer {
        // Construction
        constructor(config = new ControlLayer.Config(), environment, worldCamera) {
            super(environment);
            // View
            this.zoomObject = null;
            this.panObject = null;
            this.compass = null;
            this.padding = DeviceUtils_22.DeviceUtils.getPhysicalPixelsFromLogical(10);
            this.panButtonSizeInPx = DeviceUtils_22.DeviceUtils.getPhysicalPixelsFromLogical(24);
            this.zoomButtonSizeInPx = DeviceUtils_22.DeviceUtils.getPhysicalPixelsFromLogical(24);
            this.config = config;
            this.initView(worldCamera);
        }
        initView(worldCamera) {
            this.createView(worldCamera);
            this.layoutView();
        }
        createView(worldCamera) {
            this.initPanObject(worldCamera);
            this.initZoomObject(worldCamera);
            this.initCompass(worldCamera);
        }
        initPanObject(worldCamera) {
            this.panObject = new PanObject_1.PanObject(this.getEnvironment(), worldCamera, this.panButtonSizeInPx);
            if (this.panControlVisible()) {
                this.addChild(this.panObject);
            }
        }
        initZoomObject(worldCamera) {
            this.zoomObject = new ZoomObject_1.ZoomObject(this.getEnvironment(), worldCamera, this.zoomButtonSizeInPx);
            if (this.zoomControlVisible()) {
                this.addChild(this.zoomObject);
            }
        }
        initCompass(worldCamera) {
            this.compass = new Compass_1.Compass(this.getEnvironment(), worldCamera);
            if (this.rotationControlVisible()) {
                this.addChild(this.compass);
            }
        }
        panControlVisible() {
            return this.config.panControlVisible && (!DeviceUtils_22.DeviceUtils.isMobileDevice() || (DeviceUtils_22.DeviceUtils.isMobileDevice() && !this.config.hidePanControlOnMobile));
        }
        zoomControlVisible() {
            return this.config.zoomControlVisible;
        }
        rotationControlVisible() {
            return this.config.rotationControlVisible;
        }
        // Construction: Layout
        layoutView() {
            if (this.panControlVisible()) {
                this.layoutPanObject();
            }
            if (this.zoomControlVisible()) {
                this.layoutZoomObject();
            }
            if (this.rotationControlVisible()) {
                this.layoutCompassObject();
            }
        }
        layoutPanObject() {
            let screenWidth = this.getCanvasWidthInPx();
            this.panObject.getView().x = screenWidth - this.panObject.getView().width - this.padding;
            this.panObject.getView().y = this.padding;
        }
        layoutZoomObject() {
            let screenWidth = this.getCanvasWidthInPx();
            let yOffset = 0;
            let xOffset = 0;
            if (this.panControlVisible()) {
                yOffset += this.panButtonSizeInPx * 1.0;
            }
            if (this.panControlVisible()) {
                xOffset += this.panButtonSizeInPx * 2.5;
            }
            else {
                xOffset += this.zoomButtonSizeInPx;
            }
            this.zoomObject.getView().x = screenWidth - xOffset - this.padding;
            this.zoomObject.getView().y = this.padding + yOffset;
        }
        layoutCompassObject() {
            let screenWidth = this.getCanvasWidthInPx();
            let yOffset = 0;
            let xOffset = 0;
            if (this.panControlVisible()) {
                yOffset += this.panButtonSizeInPx * 4.0 + this.padding;
            }
            else if (this.zoomControlVisible()) {
                yOffset += this.zoomObject.getView().height + this.padding;
            }
            else {
                yOffset += +this.padding;
            }
            if (this.panControlVisible()) {
                xOffset += this.panButtonSizeInPx * 2.5 - this.panButtonSizeInPx * 0.5 + this.compass.getView().width / 2;
            }
            else {
                xOffset += this.zoomButtonSizeInPx * 1.0 - this.zoomButtonSizeInPx * 0.5 + this.compass.getView().width / 2;
            }
            this.compass.getView().x = screenWidth - xOffset - this.padding;
            this.compass.getView().y = this.padding + yOffset;
        }
        // Events: Resize
        //@Override
        onResize() {
            this.layoutView();
        }
    }
    exports.ControlLayer = ControlLayer;
    (function (ControlLayer) {
        class Config {
            constructor() {
                /**
                 * True, if the pan control elements (arrows) for panning
                 * via mouse clicks should be visible.
                 *
                 * Default: true
                 */
                this.panControlVisible = true;
                /**
                 * True, if the zoom control elements (+/-) buttons for zooming
                 * via mouse clicks should be visible.
                 *
                 * Default: true
                 */
                this.zoomControlVisible = true;
                /**
                 * True, if the rotation control element (compass needle) for resetting the
                 * camera orientation via mouse click should be visible.
                 *
                 * Default: true. The compass, however, will only be visible,
                 * when the map's orientation is not adjusted to north direction.
                 */
                this.rotationControlVisible = true;
                /**
                 * True, if the pan control elements (arrows) should be hiden
                 * on mobile devices.
                 *
                 * Default: true
                 */
                this.hidePanControlOnMobile = true;
            }
        }
        ControlLayer.Config = Config;
    })(ControlLayer = exports.ControlLayer || (exports.ControlLayer = {}));
});
define("src/map/view/hud/objects/ScrollableContentObject", ["require", "exports", "src/engine/scene/SceneObject"], function (require, exports, SceneObject_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScrollableContentObject = void 0;
    class ScrollableContentObject extends SceneObject_10.SceneObject {
        constructor(environment) {
            super(environment);
            this.container = this.getEnvironment().renderer.newDisplayObjectContainer();
        }
        // @Override
        getView() {
            return this.container;
        }
    }
    exports.ScrollableContentObject = ScrollableContentObject;
});
define("src/map/view/hud/objects/ScrollableObject", ["require", "exports", "src/engine/scene/SceneObject", "src/map/view/world/objects/WorldCamera", "src/map/view/hud/objects/ScrollableContentObject", "src/engine/general/AABB", "src/engine/math/Vector2"], function (require, exports, SceneObject_11, WorldCamera_2, ScrollableContentObject_1, AABB_9, Vector2_39) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScrollableObject = void 0;
    class ScrollableObject extends SceneObject_11.SceneObject {
        // Initialization
        constructor(environment, width, height) {
            super(environment);
            // Configuration
            this.horizontalScrollingEnabled = true;
            this.verticalScrollingEnabled = false;
            // Navigation
            this.panning = false;
            this.currentPosition = new Vector2_39.Vector2();
            this.currentPanVelocity = new Vector2_39.Vector2();
            // Create scene graph: Container -> Camera -> ContentView
            this.initContainer();
            this.initCamera(width, height);
            this.initContentView();
        }
        initContainer() {
            this.container = this.getEnvironment().renderer.newDisplayObjectContainer();
        }
        initCamera(width, height) {
            this.camera = new WorldCamera_2.WorldCamera(new WorldCamera_2.WorldCamera.Config(), this.getEnvironment(), width, height);
            this.camera.setBordersEnabled(true);
            this.camera.setUseSoftBorders(true);
            this.addChild(this.camera);
        }
        initContentView() {
            this.contentObject = new ScrollableContentObject_1.ScrollableContentObject(this.getEnvironment());
            this.camera.addChild(this.contentObject);
            this.updateContentObjectDimensions(new AABB_9.AABB(new Vector2_39.Vector2(), new Vector2_39.Vector2()));
        }
        // Configuration
        setHorizontalScrollingEnabled(enabled) {
            this.horizontalScrollingEnabled = enabled;
        }
        isHorizontalScrollingEnabled() {
            return this.horizontalScrollingEnabled;
        }
        setVerticalScrollingEnabled(enabled) {
            this.verticalScrollingEnabled = enabled;
        }
        isVerticalScrollingEnabled() {
            return this.verticalScrollingEnabled;
        }
        // View
        // @Override
        getView() {
            return this.container;
        }
        // Content based methods
        getContentObject() {
            return this.contentObject;
        }
        // Should be called, whenever the content view has been changed.
        updateContentObjectDimensions(aabb) {
            let minX = Math.min(aabb.min.x, 0);
            let minY = Math.min(aabb.min.y, 0);
            let maxX = Math.max(aabb.max.x, this.camera.getScreenWidth());
            let maxY = Math.max(aabb.max.y, this.camera.getScreenHeight());
            let worldAabb = new AABB_9.AABB(new Vector2_39.Vector2(minX, minY), new Vector2_39.Vector2(maxX, maxY));
            this.camera.setWorldDimensions(worldAabb);
        }
        // User Event-Handling
        touchPointInsideContainer(x, y) {
            let point = this.getEnvironment().renderer.newPointFromVector2(new Vector2_39.Vector2(x, y));
            let localTouchPoint = this.getView().toLocal(point, point);
            let minX = 0;
            let minY = 0;
            let maxX = this.camera.getScreenWidth();
            let maxY = this.camera.getScreenHeight();
            return localTouchPoint.x >= minX && localTouchPoint.x <= maxX &&
                localTouchPoint.y >= minX && localTouchPoint.y <= maxY;
        }
        // Can be used to mark specific areas in the container as not scrollable.
        // Default: Each area is scrollable.
        isInScrollableArea(x, y) {
            // Default implementation: return always true
            return true;
        }
        // @Override
        onPanningStart(x, y) {
            if (this.isInScrollableArea(x, y)) {
                if (this.touchPointInsideContainer(x, y)) {
                    this.panning = true;
                    if (this.isHorizontalScrollingEnabled()) {
                        this.currentPosition.x = x;
                    }
                    if (this.isVerticalScrollingEnabled()) {
                        this.currentPosition.y = y;
                    }
                    this.currentPanTimestampInMs = Date.now();
                    this.camera.setBordersEnabled(false);
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        // @Override
        onPanningMove(x, y) {
            if (this.panning) {
                // Translation
                let velocityX = 0;
                let velocityY = 0;
                if (this.isHorizontalScrollingEnabled()) {
                    velocityX = -(x - this.currentPosition.x);
                }
                if (this.isVerticalScrollingEnabled()) {
                    velocityX = -(y - this.currentPosition.y);
                }
                this.currentPanVelocity = new Vector2_39.Vector2(velocityX, velocityY);
                this.camera.translate(this.currentPanVelocity);
                // Save current position
                if (this.isHorizontalScrollingEnabled()) {
                    this.currentPosition.x = x;
                }
                if (this.isVerticalScrollingEnabled()) {
                    this.currentPosition.y = y;
                }
                // Update timestamp
                this.currentPanTimestampInMs = Date.now();
                return true;
            }
            else {
                return false;
            }
        }
        // @Override
        onPanningEnd(x, y) {
            if (this.panning) {
                this.panning = false;
                this.addTranslationImpulse(this.currentPanVelocity);
                this.camera.setBordersEnabled(true);
                return true;
            }
            else {
                return false;
            }
        }
        addTranslationImpulse(translation) {
            // Decrease velocity if last pan move event was emitted a long time ago.
            let timestamp = Date.now();
            let timeDifferenceInMs = timestamp - this.currentPanTimestampInMs;
            let referenceTimeDifferenceInMs = 10;
            let weight = Math.min(referenceTimeDifferenceInMs / timeDifferenceInMs, 1);
            translation.x *= weight;
            translation.y *= weight;
            this.camera.addTranslationImpulse(translation);
        }
        // Resizing
        /**
         * Resizes the scrollable object to the specified size
         * @param widthInPx target width in screen pixels.
         * @param heightInPx target height in screen pixels.
         */
        setSize(widthInPx, heightInPx) {
            this.camera.setScreenWidth(widthInPx);
            this.camera.setScreenHeight(heightInPx);
            this.updateContentObjectDimensions(this.camera.getWorldDimensions());
        }
        // Getters and setters
        isPanning() {
            return this.panning;
        }
    }
    exports.ScrollableObject = ScrollableObject;
});
define("src/app/relution/view/hud/barLayer/Bar", ["require", "exports", "src/map/view/hud/objects/ScrollableObject", "src/engine/animation/Animation", "src/engine/animation/LinearInterpolator"], function (require, exports, ScrollableObject_1, Animation_10, LinearInterpolator_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Bar = void 0;
    class Bar extends ScrollableObject_1.ScrollableObject {
        // Initialization
        constructor(environment, width, height) {
            super(environment, width, height);
            // View: Animation
            this.autoFadeEnabled = true;
            this.forceVisibleUntil = 0;
            // Controller
            this.mouseInsideBar = false;
            this.initAnimation();
        }
        initAnimation() {
            this.fadeAnimation = new Animation_10.Animation(new LinearInterpolator_10.LinearInterpolator());
            this.animateVisible(false, 1 * 1000);
        }
        // User: Input-Events
        // @Override
        onMouseIn(x, y) {
            this.forceVisibleUntil = Date.now() + Bar.FORCE_VISIBILITY_DURATION_IN_MS;
            this.animateVisible(true, 0);
            return false;
        }
        // @Override
        onMouseOut(x, y) {
            this.animateVisible(false, 0);
            return false;
        }
        // @Override
        onMouseMove(x, y) {
            if (this.touchPointInsideContainer(x, y)) {
                if (!this.mouseInsideBar) {
                    this.animateVisible(true, 0);
                    this.mouseInsideBar = true;
                }
            }
            else {
                if (this.mouseInsideBar) {
                    this.mouseInsideBar = false;
                    this.animateVisible(false, 1 * 1000);
                }
            }
            return false;
        }
        // @Override
        onTouchMove(x, y, touchIndex) {
            let handled = super.onTouchMove(x, y, touchIndex);
            if (!handled) {
                // Prevent touch move events to be handled on lower level layers
                // if user is inside the bar
                if (this.touchPointInsideContainer(x, y)) {
                    return true;
                }
            }
            else {
                return handled;
            }
        }
        // Animation
        animateVisible(visible, delayInMs) {
            this.animateVisibleWihDuration(visible, delayInMs, 200);
        }
        animateVisibleWihDuration(visible, delayInMs, durationInMs) {
            let startValue = this.getView().alpha;
            let endValue = 0;
            if (visible) {
                endValue = 1.0;
            }
            else {
                endValue = 0.0;
            }
            if (this.fadeAnimation.isCurrentlyAnimating()) {
                this.fadeAnimation.stop();
            }
            this.fadeAnimation.start(startValue, endValue, durationInMs, delayInMs);
        }
        // Updating
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.isAutoFadeEnabled()) {
                let nowInMs = Date.now();
                if (this.forceVisibleUntil - nowInMs > 0) {
                    this.updateAlphaWithAnimation(lastFrametime);
                }
                else if (this.forceVisibleUntil !== 0) {
                    this.forceVisibleUntil = 0;
                    if (this.mouseInsideBar) {
                        this.animateVisible(true, 0);
                    }
                    else {
                        this.animateVisible(false, 0);
                    }
                }
                else {
                    this.updateAlphaWithAnimation(lastFrametime);
                }
            }
        }
        updateAlphaWithAnimation(lastFrametime) {
            if (this.fadeAnimation.isCurrentlyAnimating()) {
                let currentAlpha = this.fadeAnimation.getValue(lastFrametime);
                this.getView().alpha = currentAlpha;
            }
        }
        // Getters and setters
        isAutoFadeEnabled() {
            return this.autoFadeEnabled;
        }
        setAutoFadeEnabled(enabled) {
            this.autoFadeEnabled = enabled;
        }
    }
    exports.Bar = Bar;
    Bar.FORCE_VISIBILITY_DURATION_IN_MS = 2 * 1000;
});
define("src/app/relution/view/hud/barLayer/actionBar/Action", ["require", "exports", "src/engine/scene/SceneObject", "src/map/utils/DeviceUtils"], function (require, exports, SceneObject_12, DeviceUtils_23) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Action = void 0;
    class Action extends SceneObject_12.SceneObject {
        // Initialization
        constructor(environment, resourceName, descriptionPlaceholder) {
            super(environment);
            // Model
            this.descriptionPlaceholder = null;
            this.hovering = false;
            this.touching = false;
            // Observers
            this.observers = new Array();
            this.descriptionPlaceholder = descriptionPlaceholder;
            this.initContainer();
            this.initBackgroundView();
            this.initSpriteView(resourceName);
            this.initTooltipView();
        }
        initContainer() {
            this.container = this.getEnvironment().renderer.newDisplayObjectContainer();
        }
        initBackgroundView() {
            this.backgroundView = this.getEnvironment().renderer.newGraphicsObject();
            this.backgroundView.beginFill(0x95b507);
            this.backgroundView.drawRect(0, 0, Action.WIDTH, Action.HEIGHT);
            this.backgroundView.endFill();
            this.backgroundView.alpha = Action.BG_ALPHA_NORMAL;
            this.container.addChild(this.backgroundView);
        }
        initSpriteView(resourceName) {
            // Load texture
            let texture = this.getEnvironment().renderer.getTexture("" + resourceName);
            // Load sprite
            this.iconView = this.getEnvironment().renderer.newSpriteObject(texture);
            // Pivot
            this.iconView.pivot.x = this.iconView.width / 2;
            this.iconView.pivot.y = this.iconView.height / 2;
            // Scale
            this.iconView.width = Action.IMAGE_WIDTH;
            this.iconView.height = Action.IMAGE_HEIGHT;
            // Position
            this.iconView.x = Action.WIDTH / 2;
            this.iconView.y = Action.HEIGHT / 2;
            this.container.addChild(this.iconView);
        }
        initTooltipView() {
            if (this.tooltipView != null) {
                this.getView().removeChild(this.tooltipView);
            }
            let textStyle = this.getEnvironment().renderer.newTextStyle();
            textStyle.fontFamily = "Arial";
            textStyle.fontSize = DeviceUtils_23.DeviceUtils.getPhysicalPixelsFromLogical(14);
            ;
            textStyle.fill = 0x000000;
            textStyle.align = "center";
            let description = this.getLocalizedStringFor(this.descriptionPlaceholder);
            this.tooltipView = this.getEnvironment().renderer.newTextObject("" + description, 1, textStyle);
            this.tooltipView.alpha = 0;
            this.container.addChild(this.tooltipView);
            // Position
            this.tooltipView.x = 0;
            this.tooltipView.y = Action.HEIGHT;
        }
        // Observation
        addObserver(observer) {
            this.observers.push(observer);
        }
        // View
        // @Override
        getView() {
            return this.container;
        }
        updateViewState() {
            if (this.touching) {
                this.backgroundView.alpha = Action.BG_ALPHA_TOUCHING;
            }
            else if (this.hovering) {
                this.backgroundView.alpha = Action.BG_ALPHA_HOVER;
            }
            else {
                this.backgroundView.alpha = Action.BG_ALPHA_NORMAL;
            }
        }
        showTooltip(show) {
            if (show) {
                this.tooltipView.alpha = 1.0;
            }
            else {
                this.tooltipView.alpha = 0.0;
            }
        }
        // Localization: Event-Handling
        // @Override
        onLocalizationChanged() {
            this.initTooltipView();
            return false;
        }
        // Input Event-Handling
        // @Override
        onMouseMove(x, y) {
            if (this.touchCollides(x, y)) {
                if (!this.hovering) {
                    this.hovering = true;
                    this.updateViewState();
                    this.showTooltip(true);
                }
            }
            else {
                if (this.hovering) {
                    this.hovering = false;
                    this.updateViewState();
                    this.showTooltip(false);
                }
            }
            return false;
        }
        // @Override
        onTouchStart(x, y) {
            if (this.touchCollides(x, y)) {
                this.touching = true;
                this.updateViewState();
                this.notifyObserversAboutButtonClicked();
                return true;
            }
            else {
                return false;
            }
        }
        touchCollides(x, y) {
            let point = this.getEnvironment().renderer.newPoint(0, 0);
            let itemPositionInImage = this.getView().toGlobal(point, point);
            let minX = itemPositionInImage.x;
            let minY = itemPositionInImage.y;
            let maxX = itemPositionInImage.x + Action.WIDTH;
            let maxY = itemPositionInImage.y + Action.HEIGHT;
            return ((x >= minX) && (x < maxX) &&
                (y >= minY) && (y < maxY));
        }
        notifyObserversAboutButtonClicked() {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                observer.onActionClicked(this);
            }
        }
        // @Override
        onTouchEnd(x, y) {
            if (this.touching) {
                this.touching = false;
                this.updateViewState();
                return true;
            }
            else {
                return false;
            }
        }
    }
    exports.Action = Action;
    // View: Dimensions
    Action.WIDTH = DeviceUtils_23.DeviceUtils.getPhysicalPixelsFromLogical(40);
    Action.HEIGHT = DeviceUtils_23.DeviceUtils.getPhysicalPixelsFromLogical(40);
    Action.IMAGE_WIDTH = DeviceUtils_23.DeviceUtils.getPhysicalPixelsFromLogical(40);
    Action.IMAGE_HEIGHT = DeviceUtils_23.DeviceUtils.getPhysicalPixelsFromLogical(40);
    // View: Hovering
    Action.BG_ALPHA_NORMAL = 0.00;
    Action.BG_ALPHA_HOVER = 0.25;
    // View: Clicking
    Action.BG_ALPHA_TOUCHING = 0.50;
});
define("src/app/relution/view/hud/helpLayer/HelpLayer", ["require", "exports", "src/map/view/Layer", "src/map/utils/DeviceUtils"], function (require, exports, Layer_16, DeviceUtils_24) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HelpLayer = void 0;
    class HelpLayer extends Layer_16.Layer {
        // Initialization
        constructor(environment) {
            super(environment);
        }
        // @Override
        initialize() {
            super.initialize();
            this.initView();
        }
        initView() {
            this.createView();
            this.layoutView();
            this.setVisible(false);
        }
        createView() {
            this.initBackgroundView();
            this.initTextView();
        }
        initBackgroundView() {
            this.backgroundView = this.getEnvironment().renderer.newGraphicsObject();
            this.backgroundView.alpha = 0.75;
            this.getView().addChild(this.backgroundView);
        }
        initTextView() {
            if (this.textView != null) {
                this.getView().removeChild(this.textView);
            }
            let text = null;
            if (DeviceUtils_24.DeviceUtils.isMobileDevice()) {
                text = this.getLocalizedStringFor("help_layer_mobile_device_description");
            }
            else {
                text = this.getLocalizedStringFor("help_layer_non_mobile_device_description");
            }
            let textStyle = this.getEnvironment().renderer.newTextStyle();
            textStyle.fontSize = DeviceUtils_24.DeviceUtils.getPhysicalPixelsFromLogical(18);
            this.textView = this.getEnvironment().renderer.newTextObject(text, 1, textStyle);
            this.getView().addChild(this.textView);
        }
        layoutView() {
            this.layoutBackgroundView();
            this.layoutTextView();
        }
        layoutBackgroundView() {
            this.backgroundView.clear();
            this.backgroundView.beginFill(0xffffff);
            this.backgroundView.lineStyle(1, 0x000000);
            this.backgroundView.drawRect(0, 0, this.getEnvironment().renderer.renderTargetSize.x, this.getEnvironment().renderer.renderTargetSize.y);
            this.backgroundView.endFill();
        }
        layoutTextView() {
            this.textView.x = this.getEnvironment().renderer.renderTargetSize.x / 2 - this.textView.width / 2;
            this.textView.y = this.getEnvironment().renderer.renderTargetSize.y / 2 - this.textView.height / 2;
        }
        // Localization Event-Handling
        // @Override
        onLocalizationChanged() {
            this.initTextView();
            return false;
        }
        // Resize Event-Handling
        // @Override
        onResize() {
            this.layoutView();
        }
        // Input: Event-Handling
        // @Override
        onTouchStart(x, y) {
            if (this.isVisible()) {
                this.animateVisible(false);
                return true;
            }
            else {
                return false;
            }
        }
    }
    exports.HelpLayer = HelpLayer;
});
define("src/app/relution/view/hud/barLayer/actionBar/ToggleAction", ["require", "exports", "src/app/relution/view/hud/barLayer/actionBar/Action"], function (require, exports, Action_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ToggleAction = void 0;
    class ToggleAction extends Action_1.Action {
        // Initialization
        constructor(environment, resourceName, description) {
            super(environment, resourceName, description);
            this.enabled = false;
        }
        // Getters and setters
        setEnabled(enabled) {
            this.enabled = enabled;
            this.updateViewState();
        }
        isEnabled() {
            return this.enabled;
        }
        // @Override
        updateViewState() {
            super.updateViewState();
            if (this.isEnabled()) {
                this.backgroundView.alpha = Action_1.Action.BG_ALPHA_TOUCHING;
            }
        }
    }
    exports.ToggleAction = ToggleAction;
});
define("src/app/relution/view/hud/barLayer/actionBar/ActionBar", ["require", "exports", "src/app/relution/view/hud/barLayer/Bar", "src/app/relution/view/hud/barLayer/actionBar/Action", "src/app/relution/view/hud/barLayer/actionBar/ToggleAction", "src/map/utils/DeviceUtils", "src/engine/general/AABB", "src/engine/math/Vector2"], function (require, exports, Bar_1, Action_2, ToggleAction_1, DeviceUtils_25, AABB_10, Vector2_40) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ActionBar = void 0;
    class ActionBar extends Bar_1.Bar {
        // Initialization
        constructor(environment, world, helpLayer, beaconRangeLayer, beaconConnectionsLayer, deviceTrackLayer, userCountHeatmapLayer) {
            super(environment, world.getScene().getCamera().getScreenWidth(), Action_2.Action.HEIGHT);
            this.actions = new Array();
            this.helpLayer = helpLayer;
            this.beaconRangeLayer = beaconRangeLayer;
            this.beaconConnectionsLayer = beaconConnectionsLayer;
            this.deviceTrackLayer = deviceTrackLayer;
            this.userCountHeatmapLayer = userCountHeatmapLayer;
            this.world = world;
        }
        // @Override
        initialize() {
            super.initialize();
            this.initModel();
            this.initView();
        }
        initModel() {
            this.helpLayer.addVisiblityObserver(this);
            this.beaconRangeLayer.addVisiblityObserver(this);
            this.beaconConnectionsLayer.addVisiblityObserver(this);
            this.deviceTrackLayer.addVisiblityObserver(this);
            this.userCountHeatmapLayer.addVisiblityObserver(this);
        }
        initView() {
            this.createView();
            this.layoutView();
            this.setHorizontalScrollingEnabled(false);
            this.setVerticalScrollingEnabled(false);
        }
        createView() {
            this.initBar();
            this.initBackgroundView();
            this.initActions();
        }
        initBar() {
            // On mobile devices the action bar should not hide
            if (DeviceUtils_25.DeviceUtils.isMobileDevice()) {
                this.setAutoFadeEnabled(false);
            }
            else {
                this.setAutoFadeEnabled(true);
            }
        }
        initBackgroundView() {
            this.backgroundView = this.getEnvironment().renderer.newGraphicsObject();
            this.backgroundView.alpha = 1;
            this.getView().addChild(this.backgroundView);
        }
        initActions() {
            this.helpAction = this.addToggleAction("action_help", "action_bar_show_help_action");
            this.syncToggleActionWithLayerVisibility(this.helpAction, this.helpLayer);
            this.showBeaconRangeAction = this.addToggleAction("action_range", "action_bar_show_beacon_ranges_action");
            this.syncToggleActionWithLayerVisibility(this.showBeaconRangeAction, this.beaconRangeLayer);
            this.showBeaconConnectionsAction = this.addToggleAction("action_connections", "action_bar_show_connections_action");
            this.syncToggleActionWithLayerVisibility(this.showBeaconConnectionsAction, this.beaconConnectionsLayer);
            this.showDeviceTrackAction = this.addToggleAction("action_track", "action_bar_show_device_tracks_action");
            this.syncToggleActionWithLayerVisibility(this.showDeviceTrackAction, this.deviceTrackLayer);
            this.showHeatmapAction = this.addToggleAction("action_heatmap", "action_bar_show_heatmap_action");
            this.syncToggleActionWithLayerVisibility(this.showHeatmapAction, this.userCountHeatmapLayer);
        }
        addToggleAction(resourceName, description) {
            let action = new ToggleAction_1.ToggleAction(this.getEnvironment(), resourceName, description);
            action.addObserver(this);
            this.getContentObject().addChild(action);
            this.actions.push(action);
            let position = this.getNextActionPosition();
            action.getView().x = position.x;
            action.getView().y = position.y;
            this.updateScrollViewDimensions();
            return action;
        }
        getNextActionPosition() {
            let x = ((this.actions.length - 1) * Action_2.Action.WIDTH);
            let y = 0;
            return new Vector2_40.Vector2(x, y);
        }
        updateScrollViewDimensions() {
            let maxX = ((this.actions.length + 1) * Action_2.Action.WIDTH);
            let maxY = Action_2.Action.HEIGHT;
            let aabb = new AABB_10.AABB(new Vector2_40.Vector2(0, 0), new Vector2_40.Vector2(maxX, maxY));
            this.updateContentObjectDimensions(aabb);
        }
        layoutView() {
            this.layoutBackgroundView();
        }
        layoutBackgroundView() {
            let camera = this.world.getScene().getCamera();
            let screenWidth = camera.getScreenWidth();
            this.backgroundView.clear();
            this.backgroundView.beginFill(0x95b507, 0);
            this.backgroundView.lineStyle(1, 0x000000, 0.15);
            this.backgroundView.drawRect(0, 0, screenWidth, Action_2.Action.HEIGHT);
            this.backgroundView.endFill();
        }
        // Event-Handling: User
        // @Override
        onPanningMove(x, y) {
            let handled = super.onPanningMove(x, y);
            if (handled) {
                return true;
            }
        }
        // @Override
        onTap(x, y, numTaps) {
            // Block taps inside the scrollable area.
            if (this.touchPointInsideContainer(x, y)) {
                return true;
            }
            else {
                return false;
            }
        }
        // Event-Handling: Action
        // @Override
        onActionClicked(action) {
            if (action === this.helpAction) {
                this.onHelpActionClicked();
            }
            else if (action === this.showBeaconRangeAction) {
                this.onShowBeaconRangeActionClicked();
            }
            else if (action === this.showBeaconConnectionsAction) {
                this.onShowBeaconConnectionsActionClicked();
            }
            else if (action === this.showDeviceTrackAction) {
                this.onShowDeviceTrackActionClicked();
            }
            else if (action === this.showHeatmapAction) {
                this.onShowHeatmapActionClicked();
            }
        }
        onHelpActionClicked() {
            this.toggleLayerVisibility(this.helpAction, this.helpLayer);
        }
        onShowBeaconRangeActionClicked() {
            this.toggleLayerVisibility(this.showBeaconRangeAction, this.beaconRangeLayer);
        }
        onShowBeaconConnectionsActionClicked() {
            this.toggleLayerVisibility(this.showBeaconConnectionsAction, this.beaconConnectionsLayer);
        }
        onShowDeviceTrackActionClicked() {
            this.toggleLayerVisibility(this.showDeviceTrackAction, this.deviceTrackLayer);
        }
        onShowHeatmapActionClicked() {
            this.toggleLayerVisibility(this.showHeatmapAction, this.userCountHeatmapLayer);
        }
        toggleLayerVisibility(toggleAction, layer) {
            if (toggleAction.isEnabled()) {
                layer.animateVisible(false);
                toggleAction.setEnabled(false);
            }
            else {
                layer.animateVisible(true);
                toggleAction.setEnabled(true);
            }
        }
        // Event-Handling: Layer visibility
        // @Override
        visibilityChanged(layer) {
            if (layer === this.helpLayer) {
                this.syncToggleActionWithLayerVisibility(this.helpAction, layer);
            }
            else if (layer === this.beaconRangeLayer) {
                this.syncToggleActionWithLayerVisibility(this.showBeaconRangeAction, layer);
            }
            else if (layer === this.beaconConnectionsLayer) {
                this.syncToggleActionWithLayerVisibility(this.showBeaconConnectionsAction, layer);
            }
            else if (layer === this.deviceTrackLayer) {
                this.syncToggleActionWithLayerVisibility(this.showDeviceTrackAction, layer);
            }
            else if (layer === this.userCountHeatmapLayer) {
                this.syncToggleActionWithLayerVisibility(this.showHeatmapAction, layer);
            }
        }
        syncToggleActionWithLayerVisibility(toggleAction, layer) {
            if (layer.isVisible()) {
                toggleAction.setEnabled(true);
            }
            else {
                toggleAction.setEnabled(false);
            }
        }
        // Resize - Event handling
        // @Override
        onResize() {
            super.onResize();
            // Relayout scrollable view
            this.setSize(this.world.getScene().getCamera().getScreenWidth(), Action_2.Action.HEIGHT);
            // Relayout action bar views
            this.layoutView();
        }
        // Getters and setters
        getBackgroundView() {
            return this.backgroundView;
        }
    }
    exports.ActionBar = ActionBar;
});
define("src/app/relution/view/hud/barLayer/deviceBar/DeviceItem", ["require", "exports", "src/engine/animation/Animation", "src/engine/animation/EaseOut", "src/engine/animation/LinearInterpolator", "src/engine/scene/SceneObject", "src/map/utils/DeviceUtils"], function (require, exports, Animation_11, EaseOut_3, LinearInterpolator_11, SceneObject_13, DeviceUtils_26) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeviceItem = void 0;
    class DeviceItem extends SceneObject_13.SceneObject {
        // Initialization
        constructor(environment, device) {
            super(environment);
            // View: Size
            this.itemWidth = 0;
            this.itemHeight = 0;
            this.pivotX = 0;
            this.pivotY = 0;
            this.initView(device);
        }
        initView(device) {
            this.device = device;
            this.createSerialNumberView();
            this.initDimensions();
            this.initContainer();
            this.initDeviceView(device);
            this.initSerialNumberView();
            this.initResetAnimation();
        }
        createSerialNumberView() {
            let serialNumber = this.device.getModel().deviceId === undefined ? this.device.getModel().name : this.device.getModel().deviceId;
            let textStyle = this.getEnvironment().renderer.newTextStyle();
            textStyle.fontFamily = "Arial";
            textStyle.fontSize = DeviceUtils_26.DeviceUtils.getPhysicalPixelsFromLogical(12);
            textStyle.fill = 0x374203;
            textStyle.align = "center";
            this.serialNumberView = this.getEnvironment().renderer.newTextObject("" + serialNumber, 1, textStyle);
        }
        initDimensions() {
            // this.itemWidth = DeviceUtils.getPhysicalPixelsFromLogical(64);
            let horizontalPadding = DeviceUtils_26.DeviceUtils.getPhysicalPixelsFromLogical(5);
            this.itemWidth = this.serialNumberView.width + horizontalPadding * 2;
            this.itemHeight = DeviceItem.ITEM_HEIGHT;
            this.pivotX = this.getItemWidth() / 2;
            this.pivotY = this.getItemHeight() * (1.0 / 3);
        }
        initContainer() {
            this.container = this.getEnvironment().renderer.newDisplayObjectContainer();
            // Pivot
            this.container.pivot.x = this.pivotX;
            this.container.pivot.y = this.pivotY;
        }
        initDeviceView(device) {
            this.addChild(device);
            // Scale
            this.device.getView().width = DeviceItem.TARGET_DEVICE_HEIGHT_IN_PX * (this.device.getTextureWidth() / this.device.getTextureHeight());
            this.device.getView().height = DeviceItem.TARGET_DEVICE_HEIGHT_IN_PX;
            // Position
            this.device.getView().x = this.pivotX;
            this.device.getView().y = this.pivotY;
        }
        initSerialNumberView() {
            // Pivot
            this.serialNumberView.pivot.x = this.serialNumberView.width / 2;
            this.serialNumberView.pivot.y = this.serialNumberView.height / 2;
            // Position
            this.serialNumberView.x = this.pivotX;
            let deviceBottomY = (this.device.getView().y + DeviceItem.TARGET_DEVICE_HEIGHT_IN_PX / 2);
            this.serialNumberView.y = deviceBottomY + ((this.getItemHeight() - deviceBottomY) / 2);
            this.container.addChild(this.serialNumberView);
        }
        initResetAnimation() {
            let interpolator = new EaseOut_3.EaseOut(new LinearInterpolator_11.LinearInterpolator());
            this.resetXAnimation = new Animation_11.Animation(interpolator);
            this.resetYAnimation = new Animation_11.Animation(interpolator);
        }
        startResetAnimation() {
            let startXValue = this.getView().x;
            let startYValue = this.getView().y;
            let endPosition = this.getTargetPosition();
            let endXValue = endPosition.x;
            let endYValue = endPosition.y;
            let durationInMs = 500;
            let delayInMs = 0;
            this.resetXAnimation.start(startXValue, endXValue, durationInMs, delayInMs);
            this.resetYAnimation.start(startYValue, endYValue, durationInMs, delayInMs);
        }
        stopResetAnimation() {
            this.resetXAnimation.stop();
            this.resetYAnimation.stop();
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.resetXAnimation.isCurrentlyAnimating()) {
                let currentX = this.resetXAnimation.getValue(lastFrametime);
                let currentY = this.resetYAnimation.getValue(lastFrametime);
                this.getView().x = currentX;
                this.getView().y = currentY;
            }
        }
        // View
        resetPosition() {
            let targetPosition = this.getTargetPosition();
            this.getView().x = targetPosition.x;
            this.getView().y = targetPosition.y;
        }
        setTargetPosition(position) {
            this.targetPosition = position;
        }
        getTargetPosition() {
            return this.targetPosition;
        }
        // @Override
        getView() {
            return this.container;
        }
        // Getters and setters
        getDevice() {
            return this.device;
        }
        // Getters and setters
        getItemWidth() {
            return this.itemWidth;
        }
        getItemHeight() {
            return this.itemHeight;
        }
        getPivotX() {
            return this.pivotX;
        }
        getPivotY() {
            return this.pivotY;
        }
    }
    exports.DeviceItem = DeviceItem;
    DeviceItem.ITEM_HEIGHT = DeviceUtils_26.DeviceUtils.getPhysicalPixelsFromLogical(42);
    DeviceItem.TARGET_DEVICE_HEIGHT_IN_PX = DeviceUtils_26.DeviceUtils.getPhysicalPixelsFromLogical(15);
});
define("src/app/relution/view/hud/barLayer/deviceBar/DeviceBar", ["require", "exports", "src/app/relution/view/hud/barLayer/Bar", "src/app/relution/view/hud/barLayer/deviceBar/DeviceItem", "src/engine/general/AABB", "src/engine/math/Vector2"], function (require, exports, Bar_2, DeviceItem_1, AABB_11, Vector2_41) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeviceBar = void 0;
    class DeviceBar extends Bar_2.Bar {
        // Initialization
        constructor(environment, world, building) {
            super(environment, world.getScene().getCamera().getScreenWidth(), DeviceItem_1.DeviceItem.ITEM_HEIGHT);
            // Observation
            this.observers = new Array();
            this.deviceItems = new Array();
            // View: Moving
            this.userMovesDevice = false;
            this.initModel(world, building);
            this.initView();
        }
        initModel(world, building) {
            this.world = world;
            this.building = building;
            this.building.addFloorObserver(this);
            this.registerAsObserver(this.building.getCurrentFloor());
        }
        registerAsObserver(currentFloor) {
            let deviceLayer = currentFloor.getDeviceLayer();
            deviceLayer.addObserver(this);
        }
        unregisterAsObserver(leftFloor) {
            let deviceLayer = leftFloor.getDeviceLayer();
            deviceLayer.removeObserver(this);
        }
        initView() {
            this.createView();
            this.layoutView();
        }
        createView() {
            this.initBar();
            this.initBackgroundView();
        }
        initBar() {
            this.setAutoFadeEnabled(false);
        }
        initBackgroundView() {
            this.backgroundView = this.getEnvironment().renderer.newGraphicsObject();
            this.backgroundView.alpha = 0.25;
            this.getView().addChild(this.backgroundView);
        }
        layoutView() {
            this.layoutScrollableContainer();
            this.layoutBackgroundView();
        }
        layoutScrollableContainer() {
            let camera = this.world.getScene().getCamera();
            // Position
            this.getView().x = 0;
            this.getView().y = camera.getScreenHeight() - DeviceItem_1.DeviceItem.ITEM_HEIGHT;
        }
        layoutBackgroundView() {
            let camera = this.world.getScene().getCamera();
            let screenWidth = camera.getScreenWidth();
            this.backgroundView.clear();
            this.backgroundView.beginFill(0x95b507);
            this.backgroundView.drawRect(0, 0, screenWidth, DeviceItem_1.DeviceItem.ITEM_HEIGHT);
            this.backgroundView.endFill();
        }
        // Scene initialization
        // @Override
        initialize() {
            super.initialize();
            // Set bar to bottom
            let worldCamera = this.getScene().getCamera();
            let screenHeight = worldCamera.getScreenHeight();
            this.getView().y = screenHeight - this.getView().height;
        }
        // Observation
        addObserver(observer) {
            this.observers.push(observer);
        }
        /**
         * @param {DeviceBar.Observer} observer
         * @returns
         * @memberof DeviceBar
         */
        removeObserver(observer) {
            if (!observer || !this.observers || !this.observers.length) {
                return false;
            }
            let index = this.observers.indexOf(observer);
            if (index !== -1) {
                this.observers.splice(index, 1);
            }
        }
        notifyObservers(callback, args) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Floor Event handling
        // @Override
        floorChanged(floorBefore, floorAfter) {
            this.unregisterAsObserver(floorBefore);
            this.registerAsObserver(floorAfter);
        }
        // DeviceLayer Event-Handling
        // @Override
        onObjectsLoaded(devices) {
            this.resetItemPositions(false);
        }
        // @Override
        onObjectsUnloaded(devices) {
            this.removeDeviceItemsForDevices(devices);
            this.resetItemPositions(false);
        }
        removeDeviceItemsForDevices(devices) {
            for (let i = 0; i < devices.length; i++) {
                let device = devices[i];
                let deviceItem = this.getDeviceItemForDevice(device);
                if (deviceItem != null) {
                    this.removeDeviceItem(deviceItem);
                }
            }
        }
        // @Override
        onObjectSetToStock(device) {
            this.addDeviceItemAndResetPosition(device, false);
        }
        // @Override
        onObjectMovedToStock(device) {
            this.addDeviceItemAndResetPosition(device, true);
        }
        addDeviceItemAndResetPosition(device, animate) {
            let deviceItem = this.addDeviceItem(device);
            this.resetDeviceItemPosition(deviceItem, animate);
            return deviceItem;
        }
        addDeviceItem(device) {
            this.initDeviceForBar(device);
            let deviceItem = this.createDeviceItem(device);
            this.reassignMovingDeviceItem(deviceItem);
            return deviceItem;
        }
        initDeviceForBar(device) {
            device.setFreezed(true);
        }
        createDeviceItem(device) {
            // Save device world position
            let deviceWorldPosition = new Vector2_41.Vector2(device.getView().x, device.getView().y);
            // Create device item
            let deviceItem = new DeviceItem_1.DeviceItem(this.getEnvironment(), device);
            this.getContentObject().addChild(deviceItem);
            this.deviceItems.push(deviceItem);
            this.updateScrollViewDimensions();
            // Set current position
            this.setInitialDeviceItemPositionToDeviceWorldPosition(deviceItem, deviceWorldPosition);
            // Set target position
            let itemIndex = this.deviceItems.length - 1;
            let itemPosition = this.getCurrentDeviceItemPositionForItemWithIndex(itemIndex);
            deviceItem.setTargetPosition(itemPosition);
            return deviceItem;
        }
        updateScrollViewDimensions() {
            let maxX = this.getMaxXDeviceItemPosition();
            let maxY = DeviceItem_1.DeviceItem.ITEM_HEIGHT;
            let aabb = new AABB_11.AABB(new Vector2_41.Vector2(0, 0), new Vector2_41.Vector2(maxX, maxY));
            this.updateContentObjectDimensions(aabb);
        }
        getMaxXDeviceItemPosition() {
            return this.getStartXPositionForDeviceItemIndex(this.deviceItems.length);
        }
        getStartXPositionForDeviceItemIndex(itemIndex) {
            let startX = 0.0;
            for (let i = 0; i < itemIndex; i++) {
                let deviceItem = this.deviceItems[i];
                startX += deviceItem.getItemWidth();
            }
            return startX;
        }
        setInitialDeviceItemPositionToDeviceWorldPosition(deviceItem, deviceWorldPosition) {
            // Set the devices position in the bar as if it was still in the world.
            let worldCamera = this.world.getScene().getCamera();
            let deviceWorldPositionInImageCoordinates = worldCamera.getImageCoordinateFromWorldPoint(deviceWorldPosition);
            let deviceLocalPosition = this.getContentObject().getView().toLocal(this.getEnvironment().renderer.newPointFromVector2(deviceWorldPositionInImageCoordinates));
            deviceItem.getView().x = deviceLocalPosition.x;
            deviceItem.getView().y = deviceLocalPosition.y;
        }
        resetDeviceItemPosition(deviceItem, animate) {
            if (animate) {
                // Do not play reset animation, if user moves the device
                if (this.movingDeviceItem == null || (this.movingDeviceItem.getDevice() !== deviceItem.getDevice())) {
                    deviceItem.startResetAnimation();
                }
            }
            else {
                deviceItem.resetPosition();
            }
        }
        reassignMovingDeviceItem(deviceItem) {
            // Change the moving device item, if the device was moved to the bar again
            if (this.movingDeviceItem != null && this.movingDeviceItem.getDevice() === deviceItem.getDevice()) {
                this.movingDeviceItem = deviceItem;
            }
        }
        getCurrentDeviceItemPositionForItemWithIndex(index) {
            let deviceItem = this.deviceItems[index];
            let startX = this.getStartXPositionForDeviceItemIndex(index);
            let x = startX + deviceItem.getPivotX();
            let y = deviceItem.getPivotY();
            return new Vector2_41.Vector2(x, y);
        }
        // @Override
        onObjectSetToMap(device) {
            this.onObjectMovedToMap(device);
        }
        // @Override
        onObjectMovedToMap(device) {
            let deviceItem = this.getDeviceItemForDevice(device);
            if (deviceItem != null) {
                this.removeDeviceItem(deviceItem);
                this.resetItemPositions();
                // Disable freezing the device
                device.setFreezed(false);
            }
        }
        getDeviceItemForDevice(device) {
            for (let i = 0; i < this.deviceItems.length; i++) {
                let deviceItem = this.deviceItems[i];
                if (deviceItem.getDevice() === device) {
                    return deviceItem;
                }
            }
            return null;
        }
        removeDeviceItem(deviceItem) {
            let index = this.deviceItems.indexOf(deviceItem);
            this.deviceItems.splice(index, 1);
            this.getContentObject().removeChild(deviceItem);
            this.updateScrollViewDimensions();
        }
        // @Override
        onObjectMoveStarted(device, x, y) {
            // We move the device to the stock and instantly to the map again.
            // Observers in the device layer should not notice any change, so we
            // unregister them during this process.
            let deviceLayerObservers = this.unregisterRemainingObserversFromDeviceLayer();
            let devicePosition = new Vector2_41.Vector2(device.getView().x, device.getView().y);
            // 1. Move device instantly to stock
            this.building.getCurrentFloor().getDeviceLayer().moveObjectToStock(device);
            let deviceItem = this.getDeviceItemForDevice(device);
            deviceItem.stopResetAnimation();
            deviceItem.resetPosition();
            // 2. Move device to world and change its position back to (x,y)
            this.notifyObservers("onDeviceEnteredWorld", []);
            this.movingPointInDeviceLocalTx = this.getMovingPointInDeviceLocalTexels(devicePosition.x, devicePosition.y, x, y);
            this.moveDeviceToMap(x, y, deviceItem);
            this.resetItemPositions();
            this.setDevicePositionInMap(deviceItem.getDevice(), x, y);
            // 3. Simulate panning start
            this.userMovesDevice = true;
            this.movingDeviceItem = deviceItem;
            this.registerRemainingObserversFromDeviceLayer(deviceLayerObservers);
        }
        unregisterRemainingObserversFromDeviceLayer() {
            let observers = this.building.getCurrentFloor().getDeviceLayer().getObservers();
            let observersCopy = observers.slice();
            let unregisteredObservers = [];
            for (let i = 0; i < observersCopy.length; i++) {
                let observer = observersCopy[i];
                if (observer !== this && observer !== this.building.getCurrentFloor().getDeviceLayer()) {
                    this.building.getCurrentFloor().getDeviceLayer().removeObserver(observer);
                    unregisteredObservers.push(observer);
                }
            }
            return unregisteredObservers;
        }
        registerRemainingObserversFromDeviceLayer(deviceLayerObservers) {
            for (let i = 0; i < deviceLayerObservers.length; i++) {
                let observer = deviceLayerObservers[i];
                if (observer !== this) {
                    this.building.getCurrentFloor().getDeviceLayer().addObserver(observer);
                }
            }
        }
        // @Override
        onObjectMoveChanged(device, x, y) {
            this.onPanningMove(x, y);
        }
        // @Override
        onObjectMoveStopped(device, x, y) {
            this.onPanningEnd(x, y);
        }
        // Input Event-Handling
        // @Override: Device items define a non-scrollable area.
        isInScrollableArea(x, y) {
            let touchingDeviceItem = this.getTouchingDeviceItem(x, y);
            return touchingDeviceItem == null;
        }
        // @Override
        onPanningStart(x, y) {
            let handled = super.onPanningStart(x, y);
            if (handled) {
                return true;
            }
            let touchingDeviceItem = this.getTouchingDeviceItem(x, y);
            if (touchingDeviceItem != null) {
                this.userMovesDevice = true;
                this.movingDeviceItem = touchingDeviceItem;
                let floorplanLayer = this.building.getCurrentFloor().getFloorplanLayer();
                let device = this.movingDeviceItem.getDevice();
                if (device.getScene() === this.world.getScene()) {
                    this.movingPointInDeviceLocalTx = this.getMovingPointInDeviceLocalTexels(device.getView().x, device.getView().y, x, y);
                }
                else {
                    this.movingPointInDeviceLocalTx = new Vector2_41.Vector2();
                }
                return true;
            }
            else {
                return false;
            }
        }
        getTouchingDeviceItem(touchX, touchY) {
            for (let i = 0; i < this.deviceItems.length; i++) {
                let deviceItem = this.deviceItems[i];
                let device = deviceItem.getDevice();
                if (this.isPointInsideDevice(touchX, touchY, device, deviceItem)) {
                    return deviceItem;
                }
            }
            return null;
        }
        isPointInsideDevice(xInImage, yInImage, device, deviceItem) {
            let point = this.getEnvironment().renderer.newPoint();
            let deviceGlobalPos = device.getView().toGlobal(point, point);
            let deviceCenterX = deviceGlobalPos.x + device.getView().width / 2;
            let deviceCenterY = deviceGlobalPos.y + device.getView().height / 2;
            let collisionMinX = deviceCenterX - deviceItem.getItemWidth() / 2;
            let collisionMaxX = deviceCenterX + deviceItem.getItemWidth() / 2;
            let collisionMinY = deviceCenterY - deviceItem.getItemHeight() / 2;
            // To lower part of the bar should not trigger device movement to be able to scroll the bar!
            let collisionMaxY = deviceCenterY;
            return xInImage >= collisionMinX && xInImage <= collisionMaxX &&
                yInImage >= collisionMinY && yInImage <= collisionMaxY;
        }
        /**
         * Returns the difference vector of the device's anchor point and the mouse in world coordinates.
         * This is equal to the touch point on the device in the device's local coordinate system.
         */
        getMovingPointInDeviceLocalTexels(deviceXInTexels, deviceYInTexels, mouseXInScreen, mouseYInScreen) {
            let floorplanLayer = this.building.getCurrentFloor().getFloorplanLayer();
            let mouseInTx = floorplanLayer.getTexelsFromScreenPixels(new Vector2_41.Vector2(mouseXInScreen, mouseYInScreen));
            let movingPointInDeviceLocalTx = new Vector2_41.Vector2(mouseInTx.x - deviceXInTexels, mouseInTx.y - deviceYInTexels);
            return movingPointInDeviceLocalTx;
        }
        // @Override
        onTouchStart(x, y, touchIndex) {
            let handled = super.onTouchStart(x, y, touchIndex);
            if (!handled) {
                // Block touch events inside the bar
                if (this.isPanning() || this.userMovesDevice) {
                    this.onPanningStart(x, y);
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return handled;
            }
        }
        // @Override
        onTouchMove(x, y, touchIndex) {
            let handled = super.onTouchMove(x, y, touchIndex);
            if (!handled) {
                // Block touch events inside the bar
                if (this.isPanning() || this.userMovesDevice) {
                    this.onPanningMove(x, y);
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return handled;
            }
        }
        // @Override
        onTouchEnd(x, y, touchIndex) {
            let handled = super.onTouchEnd(x, y, touchIndex);
            if (!handled) {
                // Block touch events inside the bar
                if (this.isPanning() || this.userMovesDevice) {
                    this.onPanningEnd(x, y);
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return handled;
            }
        }
        // @Override
        onPanningMove(x, y) {
            let handled = super.onPanningMove(x, y);
            if (handled) {
                return true;
            }
            if (this.userMovesDevice) {
                if (this.movingDeviceItem.getDevice().getScene()) {
                    if (this.touchPointInsideBar(x, y)) {
                        // If device was in world before, move it to the bar's scene.
                        if (this.deviceIsInWorld(this.movingDeviceItem.getDevice())) {
                            this.notifyObservers("onDeviceLeftWorld", []);
                            this.moveDeviceToStock(x, y, this.movingDeviceItem);
                        }
                        this.setDeviceItemPositionInBar(this.movingDeviceItem, x, y);
                        this.repositionItemsIfNecessary();
                    }
                    else {
                        // If device was in bar before, move it to the world scene.
                        if (this.deviceIsInBar(this.movingDeviceItem.getDevice())) {
                            this.notifyObservers("onDeviceEnteredWorld", []);
                            this.moveDeviceToMap(x, y, this.movingDeviceItem);
                            this.resetItemPositions();
                        }
                        this.setDevicePositionInMap(this.movingDeviceItem.getDevice(), x, y);
                    }
                }
                return true;
            }
            else {
                return false;
            }
        }
        touchPointInsideBar(x, y) {
            return this.touchPointInsideContainer(x, y);
        }
        deviceIsInWorld(device) {
            return device.getScene() === this.world.getScene();
        }
        moveDeviceToStock(x, y, deviceItem) {
            // Add device to stock
            let device = deviceItem.getDevice();
            this.building.getCurrentFloor().getDeviceLayer().moveObjectToStock(device);
            device.setPivotCentered(true);
            this.setDeviceItemPositionInBar(deviceItem, x, y);
        }
        setDeviceItemPositionInBar(deviceItem, imageX, imageY) {
            let pointInBar = this.getContentObject().getView().toLocal(this.getEnvironment().renderer.newPoint(imageX, imageY));
            deviceItem.getView().x = pointInBar.x;
            deviceItem.getView().y = pointInBar.y;
        }
        repositionItemsIfNecessary() {
            // 1. Remove moving device item from list
            let index = this.deviceItems.indexOf(this.movingDeviceItem);
            if (index > -1) {
                this.deviceItems.splice(index, 1);
            }
            // 2. Reorder device item list
            let itemInserted = false;
            let movingItemX = this.movingDeviceItem.getView().x;
            for (let i = 0; i < this.deviceItems.length; i++) {
                let deviceItem = this.deviceItems[i];
                let currentItemX = deviceItem.getView().x;
                if (currentItemX > movingItemX) {
                    // Insert device to this index.
                    this.deviceItems.splice(i, 0, this.movingDeviceItem);
                    itemInserted = true;
                    break;
                }
            }
            // If item was not inserted, it must be the last element in the list
            if (!itemInserted) {
                this.deviceItems.push(this.movingDeviceItem);
            }
            // 3. Reposition the items
            this.resetItemPositions();
        }
        resetItemPositions(animate = true) {
            for (let i = 0; i < this.deviceItems.length; i++) {
                let deviceItem = this.deviceItems[i];
                let position = this.getCurrentDeviceItemPositionForItemWithIndex(i);
                deviceItem.setTargetPosition(position);
                // We do not want to reset the position of the moving device item,
                // because the user wants to move it.
                if (this.movingDeviceItem !== deviceItem) {
                    if (animate) {
                        deviceItem.startResetAnimation();
                    }
                    else {
                        deviceItem.resetPosition();
                    }
                }
            }
        }
        deviceIsInBar(device) {
            return !this.deviceIsInWorld(device);
        }
        moveDeviceToMap(imageX, imageY, deviceItem) {
            let device = deviceItem.getDevice();
            this.building.getCurrentFloor().getDeviceLayer().moveObjectToMap(device);
            device.setPivotCentered(false);
            this.setDevicePositionInMap(device, imageX, imageY);
        }
        setDevicePositionInMap(device, imageX, imageY) {
            let worldCamera = this.world.getScene().getCamera();
            let mouseInScreenPx = new Vector2_41.Vector2(imageX, imageY);
            let mouseInTx = worldCamera.getWorldCoordinateFromImagePoint(mouseInScreenPx);
            device.getView().x = mouseInTx.x - this.movingPointInDeviceLocalTx.x;
            device.getView().y = mouseInTx.y - this.movingPointInDeviceLocalTx.y;
            device.updateModelPositionFromViewPosition();
            this.notifyObservers("onUserMovedDevice", [device]);
        }
        // @Override
        onPanningEnd(x, y) {
            let handled = super.onPanningEnd(x, y);
            if (handled) {
                return true;
            }
            if (this.userMovesDevice) {
                if (this.movingDeviceItem.getDevice().getScene()) {
                    if (this.touchPointInsideBar(x, y)) {
                        this.movingDeviceItem.startResetAnimation();
                    }
                    else {
                        // If device was in bar before, move it to the world scene.
                        if (this.deviceIsInBar(this.movingDeviceItem.getDevice())) {
                            this.moveDeviceToMap(x, y, this.movingDeviceItem);
                        }
                        this.setDevicePositionInMap(this.movingDeviceItem.getDevice(), x, y);
                        // Finally we need to ensure, that the device is not outside the world.
                        this.movingDeviceItem.getDevice().updateModelPositionFromViewPositionAndConsiderWorldConstraints();
                    }
                }
                this.userMovesDevice = false;
                this.notifyObservers("onObjectMoveStopped", []);
                this.movingDeviceItem = null;
                this.movingPointInDeviceLocalTx = null;
                return true;
            }
            else {
                return false;
            }
        }
        // Resize - Event handling
        // @Override
        onResize() {
            super.onResize();
            // Relayout scrollable view
            this.setSize(this.world.getScene().getCamera().getScreenWidth(), DeviceItem_1.DeviceItem.ITEM_HEIGHT);
            // Relayout action bar views
            this.layoutView();
        }
    }
    exports.DeviceBar = DeviceBar;
});
define("src/app/relution/view/hud/barLayer/BarLayer", ["require", "exports", "src/map/view/Layer", "src/app/relution/view/hud/barLayer/deviceBar/DeviceBar"], function (require, exports, Layer_17, DeviceBar_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BarLayer = void 0;
    class BarLayer extends Layer_17.Layer {
        // Initialilzation
        constructor(environment, world, building) {
            super(environment);
            this.initView(world, building);
        }
        initView(world, building) {
            // this.actionBar = new ActionBar(helpLayer, world);
            // this.addChild(this.actionBar);
            this.deviceBar = new DeviceBar_1.DeviceBar(this.getEnvironment(), world, building);
        }
        // Enabling beacon bar
        makeBeaconBarVisible(enabled) {
            let deviceBar = this.deviceBar;
            if (enabled) {
                if (!this.hasChild(deviceBar)) {
                    this.addChild(deviceBar);
                }
            }
            else {
                if (this.hasChild(deviceBar)) {
                    this.removeChild(deviceBar);
                }
            }
        }
        isBeaconBarVisible() {
            return this.hasChild(this.deviceBar);
        }
        // Getters and setters
        getActionBar() {
            return this.actionBar;
        }
        getDeviceBar() {
            return this.deviceBar;
        }
    }
    exports.BarLayer = BarLayer;
});
define("src/app/relution/view/hud/tapeMeasure/TapeMeasureHudLayer", ["require", "exports", "src/map/view/Layer"], function (require, exports, Layer_18) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TapeMeasureHudLayer = void 0;
    /**
     * The Head-up-display layer part of the tape measure.
     *
     * <p>
     * This layer extends the [[TapeMeasureWorldLayer]] in the HUD scene by
     * preventing touch and pan events to be absorbed by the succeeding HUD layers
     * so that moving the edit points of the tape measure world layer is possible.
     * </p>
     */
    class TapeMeasureHudLayer extends Layer_18.Layer {
        // Construction
        constructor(environment, building) {
            super(environment);
            // Configuration
            this.enabled = false;
            // State
            this.touching = false;
            this.building = building;
        }
        // Event delegation: Low level events
        // @Override
        onTouchStart(x, y, touchIndex) {
            if (this.enabled) {
                if (this.shouldDragTapeMeasureEditPoints(x, y)) {
                    this.touching = true;
                    // Delegate this event to the corresponding world layer
                    this.building.getCurrentFloor().getTapeMeasureLayer().onTouchStart(x, y, touchIndex);
                    return true;
                }
            }
            return false;
        }
        // @Override
        onTouchMove(x, y, touchIndex) {
            if (this.enabled) {
                if (this.touching) {
                    // Delegate this event to the corresponding world layer
                    this.building.getCurrentFloor().getTapeMeasureLayer().onTouchMove(x, y, touchIndex);
                    return true;
                }
            }
            return false;
        }
        // @Override
        onTouchEnd(x, y, touchIndex) {
            if (this.enabled) {
                if (this.touching) {
                    this.touching = false;
                    // Delegate this event to the corresponding world layer
                    this.building.getCurrentFloor().getTapeMeasureLayer().onTouchEnd(x, y, touchIndex);
                    return true;
                }
            }
            return false;
        }
        // Event delegation: High level events
        // @Override
        onPanningStart(x, y) {
            if (this.enabled) {
                if (this.shouldDragTapeMeasureEditPoints(x, y)) {
                    this.touching = true;
                    return true;
                }
            }
            return false;
        }
        // @Override
        onPanningMove(x, y) {
            if (this.enabled) {
                if (this.touching) {
                    return true;
                }
            }
            return false;
        }
        // @Override
        onPanningEnd(x, y) {
            if (this.enabled) {
                if (this.touching) {
                    this.touching = false;
                    return true;
                }
            }
            return false;
        }
        // Helper methods
        shouldDragTapeMeasureEditPoints(x, y) {
            if (this.enabled) {
                const tapeMeasureWorldLayer = this.building.getCurrentFloor().getTapeMeasureLayer();
                return tapeMeasureWorldLayer.pointIsCloseToEditableArea(x, y);
            }
            return false;
        }
        // Getters and setters
        setEnabled(enabled) {
            this.enabled = enabled;
        }
        isEnabled() {
            return this.enabled;
        }
    }
    exports.TapeMeasureHudLayer = TapeMeasureHudLayer;
});
define("src/app/relution/view/hud/debugLayer/DebugLayer", ["require", "exports", "src/map/view/Layer", "src/map/utils/DeviceUtils"], function (require, exports, Layer_19, DeviceUtils_27) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DebugLayer = void 0;
    class DebugLayer extends Layer_19.Layer {
        // Initialization
        constructor(environment) {
            super(environment);
        }
        // @Override
        initialize() {
            super.initialize();
            this.initView();
        }
        initView() {
            this.createView();
            this.layoutView();
            this.setVisible(true);
        }
        createView() {
            let textStyle = this.getEnvironment().renderer.newTextStyle();
            textStyle.fontSize = DeviceUtils_27.DeviceUtils.getPhysicalPixelsFromLogical(14);
            this.textView = this.getEnvironment().renderer.newTextObject("", 1, textStyle);
            this.getView().addChild(this.textView);
        }
        layoutView() {
            this.textView.x = DebugLayer.PADDING_X_PX;
            this.textView.y = DebugLayer.PADDING_Y_PX;
        }
        // Text
        setDebugText(debugText) {
            this.textView.text = debugText;
        }
    }
    exports.DebugLayer = DebugLayer;
    // View: Constants
    DebugLayer.PADDING_X_PX = 20;
    DebugLayer.PADDING_Y_PX = 0;
});
define("src/app/relution/view/hud/RelutionMapHud", ["require", "exports", "src/app/relution/view/hud/selectionLayer/SelectionLayer", "src/map/view/hud/layers/navigationLayer/NavigationLayer", "src/map/view/hud/layers/controlLayer/ControlLayer", "src/app/relution/view/hud/barLayer/BarLayer", "src/app/relution/view/hud/helpLayer/HelpLayer", "src/map/view/Layer", "src/app/relution/view/hud/popupLayer/PopupLayer", "src/app/relution/view/hud/tapeMeasure/TapeMeasureHudLayer", "src/app/relution/view/hud/debugLayer/DebugLayer"], function (require, exports, SelectionLayer_1, NavigationLayer_1, ControlLayer_1, BarLayer_1, HelpLayer_1, Layer_20, PopupLayer_1, TapeMeasureHudLayer_1, DebugLayer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RelutionMapHud = void 0;
    class RelutionMapHud extends Layer_20.Layer {
        // Construction
        constructor(config, environment, relutionMapWorld) {
            super(environment);
            this.hudConfig = config;
            this.selectionLayer = new SelectionLayer_1.SelectionLayer(this.hudConfig.selectionLayer, environment, relutionMapWorld.getBuilding());
            this.navigationLayer = new NavigationLayer_1.NavigationLayer(this.hudConfig.navigationLayer, environment, relutionMapWorld.getCamera());
            this.popupLayer = new PopupLayer_1.PopupLayer(this.hudConfig.popupLayer, environment, relutionMapWorld.getBuilding());
            this.tapeMeasureHudLayer = new TapeMeasureHudLayer_1.TapeMeasureHudLayer(environment, relutionMapWorld.getBuilding());
            this.controlLayer = new ControlLayer_1.ControlLayer(this.hudConfig.controlLayer, environment, relutionMapWorld.getCamera());
            this.helpLayer = new HelpLayer_1.HelpLayer(environment);
            this.barLayer = new BarLayer_1.BarLayer(environment, relutionMapWorld.getWorld(), relutionMapWorld.getBuilding());
            this.debugLayer = new DebugLayer_1.DebugLayer(environment);
            this.addLayer(this.selectionLayer);
            this.addLayer(this.navigationLayer);
            this.addLayer(this.popupLayer);
            this.addLayer(this.tapeMeasureHudLayer);
            this.addLayer(this.controlLayer);
            this.addLayer(this.barLayer);
            this.addLayer(this.helpLayer);
            this.addLayer(this.debugLayer);
        }
        getLayerByName(layerName) {
            switch (layerName) {
                case 'selection':
                    return this.selectionLayer;
                case 'navigation':
                    return this.navigationLayer;
                case 'popup':
                    return this.popupLayer;
                case 'tapeMeasureHud':
                    return this.tapeMeasureHudLayer;
                case 'control':
                    return this.controlLayer;
                case 'bar':
                    return this.barLayer;
                case 'help':
                    return this.helpLayer;
                case 'debug':
                    return this.debugLayer;
            }
            return null;
        }
        // Getters
        getSelectionLayer() {
            return this.selectionLayer;
        }
        getNavigationLayer() {
            return this.navigationLayer;
        }
        getPopupLayer() {
            return this.popupLayer;
        }
        getTapeMeasureHudLayer() {
            return this.tapeMeasureHudLayer;
        }
        getControlLayer() {
            return this.controlLayer;
        }
        getBarLayer() {
            return this.barLayer;
        }
        getHelpLayer() {
            return this.helpLayer;
        }
        getDebugLayer() {
            return this.debugLayer;
        }
    }
    exports.RelutionMapHud = RelutionMapHud;
    (function (RelutionMapHud) {
        class Config {
            constructor() {
                this.selectionLayer = new SelectionLayer_1.SelectionLayer.Config();
                this.navigationLayer = new NavigationLayer_1.NavigationLayer.Config();
                this.popupLayer = new PopupLayer_1.PopupLayer.Config();
                this.controlLayer = new ControlLayer_1.ControlLayer.Config();
            }
        }
        RelutionMapHud.Config = Config;
    })(RelutionMapHud = exports.RelutionMapHud || (exports.RelutionMapHud = {}));
});
define("src/app/relution/modes/RelutionMapMode", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RelutionMapMode = void 0;
    class RelutionMapMode {
        // Construction
        constructor(relutionMapWorld, relutionMapHud) {
            // Configuration
            this.enabled = false;
            this.relutionMapWorld = relutionMapWorld;
            this.relutionMapHud = relutionMapHud;
        }
        // Getters and setters
        setEnabled(enabled) {
            if (enabled !== this.enabled) {
                this.enabled = enabled;
                if (enabled) {
                    this.enable();
                }
                else {
                    this.disable();
                }
            }
        }
        isEnabled() {
            return this.enabled;
        }
    }
    exports.RelutionMapMode = RelutionMapMode;
});
define("src/app/relution/modes/DeviceEditMode", ["require", "exports", "src/app/relution/modes/RelutionMapMode"], function (require, exports, RelutionMapMode_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeviceEditMode = void 0;
    class DeviceEditMode extends RelutionMapMode_1.RelutionMapMode {
        // Construction
        constructor(relutionMapWorld, relutionMapHud) {
            super(relutionMapWorld, relutionMapHud);
        }
        // Enable/disable mode
        // @Override
        enable() {
            this.setModeEnabled(true);
        }
        // @Override
        disable() {
            this.setModeEnabled(false);
        }
        // Helper methods
        setModeEnabled(enabled) {
            this.setModeEnabledInWorld(enabled);
            this.setModeEnabledInHud(enabled);
        }
        setModeEnabledInWorld(enabled) {
            this.relutionMapWorld.getBuilding().setDeviceEditingEnabled(enabled);
        }
        setModeEnabledInHud(enabled) {
            this.relutionMapHud.selectionLayer.setDeleteSelectedBeaconsAllowed(enabled);
            this.relutionMapHud.barLayer.makeBeaconBarVisible(enabled);
        }
    }
    exports.DeviceEditMode = DeviceEditMode;
});
define("src/app/relution/modes/GeofenceEditMode", ["require", "exports", "src/app/relution/modes/RelutionMapMode"], function (require, exports, RelutionMapMode_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GeofenceEditMode = void 0;
    class GeofenceEditMode extends RelutionMapMode_2.RelutionMapMode {
        // Construction
        constructor(relutionMapWorld, relutionMapHud) {
            super(relutionMapWorld, relutionMapHud);
        }
        // Enabling/Disabling mode
        // @Override
        enable() {
            this.setModeEnabled(true);
        }
        // @Override
        disable() {
            this.setModeEnabled(false);
        }
        setModeEnabled(enabled) {
            if (enabled) {
                this.relutionMapWorld.getBuilding().toggleLayerVisibility("geofence", enabled);
            }
            this.relutionMapWorld.getBuilding().setGeofenceEditingEnabled(enabled);
        }
    }
    exports.GeofenceEditMode = GeofenceEditMode;
});
define("src/app/relution/modes/RoomEditMode", ["require", "exports", "src/app/relution/modes/RelutionMapMode"], function (require, exports, RelutionMapMode_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RoomEditMode = void 0;
    class RoomEditMode extends RelutionMapMode_3.RelutionMapMode {
        // Construction
        constructor(relutionMapWorld, relutionMapHud) {
            super(relutionMapWorld, relutionMapHud);
        }
        // Enabling/Disabling mode
        // @Override
        enable() {
            this.setModeEnabled(true);
        }
        // @Override
        disable() {
            this.setModeEnabled(false);
        }
        setModeEnabled(enabled) {
            if (enabled) {
                this.relutionMapWorld.getBuilding().toggleLayerVisibility("room", enabled);
            }
            this.relutionMapWorld.getBuilding().setRoomEditingEnabled(enabled);
        }
    }
    exports.RoomEditMode = RoomEditMode;
});
define("src/app/relution/modes/ZoneEditMode", ["require", "exports", "src/app/relution/modes/RelutionMapMode"], function (require, exports, RelutionMapMode_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ZoneEditMode = void 0;
    class ZoneEditMode extends RelutionMapMode_4.RelutionMapMode {
        // Construction
        constructor(relutionMapWorld, relutionMapHud) {
            super(relutionMapWorld, relutionMapHud);
        }
        // Enabling/Disabling mode
        // @Override
        enable() {
            this.setModeEnabled(true);
        }
        // @Override
        disable() {
            this.setModeEnabled(false);
        }
        setModeEnabled(enabled) {
            if (enabled) {
                this.relutionMapWorld.getBuilding().toggleLayerVisibility("zone", enabled);
            }
            this.relutionMapWorld.getBuilding().setZoneEditingEnabled(enabled);
        }
    }
    exports.ZoneEditMode = ZoneEditMode;
});
define("src/app/relution/utils/KeyUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyUtils = void 0;
    class KeyUtils {
        static getKeyCodeForNumberKey(num) {
            return 48 + num;
        }
        static getKeyCodeForChar(char) {
            var keyCode = char.charCodeAt(0);
            if (keyCode > 90) { // 90 is keyCode for 'z'
                return keyCode - 32;
            }
            return keyCode;
        }
        static isCtrlKey(num) {
            return 17;
        }
    }
    exports.KeyUtils = KeyUtils;
});
define("src/app/relution/modes/DeviceTaggingMode", ["require", "exports", "src/app/relution/modes/RelutionMapMode"], function (require, exports, RelutionMapMode_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeviceTaggingMode = void 0;
    class DeviceTaggingMode extends RelutionMapMode_5.RelutionMapMode {
        // Construction
        constructor(relutionMapWorld, relutionMapHud) {
            super(relutionMapWorld, relutionMapHud);
        }
        // Enabling/Disabling mode
        // @Override
        enable() {
            this.setModeEnabled(true);
        }
        // @Override
        disable() {
            this.setModeEnabled(false);
        }
        setModeEnabled(enabled) {
            this.relutionMapWorld.getBuilding().toggleLayerVisibility("tagging", enabled);
            this.relutionMapWorld.getBuilding().setTaggingModeEnabled(enabled);
        }
    }
    exports.DeviceTaggingMode = DeviceTaggingMode;
});
define("src/app/relution/locale/LocalizationEn", ["require", "exports", "src/engine/locale/Localization"], function (require, exports, Localization_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocalizationEn = void 0;
    class LocalizationEn extends Localization_2.Localization {
        constructor() {
            super();
            this.mapping = [];
            this.defineLocalization();
        }
        defineLocalization() {
            // Help
            this.mapping["device_info_average_users"] =
                "Average users";
            this.mapping["help_layer_mobile_device_description"] =
                "Zoom: Pinch\n" +
                    "Rotate: Pinch and Rotate\n" +
                    "Move: Pan\n" +
                    "Show beacon information: Tap\n";
            this.mapping["help_layer_non_mobile_device_description"] =
                "Zoom: Ctrl/Cmd + Mouse wheel\n" +
                    "Rotate: Alt + Shift + Mouse wheel\n" +
                    "Move: Ctrl/Cmd + Mouse\n" +
                    "Select: Mouse\n" +
                    "Multi-Select: Shift + Mouse\n" +
                    "Move Beacon: Alt + Shift + Mouse\n" +
                    "Move Beacon to stock: Del\n" +
                    "Turn on/off Layers: 1-9";
            // Action Bar
            this.mapping["action_bar_show_help_action"] = "Show help";
            this.mapping["action_bar_show_beacon_ranges_action"] = "Show beacon ranges";
            this.mapping["action_bar_show_connections_action"] = "Show beacon connections";
            this.mapping["action_bar_show_beacon_infos_action"] = "Show beacon infos";
            this.mapping["action_bar_show_device_tracks_action"] = "Show device tracks";
            this.mapping["action_bar_show_heatmap_action"] = "Show heatmap";
            // Popup: General
            this.mapping["popup_time_unit_prefix"] = "";
            this.mapping["popup_time_unit_postfix"] = " ago";
            this.mapping["popup_time_unit_year"] = "year";
            this.mapping["popup_time_unit_years"] = "years";
            this.mapping["popup_time_unit_month"] = "month";
            this.mapping["popup_time_unit_months"] = "months";
            this.mapping["popup_time_unit_day"] = "day";
            this.mapping["popup_time_unit_days"] = "days";
            this.mapping["popup_time_unit_hour"] = "h";
            this.mapping["popup_time_unit_hours"] = "h";
            this.mapping["popup_time_unit_minute"] = "min";
            this.mapping["popup_time_unit_minutes"] = "min";
            this.mapping["popup_time_unit_second"] = "s";
            this.mapping["popup_time_unit_seconds"] = "s";
            // Popup Layer: Device
            this.mapping["popup_device_name"] = "Name";
            this.mapping["popup_device_serial"] = "Serial";
            this.mapping["popup_device_last_connected"] = "Last connected";
            this.mapping["popup_device_node_id"] = "Node-ID";
            this.mapping["popup_device_version"] = "Beacon version";
            this.mapping["popup_device_meshgw_version"] = "MeshGateway version";
            this.mapping["popup_device_asset_id"] = "Asset-ID";
            this.mapping["popup_device_battery"] = "Battery";
            this.mapping["popup_device_user_count"] = "User count";
            this.mapping["popup_device_sensor_description"] = "Sensor value";
            this.mapping["popup_device_motion_state"] = "Motion sensor";
            this.mapping["popup_device_motion_state__MOVING"] = "moving";
            this.mapping["popup_device_motion_state__NON_MOVING"] = "standstill";
            this.mapping["popup_device_zpos"] = "Height above floor";
            // Popup Layer: FloorElement
            this.mapping["popup_room_name"] = "Room";
            this.mapping["popup_zone_name"] = "Zone";
            this.mapping["popup_floor_element_occupancy_average"] = "Average";
            // Popup Layer: Geofence
            this.mapping["popup_geofence_name"] = "Name";
            this.mapping["popup_geofence_time_threshold"] = "Time threshold";
            this.mapping["popup_geofence_accuracy_threshold"] = "Accuracy threshold";
        }
        getLocalizedStringFor(placeholderString) {
            return this.mapping["" + placeholderString];
        }
    }
    exports.LocalizationEn = LocalizationEn;
});
define("src/app/relution/modes/SingleDeviceEditMode", ["require", "exports", "src/app/relution/modes/RelutionMapMode", "src/map/utils/DeviceUtils"], function (require, exports, RelutionMapMode_6, DeviceUtils_28) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SingleDeviceEditMode = void 0;
    class SingleDeviceEditMode extends RelutionMapMode_6.RelutionMapMode {
        // Construction
        constructor(relutionMapWorld, relutionMapHud) {
            super(relutionMapWorld, relutionMapHud);
            // Configuration
            this.editableDeviceUuid = null;
        }
        // Enable/disable mode
        // @Override
        enable() {
            this.setModeEnabled(true);
        }
        // @Override
        disable() {
            this.setModeEnabled(false);
        }
        // Helper methods
        setModeEnabled(enabled) {
            this.setModeEnabledInWorld(enabled);
            this.setModeEnabledInHud(enabled);
        }
        setModeEnabledInWorld(enabled) {
            this.relutionMapWorld.getBuilding().setSingleDeviceEditModeEnabled(enabled, this.editableDeviceUuid);
        }
        setModeEnabledInHud(enabled) {
            if (DeviceUtils_28.DeviceUtils.isMobileDevice()) {
                this.relutionMapHud.popupLayer.setEnabled(!enabled);
            }
            this.relutionMapHud.selectionLayer.setEnabled(!enabled);
        }
        // Getters and setters
        setEditableDevice(deviceUuid) {
            this.editableDeviceUuid = deviceUuid;
        }
    }
    exports.SingleDeviceEditMode = SingleDeviceEditMode;
});
define("src/app/relution/modes/TapeMeasureEditMode", ["require", "exports", "src/app/relution/modes/RelutionMapMode", "src/map/utils/DeviceUtils"], function (require, exports, RelutionMapMode_7, DeviceUtils_29) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TapeMeasureEditMode = void 0;
    /**
     * A Relution map mode making creating and modifying the tape measure possible.
     */
    class TapeMeasureEditMode extends RelutionMapMode_7.RelutionMapMode {
        // Construction
        constructor(relutionMapWorld, relutionMapHud) {
            super(relutionMapWorld, relutionMapHud);
        }
        // Enable/disable mode
        // @Override
        enable() {
            this.setModeEnabled(true);
        }
        // @Override
        disable() {
            this.setModeEnabled(false);
        }
        // Helper methods
        setModeEnabled(enabled) {
            this.setModeEnabledInWorld(enabled);
            this.setModeEnabledInHud(enabled);
        }
        setModeEnabledInWorld(enabled) {
            this.relutionMapWorld.getBuilding().setTapeMeasureEditModeEnabled(enabled);
        }
        setModeEnabledInHud(enabled) {
            if (DeviceUtils_29.DeviceUtils.isMobileDevice()) {
                this.relutionMapHud.popupLayer.setEnabled(!enabled);
            }
            this.relutionMapHud.selectionLayer.setEnabled(!enabled);
            this.relutionMapHud.navigationLayer.setDoubleTapZoomingEnabled(!enabled);
            this.relutionMapHud.tapeMeasureHudLayer.setEnabled(enabled);
        }
    }
    exports.TapeMeasureEditMode = TapeMeasureEditMode;
});
define("src/rendering/pixi/PixiDecoratingObject", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PixiDecoratingObject = void 0;
    /**
     * <h1>
     * Base class for all decorator render objects.
     * </h1>
     *
     * <p>
     * A decorator encapsulates the internal PIXI render object. All method calls will
     * be delegated to the PIXI object. Method calls that change the rendering state and
     * require a rerendering of the screen will set the dirty flag of the rendering environment to true.
     * If no object set the dirty flag to true, the rendering phase will be skipped to
     * minimize the GPU and CPU utilization (silent rendering loop).
     * </p>
     */
    class PixiDecoratingObject {
        // Construction
        constructor(baseObject, renderer) {
            this.baseObject = baseObject;
            this.renderer = renderer;
        }
        // Getters and setters
        pixi() {
            return this.baseObject;
        }
        setPixi(baseObject) {
            this.baseObject = baseObject;
        }
    }
    exports.PixiDecoratingObject = PixiDecoratingObject;
});
define("src/rendering/pixi/utils/PixiPoint", ["require", "exports", "src/rendering/pixi/PixiDecoratingObject"], function (require, exports, PixiDecoratingObject_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PixiPoint = void 0;
    class PixiPoint extends PixiDecoratingObject_1.PixiDecoratingObject {
        // Getters and setters
        set x(x) {
            let oldX = this.pixi().x;
            if (oldX !== x) {
                this.pixi().x = x;
                this.renderer.dirty = true;
            }
        }
        get x() {
            return this.pixi().x;
        }
        set y(y) {
            let oldY = this.pixi().y;
            if (oldY !== y) {
                this.pixi().y = y;
                this.renderer.dirty = true;
            }
        }
        get y() {
            return this.pixi().y;
        }
    }
    exports.PixiPoint = PixiPoint;
});
define("src/rendering/pixi/utils/PixiMatrix", ["require", "exports", "src/rendering/pixi/PixiDecoratingObject", "src/rendering/pixi/utils/PixiPoint"], function (require, exports, PixiDecoratingObject_2, PixiPoint_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PixiMatrix = void 0;
    class PixiMatrix extends PixiDecoratingObject_2.PixiDecoratingObject {
        /**
         * sets the matrix properties
         *
         * @param {number} a - Matrix component
         * @param {number} b - Matrix component
         * @param {number} c - Matrix component
         * @param {number} d - Matrix component
         * @param {number} tx - Matrix component
         * @param {number} ty - Matrix component
         *
         * @return {PixiMatrix} This matrix. Good for chaining method calls.
         */
        set(a, b, c, d, tx, ty) {
            this.pixi().set(a, b, c, d, tx, ty);
            return this;
        }
        /**
         * Sets the matrix based on all the available properties
         *
         * @param {number} x - Position on the x axis
         * @param {number} y - Position on the y axis
         * @param {number} pivotX - Pivot on the x axis
         * @param {number} pivotY - Pivot on the y axis
         * @param {number} scaleX - Scale on the x axis
         * @param {number} scaleY - Scale on the y axis
         * @param {number} rotation - Rotation in radians
         * @param {number} skewX - Skew on the x axis
         * @param {number} skewY - Skew on the y axis
         * @return {PixiMatrix} This matrix. Good for chaining method calls.
         */
        setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
            this.pixi().setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY);
            return this;
        }
        // Matrix multiplication
        /**
         * Get a new position with the current transformation applied.
         * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
         *
         * @param {Point} pos - The origin
         * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
         * @return {Point} The new point, transformed through this matrix
         */
        apply(pos, newPos) {
            if (newPos === undefined) {
                return new PixiPoint_1.PixiPoint(this.pixi().apply(pos.pixi()), this.renderer);
            }
            else {
                this.pixi().apply(pos.pixi(), newPos.pixi());
                return newPos;
            }
        }
        /**
         * Get a new position with the inverse of the current transformation applied.
         * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
         *
         * @param {Point} pos - The origin
         * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
         * @return {Point} The new point, inverse-transformed through this matrix
         */
        applyInverse(pos, newPos) {
            if (newPos === undefined) {
                return new PixiPoint_1.PixiPoint(this.pixi().applyInverse(pos.pixi()), this.renderer);
            }
            else {
                this.pixi().applyInverse(pos.pixi(), newPos.pixi());
                return newPos;
            }
        }
        // Specific transformations
        /**
         * Translates the matrix on the x and y.
         *
         * @param {number} x How much to translate x by
         * @param {number} y How much to translate y by
         * @return {PixiMatrix} This matrix. Good for chaining method calls.
         */
        translate(x, y) {
            this.pixi().translate(x, y);
            return this;
        }
        /**
         * Applies a scale transformation to the matrix.
         *
         * @param {number} x The amount to scale horizontally
         * @param {number} y The amount to scale vertically
         * @return {PixiMatrix} This matrix. Good for chaining method calls.
         */
        scale(x, y) {
            this.pixi().scale(x, y);
            return this;
        }
        /**
         * Applies a rotation transformation to the matrix.
         *
         * @param {number} angle - The angle in radians.
         * @return {PixiMatrix} This matrix. Good for chaining method calls.
         */
        rotate(angle) {
            this.pixi().rotate(angle);
            return this;
        }
        /**
         * Appends the given Matrix to this Matrix.
         *
         * @param {PixiMatrix} matrix - The matrix to append.
         * @return {PixiMatrix} This matrix. Good for chaining method calls.
         */
        append(matrix) {
            this.pixi().append(matrix.pixi());
            return this;
        }
        /**
         * Prepends the given Matrix to this Matrix.
         *
         * @param {PixiMatrix} matrix - The matrix to prepend
         * @return {PixiMatrix} This matrix. Good for chaining method calls.
         */
        prepend(matrix) {
            this.pixi().prepend(matrix.pixi());
            return this;
        }
        /**
         * Inverts this matrix
         *
         * @return {PixiMatrix} This matrix. Good for chaining method calls.
         */
        invert() {
            this.pixi().invert();
            return this;
        }
        /**
         * Resets this Matix to an identity (default) matrix.
         *
         * @return {PixiMatrix} This matrix. Good for chaining method calls.
         */
        identity() {
            this.pixi().identity();
            return this;
        }
        /**
         * Creates a new Matrix object with the same values as this one.
         *
         * @return {PixiMatrix} A copy of this matrix. Good for chaining method calls.
         */
        clone() {
            return new PixiMatrix(this.pixi().clone(), this.renderer);
        }
        /**
         * Changes the values of the given matrix to be the same as the ones in this matrix
         *
         * @param {PixiMatrix} matrix - The matrix to copy from.
         * @return {PixiMatrix} The matrix given in parameter with its values updated.
         */
        copy(matrix) {
            matrix.a = this.a;
            matrix.b = this.b;
            matrix.c = this.c;
            matrix.d = this.d;
            matrix.tx = this.tx;
            matrix.ty = this.ty;
            return matrix;
        }
        // Getters and setters
        /**
         * Getter a
         * @return {number}
         */
        get a() {
            return this.pixi().a;
        }
        /**
         * Getter b
         * @return {number}
         */
        get b() {
            return this.pixi().b;
        }
        /**
         * Getter c
         * @return {number}
         */
        get c() {
            return this.pixi().c;
        }
        /**
         * Getter d
         * @return {number}
         */
        get d() {
            return this.pixi().d;
        }
        /**
         * Getter tx
         * @return {number}
         */
        get tx() {
            return this.pixi().tx;
        }
        /**
         * Getter ty
         * @return {number}
         */
        get ty() {
            return this.pixi().ty;
        }
        /**
         * Setter a
         * @param {number} value
         */
        set a(value) {
            this.pixi().a = value;
        }
        /**
         * Setter b
         * @param {number} value
         */
        set b(value) {
            this.pixi().b = value;
        }
        /**
         * Setter c
         * @param {number} value
         */
        set c(value) {
            this.pixi().c = value;
        }
        /**
         * Setter d
         * @param {number} value
         */
        set d(value) {
            this.pixi().d = value;
        }
        /**
         * Setter tx
         * @param {number} value
         */
        set tx(value) {
            this.pixi().tx = value;
        }
        /**
         * Setter ty
         * @param {number} value
         */
        set ty(value) {
            this.pixi().ty = value;
        }
    }
    exports.PixiMatrix = PixiMatrix;
});
define("src/rendering/pixi/objects/PixiDisplayObjectContainer", ["require", "exports", "src/rendering/pixi/objects/PixiDisplayObject"], function (require, exports, PixiDisplayObject_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PixiDisplayObjectContainer = void 0;
    class PixiDisplayObjectContainer extends PixiDisplayObject_1.PixiDisplayObject {
        // Construction
        constructor(baseObject, renderer) {
            super(baseObject, renderer);
            this._children = new Array();
            for (let object of baseObject.children) {
                this._children.push(new PixiDisplayObject_1.PixiDisplayObject(object, renderer));
            }
        }
        // Decorating methods
        destroy(destroyTextures) {
            this.pixi().destroy(destroyTextures);
            this.renderer.dirty = true;
        }
        addChild(child) {
            this.pixi().addChild(child.pixi());
            this._children.push(child);
            this.renderer.dirty = true;
        }
        removeChild(child) {
            this.pixi().removeChild(child.pixi());
            for (let i = 0; i < this._children.length; i++) {
                let c = this._children[i];
                if (c.pixi() === child.pixi()) {
                    this._children.splice(i, 1);
                }
            }
            this.renderer.dirty = true;
        }
        removeChildren() {
            this.pixi().removeChildren();
            this._children = [];
            this.renderer.dirty = true;
        }
        getChildAt(index) {
            return this._children[index];
        }
        setChildIndex(child, index) {
            this.pixi().setChildIndex(child.pixi(), index);
            // 1. Remove child, if exists
            for (let i = 0; i < this._children.length; i++) {
                let c = this._children[i];
                if (c.pixi() === child.pixi()) {
                    this._children.splice(i, 1);
                    break;
                }
            }
            // 2. Insert child at index
            this._children.splice(index, 0, child);
            this.renderer.dirty = true;
        }
        // Decorating setters and getters
        get children() {
            return this._children;
        }
        set width(width) {
            let oldWidth = this.pixi().width;
            this.pixi().width = width;
            if (Math.abs(oldWidth - width) > PixiDisplayObject_1.PixiDisplayObject.EPSILON) {
                this.renderer.dirty = true;
            }
        }
        get width() {
            return this.pixi().width;
        }
        set height(height) {
            let oldHeight = this.pixi().height;
            this.pixi().height = height;
            if (Math.abs(oldHeight - height) > PixiDisplayObject_1.PixiDisplayObject.EPSILON) {
                this.renderer.dirty = true;
            }
        }
        get height() {
            return this.pixi().height;
        }
        // Getters and setters
        pixi() {
            return super.pixi();
        }
    }
    exports.PixiDisplayObjectContainer = PixiDisplayObjectContainer;
});
define("src/rendering/pixi/utils/PixiObservablePoint", ["require", "exports", "src/rendering/pixi/PixiDecoratingObject"], function (require, exports, PixiDecoratingObject_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PixiObservablePoint = void 0;
    class PixiObservablePoint extends PixiDecoratingObject_3.PixiDecoratingObject {
        set x(x) {
            let oldX = this.pixi().x;
            if (oldX !== x) {
                this.pixi().x = x;
                this.renderer.dirty = true;
            }
        }
        get x() {
            return this.pixi().x;
        }
        set y(y) {
            let oldY = this.pixi().y;
            if (oldY !== y) {
                this.pixi().y = y;
                this.renderer.dirty = true;
            }
        }
        get y() {
            return this.pixi().y;
        }
    }
    exports.PixiObservablePoint = PixiObservablePoint;
});
define("src/rendering/pixi/objects/PixiDisplayObject", ["require", "exports", "src/engine/general/AABB", "src/engine/math/Vector2", "src/rendering/pixi/utils/PixiPoint", "src/rendering/pixi/utils/PixiMatrix", "src/rendering/pixi/PixiDecoratingObject", "src/rendering/pixi/utils/PixiObservablePoint"], function (require, exports, AABB_12, Vector2_42, PixiPoint_2, PixiMatrix_1, PixiDecoratingObject_4, PixiObservablePoint_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PixiDisplayObject = void 0;
    class PixiDisplayObject extends PixiDecoratingObject_4.PixiDecoratingObject {
        // Constructor
        constructor(baseObject, renderer) {
            super(baseObject, renderer);
            this._pivot = new PixiObservablePoint_1.PixiObservablePoint(baseObject.pivot, renderer);
            this._scale = new PixiObservablePoint_1.PixiObservablePoint(baseObject.scale, renderer);
            this._position = new PixiObservablePoint_1.PixiObservablePoint(baseObject.position, renderer);
            this._localTransform = new PixiMatrix_1.PixiMatrix(baseObject.localTransform, renderer);
            this._worldTransform = new PixiMatrix_1.PixiMatrix(baseObject.worldTransform, renderer);
            this._bounds = new AABB_12.AABB(new Vector2_42.Vector2(), new Vector2_42.Vector2());
        }
        // Decorating methods
        destroy(destroyResources) {
            this.pixi().destroy();
            this.renderer.dirty = true;
        }
        setParent(container) {
            this.pixi().setParent(container.pixi());
            this.renderer.dirty = true;
        }
        // Transformation
        setTransform(x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {
            let oldPositionX = this.pixi().position.x;
            let oldPositionY = this.pixi().position.y;
            let oldScaleX = this.pixi().scale.x;
            let oldScaleY = this.pixi().scale.y;
            let oldRotation = this.pixi().rotation;
            let oldSkewX = this.pixi().skew.x;
            let oldSkewY = this.pixi().skew.y;
            let oldPivotX = this.pixi().pivot.x;
            let oldPivotY = this.pixi().pivot.y;
            this.pixi().setTransform(x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY);
            if (Math.abs(oldPositionX - x) > PixiDisplayObject.EPSILON ||
                Math.abs(oldPositionY - y) > PixiDisplayObject.EPSILON ||
                Math.abs(oldScaleX - scaleX) > PixiDisplayObject.EPSILON ||
                Math.abs(oldScaleY - scaleY) > PixiDisplayObject.EPSILON ||
                Math.abs(oldRotation - rotation) > PixiDisplayObject.EPSILON ||
                Math.abs(oldSkewX - skewX) > PixiDisplayObject.EPSILON ||
                Math.abs(oldSkewY - skewY) > PixiDisplayObject.EPSILON ||
                Math.abs(oldPivotX - pivotX) > PixiDisplayObject.EPSILON ||
                Math.abs(oldPivotY - pivotY) > PixiDisplayObject.EPSILON) {
                this.renderer.dirty = true;
            }
        }
        toLocal(position, point, from) {
            if (point === undefined) {
                return new PixiPoint_2.PixiPoint(this.pixi().toLocal(position.pixi(), from == undefined ? undefined : from.pixi()), this.renderer);
            }
            else {
                point.setPixi(this.pixi().toLocal(position.pixi()));
                return point;
            }
        }
        toGlobal(position, point) {
            if (point === undefined) {
                return new PixiPoint_2.PixiPoint(this.pixi().toGlobal(position.pixi()), this.renderer);
            }
            else {
                this.pixi().toGlobal(position.pixi(), point.pixi());
                return point;
            }
        }
        getBounds() {
            let bounds = this.pixi().getBounds();
            this._bounds.min.x = bounds.x;
            this._bounds.min.y = bounds.y;
            this._bounds.max.x = bounds.x + bounds.width;
            this._bounds.max.y = bounds.y + bounds.height;
            return this._bounds;
        }
        // Decorating getters and setters
        set alpha(alpha) {
            let oldAlpha = this.pixi().alpha;
            this.pixi().alpha = alpha;
            if (Math.abs(oldAlpha - alpha) > PixiDisplayObject.EPSILON) {
                this.renderer.dirty = true;
            }
        }
        get alpha() {
            return this.pixi().alpha;
        }
        set worldAlpha(worldAlpha) {
            let oldWorldAlpha = this.pixi().worldAlpha;
            this.pixi().worldAlpha = worldAlpha;
            if (Math.abs(oldWorldAlpha - worldAlpha) > PixiDisplayObject.EPSILON) {
                this.renderer.dirty = true;
            }
        }
        get worldAlpha() {
            return this.pixi().worldAlpha;
        }
        set visible(visible) {
            let oldVisible = this.pixi().visible;
            if (oldVisible !== visible) {
                this.pixi().visible = visible;
                this.renderer.dirty = true;
            }
        }
        get visible() {
            return this.pixi().visible;
        }
        set localTransform(localTransform) {
            let oldLocalTransform = this.pixi().localTransform;
            this.pixi().localTransform.set(localTransform.a, localTransform.b, localTransform.c, localTransform.d, localTransform.tx, localTransform.ty);
            if (Math.abs(oldLocalTransform.a - localTransform.a) > PixiDisplayObject.EPSILON ||
                Math.abs(oldLocalTransform.b - localTransform.b) > PixiDisplayObject.EPSILON ||
                Math.abs(oldLocalTransform.c - localTransform.c) > PixiDisplayObject.EPSILON ||
                Math.abs(oldLocalTransform.d - localTransform.d) > PixiDisplayObject.EPSILON ||
                Math.abs(oldLocalTransform.tx - localTransform.tx) > PixiDisplayObject.EPSILON ||
                Math.abs(oldLocalTransform.ty - localTransform.ty) > PixiDisplayObject.EPSILON) {
                this.renderer.dirty = true;
            }
        }
        get localTransform() {
            this._localTransform.setPixi(this.pixi().localTransform);
            return this._localTransform;
        }
        get worldTransform() {
            this._worldTransform.setPixi(this.pixi().worldTransform);
            return this._worldTransform;
        }
        set pivot(pivot) {
            let oldPivot = this.pixi().pivot;
            this.pixi().pivot = pivot.pixi();
            if (Math.abs(oldPivot.x - pivot.x) > PixiDisplayObject.EPSILON ||
                Math.abs(oldPivot.y - pivot.y) > PixiDisplayObject.EPSILON) {
                this.renderer.dirty = true;
            }
        }
        get pivot() {
            this._pivot.setPixi(this.pixi().pivot);
            return this._pivot;
        }
        set position(position) {
            let oldPosition = this.pixi().position;
            this.pixi().position = position.pixi();
            if (Math.abs(oldPosition.x - position.x) > PixiDisplayObject.EPSILON ||
                Math.abs(oldPosition.y - position.y) > PixiDisplayObject.EPSILON) {
                this.renderer.dirty = true;
            }
        }
        get position() {
            this._position.setPixi(this.pixi().position);
            return this._position;
        }
        set x(x) {
            let oldX = this.pixi().x;
            this.pixi().x = x;
            if (Math.abs(oldX - x) > PixiDisplayObject.EPSILON) {
                this.renderer.dirty = true;
            }
        }
        get x() {
            return this.pixi().x;
        }
        set y(y) {
            let oldY = this.pixi().y;
            this.pixi().y = y;
            if (Math.abs(oldY - y) > PixiDisplayObject.EPSILON) {
                this.renderer.dirty = true;
            }
        }
        get y() {
            return this.pixi().y;
        }
        set scale(scale) {
            let oldScale = this.pixi().scale;
            this.pixi().scale = scale.pixi();
            if (Math.abs(oldScale.x - scale.x) > PixiDisplayObject.EPSILON ||
                Math.abs(oldScale.y - scale.y) > PixiDisplayObject.EPSILON) {
                this.renderer.dirty = true;
            }
        }
        get scale() {
            this._scale.setPixi(this.pixi().scale);
            return this._scale;
        }
        set rotation(rotation) {
            let oldRotation = this.pixi().rotation;
            this.pixi().rotation = rotation;
            if (Math.abs(oldRotation - rotation) > PixiDisplayObject.EPSILON) {
                this.renderer.dirty = true;
            }
        }
        get rotation() {
            return this.pixi().rotation;
        }
        set interactive(interactive) {
            let oldInteractive = this.pixi().interactive;
            if (oldInteractive !== interactive) {
                this.pixi().interactive = interactive;
                this.renderer.dirty = true;
            }
        }
        get interactive() {
            return this.pixi().interactive;
        }
        // Getters and setters
        pixi() {
            return super.pixi();
        }
    }
    exports.PixiDisplayObject = PixiDisplayObject;
    // Constants
    PixiDisplayObject.EPSILON = 0.0001;
});
define("src/rendering/pixi/objects/PixiGraphicsObject", ["require", "exports", "src/rendering/pixi/objects/PixiDisplayObjectContainer"], function (require, exports, PixiDisplayObjectContainer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PixiGraphicsObject = void 0;
    class PixiGraphicsObject extends PixiDisplayObjectContainer_1.PixiDisplayObjectContainer {
        // Construction
        constructor(baseObject, renderer) {
            super(baseObject, renderer);
        }
        // Decorating methods
        beginFill(color, alpha) {
            this.pixi().beginFill(color, alpha);
            this.renderer.dirty = true;
            return this;
        }
        drawRect(x, y, width, height) {
            this.pixi().drawRect(x, y, width, height);
            this.renderer.dirty = true;
            return this;
        }
        drawCircle(x, y, radius) {
            this.pixi().drawCircle(x, y, radius);
            this.renderer.dirty = true;
            return this;
        }
        drawEllipse(x, y, width, height) {
            this.pixi().drawEllipse(x, y, width, height);
            this.renderer.dirty = true;
            return this;
        }
        drawPolygon(path) {
            this.pixi().drawPolygon(this.renderer.newPointToPixiArray(path));
            this.renderer.dirty = true;
            return this;
        }
        moveTo(x, y) {
            this.pixi().moveTo(x, y);
            this.renderer.dirty = true;
            return this;
        }
        lineTo(x, y) {
            this.pixi().lineTo(x, y);
            this.renderer.dirty = true;
            return this;
        }
        closePath() {
            this.pixi().closePath();
            this.renderer.dirty = true;
            return this;
        }
        endFill() {
            this.pixi().endFill();
            this.renderer.dirty = true;
            return this;
        }
        clear() {
            this.pixi().clear();
            this.renderer.dirty = true;
            return this;
        }
        lineStyle(lineWidth, color, alpha) {
            this.pixi().lineStyle(lineWidth, color, alpha);
            this.renderer.dirty = true;
            return this;
        }
        // Getters and setters
        pixi() {
            return super.pixi();
        }
    }
    exports.PixiGraphicsObject = PixiGraphicsObject;
});
define("src/rendering/pixi/texture/PixiBaseTexture", ["require", "exports", "src/rendering/pixi/PixiDecoratingObject", "pixijs"], function (require, exports, PixiDecoratingObject_5, PIXI) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PixiBaseTexture = void 0;
    PIXI = __importStar(PIXI);
    class PixiBaseTexture extends PixiDecoratingObject_5.PixiDecoratingObject {
        // Construction
        constructor(baseObject, renderer, mipmapEnabled) {
            super(baseObject, renderer);
            this.pixi().mipmap = mipmapEnabled ? PIXI.MIPMAP_MODES.ON : PIXI.MIPMAP_MODES.OFF;
        }
        // Decorating methods
        loadSource(source) {
            this.pixi().resource = null;
            if (source instanceof HTMLImageElement) {
                this.pixi().setResource(new PIXI.ImageResource(source));
            }
            else if (source instanceof HTMLCanvasElement) {
                this.pixi().setResource(new PIXI.CanvasResource(source));
            }
            this.renderer.dirty = true;
        }
        // Decorating getters and setters
        set mipmap(mipmap) {
            let oldMipmap = this.pixi().mipmap !== PIXI.MIPMAP_MODES.OFF;
            if (oldMipmap !== mipmap) {
                this.pixi().mipmap = mipmap ? PIXI.MIPMAP_MODES.ON : PIXI.MIPMAP_MODES.OFF;
                this.renderer.dirty = true;
            }
        }
        get mipmap() {
            return this.pixi().mipmap !== PIXI.MIPMAP_MODES.OFF;
        }
        set width(width) {
            let oldWidth = this.pixi().width;
            if (oldWidth !== width) {
                this.pixi().width = width;
                this.renderer.dirty = true;
            }
        }
        get width() {
            return this.pixi().width;
        }
        set height(height) {
            let oldHeight = this.pixi().height;
            if (oldHeight !== height) {
                this.pixi().height = height;
                this.renderer.dirty = true;
            }
        }
        get height() {
            return this.pixi().height;
        }
    }
    exports.PixiBaseTexture = PixiBaseTexture;
});
define("src/rendering/pixi/texture/PixiTexture", ["require", "exports", "src/engine/rendering/texture/Texture", "src/rendering/pixi/texture/PixiBaseTexture", "src/rendering/pixi/PixiDecoratingObject"], function (require, exports, Texture_1, PixiBaseTexture_1, PixiDecoratingObject_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PixiTexture = void 0;
    class PixiTexture extends PixiDecoratingObject_6.PixiDecoratingObject {
        // Construction
        constructor(baseObject, renderer, config = new Texture_1.Texture.Config()) {
            super(baseObject, renderer);
            this._baseTexture = new PixiBaseTexture_1.PixiBaseTexture(baseObject.baseTexture, renderer, config.mipmap);
        }
        // Decorating methods
        destroy() {
            this.pixi().destroy(true);
            this.renderer.dirty = true;
        }
        // Decorating getters and setters
        get width() {
            return this.pixi().width;
        }
        get height() {
            return this.pixi().height;
        }
        set baseTexture(baseTexture) {
            let oldBaseTexture = this.pixi().baseTexture;
            if (oldBaseTexture !== baseTexture.pixi()) {
                this.pixi().baseTexture = baseTexture.pixi();
                this.renderer.dirty = true;
            }
        }
        get baseTexture() {
            this._baseTexture.setPixi(this.pixi().baseTexture);
            return this._baseTexture;
        }
        // Source
        get source() {
            return this.pixi().baseTexture.resource.source;
        }
        load(source) {
            this.baseTexture.loadSource(source);
        }
    }
    exports.PixiTexture = PixiTexture;
});
define("src/rendering/pixi/extensions/filters/PixiSpriteInverseMaskFilter", ["require", "exports", "pixijs"], function (require, exports, PIXI) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PixiSpriteInverseMaskFilter = void 0;
    PIXI = __importStar(PIXI);
    /**
     * This handles a Sprite acting as a mask, as opposed to a Graphic.
     *
     * WebGL only.
     *
     * @class
     * @extends PIXI.Filter
     * @memberof PIXI
     */
    class PixiSpriteInverseMaskFilter extends PIXI.Filter {
        /**
         * @param {PIXI.Sprite} sprite - the target sprite
         */
        constructor(sprite) {
            const maskMatrix = new PIXI.Matrix();
            super(`
            attribute vec2 aVertexPosition;
            attribute vec2 aTextureCoord;

            uniform mat3 projectionMatrix;
            uniform mat3 otherMatrix;

            varying vec2 vMaskCoord;
            varying vec2 vTextureCoord;

            void main(void)
            {
                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

                vTextureCoord = aTextureCoord;
                vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
            }
            `, `
            varying vec2 vMaskCoord;
            varying vec2 vTextureCoord;

            uniform sampler2D uSampler;
            uniform sampler2D mask;
            uniform float alpha;
            uniform vec4 maskClamp;

            void main(void)
            {
                float clip = step(3.5,
                    step(maskClamp.x, vMaskCoord.x) +
                    step(maskClamp.y, vMaskCoord.y) +
                    step(vMaskCoord.x, maskClamp.z) +
                    step(vMaskCoord.y, maskClamp.w));

                vec4 original = texture2D(uSampler, vTextureCoord);
                vec4 masky = texture2D(mask, vMaskCoord);

                original *= 1.0 - (masky.r * masky.a * alpha * clip);

                gl_FragColor = original;
            }

            `);
            sprite.renderable = false;
            /**
             * Sprite mask
             * @member {PIXI.Sprite}
             */
            this.maskSprite = sprite;
            /**
             * Mask matrix
             * @member {PIXI.Matrix}
             */
            this.maskMatrix = maskMatrix;
        }
        /**
         * Applies the filter
         *
         * @param {PIXI.FilterSystem} filterManager - The renderer to retrieve the filter from
         * @param {PIXI.RenderTexture} input - The input render target.
         * @param {PIXI.RenderTexture} output - The target to output to.
         * @param {PIXI.CLEAR_MODES} clearMode - Should the output be cleared before rendering to it.
         */
        apply(filterManager, input, output, clearMode) {
            const maskSprite = this.maskSprite;
            const tex = maskSprite._texture;
            if (!tex.valid) {
                return;
            }
            if (!tex.uvMatrix) {
                // margin = 0.0, let it bleed a bit, shader code becomes easier
                // assuming that atlas textures were made with 1-pixel padding
                tex.uvMatrix = new PIXI.TextureMatrix(tex, 0.0);
            }
            tex.uvMatrix.update();
            this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0.0 : 1.0;
            this.uniforms.mask = tex;
            // get _normalized sprite texture coords_ and convert them to _normalized atlas texture coords_ with `prepend`
            this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite)
                .prepend(tex.uvMatrix.mapCoord);
            this.uniforms.alpha = maskSprite.worldAlpha;
            this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
            filterManager.applyFilter(this, input, output, clearMode);
        }
    }
    exports.PixiSpriteInverseMaskFilter = PixiSpriteInverseMaskFilter;
});
define("src/rendering/pixi/objects/PixiSpriteObject", ["require", "exports", "src/rendering/pixi/objects/PixiDisplayObjectContainer", "src/rendering/pixi/texture/PixiTexture", "src/rendering/pixi/utils/PixiObservablePoint", "src/rendering/pixi/extensions/filters/PixiSpriteInverseMaskFilter", "src/rendering/pixi/objects/PixiDisplayObject"], function (require, exports, PixiDisplayObjectContainer_2, PixiTexture_1, PixiObservablePoint_2, PixiSpriteInverseMaskFilter_1, PixiDisplayObject_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PixiSpriteObject = void 0;
    class PixiSpriteObject extends PixiDisplayObjectContainer_2.PixiDisplayObjectContainer {
        // Construction
        constructor(baseObject, renderer) {
            super(baseObject, renderer);
            this._texture = new PixiTexture_1.PixiTexture(this.pixi().texture, renderer);
            this._anchor = new PixiObservablePoint_2.PixiObservablePoint(this.pixi().anchor, renderer);
            this._maskFilter = null;
            this._mask;
        }
        // Decorating getters and setters
        set texture(texture) {
            let oldTexture = this.pixi().texture;
            if (oldTexture !== texture.pixi()) {
                this.pixi().texture = texture.pixi();
                this.renderer.dirty = true;
            }
        }
        get texture() {
            this._texture.setPixi(this.pixi().texture);
            return this._texture;
        }
        set tint(tint) {
            let oldTint = this.pixi().tint;
            if (oldTint !== tint) {
                this.pixi().tint = tint;
                this.renderer.dirty = true;
            }
        }
        get tint() {
            return this.pixi().tint;
        }
        set mask(mask) {
            if (this.pixi().filters === null) {
                this.pixi().filters = [];
            }
            let indexOfFilter = this.pixi().filters.indexOf(this._maskFilter);
            if (indexOfFilter >= 0) {
                this.pixi().filters.splice(indexOfFilter, 1);
            }
            this._mask = mask;
            this._maskFilter = new PixiSpriteInverseMaskFilter_1.PixiSpriteInverseMaskFilter(mask.pixi());
            this.pixi().filters.push(this._maskFilter);
        }
        get mask() {
            return this._mask;
        }
        set filters(filters) {
            this.pixi().filters = filters;
            this.renderer.dirty = true;
        }
        get filters() {
            return this.pixi().filters;
        }
        set anchor(anchor) {
            let oldAnchor = this.pixi().anchor;
            this.pixi().anchor = anchor.pixi();
            if (Math.abs(oldAnchor.x - anchor.x) > PixiDisplayObject_2.PixiDisplayObject.EPSILON ||
                Math.abs(oldAnchor.y - anchor.y) > PixiDisplayObject_2.PixiDisplayObject.EPSILON) {
                this.renderer.dirty = true;
            }
        }
        get anchor() {
            this._anchor.setPixi(this.pixi().anchor);
            return this._anchor;
        }
        // Getters and setters
        pixi() {
            return super.pixi();
        }
    }
    exports.PixiSpriteObject = PixiSpriteObject;
});
define("src/rendering/pixi/objects/text/PixiTextStyle", ["require", "exports", "src/rendering/pixi/PixiDecoratingObject"], function (require, exports, PixiDecoratingObject_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PixiTextStyle = void 0;
    class PixiTextStyle extends PixiDecoratingObject_7.PixiDecoratingObject {
        // Construction
        constructor(baseObject, renderer) {
            super(baseObject, renderer);
        }
        // Decorating methods
        set align(newValue) {
            let oldValue = this.pixi().align;
            if (oldValue !== newValue) {
                this.pixi().align = newValue;
                // As the fill field may be saved in a different format (e.g. hex string), we must check
                // for modification again (this time definitely with the same format).
                if (this.pixi().align !== oldValue) {
                    this.renderer.dirty = true;
                }
            }
        }
        get align() {
            return this.pixi().align;
        }
        set fill(fill) {
            let oldFill = this.pixi().fill;
            if (oldFill !== fill) {
                this.pixi().fill = fill;
                // As the fill field may be saved in a different format (e.g. hex string), we must check
                // for modification again (this time definitely with the same format).
                if (this.pixi().fill !== oldFill) {
                    this.renderer.dirty = true;
                }
            }
        }
        get fill() {
            return this.pixi().fill;
        }
        set fontFamily(newValue) {
            let oldValue = this.pixi().fontFamily;
            if (oldValue !== newValue) {
                this.pixi().fontFamily = newValue;
                // As the fill field may be saved in a different format (e.g. hex string), we must check
                // for modification again (this time definitely with the same format).
                if (this.pixi().fontFamily !== oldValue) {
                    this.renderer.dirty = true;
                }
            }
        }
        get fontFamily() {
            return this.pixi().fontFamily;
        }
        set fontSize(newValue) {
            let oldValue = this.pixi().fontSize;
            if (oldValue !== newValue) {
                this.pixi().fontSize = newValue;
                // As the fill field may be saved in a different format (e.g. hex string), we must check
                // for modification again (this time definitely with the same format).
                if (this.pixi().fontSize !== oldValue) {
                    this.renderer.dirty = true;
                }
            }
        }
        get fontSize() {
            return this.pixi().fontSize;
        }
        set dropShadow(newValue) {
            let oldValue = this.pixi().dropShadow;
            if (oldValue !== newValue) {
                this.pixi().dropShadow = newValue;
                // As the fill field may be saved in a different format (e.g. hex string), we must check
                // for modification again (this time definitely with the same format).
                if (this.pixi().dropShadow !== oldValue) {
                    this.renderer.dirty = true;
                }
            }
        }
        get dropShadow() {
            return this.pixi().dropShadow;
        }
        set dropShadowAlpha(newValue) {
            let oldValue = this.pixi().dropShadowAlpha;
            if (oldValue !== newValue) {
                this.pixi().dropShadowAlpha = newValue;
                // As the fill field may be saved in a different format (e.g. hex string), we must check
                // for modification again (this time definitely with the same format).
                if (this.pixi().dropShadowAlpha !== oldValue) {
                    this.renderer.dirty = true;
                }
            }
        }
        get dropShadowAlpha() {
            return this.pixi().dropShadowAlpha;
        }
        set dropShadowAngle(newValue) {
            let oldValue = this.pixi().dropShadowAngle;
            if (oldValue !== newValue) {
                this.pixi().dropShadowAngle = newValue;
                // As the fill field may be saved in a different format (e.g. hex string), we must check
                // for modification again (this time definitely with the same format).
                if (this.pixi().dropShadowAngle !== oldValue) {
                    this.renderer.dirty = true;
                }
            }
        }
        get dropShadowAngle() {
            return this.pixi().dropShadowAngle;
        }
        set dropShadowBlur(newValue) {
            let oldValue = this.pixi().dropShadowBlur;
            if (oldValue !== newValue) {
                this.pixi().dropShadowBlur = newValue;
                // As the fill field may be saved in a different format (e.g. hex string), we must check
                // for modification again (this time definitely with the same format).
                if (this.pixi().dropShadowBlur !== oldValue) {
                    this.renderer.dirty = true;
                }
            }
        }
        get dropShadowBlur() {
            return this.pixi().dropShadowBlur;
        }
        set dropShadowColor(newValue) {
            let oldValue = this.pixi().dropShadowColor;
            if (oldValue !== newValue) {
                this.pixi().dropShadowColor = newValue;
                // As the fill field may be saved in a different format (e.g. hex string), we must check
                // for modification again (this time definitely with the same format).
                if (this.pixi().dropShadowColor !== oldValue) {
                    this.renderer.dirty = true;
                }
            }
        }
        get dropShadowColor() {
            return this.pixi().dropShadowColor;
        }
        set dropShadowDistance(newValue) {
            let oldValue = this.pixi().dropShadowDistance;
            if (oldValue !== newValue) {
                this.pixi().dropShadowDistance = newValue;
                // As the fill field may be saved in a different format (e.g. hex string), we must check
                // for modification again (this time definitely with the same format).
                if (this.pixi().dropShadowDistance !== oldValue) {
                    this.renderer.dirty = true;
                }
            }
        }
        get dropShadowDistance() {
            return this.pixi().dropShadowDistance;
        }
    }
    exports.PixiTextStyle = PixiTextStyle;
});
define("src/rendering/pixi/objects/PixiTextObject", ["require", "exports", "src/rendering/pixi/objects/PixiSpriteObject", "src/rendering/pixi/objects/text/PixiTextStyle"], function (require, exports, PixiSpriteObject_1, PixiTextStyle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PixiTextObject = void 0;
    class PixiTextObject extends PixiSpriteObject_1.PixiSpriteObject {
        // Construction
        constructor(baseObject, renderer) {
            super(baseObject, renderer);
            this._textStyle = new PixiTextStyle_1.PixiTextStyle(this.pixi().style, renderer);
        }
        // Decorating methods
        destroy(destroyTextures) {
            this.pixi().destroy(destroyTextures);
            this.renderer.dirty = true;
        }
        set text(text) {
            let oldText = this.pixi().text;
            if (oldText !== text) {
                this.pixi().text = text;
                this.renderer.dirty = true;
            }
        }
        get text() {
            return this.pixi().text;
        }
        set style(style) {
            this.pixi().style = style.pixi();
            this.renderer.dirty = true;
        }
        get style() {
            this._textStyle.setPixi(this.pixi().style);
            return this._textStyle;
        }
        flush() {
            this.pixi().updateText(false);
            this.renderer.dirty = true;
        }
        // Getters and setters
        pixi() {
            return super.pixi();
        }
    }
    exports.PixiTextObject = PixiTextObject;
});
define("src/rendering/pixi/utils/PixiScaledPoint", ["require", "exports", "src/rendering/pixi/utils/PixiObservablePoint"], function (require, exports, PixiObservablePoint_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PixiScaledPoint = void 0;
    class PixiScaledPoint extends PixiObservablePoint_3.PixiObservablePoint {
        // Construction
        constructor(baseObject, renderer, scaleFactor) {
            super(baseObject, renderer);
            this.scaleFactor = scaleFactor;
        }
        // Getters and setters
        set x(x) {
            let oldX = this.pixi().x;
            x /= this.scaleFactor;
            if (oldX !== x) {
                this.pixi().x = x;
                this.renderer.dirty = true;
            }
        }
        get x() {
            return this.pixi().x * this.scaleFactor;
        }
        set y(y) {
            let oldY = this.pixi().y;
            y /= this.scaleFactor;
            if (oldY !== y) {
                this.pixi().y = y;
                this.renderer.dirty = true;
            }
        }
        get y() {
            return this.pixi().y * this.scaleFactor;
        }
    }
    exports.PixiScaledPoint = PixiScaledPoint;
});
define("src/rendering/pixi/objects/PixiHighResTextObject", ["require", "exports", "src/rendering/pixi/objects/PixiTextObject", "src/rendering/pixi/objects/PixiDisplayObject", "src/rendering/pixi/utils/PixiScaledPoint", "pixijs"], function (require, exports, PixiTextObject_1, PixiDisplayObject_3, PixiScaledPoint_1, PIXI) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PixiHighResTextObject = void 0;
    PIXI = __importStar(PIXI);
    class PixiHighResTextObject extends PixiTextObject_1.PixiTextObject {
        // Construction
        constructor(baseObject, scaleFactor, renderer) {
            super(baseObject, renderer);
            this._scaleFactor = scaleFactor;
            // Increase font size for higher resolution.
            this.style.fontSize = (this.style.fontSize) * this._scaleFactor;
            this._modifiedScale = new PixiScaledPoint_1.PixiScaledPoint(new PIXI.ObservablePoint(() => { }, 0, 1.0 / scaleFactor, 1. / scaleFactor), renderer, scaleFactor);
            this.pixi().scale.x = this._modifiedScale.pixi().x;
            this.pixi().scale.y = this._modifiedScale.pixi().y;
        }
        // Decorating getters and setters
        set scale(scale) {
            let oldScale = this.pixi().scale;
            this.pixi().scale.x = scale.x / this._scaleFactor;
            this.pixi().scale.y = scale.y / this._scaleFactor;
            if (Math.abs(oldScale.x - scale.x) > PixiDisplayObject_3.PixiDisplayObject.EPSILON ||
                Math.abs(oldScale.y - scale.y) > PixiDisplayObject_3.PixiDisplayObject.EPSILON) {
                this.renderer.dirty = true;
            }
        }
        get scale() {
            this._modifiedScale.setPixi(this.pixi().scale);
            return this._modifiedScale;
        }
        // Getters and setters
        pixi() {
            return super.pixi();
        }
    }
    exports.PixiHighResTextObject = PixiHighResTextObject;
});
define("src/rendering/pixi/PixiRenderer", ["require", "exports", "src/engine/rendering/WebGlRenderer", "src/rendering/pixi/objects/PixiDisplayObjectContainer", "src/rendering/pixi/objects/PixiGraphicsObject", "src/rendering/pixi/objects/PixiHighResTextObject", "src/rendering/pixi/objects/PixiSpriteObject", "src/rendering/pixi/texture/PixiTexture", "src/rendering/pixi/utils/PixiMatrix", "src/rendering/pixi/utils/PixiPoint", "src/rendering/pixi/objects/text/PixiTextStyle", "src/rendering/pixi/objects/PixiTextObject", "src/engine/rendering/Renderer", "pixijs"], function (require, exports, WebGlRenderer_2, PixiDisplayObjectContainer_3, PixiGraphicsObject_1, PixiHighResTextObject_1, PixiSpriteObject_2, PixiTexture_2, PixiMatrix_2, PixiPoint_3, PixiTextStyle_2, PixiTextObject_2, Renderer_2, PIXI) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PixiRenderer = void 0;
    PIXI = __importStar(PIXI);
    class PixiRenderer extends WebGlRenderer_2.WebGlRenderer {
        // Construction
        constructor(config) {
            super(config);
            this.cachedResources = new Map();
            this.initPixi();
            // On Retina monitors, sprites look sometimes blurry. Thus, we
            // render it in the double size and rescale it to get sharp edges
            // (resolution, autoResize and PIXI.Resolution).
            let options = {
                width: this.renderTargetSize.x,
                height: this.renderTargetSize.y,
                antialias: true,
                resolution: this.pixelRatio < 1 ? 1.0 : this.pixelRatio || 1,
                autoDensity: true
            };
            this.app = new PIXI.Application(options);
            // Creates the renderer and determines, whether to use WebGL or Canvas.
            this.app.renderer.backgroundColor = 0xffffff;
        }
        initPixi() {
            // Do not log pixi logo to the console.
            PIXI.utils.skipHello();
            // Fall back to WebGL1, as the heatmap currently does not have WebGL2 support, yet.
            PIXI.settings.PREFER_ENV = PIXI.ENV.WEBGL;
            // We use a custom WebGL shader to get sharper mipmapped textures by setting the LOD bias to 1.0. As soon as
            // https://github.com/pixijs/pixi.js/issues/2277
            // has been merged into master, the custom shader implementation
            // can be replaced by the default one.
            PIXI.BatchShaderGenerator.prototype.generateSampleSrc = function (maxTextures) {
                var src = '';
                src += '\n';
                src += '\n';
                for (var i = 0; i < maxTextures; i++) {
                    if (i > 0) {
                        src += '\nelse ';
                    }
                    if (i < maxTextures - 1) {
                        src += "if(vTextureId < " + i + ".5)";
                    }
                    src += '\n{';
                    src += "\n\tcolor = texture2D(uSamplers[" + i + "], vTextureCoord, -1.0);";
                    src += '\n}';
                }
                src += '\n';
                src += '\n';
                return src;
            };
        }
        // Destruction
        destroy() {
            this.app.destroy(true);
        }
        // Rendering trigger
        clear() {
            this.app.renderer.clearBeforeRender = true;
        }
        render(displayObject, options = new Renderer_2.Renderer.RenderingOptions()) {
            this.app.renderer.render(displayObject.pixi());
            this.app.renderer.clearBeforeRender = false;
        }
        // Rendering target
        /**
         * Returns the {@link HTMLElement}, which the scenes will be rendered to.
         */
        getHtmlElement() {
            return this.app.renderer.view;
        }
        // Rendering dimensions
        resize(widthInPx, heightInPx) {
            this.app.renderer.resize(widthInPx, heightInPx);
        }
        // Render resources
        loadResources(resources, callback) {
            this.app.loader.reset();
            if (resources.length > 0) {
                for (let i = 0; i < resources.length; i++) {
                    let image = resources[i];
                    let resourceName = image.resourceName;
                    let url = image.url;
                    this.addResource(resourceName, url);
                }
                this.app.loader.load(() => {
                    callback();
                });
            }
            else {
                callback();
            }
        }
        addResource(resourceName, url) {
            if (this.app.loader.resources[resourceName] === undefined) {
                let options = {
                    crossOrigin: this.getConfig().crossOriginAttribute,
                    // Forces the loader to load URLs without extension as PNG.
                    loadType: PIXI.LoaderResource.LOAD_TYPE.IMAGE,
                    xhrType: PIXI.LoaderResource.XHR_RESPONSE_TYPE.BLOB,
                };
                this.app.loader.add(resourceName, url, options);
            }
        }
        isLoadingResources() {
            return this.app.loader.loading;
        }
        unloadAllResources() {
            // Not necessary anymore.
            // Destroying the app also clears the app internal texture caches etc.
        }
        getTexture(resourceName) {
            if (this.cachedResources.has(resourceName)) {
                return this.cachedResources.get(resourceName);
            }
            else {
                const rawTexture = this.app.loader.resources[resourceName].texture;
                if (rawTexture === undefined) {
                    return undefined;
                }
                else {
                    const texture = new PixiTexture_2.PixiTexture(this.app.loader.resources[resourceName].texture, this);
                    this.cachedResources.set(resourceName, texture);
                    return texture;
                }
            }
        }
        flushTexture(texture) {
            if (this.app.renderer instanceof PIXI.Renderer) {
                this.app.renderer.texture.updateTexture(texture.baseTexture.pixi());
            }
            else {
                // Nothing to do
            }
        }
        // Render object factories - Text
        newTextStyle() {
            return new PixiTextStyle_2.PixiTextStyle(new PIXI.TextStyle({}), this);
        }
        // Render object factories - Display objects
        newDisplayObjectContainer() {
            return new PixiDisplayObjectContainer_3.PixiDisplayObjectContainer(new PIXI.Container(), this);
        }
        newGraphicsObject() {
            return new PixiGraphicsObject_1.PixiGraphicsObject(new PIXI.Graphics(), this);
        }
        newSpriteObject(texture) {
            return new PixiSpriteObject_2.PixiSpriteObject(new PIXI.Sprite(texture === undefined ? undefined : texture.pixi()), this);
        }
        newTextObject(text, scaleFactor, style) {
            if (scaleFactor === undefined || scaleFactor === 1.0) {
                return new PixiTextObject_2.PixiTextObject(new PIXI.Text(text, style === undefined ? undefined : JSON.parse(JSON.stringify(style.pixi()))), this);
            }
            else {
                return new PixiHighResTextObject_1.PixiHighResTextObject(new PIXI.Text(text, style === undefined ? undefined : JSON.parse(JSON.stringify(style.pixi()))), scaleFactor, this);
            }
        }
        newTexture(source, config) {
            return new PixiTexture_2.PixiTexture(new PIXI.Texture(new PIXI.BaseTexture(source)), this, config);
        }
        // Render object factories - Utils
        newMatrix(a, b, c, d, tx, ty) {
            return new PixiMatrix_2.PixiMatrix(new PIXI.Matrix(a, b, c, d, tx, ty), this);
        }
        newPoint(x, y) {
            return new PixiPoint_3.PixiPoint(new PIXI.Point(x, y), this);
        }
        newPointToPixiArray(path) {
            let pixiPoints = new Array();
            for (let i = 0; i < path.length; i++) {
                let point = path[i];
                pixiPoints.push(point.pixi());
            }
            return pixiPoints;
        }
        // WebGL specific
        get gl() {
            if (this.app.renderer instanceof PIXI.Renderer) {
                return this.app.renderer.gl;
            }
            else {
                throw new Error("PixiRenderer.gl called althoug WebGL is not used!");
            }
        }
        getWebGlState() {
            if (this.app.renderer instanceof PIXI.Renderer) {
                return {};
            }
            else {
                throw new Error("PixiRenderer.getWebGlState called althoug WebGL is not used!");
            }
        }
        /**
         * Loads the previous WebGL state into the renderer, if WebGL is used.
         *
         * @param previousState the previous WebGL state.
         * @throws an error, if WebGL is not used.
         */
        restoreWebGlState(previousState) {
            if (this.app.renderer instanceof PIXI.Renderer) {
                // Reset the WebGL renderer to use the previous shader program again
                // and to rebind the framebuffer and reset the viewport used before.
                this.app.renderer.reset();
                // We need to rebind the vertex array object, as it was set to null in the renderer reset.
                let state = this.app.renderer.state;
                if (state.nativeVaoExtension) {
                    state.nativeVaoExtension.bindVertexArrayOES(this.app.renderer._activeVao.nativeVao);
                }
            }
            else {
                throw new Error("PixiRenderer.restoreWebGlState called althoug WebGL is not used!");
            }
        }
        /**
         * Resets the WebGL renderer, if WebGL is used.
         */
        resetWebGlState() {
            if (this.app.renderer instanceof PIXI.Renderer) {
                // Reset the renderer to avoid working on VAOs from Pixi.
                this.app.renderer.reset();
            }
            else {
                throw new Error("PixiRenderer.resetWebGlState called althoug WebGL is not used!");
            }
        }
        getWebGlTexture(texture) {
            if (this.app.renderer instanceof PIXI.Renderer) {
                return texture.baseTexture.pixi()._glTextures[this.app.renderer.CONTEXT_UID].texture;
            }
            else {
                throw new Error("PixiRenderer.getWebGlTexture called althoug WebGL is not used!");
            }
        }
    }
    exports.PixiRenderer = PixiRenderer;
});
define("src/app/relution/RelutionMap", ["require", "exports", "src/engine/scene/GameObject", "src/map/FruityMap", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/BeaconMapObject", "src/engine/input/GestureRecognizer", "src/app/relution/view/world/Floor", "src/app/relution/modes/DeviceEditMode", "src/app/relution/modes/GeofenceEditMode", "src/app/relution/modes/RoomEditMode", "src/app/relution/modes/ZoneEditMode", "src/app/relution/view/world/RelutionMapWorld", "src/app/relution/view/hud/RelutionMapHud", "src/app/relution/utils/KeyUtils", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/AssetMapObject", "src/app/relution/modes/DeviceTaggingMode", "src/engine/scene/SceneObject", "src/app/relution/locale/LocalizationEn", "src/map/view/world/objects/WorldCamera", "src/app/relution/modes/SingleDeviceEditMode", "src/app/relution/modes/TapeMeasureEditMode", "src/rendering/pixi/PixiRenderer", "src/engine/rendering/Renderer", "src/map/utils/DeviceUtils"], function (require, exports, GameObject_5, FruityMap_1, BeaconMapObject_7, GestureRecognizer_7, Floor_2, DeviceEditMode_1, GeofenceEditMode_1, RoomEditMode_1, ZoneEditMode_1, RelutionMapWorld_1, RelutionMapHud_1, KeyUtils_1, AssetMapObject_4, DeviceTaggingMode_1, SceneObject_14, LocalizationEn_1, WorldCamera_3, SingleDeviceEditMode_1, TapeMeasureEditMode_1, PixiRenderer_1, Renderer_3, DeviceUtils_30) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RelutionMap = void 0;
    /**
     * The Relution map is a map application that is based on the FruityMap engine.
     *
     * <p>
     * It is used to display sites, beacons, assets, geofences and other site
     * specific elements in Relution. The FruityMap engine is used as a base layer
     * to manage rendering, scene graph construction, input event handling and
     * camera dynamics.
     * </p>
     *
     * <p>
     * The map basically contains two scenes:
     * </p>
     * <h3>1. Relution World</h3>
     * This scene contains a camera that can be moved both kinematically and dynamically (by applying impulses/forces).
     * All views inside the Relution world scene use world coordinates that correspond with the texels of the corresponding floorplan.
     * The Relution world builds up a highly nested view hierarchy, containing floors, and layers inside.
     * The leaf elements of this tree are mostly Relution map objects (e.g. beacons, geofences) and their corresponding
     * Relution map object attributes (e.g. beacon connections, ranges etc.).
     *
     * <h3>2. Relution HUD</h3>
     * This scene contains all the elements that should not move with the world camera. Thus, it uses its own static camera.
     * This scene is build up of many layers, like the selection layer that creates a selection rectangle, used for
     * selecting Relution map objects.
     *
     * <h3>Relution Map modes</h3>
     * <p>
     * The map can be set to a specific mode, e.g. device edit mode, geofence edit mode, tape measure edit mode etc.
     * Notice, that enabling a mode, will disable all other modes before, i.e. modes are mutually exclusive, as they
     * configure the the layers in the scenes by their demands. Combining multiple modes is currently not supported.
     * </p>
     */
    class RelutionMap {
        // Construction
        /**
         * Creates a new Relution map.
         * @param options See RelutionMap.Options for more information
         * @param floor The Relution map requires at least on floor. You must instantiate a floor first,
         * before you can create a Relution map.
         * @param initializedCallback This callback will be called, after the Relution Map has been initialized.
         * The initialization of the Relution Map includes creating a WebGL canvas, initializing the game and rendering engine,
         * building up the Relution World and Relution HUD scenes.
         */
        constructor(options) {
            // Configuration
            this.config = new RelutionMap.Options();
            // Observation
            this.observers = new Array();
            // Modes
            this.modes = new Array();
            this.config = options;
            this.initDeviceType();
            this.environment = this.initEnvironment();
        }
        initDeviceType() {
            if (!this.config.mobileDeviceAutoDetectionEnabled) {
                DeviceUtils_30.DeviceUtils.isMobile = this.config.isMobileDevice;
            }
        }
        initEnvironment() {
            let environment = new RelutionMap.Environment();
            environment.scene.renderer = new PixiRenderer_1.PixiRenderer(this.config.renderer);
            environment.scene.localization = this.config.localization;
            return environment;
        }
        /**
         * Creates a floor with name ```floorName``` and model ```floorModel```.
         * The config parameter is optional. If the config is null, the default floor configuration
         * specified in the building configuration will be used. If the config is not null, the default
         * floor configuration will be overridden by this one.
         * @param floorName
         * @param floorModel
         * @param config
         */
        createFloor(floorName, floorModel, config = null) {
            if (config === null) {
                config = this.config.world.building.floor;
            }
            let floor = new Floor_2.Floor(this.environment.scene, floorName, floorModel, config);
            return floor;
        }
        /**
         * Initializes the map. This loads all textures into the GPU and starts the rendering loop.
         * @param floor
         * @param initializedCallback
         */
        load(floor, initializedCallback) {
            // Create options
            let fruityMapOptions = new FruityMap_1.FruityMap.Options();
            fruityMapOptions.parentHtmlElement = this.config.parentHtmlElement;
            fruityMapOptions.camera = this.config.camera;
            fruityMapOptions.preloadingImages = this.getPreloadingImages(this.config.pathToImages);
            // Create map
            this.fruityMap = new FruityMap_1.FruityMap(fruityMapOptions, this.environment, () => {
                this.registerForInteractionEvents();
                this.initWorldLayers(floor);
                this.initHudLayers();
                this.initModes();
                this.addVisibilityObservers();
                initializedCallback();
            });
        }
        getPreloadingImages(pathToImages) {
            let images = [];
            let preloadingImageNames = this.getPreloadingImageNames();
            for (let i = 0; i < preloadingImageNames.length; i++) {
                let name = preloadingImageNames[i];
                images.push(this.getPreloadingImage(name, pathToImages));
            }
            return images;
        }
        // @Override
        getPreloadingImageNames() {
            return [
                "compass",
                "plus_normal",
                "minus_normal",
                "pan_center",
                "pan_down",
                "pan_up",
                "pan_left",
                "pan_right",
                "beacon_white",
                "gateway_white",
                "range",
                "asset_device_white",
                "asset_device_fixed_white",
                "bacnet_white",
                "knx_white",
                "arrow_head",
                "arrow_head_transparent",
                "arrow_body"
            ];
        }
        getPreloadingImage(imageName, pathToImages) {
            return { resourceName: imageName, url: "" + pathToImages + "" + imageName + ".png" };
        }
        registerForInteractionEvents() {
            let that = this;
            this.fruityMap.addScenelessGameObject(new class extends GameObject_5.GameObject {
                constructor(environment) {
                    super(environment);
                }
                // @Override
                onKeyDown(keyCode) {
                    super.onKeyDown(keyCode);
                    that.updateEditMode();
                    that.changeFloorIfNecessary(keyCode);
                    that.updateLayerVisibility(keyCode);
                    return false;
                }
                // @Override
                onKeyUp(keyCode) {
                    super.onKeyUp(keyCode);
                    that.updateEditMode();
                    return false;
                }
                // @Override
                onMouseMove(x, y) {
                    super.onMouseMove(x, y);
                    // This event is used to disable edit mode if key up event
                    // was lost, because the user moved out of the window while
                    // holding the edit button.
                    that.updateEditMode();
                    return false;
                }
            }(this.fruityMap.getEnvironment()));
        }
        initWorldLayers(floor) {
            let world = this.fruityMap.getWorld();
            this.relutionMapWorld = new RelutionMapWorld_1.RelutionMapWorld(this.config.world, this.fruityMap.getEnvironment(), world, floor);
            world.addLayer(this.relutionMapWorld);
            this.relutionMapWorld.getBuilding().addRelutionMapObjectObserver(this);
        }
        initHudLayers() {
            let hud = this.fruityMap.getHud();
            this.relutionMapHud = new RelutionMapHud_1.RelutionMapHud(this.config.hud, this.fruityMap.getEnvironment(), this.relutionMapWorld);
            this.config.world.building.layerVisibilities.forEach((visible, layerName) => {
                const layer = this.relutionMapHud.getLayerByName(layerName);
                const setEnabled = layer === null || layer === void 0 ? void 0 : layer['setEnabled'];
                if (setEnabled instanceof Function) {
                    setEnabled.call(layer, visible);
                }
            });
            hud.addLayer(this.relutionMapHud);
            this.relutionMapHud.selectionLayer.addObserver(this);
            this.relutionMapHud.popupLayer.addObserver(this);
            this.relutionMapHud.barLayer.getDeviceBar().addObserver(this);
        }
        initModes() {
            // Device edit mode
            this.deviceEditMode = new DeviceEditMode_1.DeviceEditMode(this.relutionMapWorld, this.relutionMapHud);
            this.modes.push(this.deviceEditMode);
            // Single device edit mode
            this.singleDeviceEditMode = new SingleDeviceEditMode_1.SingleDeviceEditMode(this.relutionMapWorld, this.relutionMapHud);
            this.modes.push(this.singleDeviceEditMode);
            if (this.config.world.building.floor.singleDeviceEditLayer.enabled) {
                this.singleDeviceEditMode.setEditableDevice(this.config.world.building.floor.singleDeviceEditLayer.editableDeviceUuid);
                this.singleDeviceEditMode.setEnabled(this.config.world.building.floor.singleDeviceEditLayer.enabled);
            }
            // Geofence edit mode
            this.geofenceEditMode = new GeofenceEditMode_1.GeofenceEditMode(this.relutionMapWorld, this.relutionMapHud);
            this.modes.push(this.geofenceEditMode);
            // Room edit mode
            this.roomEditMode = new RoomEditMode_1.RoomEditMode(this.relutionMapWorld, this.relutionMapHud);
            this.modes.push(this.roomEditMode);
            // Room edit mode
            this.zoneEditMode = new ZoneEditMode_1.ZoneEditMode(this.relutionMapWorld, this.relutionMapHud);
            this.modes.push(this.zoneEditMode);
            // Device tagging mode
            this.deviceTaggingMode = new DeviceTaggingMode_1.DeviceTaggingMode(this.relutionMapWorld, this.relutionMapHud);
            this.modes.push(this.deviceTaggingMode);
            // Tape measure edit mode
            this.tapeMeasureEditMode = new TapeMeasureEditMode_1.TapeMeasureEditMode(this.relutionMapWorld, this.relutionMapHud);
            if (this.config.world.building.floor.tapeMeasureLayer.editModeEnabled) {
                this.tapeMeasureEditMode.setEnabled(this.config.world.building.floor.tapeMeasureLayer.editModeEnabled);
            }
            this.modes.push(this.tapeMeasureEditMode);
        }
        addVisibilityObservers() {
            this.relutionMapHud.helpLayer.addVisiblityObserver(this);
        }
        // Destruction
        /**
         * In single page applications, it is necessary to completely destroy the map, whenever
         * the user changes the page and the map should be reloaded. A map destruction will release
         * all textures from the GPU and unregister all observers.
         */
        destroy() {
            if (this.fruityMap) {
                this.unregisterAsObserver();
                this.unregisterVisibilityObservers();
                this.fruityMap.destroy();
            }
        }
        unregisterAsObserver() {
            var _a, _b, _c, _d, _e;
            if (this.relutionMapHud) {
                (_a = this.relutionMapHud.selectionLayer) === null || _a === void 0 ? void 0 : _a.removeObserver(this);
                (_b = this.relutionMapHud.popupLayer) === null || _b === void 0 ? void 0 : _b.removeObserver(this);
                (_d = (_c = this.relutionMapHud.barLayer) === null || _c === void 0 ? void 0 : _c.getDeviceBar()) === null || _d === void 0 ? void 0 : _d.removeObserver(this);
            }
            if (this.relutionMapWorld) {
                (_e = this.relutionMapWorld.getBuilding()) === null || _e === void 0 ? void 0 : _e.removeRelutionMapObjectObserver(this);
            }
        }
        unregisterVisibilityObservers() {
            if (this.relutionMapHud) {
                this.relutionMapHud.helpLayer.removeVisibilityObserver(this);
            }
        }
        // Observation
        /**
         * Adds an observer to the list of observers. The observer will
         * get informed about all map events.
         * @param observer
         */
        addObserver(observer) {
            this.observers.push(observer);
        }
        notifyObservers(callback, args) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Time
        /**
         *
         * Configures the map animation.
         * @param startTimeInSec The start time of the animation given as a UNIX timestamp (in seconds).
         * @param endTimeInSec The end time of the animation given as a UNIX timestamp (in seconds).
         * @param durationInMs The duration of the animation (in milliseconds).
         * @param progressCallback A callback that will be called, whenever the progress changes.
         */
        setAnimationConfiguration(startTimeInSec, endTimeInSec, durationInMs, progressCallback) {
            this.fruityMap.setAnimationConfiguration(startTimeInSec, endTimeInSec, durationInMs, progressCallback);
        }
        /**
         * Returns the current animation configuration.
         */
        getAnimationConfiguration() {
            return this.fruityMap.getAnimationConfiguration();
        }
        /**
         * Starts the map animation starting with the start time given in the
         * animation's configuration.
         */
        startAnimation() {
            this.fruityMap.startAnimation();
        }
        /**
         * Stops the map animation.
         */
        stopAnimation() {
            this.fruityMap.stopAnimation();
        }
        /**
         * Pauses the map animation.
         */
        pauseAnimation() {
            this.fruityMap.pauseAnimation();
        }
        /**
         * Resumes the map animation.
         */
        resumeAnimation() {
            this.fruityMap.resumeAnimation();
        }
        /**
         * Sets the animation progress to the passed argument.
         * @param progress the animation progress in [0,1].
         */
        seekAnimation(progress) {
            this.fruityMap.seekAnimation(progress);
        }
        // Locale
        /**
         * Sets the map's locale to the passed argument
         * @param localization E.g. an instance of LocalizationDe or LocalizationEn
         */
        setLocalization(localization) {
            this.fruityMap.setLocalization(localization);
        }
        // Layers
        supportsLayerVisibility(layerName) {
            const building = this.relutionMapWorld.getBuilding();
            const floor = building.getCurrentFloor();
            return (floor || building).supportsLayerVisibility(layerName);
        }
        /**
         * Toggles the visibility of the given layer.
         *
         * @param layerName The layer's name. Possible values are:
         * "help": The layer containing the quick guide (tutorial).
         * "devices" The layer holding all devices (and their corresponding attributes)
         * "ranges": The beacon range layer
         * "info": The beacon info layer
         * "connections": The beacon connection layer
         * "tracking": The device tracking layer (position estimate paths for the assets).
         * "userCountHeatmap": The heatmap layer for the user count measurements.
         * "geofence": The geofence layer
         * @param enabled Optional argument. If it is missing the layer visibility will be toggled.
         * Otherwise the layer will be set visible, if "true" is passed, invisible, if the value is "false".
         */
        toggleLayerVisibility(layerName, enabled) {
            const layer = this.relutionMapHud.getLayerByName(layerName);
            if (layer) {
                this.toggleLayer(layer, enabled);
            }
            else {
                this.relutionMapWorld.getBuilding().toggleLayerVisibility(layerName, enabled);
            }
        }
        toggleLayer(layer, enabled) {
            if (enabled == null) {
                layer.animateVisible(!layer.isVisible());
            }
            else {
                layer.animateVisible(enabled);
            }
        }
        // @Override
        visibilityChanged(layer) {
            if (layer == this.relutionMapHud.helpLayer) {
                let layerName = "help";
                let layerVisible = layer.isVisible();
                this.notifyObservers("onLayerVisibilityChanged", [layerName, layerVisible]);
            }
        }
        // Relution map objects
        supportsObjectTypeVisibility(objectType, filter) {
            const building = this.relutionMapWorld.getBuilding();
            const floor = building.getCurrentFloor();
            return (floor || building).supportsObjectTypeVisibility(objectType, filter);
        }
        /**
         * Toggles the visibility of all RelutionMap objects of type "objectType".
         * @param objectType the constructor function of the object type whose visibility should be changed, e.g. Beacon, Asset etc.
         * @param visible a flag indicating whether the object type should be visible (true) or not (false).
         */
        toggleRelutionMapObjectTypeVisibility(objectType, visible, notifyObservers = false) {
            this.relutionMapWorld.getBuilding().toggleRelutionMapObjectTypeVisibility(objectType, visible, notifyObservers);
        }
        toggleRelutionMapObjectTypeVisibilityWithNotification(objectType, visible) {
            this.relutionMapWorld.getBuilding().toggleRelutionMapObjectTypeVisibility(objectType, visible, true);
        }
        /**
         * Sets the info labels of all Relution map objects that are type compatible with the {@code objectType} type to {@link visible}.
         *
         * <p>
         * By default, the info labels of all {@link RelutionMapObject} types are set to visible. To actually see the infos, however,
         * the info layers visibility must be set to true, as well. Notice, that this function also considers the type hierarchy. By
         * default, the visibility of all subtypes of {@link RelutionMapObject} is set to true. To make the infos of objects of a concrete subclass
         * visible, the visibilities of all object types the object is substitutable must be set to true (or left to the default value).
         * </p>
         *
         * <p>
         * Example: Setting the visibility of {@link Device} to true, will make all infos attached to devices visible. If setting the visibility
         * of {@link Beacon} to false, only non-beacon devices will be visible after calling this function.
         * </p>
         *
         * @param objectType the constructor function of a subclass of {@link RelutionMapObject}, e.g. Device or Geofence
         * @param visible true, if all objects of the given type and its subtypes should be permanently visible.
         */
        toggleRelutionMapObjectInfoVisibility(objectType, visible) {
            this.relutionMapWorld.getBuilding().toggleRelutionMapObjectInfoVisibility(objectType, visible);
        }
        // Event-Handling
        // Events: World and HUD
        // @Override
        onDeviceEnteredWorld() {
            this.setEditModeActive(true);
        }
        // @Override
        onDeviceLeftWorld() {
            this.setEditModeActive(false);
        }
        // @Override
        onUserStoppedMovingDevice() {
            this.setEditModeActive(false);
        }
        // @Override
        onUserMovedDevice(device) {
            this.notifyObservers("onUserMovedDevice", [device]);
        }
        // @Override
        onObjectSelected(object) {
            this.notifyObservers("onObjectSelected", [object]);
        }
        // @Override
        onObjectUnselected(object) {
            this.notifyObservers("onObjectUnselected", [object]);
        }
        // @Override
        onObjectDoubleClicked(object) {
            this.notifyObservers("onObjectDoubleClicked", [object]);
        }
        // @Override
        onObjectClicked(object) {
            this.notifyObservers("onObjectClicked", [object]);
        }
        // @Override
        onObjectHovering(object, x, y) {
            this.notifyObservers("onObjectHovering", [object, x, y]);
        }
        // Beacon adding/removing
        // @Override
        onObjectMovedToMap(beacon) {
            this.notifyObservers("onObjectMovedToMap", [beacon]);
        }
        // @Override
        onObjectMovedToStock(beacon) {
            this.notifyObservers("onObjectMovedToStock", [beacon]);
        }
        // Object type visibility
        // @Override
        onObjectTypeVisibilityChanged(objectType, visible) {
            this.notifyObservers("onObjectTypeVisibilityChanged", [objectType, visible]);
        }
        // Layer visibility
        // @Override
        onLayerVisibilityChanged(layerName, visible) {
            this.notifyObservers("onLayerVisibilityChanged", [layerName, visible]);
        }
        // Event-Handling: Key events
        changeFloorIfNecessary(keyCode) {
            const arrowUpKeyCode = 38;
            const arrowDownKeyCode = 40;
            if (GestureRecognizer_7.GestureRecognizer.isCtrlPressed()) {
                if (keyCode === arrowUpKeyCode) {
                    this.getBuilding().changeToUpperFloor();
                }
                else if (keyCode === arrowDownKeyCode) {
                    this.getBuilding().changeToLowerFloor();
                }
            }
        }
        updateLayerVisibility(keyCode) {
            if (keyCode === KeyUtils_1.KeyUtils.getKeyCodeForNumberKey(1)) {
                this.toggleLayerVisibility("help");
            }
            else if (keyCode === KeyUtils_1.KeyUtils.getKeyCodeForNumberKey(2)) {
                this.toggleLayerVisibility("wallplan");
            }
            else if (keyCode === KeyUtils_1.KeyUtils.getKeyCodeForNumberKey(3)) {
                this.toggleLayerVisibility("devices");
            }
            else if (keyCode === KeyUtils_1.KeyUtils.getKeyCodeForNumberKey(4)) {
                this.toggleLayerVisibility("geofence");
            }
            else if (keyCode === KeyUtils_1.KeyUtils.getKeyCodeForNumberKey(5)) {
                this.toggleRelutionMapObjectTypeVisibilityWithNotification(BeaconMapObject_7.BeaconMapObject);
            }
            else if (keyCode === KeyUtils_1.KeyUtils.getKeyCodeForNumberKey(6)) {
                this.toggleRelutionMapObjectTypeVisibilityWithNotification(AssetMapObject_4.AssetMapObject);
            }
            else if (keyCode === KeyUtils_1.KeyUtils.getKeyCodeForNumberKey(7)) {
                this.toggleLayerVisibility("info");
            }
            else if (keyCode === KeyUtils_1.KeyUtils.getKeyCodeForNumberKey(8)) {
                this.toggleLayerVisibility("ranges");
            }
            else if (keyCode === KeyUtils_1.KeyUtils.getKeyCodeForNumberKey(9)) {
                this.toggleLayerVisibility("connections");
            }
            else if (keyCode === KeyUtils_1.KeyUtils.getKeyCodeForNumberKey(0)) {
                this.toggleLayerVisibility("tracking");
            }
        }
        updateEditMode() {
            if (GestureRecognizer_7.GestureRecognizer.isAltPressed()) {
                this.setEditModeActive(true);
            }
            else if (this.isEditModeActive() && !GestureRecognizer_7.GestureRecognizer.isAltPressed()) {
                this.setEditModeActive(false);
            }
        }
        // Modes
        /**
         * Returns true, if the edit mode is currently active.
         */
        isEditModeActive() {
            return this.relutionMapWorld.getBuilding().isEditModeActive();
        }
        /**
         * Sets the edit mode to active, if true was passed.
         * @param editModeActive
         */
        setEditModeActive(editModeActive) {
            if (!this.isDeviceEditModeEnabled()) {
                this.relutionMapWorld.getBuilding().setEditModeActive(editModeActive);
            }
        }
        /**
         * Enables/disables the geofence edit mode.
         *
         * <p>
         * In the geofence edit mode, geofences can be moved on the map. Moreover,
         * the shape of the geofences can be edited.
         * </p>
         *
         * @param enabled
         */
        setGeofenceEditModeEnabled(enabled) {
            if (enabled) {
                this.disableAllModes();
            }
            this.geofenceEditMode.setEnabled(enabled);
        }
        /**
         * Returns true, if the geofence edit mode is enabled.
         */
        isGeofenceEditModeEnabled() {
            return this.geofenceEditMode.isEnabled();
        }
        /**
         * Enables/disables the room edit mode.
         *
         * <p>
         * In the room edit mode, room can be moved on the map. Moreover,
         * the shape of the room can be edited.
         * </p>
         *
         * @param enabled
         */
        setRoomEditModeEnabled(enabled) {
            if (enabled) {
                this.disableAllModes();
            }
            this.roomEditMode.setEnabled(enabled);
        }
        /**
         * Returns true, if the room edit mode is enabled.
         */
        isRoomEditModeEnabled() {
            return this.roomEditMode.isEnabled();
        }
        /**
         * Enables/disables the zone edit mode.
         *
         * <p>
         * In the zone edit mode, zone can be moved on the map. Moreover,
         * the shape of the zone can be edited.
         * </p>
         *
         * @param enabled
         */
        setZoneEditModeEnabled(enabled) {
            if (enabled) {
                this.disableAllModes();
            }
            this.zoneEditMode.setEnabled(enabled);
        }
        /**
         * Returns true, if the zone edit mode is enabled.
         */
        isZoneEditModeEnabled() {
            return this.zoneEditMode.isEnabled();
        }
        /**
         * Enables/disables the device edit mode.
         *
         * <p>
         * In the device edit mode, devices can be moved on the map. Moreover, the
         * beacon bar is enabled in this mode making it possible to move beacon from
         * the stock into the map and vice versa.
         * </p>
         *
         * @param deviceEditModeEnabled
         */
        setDeviceEditModeEnabled(enabled) {
            if (enabled) {
                this.disableAllModes();
            }
            this.deviceEditMode.setEnabled(enabled);
        }
        /**
         * Returns true, if the device edit mode is enabled.
         */
        isDeviceEditModeEnabled() {
            return this.deviceEditMode.isEnabled();
        }
        /**
         * Enables/disables the single device edit mode.
         *
         * <p>
         * This edit mode supports only editing one specific device. All other
         * devices will be locked.
         * </p>
         *
         * @param enabled true, if the edit mode should be enabled
         */
        setSingleDeviceEditModeEnabled(enabled, deviceUuid) {
            if (enabled) {
                this.disableAllModes();
            }
            this.singleDeviceEditMode.setEditableDevice(deviceUuid);
            this.singleDeviceEditMode.setEnabled(enabled);
        }
        /**
         * @see [[setSingleDeviceEditModeEnabled]]
         */
        isSingleDeviceEditModeEnabled() {
            return this.singleDeviceEditMode.isEnabled();
        }
        /**
         * Enables the tagging mode. In tagging mode the user can
         * move devices to their "real" positions which is used
         * to calibrate the indoor positioning system.
         * @param enabled
         */
        setDeviceTaggingModeEnabled(enabled) {
            if (enabled) {
                this.disableAllModes();
            }
            this.deviceTaggingMode.setEnabled(enabled);
        }
        /**
         * Returns true, if the tagging mode is enabled.
         */
        isTaggingModeEnabled() {
            return this.deviceTaggingMode.isEnabled();
        }
        /**
         * Sets the tape measure edit mode to enabled/disabled.
         *
         * <p>
         * The tape measure edit mode makes it possible to create a rectangular tape
         * measure showing the width and height and the diagonal length of the tape
         * measure. The rectangle can be created by sequentially tapping on two
         * positions on the map. A third tap will remove the tape measure rectangle.
         * Moreover, in the edit mode, it is possible to drag and drop the corners
         * of the rectangle. When leaving the edit mode, editing the corners is not
         * possible anymore. Hence, the tape measure rectangle is fixed.
         * </p>
         *
         * <p>
         * Notice, that leaving the tape measure edit mode will not make the tape
         * measure invisible. Only editing the tape measure rectangle is not
         * possible anymore.
         * </p>
         *
         * @param enabled true, if the tape measure edit mode should be enabled.
         */
        setTapeMeasureEditModeEnabled(enabled) {
            if (enabled) {
                this.disableAllModes();
            }
            this.tapeMeasureEditMode.setEnabled(enabled);
        }
        /**
         * Returns true, if the tape measure edit mode is enabled.
         *
         * @see [[RelutionMap#setTapeMeasureEditModeEnabled]]
         */
        isTapeMeasureEditModeEnabled() {
            return this.tapeMeasureEditMode.isEnabled();
        }
        disableAllModes() {
            for (let i = 0; i < this.modes.length; i++) {
                const mode = this.modes[i];
                if (mode.isEnabled()) {
                    mode.setEnabled(false);
                }
            }
        }
        // Rendering
        /**
         * Resizes the map's canvas to the specified width and height
         * @param width The target width (in pixels)
         * @param height The target height (in pixels)
         */
        setSize(width, height) {
            if (this.getWidth() !== width || this.getHeight() !== height) {
                this.fruityMap.setCanvasSize(width, height);
            }
        }
        /**
         * Returns the current canvas width of the map (in pixels).
         */
        getWidth() {
            return this.fruityMap.getCanvasWidth();
        }
        /**
         * Returns the current canvas height of the map (in pixels).
         */
        getHeight() {
            return this.fruityMap.getCanvasHeight();
        }
        /**
         * reposition camera such that an AABB is entirely visible.
         *
         * @param aabb of interest in normalized coordinates.
         */
        zoomIn(aabb) {
            const floorSize = this.getBuilding().getCurrentFloor().getFloorplanLayer().getFloorSize();
            aabb.min.x *= floorSize.x;
            aabb.min.y *= floorSize.y;
            aabb.max.x *= floorSize.x;
            aabb.max.y *= floorSize.y;
            this.fruityMap.getCamera().zoomIn(aabb);
        }
        // State
        /**
         * Pauses the map rendering and event handling
         */
        pause() {
            this.fruityMap.pause();
        }
        resume() {
            this.fruityMap.resume();
        }
        // Diagnosis
        getCurrentFrameTimeMs() {
            return this.fruityMap.getCurrentFrametimeInMs();
        }
        setDebugText(debugText) {
            this.relutionMapHud.getDebugLayer().setDebugText(debugText);
        }
        // Getters and setters
        getConfig() {
            return this.config;
        }
        /**
         * Returns the Relution map's building.
         */
        getBuilding() {
            return this.relutionMapWorld.getBuilding();
        }
    }
    exports.RelutionMap = RelutionMap;
    (function (RelutionMap) {
        /**
         * The options must be passt to the RelutionMaps constructor.
         */
        class Options {
            constructor() {
                // General
                // Rendering
                /**
                 * The configuration of the renderer
                 */
                this.renderer = new Renderer_3.Renderer.Config();
                // Localization
                /**
                 * The initial localization for english or german
                 * text translations.
                 * E.g. LocalizationDe or LocalizationEn
                 */
                this.localization = new LocalizationEn_1.LocalizationEn();
                // Device type
                /**
                 * True, if mobile device detection should be done automatically.
                 */
                this.mobileDeviceAutoDetectionEnabled = true;
                /**
                 * True, if the map is displayed on a mobile device.
                 *
                 * <p>
                 * This field is only considered, if auto mobile device detection
                 * is turned off.
                 * </p>
                 */
                this.isMobileDevice = false;
                // Camera
                /**
                 * Configuration of the world camera.
                 */
                this.camera = new WorldCamera_3.WorldCamera.Config();
                // HUD
                /**
                 * Config of the Relution map HUD.
                 */
                this.hud = new RelutionMapHud_1.RelutionMapHud.Config();
                // World
                /**
                 * Config of the Relution map world
                 */
                this.world = new RelutionMapWorld_1.RelutionMapWorld.Config();
            }
        }
        RelutionMap.Options = Options;
        class Environment {
            constructor() {
                this.scene = new SceneObject_14.SceneObject.Environment();
            }
        }
        RelutionMap.Environment = Environment;
    })(RelutionMap = exports.RelutionMap || (exports.RelutionMap = {}));
});
define("src/app/portal/PortalMap", ["require", "exports", "src/app/relution/RelutionMap"], function (require, exports, RelutionMap_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PortalMap = void 0;
    class PortalMap extends RelutionMap_1.RelutionMap {
    }
    exports.PortalMap = PortalMap;
    (function (PortalMap) {
        class Options extends RelutionMap_1.RelutionMap.Options {
        }
        PortalMap.Options = Options;
    })(PortalMap = exports.PortalMap || (exports.PortalMap = {}));
});
define("src/app/relution/events/RelutionEventSystem", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RelutionEventSystem = void 0;
    /**
     * The relution event system is used as the observer-mediator for decoupled event communication
     * between scene objects inside the relution map.
     *
     * Publish-Subscribe event system:
     * The event communication is based on a publish-subscribe mechanism.
     *
     * Event stickiness
     * Scene objects that are created at a later time, however, may miss important events,
     * like a change in the map mode. Thus, all events are "sticky, i.e. we always
     * provide getters and setters for the events so that subscribers may fetch the event
     * at a later time.
     *
     * @export
     * @class RelutionEventSystem
     */
    class RelutionEventSystem {
        // Construction
        constructor() {
            // Subscribers
            this.subscriptions = new Array();
            // Private -> Singleton
        }
        static getInstance() {
            if (RelutionEventSystem.instance == null) {
                RelutionEventSystem.instance = new RelutionEventSystem();
            }
            return RelutionEventSystem.instance;
        }
        // Subscription
        subscribe(eventName, subscriber) {
            if (!this.existsSubscription(eventName, subscriber)) {
                let subscription = new RelutionEventSystem.Subscription(eventName, subscriber);
                this.subscriptions.push(subscription);
            }
        }
        unsubscribe(eventName, subscriber) {
            let index = this.getIndexOfSubscription(eventName, subscriber);
            if (index > -1) {
                this.subscriptions.splice(index, 1);
            }
        }
        existsSubscription(eventName, subscriber) {
            return this.getIndexOfSubscription(eventName, subscriber) > -1;
        }
        getIndexOfSubscription(eventName, subscriber) {
            for (let i = 0; i < this.subscriptions.length; i++) {
                let subscription = this.subscriptions[i];
                if (subscription.eventName === eventName && subscription.subscriber === subscriber) {
                    return i;
                }
            }
            return -1;
        }
        // Publication
        publish(eventName) {
            for (let i = 0; i < this.subscriptions.length; i++) {
                let subscription = this.subscriptions[i];
                if (subscription.eventName === eventName) {
                    this.publishEventToSubscriber(eventName, subscription.subscriber);
                }
            }
        }
        publishEventToSubscriber(eventName, subscriber) {
            if (subscriber !== null) {
                const prefix = "onRelution";
                const callbackName = prefix + eventName;
                if (typeof subscriber["" + callbackName] === "function") {
                    subscriber["" + callbackName].apply(subscriber, []);
                }
            }
        }
        publishEventForProperty(propertyName) {
            this.publish(propertyName + "Changed");
        }
    }
    exports.RelutionEventSystem = RelutionEventSystem;
    // Singleton instance
    RelutionEventSystem.instance = null;
    (function (RelutionEventSystem) {
        class Subscription {
            constructor(eventName, subscriber) {
                this.eventName = eventName;
                this.subscriber = subscriber;
            }
        }
        RelutionEventSystem.Subscription = Subscription;
    })(RelutionEventSystem = exports.RelutionEventSystem || (exports.RelutionEventSystem = {}));
});
define("src/app/relution/locale/LocalizationDe", ["require", "exports", "src/engine/locale/Localization"], function (require, exports, Localization_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocalizationDe = void 0;
    class LocalizationDe extends Localization_3.Localization {
        constructor() {
            super();
            this.mapping = [];
            this.defineLocalization();
        }
        defineLocalization() {
            // Help
            this.mapping["device_info_average_users"] =
                "Durchschnittliche Benutzerzahl";
            this.mapping["help_layer_mobile_device_description"] =
                "Zoomen: Pinch-Geste\n" +
                    "Rotieren: Pinch- und Rotieren-Geste\n" +
                    "Bewegen: Pan-Geste\n" +
                    "Geräteinformationen anzeigen: Klicken\n";
            this.mapping["help_layer_non_mobile_device_description"] =
                "Zoomen: Strg/Cmd + Mausrad\n" +
                    "Rotieren: Alt + Shift + Mausrad\n" +
                    "Bewegen: Strg/Cmd + Maus\n" +
                    "Auswählen: Maus\n" +
                    "Mehrfachauswahl: Shift + Maus\n" +
                    "Beacon bewegen: Alt + Shift + Maus\n" +
                    "Beacon ins Lager verschieben: Entf\n" +
                    "Ebenen ein-/ausschalten: 1-9";
            // Action Bar
            this.mapping["action_bar_show_help_action"] = "Hilfe anzeigen";
            this.mapping["action_bar_show_beacon_ranges_action"] = "Beaconkreise anzeigen";
            this.mapping["action_bar_show_connections_action"] = "Beaconverbindungen anzeigen";
            this.mapping["action_bar_show_beacon_infos_action"] = "Geräteinformationen anzeigen";
            this.mapping["action_bar_show_device_tracks_action"] = "Gerätespuren anzeigen";
            this.mapping["action_bar_show_heatmap_action"] = "Heatmap anzeigen";
            // Popup: General
            this.mapping["popup_time_unit_prefix"] = "vor ";
            this.mapping["popup_time_unit_postfix"] = "";
            this.mapping["popup_time_unit_year"] = "Jahr";
            this.mapping["popup_time_unit_years"] = "Jahren";
            this.mapping["popup_time_unit_month"] = "Monat";
            this.mapping["popup_time_unit_months"] = "Monaten";
            this.mapping["popup_time_unit_day"] = "Tag";
            this.mapping["popup_time_unit_days"] = "Tagen";
            this.mapping["popup_time_unit_hour"] = "h";
            this.mapping["popup_time_unit_hours"] = "h";
            this.mapping["popup_time_unit_minute"] = "min";
            this.mapping["popup_time_unit_minutes"] = "min";
            this.mapping["popup_time_unit_second"] = "s";
            this.mapping["popup_time_unit_seconds"] = "s";
            // Popup Layer: Device
            this.mapping["popup_device_name"] = "Name";
            this.mapping["popup_device_serial"] = "Seriennummer";
            this.mapping["popup_device_last_connected"] = "Zuletzt gemeldet";
            this.mapping["popup_device_node_id"] = "Node-ID";
            this.mapping["popup_device_version"] = "Beacon-Version";
            this.mapping["popup_device_meshgw_version"] = "MeshGateway-Version";
            this.mapping["popup_device_asset_id"] = "Asset-ID";
            this.mapping["popup_device_battery"] = "Batterie";
            this.mapping["popup_device_user_count"] = "Benutzerzahl";
            this.mapping["popup_device_sensor_description"] = "Sensorwert";
            this.mapping["popup_device_motion_state"] = "Bewegungszustand";
            this.mapping["popup_device_motion_state__MOVING"] = "in Bewegung";
            this.mapping["popup_device_motion_state__NON_MOVING"] = "in Ruhe";
            this.mapping["popup_device_zpos"] = "Height above floor";
            // Popup Layer: FloorElement
            this.mapping["popup_room_name"] = "Raum";
            this.mapping["popup_zone_name"] = "Zone";
            this.mapping["popup_floor_element_occupancy_average"] = "Durchschnitt";
            // Popup Layer: Geofence
            this.mapping["popup_geofence_name"] = "Name";
            this.mapping["popup_geofence_time_threshold"] = "Mindestverweildauer";
            this.mapping["popup_geofence_accuracy_threshold"] = "Benötigte Schätzgenauigkeit";
        }
        getLocalizedStringFor(placeholderString) {
            return this.mapping["" + placeholderString];
        }
    }
    exports.LocalizationDe = LocalizationDe;
});
define("src/app/relution/model/RelutionMapModelLoader", ["require", "exports", "src/map/utils/Logger", "src/app/relution/model/Model"], function (require, exports, Logger_7, Model_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RelutionMapModelLoader = void 0;
    /**
     * An object mapper that is able to deserialize/serialize JSON arrays/objects to arrays/objects of type @code{RelutionMapModel}.
     *
     * <h2>Model inheritance</h2>
     * <p>
     * The serialization/deserialization process considers both polymorphic structures,
     * if the model subclass is annotated correctly with @ModelTypeInfo and @ModelSubTypes decorators.
     * </p>
     *
     * <h2>Model composition</h2>
     * <p>
     * The serialization/deserialization process also considers compositions of @code{RelutionMapModel} objects.
     * This, however, requires the @ModelProperty annotated data field to pass an options, containing the correct class consturctor:
     * E.g.
     * </p>
     *
     * <p>
     * @ModelProperty({clazz: MySubModelClass})
     * private _x : MySubModelClass = 0;
     * </p>
     *
     * <p>
     * Moreover, you can also force the serialization/deserialization to cast to a specific type, e.g.:
     * </p>
     *
     * <p>
     * @ModelProperty({clazz: Number})
     * private _x : number = 0;
     * </p>
     *
     * If your model structure is flattened, you must use the {@code findInd} field in the options of @ModelProperty. E.g.
     *
     * <p>
     * @ModelProperty({findIn: "properties"})
     * private _x : number = 0;
     * </p>
     *
     * will map "jsonObject.properties.x" to model.x.
     *
     * @export
     * @class ModelLoader
     */
    class RelutionMapModelLoader {
        // Deserialization
        /**
         * Deserializes @code{jsonModels} and returns a list of models of the generic type @code{M}.
         * @param jsonModels An array containing models of type M
         * @param modelClassConstructor The constructor function to create models of type M
         * @param isPortalMode Set this value to true, if @code{jsonModels} is a collection from Relution portal.
         */
        static loadModels(jsonModels, modelClassConstructor, isPortalMode = false) {
            let models = Array();
            for (let i = 0; i < jsonModels.length; i++) {
                // Extract the object to be parsed.
                let jsonObject = jsonModels[i];
                // Load the model
                let model = RelutionMapModelLoader.loadModel(jsonObject, modelClassConstructor, isPortalMode);
                // Add object to array
                models.push(model);
            }
            return models;
        }
        static loadModel(jsonObject, modelClassConstructor, isPortalMode = false) {
            let object = null;
            if (isPortalMode) {
                object = jsonObject.attributes;
            }
            else {
                object = jsonObject;
            }
            let model = this.createInstanceOfCorrectSubclass(object, modelClassConstructor);
            this.assignJsonValuesToModel(object, model, isPortalMode);
            return model;
        }
        static createInstanceOfCorrectSubclass(jsonObject, modelClassConstructor) {
            // Load the subtype bindings by calling the default constructor
            let model = new modelClassConstructor(jsonObject);
            // Polymorphic deserialization if necessary.
            let typeFieldName = Model_12.Model.getTypeFieldForModelClass(modelClassConstructor);
            if (typeFieldName !== null) {
                if (jsonObject[typeFieldName] !== null && jsonObject[typeFieldName] !== undefined) {
                    let type = jsonObject[typeFieldName];
                    let subClassConstructor = Model_12.Model.getModelClassForType(type);
                    if (subClassConstructor !== null) {
                        model = new subClassConstructor(jsonObject);
                    }
                    else {
                        Logger_7.Logger.logDebug("Failed to map the type field \'" + typeFieldName
                            + "\'" + " with value \'" + type + "\' to a model class. Probably @ModelSubType is missing.");
                    }
                }
                else {
                    Logger_7.Logger.logDebug("Model could not be parsed. Type field \'"
                        + typeFieldName + "\' needed for polymorphic deserialization is missing.");
                }
            }
            return model;
        }
        static assignJsonValuesToModel(jsonObject, model, isPortalMode) {
            const classBindings = Model_12.Model.getPropertyBindingsForObject(model);
            for (let i = 0; i < classBindings.length; i++) {
                const classBinding = classBindings[i];
                for (let fieldName of Array.from(classBinding.propertyNameToOption.keys())) {
                    const propertyName = fieldName.substring(1, fieldName.length);
                    try {
                        const propertyOptions = classBinding.propertyNameToOption.get(fieldName);
                        if (propertyOptions !== undefined) {
                            const parentJsonObject = RelutionMapModelLoader.getParentJsonObject(jsonObject, propertyOptions);
                            if (propertyName in parentJsonObject && parentJsonObject[propertyName] !== null) {
                                RelutionMapModelLoader.assignJsonValueToModelProperty(propertyName, parentJsonObject, model, propertyOptions, isPortalMode);
                            }
                        }
                    }
                    catch (e) {
                        Logger_7.Logger.logDebug("Failed to deserialize model property \"" + propertyName + "\". " + e);
                    }
                }
            }
        }
        static getParentJsonObject(jsonObject, propertyOptions) {
            let object = jsonObject;
            if (propertyOptions.findIn !== undefined) {
                object = jsonObject[propertyOptions.findIn];
            }
            return object;
        }
        static assignJsonValueToModelProperty(propertyName, parentJsonObject, model, propertyOptions, isPortalMode) {
            if (propertyOptions.clazz !== undefined) {
                // Assignment with explicit casting
                if (propertyOptions.clazz === Number) {
                    if (typeof parentJsonObject[propertyName] === "string") {
                        model[propertyName] = Number.parseFloat(parentJsonObject[propertyName]);
                    }
                    else {
                        model[propertyName] = Number(parentJsonObject[propertyName]);
                    }
                }
                else if (propertyOptions.clazz === Boolean) {
                    if (typeof parentJsonObject[propertyName] === "string") {
                        model[propertyName] = parentJsonObject[propertyName] === "true" ? true : false;
                    }
                    else {
                        model[propertyName] = Boolean(parentJsonObject[propertyName]);
                    }
                }
                else {
                    if (Array.isArray(parentJsonObject[propertyName])) {
                        model[propertyName] = RelutionMapModelLoader.loadModels(parentJsonObject[propertyName], propertyOptions.clazz, isPortalMode);
                    }
                    else {
                        model[propertyName] = RelutionMapModelLoader.loadModel(parentJsonObject[propertyName], propertyOptions.clazz, isPortalMode);
                    }
                }
            }
            else {
                // Assignment with implicit casting
                if (Array.isArray(parentJsonObject[propertyName])) {
                    model[propertyName] = parentJsonObject[propertyName].slice();
                }
                else {
                    model[propertyName] = parentJsonObject[propertyName];
                }
            }
        }
        // Serialization
        /**
         * Synchronizes the 'jsonArray' with the Relution Map internal 'models'.
         * This method guarantees the jsonArray to have the same data field values as the ones contained in 'models'.
         * This method, however does not add or remove models from the JSON array!
         * @param models The Relution Map internal models
         * @param jsonArray A JSON array containing the models obtained from Relution.
         * @param isPortalMode True, if this method is called from Relution Portal
         */
        static syncModels(models, jsonArray, isPortalMode = false) {
            for (let i = 0; i < models.length; i++) {
                let model = models[i];
                let object = this.getJsonObjectForModel(model, jsonArray, isPortalMode);
                if (object !== null) {
                    this.syncModel(model, object, isPortalMode);
                }
            }
        }
        static getJsonObjectForModel(model, jsonArray, isPortalMode) {
            for (let i = 0; i < jsonArray.length; i++) {
                let jsonObject = jsonArray[i];
                let object = jsonObject;
                if (isPortalMode) {
                    object = jsonObject.attributes;
                }
                if (object.uuid === model.uuid) {
                    return jsonObject;
                }
            }
            return null;
        }
        static syncModel(model, jsonObject, isPortalMode = false) {
            let object = jsonObject;
            if (isPortalMode) {
                object = jsonObject.attributes;
            }
            this.assignModelPropertyValuesToJson(model, object, isPortalMode);
        }
        static assignModelPropertyValuesToJson(model, jsonObject, isPortalMode) {
            const classBindings = Model_12.Model.getPropertyBindingsForObject(model);
            for (let i = 0; i < classBindings.length; i++) {
                const classBinding = classBindings[i];
                for (let fieldName of Array.from(classBinding.propertyNameToOption.keys())) {
                    const propertyName = fieldName.substring(1, fieldName.length);
                    try {
                        const propertyOptions = classBinding.propertyNameToOption.get(fieldName);
                        if (propertyOptions !== undefined) {
                            const parentJsonObject = RelutionMapModelLoader.getParentJsonObject(jsonObject, propertyOptions);
                            if (propertyName in parentJsonObject) {
                                RelutionMapModelLoader.assignModelPropertyValueToJson(propertyName, parentJsonObject, model, propertyOptions, isPortalMode);
                            }
                        }
                    }
                    catch (e) {
                        Logger_7.Logger.logDebug("Failed to serialize model property \"" + propertyName + "\". " + e);
                    }
                }
            }
        }
        static assignModelPropertyValueToJson(propertyName, parentJsonObject, model, propertyOptions, isPortalMode) {
            if (propertyOptions.clazz !== undefined) {
                // Assignment with explicit casting
                if (propertyOptions.clazz === Number) {
                    if (typeof model[propertyName] === "string") {
                        parentJsonObject[propertyName] = Number.parseFloat(model[propertyName]);
                    }
                    else {
                        parentJsonObject[propertyName] = Number(model[propertyName]);
                    }
                }
                else if (propertyOptions.clazz === Boolean) {
                    if (typeof model[propertyName] === "string") {
                        parentJsonObject[propertyName] = model[propertyName] === "true" ? true : false;
                    }
                    else {
                        parentJsonObject[propertyName] = Boolean(model[propertyName]);
                    }
                }
                else {
                    if (Array.isArray(model[propertyName])) {
                        RelutionMapModelLoader.syncModels(model[propertyName], parentJsonObject[propertyName], isPortalMode);
                    }
                    else {
                        RelutionMapModelLoader.syncModel(model[propertyName], parentJsonObject[propertyName], isPortalMode);
                    }
                }
            }
            else {
                // Assignment with implicit casting
                if (Array.isArray(model[propertyName])) {
                    parentJsonObject[propertyName] = model[propertyName].slice();
                }
                else {
                    parentJsonObject[propertyName] = model[propertyName];
                }
            }
        }
    }
    exports.RelutionMapModelLoader = RelutionMapModelLoader;
});
define("src/app/relution/model/floor/FloorModelLoader", ["require", "exports", "src/app/relution/model/floor/FloorModel", "src/app/relution/model/RelutionMapModelLoader"], function (require, exports, FloorModel_1, RelutionMapModelLoader_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FloorModelLoader = void 0;
    class FloorModelLoader {
        static loadFloor(options) {
            // 1. Workaround for the building structure migration.
            // If the floor is already part of the site, parse only the floor.
            let baseJsonObject = options.isPortalMode ? options.jsonObject.attributes : options.jsonObject;
            let jsonObject = ("floor" in baseJsonObject && baseJsonObject["floor"] != undefined) ? baseJsonObject["floor"] : baseJsonObject;
            // 2. Create a new floor model based on the fields inside the JSON object.
            let floorModel = RelutionMapModelLoader_1.RelutionMapModelLoader.loadModel(jsonObject, FloorModel_1.FloorModel, false);
            // 3. Add the image reference
            floorModel.floorplanImageUrl = options.pathToFloorplan;
            floorModel.wallplanImageUrl = options.wallplanUrl;
            if (options.floorplanOverlayNameToImageUrl === undefined) {
                floorModel.floorplanOverlayNameToImageUrl = new Map();
            }
            else {
                floorModel.floorplanOverlayNameToImageUrl = options.floorplanOverlayNameToImageUrl;
            }
            return floorModel;
        }
    }
    exports.FloorModelLoader = FloorModelLoader;
    (function (FloorModelLoader) {
        class Options {
            constructor() {
                this.wallplanUrl = null;
                this.floorplanOverlayNameToImageUrl = new Map();
                this.isPortalMode = false;
            }
        }
        FloorModelLoader.Options = Options;
    })(FloorModelLoader = exports.FloorModelLoader || (exports.FloorModelLoader = {}));
});
define("src/app/relution/utils/ReflectionUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReflectionUtils = void 0;
    class ReflectionUtils {
        static getAllPropertyNames(obj) {
            let props = [];
            do {
                Object.getOwnPropertyNames(obj).forEach(function (prop) {
                    if (props.indexOf(prop) === -1) {
                        props.push(prop);
                    }
                });
            } while (obj = Object.getPrototypeOf(obj));
            return props;
        }
    }
    exports.ReflectionUtils = ReflectionUtils;
});
define("src/app/relution/utils/SerialNumberUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SerialNumberUtils = void 0;
    class SerialNumberUtils {
        static generateBeaconSerialForIndex(index) {
            let serial = "";
            while (serial.length < this.SERIAL_NUMBER_LENGTH) {
                let rest = index % this.ALPHABET.length;
                serial += this.ALPHABET.substring(rest, rest + 1);
                index /= this.ALPHABET.length;
            }
            return serial.split("").reverse().join("");
        }
        static generateAssetSerialForIndex(index) {
            let serial = this.generateBeaconSerialForIndex(index);
            if (index < 0 || serial.charAt(0) != 'B') {
                throw new Error("Index out of range");
            }
            return "A" + serial.substring(1, this.SERIAL_NUMBER_LENGTH);
        }
        static getIndexForSerial(serialNumber) {
            if (serialNumber.charAt(0) == 'A')
                serialNumber = serialNumber.substring(1, this.SERIAL_NUMBER_LENGTH);
            let index = 0;
            for (let i = 0; i < serialNumber.length; i++) {
                let currentChar = serialNumber.charAt(serialNumber.length - i - 1);
                let charValue = this.ALPHABET.indexOf(currentChar);
                if (charValue == -1)
                    return 0;
                index += Math.pow(this.ALPHABET.length, i) * charValue;
            }
            return index;
        }
    }
    exports.SerialNumberUtils = SerialNumberUtils;
    SerialNumberUtils.SERIAL_NUMBER_LENGTH = 5;
    SerialNumberUtils.ALPHABET = "BCDFGHJKLMNPQRSTVWXYZ123456789";
});
define("src/app/relution/view/world/layers/deviceLayers/beaconDetailsLayer/BeaconConnectionDetails", ["require", "exports", "src/app/relution/model/device/DeviceModel", "src/map/view/hud/objects/ArrowObject", "src/map/utils/DeviceUtils", "src/engine/math/Vector2", "src/map/utils/Logger", "src/app/relution/view/world/RelutionMapAttributeObject"], function (require, exports, DeviceModel_7, ArrowObject_2, DeviceUtils_31, Vector2_43, Logger_8, RelutionMapAttributeObject_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BeaconConnectionDetails = void 0;
    class BeaconConnectionDetails extends RelutionMapAttributeObject_7.RelutionMapAttributeObject {
        // Initialization
        constructor(environment, sourceBeacon, deviceLayer) {
            super(environment, sourceBeacon);
            // View: Connections: Configuration
            this.referenceArrowLineWidth = 1.5; // In pixels
            this.connectionArrowHeadLengthInLogicalPx = 12;
            this.connectionArrowHeadMaxLengthInPercent = 0.2;
            this.connectionDirectionArrowHeadLengthInLogicalPx = 32;
            this.connectionDirectionArrowHeadMaxLengthInPercent = 0.4;
            this.connectionViews = new Array();
            // View: Update
            this.invalidated = true;
            this.redrawRequested = true;
            this.forceCompleteRedraw = true;
            this.lastScaleFactor = -1;
            this.lastScaleFactorForTranslation = -1;
            this.sendingMessageViewUpdateRequested = false;
            this.currentModel = new DeviceModel_7.BleNodeModel();
            this.deviceLayer = deviceLayer;
            this.sourceBeacon = sourceBeacon;
            this.initView();
            this.redraw();
        }
        initView() {
            this.initLedView();
            this.initClusterIndicatorRing();
            this.initConnectionViews();
            this.initConnectionDirectionView();
            this.initConnectionInfoView();
            this.initConnectionOwnMasterBitView();
            this.initConnectionPartnerMasterBitView();
            this.initNodeIdView();
            this.initSendingMessageView();
        }
        initLedView() {
            this.ledView = this.getEnvironment().renderer.newSpriteObject();
            this.getView().addChild(this.ledView);
            this.ledView.texture = this.getEnvironment().renderer.getTexture("light");
            this.ledView.alpha = 0;
        }
        initClusterIndicatorRing() {
            this.clusterIndicatorRing = this.getEnvironment().renderer.newGraphicsObject();
            this.getView().addChild(this.clusterIndicatorRing);
        }
        initConnectionViews() {
            this.connectionViews = new Array();
        }
        initConnectionDirectionView() {
            let arrowObjectConfig = new ArrowObject_2.ArrowObject.Config();
            arrowObjectConfig.arrowBodyTextureName = "arrow_body";
            arrowObjectConfig.arrowHeadTextureName = "arrow_head_transparent";
            arrowObjectConfig.arrowHeadLengthInLogicalPx = this.connectionDirectionArrowHeadLengthInLogicalPx;
            arrowObjectConfig.maxArrowHeadLengthInPercent = this.connectionDirectionArrowHeadMaxLengthInPercent;
            this.connectionDirectionView = new ArrowObject_2.ArrowObject(arrowObjectConfig, this.getEnvironment());
            this.addChild(this.connectionDirectionView);
        }
        initConnectionInfoView() {
            let fontSize = DeviceUtils_31.DeviceUtils.getPhysicalPixelsFromLogical(15);
            let textStyle = this.getEnvironment().renderer.newTextStyle();
            textStyle.fontSize = fontSize;
            this.connectionInfoView = this.getEnvironment().renderer.newTextObject("", 2, textStyle);
            this.getView().addChild(this.connectionInfoView);
        }
        initConnectionOwnMasterBitView() {
            this.connectionOwnMasterBitView = this.initConnectionMasterBitView();
        }
        initConnectionPartnerMasterBitView() {
            this.connectionPartnerMasterBitView = this.initConnectionMasterBitView();
        }
        initConnectionMasterBitView() {
            // Create
            let masterBitView = this.getEnvironment().renderer.newGraphicsObject();
            // Draw
            masterBitView.beginFill(0x000000);
            masterBitView.drawCircle(0, 0, 7);
            masterBitView.endFill();
            // Add to scene
            this.getView().addChild(masterBitView);
            // Alpha
            masterBitView.visible = false;
            return masterBitView;
        }
        initNodeIdView() {
            let fontSize = DeviceUtils_31.DeviceUtils.getPhysicalPixelsFromLogical(15);
            let textStyle = this.getEnvironment().renderer.newTextStyle();
            textStyle.fontSize = fontSize;
            this.nodeIdView = this.getEnvironment().renderer.newTextObject("", 2, textStyle);
            this.getView().addChild(this.nodeIdView);
        }
        initSendingMessageView() {
            // Create
            this.sendingMessageView = this.getEnvironment().renderer.newGraphicsObject();
            // Draw
            this.sendingMessageView.beginFill(0xff0000);
            this.sendingMessageView.drawCircle(0, 0, 1);
            this.sendingMessageView.endFill();
            this.sendingMessageView.alpha = 0.0;
            // Add to scene
            this.getView().addChild(this.sendingMessageView);
        }
        // View
        redraw() {
            this.invalidated = true;
            this.redrawRequested = true;
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            this.redrawViewsIfNecessary();
            this.syncWithSourceBeaconScale();
            this.syncWithCameraRotation();
            this.syncWithCameraTranslation();
            this.updateSendingMessageView();
            this.invalidated = false;
        }
        redrawViewsIfNecessary() {
            if (this.redrawRequested) {
                this.redrawRequested = false;
                this.redrawLedView();
                this.redrawClusterIndicatorRing();
                this.redrawConnectionViews();
                this.redrawConnectionDirectionView();
                this.redrawConnectionInfoView();
                this.redrawNodeIdView();
                this.currentModel = this.sourceBeacon.getModel().clone();
                this.forceCompleteRedraw = false;
            }
        }
        redrawLedView() {
            let ledOn = this.sourceBeacon.getModel().ledOn;
            if (ledOn) {
                // Alpha
                this.ledView.alpha = 1.0;
                // Pivot
                this.ledView.pivot.x = this.ledView.texture.width / 2;
                this.ledView.pivot.y = this.ledView.texture.height / 2;
                // Translate
                this.ledView.x = this.sourceBeacon.getView().x;
                this.ledView.y = this.sourceBeacon.getView().y;
            }
            else {
                this.ledView.alpha = 0.0;
            }
        }
        redrawClusterIndicatorRing() {
            let clusterId = this.sourceBeacon.getModel().clusterId;
            if (this.forceCompleteRedraw || this.currentModel.clusterId !== clusterId) {
                let colorString = this.getColorForClusterId(clusterId);
                let color = parseInt(colorString.replace(/^#/, ""), 16);
                this.clusterIndicatorRing.beginFill(color);
                this.clusterIndicatorRing.drawCircle(0, 0, 1);
                this.clusterIndicatorRing.endFill();
            }
        }
        getColorForClusterId(clusterId) {
            // Return cluster color if already exists.
            for (let i = 0; i < BeaconConnectionDetails.clusterColors.length; i++) {
                let c = BeaconConnectionDetails.clusterColors[i];
                if (c.clusterId === clusterId) {
                    return c.color;
                }
            }
            // If it does not exist, create a new cluster color.
            let randomColor = this.getRandomColor();
            let cluster = new BeaconConnectionDetails.Cluster(clusterId, randomColor);
            BeaconConnectionDetails.clusterColors.push(cluster);
            return cluster.color;
        }
        getRandomColor() {
            let letters = "0123456789ABCDEF";
            let color = "#";
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }
        redrawConnectionViews() {
            if (this.forceCompleteRedraw || this.connectionsHaveChanged()) {
                this.removeAllConnectionViews();
                this.addConnectionViews();
            }
        }
        connectionsHaveChanged() {
            let modelConnections = this.sourceBeacon.getModel().connections;
            // Check length
            if (this.currentModel.connections == null || this.currentModel.connections.length !== modelConnections.length) {
                return true;
            }
            // Check connection targets
            for (let i = 0; i < modelConnections.length; i++) {
                let modelConnection = modelConnections[i];
                let connectionFound = false;
                for (let j = 0; j < this.currentModel.connections.length; j++) {
                    let currentConnection = this.currentModel.connections[j];
                    if (modelConnection.target === currentConnection.target) {
                        connectionFound = true;
                    }
                }
                if (!connectionFound) {
                    return true;
                }
            }
            return false;
        }
        removeAllConnectionViews() {
            for (let i = 0; i < this.connectionViews.length; i++) {
                let connectionView = this.connectionViews[i];
                this.removeChild(connectionView);
            }
            this.connectionViews = [];
        }
        addConnectionViews() {
            if (this.sourceBeacon.getModel().connections) {
                for (let i = 0; i < this.sourceBeacon.getModel().connections.length; i++) {
                    let arrowObjectConfig = new ArrowObject_2.ArrowObject.Config();
                    arrowObjectConfig.arrowBodyTextureName = "arrow_body";
                    arrowObjectConfig.arrowHeadTextureName = "arrow_head";
                    arrowObjectConfig.arrowHeadLengthInLogicalPx = this.connectionArrowHeadLengthInLogicalPx;
                    arrowObjectConfig.maxArrowHeadLengthInPercent = this.connectionArrowHeadMaxLengthInPercent;
                    let connectionView = new ArrowObject_2.ArrowObject(arrowObjectConfig, this.getEnvironment());
                    this.addChild(connectionView);
                    this.connectionViews.push(connectionView);
                }
            }
        }
        redrawConnectionDirectionView() {
            if (this.sourceBeacon.getModel().inConnectionPartner === 0) {
                this.connectionDirectionView.getView().visible = false;
            }
            else {
                this.connectionDirectionView.getView().visible = true;
            }
        }
        redrawConnectionInfoView() {
            if (this.sourceBeacon.getModel().inConnectionPartner === 0) {
                this.connectionInfoView.visible = false;
            }
            else {
                this.connectionInfoView.visible = true;
                this.setConnectionInfoViewText();
            }
        }
        setConnectionInfoViewText() {
            if (this.forceCompleteRedraw || this.inConnectionRssiHasChanged() || this.inConnectionHandleHasChanged()) {
                let inConnectionRssiString = "?";
                if (this.sourceBeacon.getModel().inConnectionRssi !== 0) {
                    inConnectionRssiString = "" + this.sourceBeacon.getModel().inConnectionRssi;
                }
                let connectionHandleString = "?";
                if (this.sourceBeacon.getModel().inConnectionPartner !== 0) {
                    const inConnectionModel = this.getInConnectionModel();
                    if (inConnectionModel !== null) {
                        connectionHandleString = "" + inConnectionModel.handle;
                    }
                }
                this.connectionInfoView.text = "" + inConnectionRssiString + "/" + connectionHandleString;
                // The text will be updated so that the width and height are accessible now.
                this.connectionInfoView.flush();
            }
        }
        inConnectionRssiHasChanged() {
            return this.currentModel.inConnectionRssi !== this.sourceBeacon.getModel().inConnectionRssi;
        }
        inConnectionHandleHasChanged() {
            return this.connectionsHaveChanged();
        }
        getInConnectionModel() {
            for (let i = 0; i < this.sourceBeacon.getModel().connections.length; i++) {
                const connection = this.sourceBeacon.getModel().connections[i];
                if (connection.target === this.sourceBeacon.getModel().inConnectionPartner) {
                    return connection;
                }
            }
            return null;
        }
        redrawNodeIdView() {
            if (this.forceCompleteRedraw
                || this.currentModel.nodeId !== this.sourceBeacon.getModel().nodeId
                || this.currentModel.clusterId !== this.sourceBeacon.getModel().clusterId
                || this.currentModel.clusterSize !== this.sourceBeacon.getModel().clusterSize) {
                let nodeIdString = "?";
                if (this.sourceBeacon.getModel().nodeId) {
                    nodeIdString = "" + this.sourceBeacon.getModel().nodeId;
                }
                let clusterSizeString = "?";
                if (this.sourceBeacon.getModel().clusterSize) {
                    clusterSizeString = "" + this.sourceBeacon.getModel().clusterSize;
                }
                this.nodeIdView.text = nodeIdString + " / " + clusterSizeString;
            }
        }
        syncWithSourceBeaconScale() {
            let sourceBeacon = this.getSourceBeacon();
            let scaleFactor = sourceBeacon.getView().scale.x;
            if (this.lastScaleFactor !== scaleFactor || this.invalidated) {
                this.lastScaleFactor = scaleFactor;
                this.retransformLedView(scaleFactor);
                this.retransformClusterIndicatorRing();
                this.retransformConnectionViews(scaleFactor);
                this.retransformConnectionDirectionView(scaleFactor);
                this.retransformConnectionInfoView(scaleFactor);
                this.retransformConnectionOwnMasterBitView(scaleFactor);
                this.retransformConnectionPartnerMasterBitView(scaleFactor);
                this.retransformNodeIdView(scaleFactor);
                this.retransformSendingMessageView(scaleFactor);
            }
        }
        retransformLedView(scaleFactor) {
            // Scale
            let radiusInPx = this.sourceBeacon.getView().width * 10;
            this.ledView.scale.x = (1.0 / this.ledView.texture.width) * radiusInPx;
            this.ledView.scale.y = (1.0 / this.ledView.texture.height) * radiusInPx;
        }
        retransformClusterIndicatorRing() {
            // Scale
            let radiusInPx = this.sourceBeacon.getView().width;
            this.clusterIndicatorRing.scale.x = radiusInPx;
            this.clusterIndicatorRing.scale.y = radiusInPx;
            // Translation
            let sourceX = this.sourceBeacon.getView().x;
            let sourceY = this.sourceBeacon.getView().y;
            this.clusterIndicatorRing.x = sourceX;
            this.clusterIndicatorRing.y = sourceY;
        }
        retransformConnectionViews(scaleFactor) {
            let lineWidth = this.referenceArrowLineWidth * scaleFactor;
            for (let i = 0; i < this.connectionViews.length; i++) {
                let connectionView = this.connectionViews[i];
                let connection = this.sourceBeacon.getModel().connections[i];
                this.retransformConnectionViewWithLineWidth(connectionView, connection, lineWidth);
            }
        }
        retransformConnectionViewWithLineWidth(connectionView, connection, lineWidth) {
            // Target beacon
            let targetNodeId = connection.target;
            let targetBeacon = this.deviceLayer.getBeaconWithNodeId(targetNodeId);
            if (targetBeacon != null) {
                // Since the connection is bidirectional, we move the arrow a bit upwards
                // to see both directions.
                let sourcePosition = Vector2_43.Vector2.getVector2(this.sourceBeacon.getView().position);
                let targetPosition = Vector2_43.Vector2.getVector2(targetBeacon.getView().position);
                // sourcePosition = this.getUpwardsDisplacedSourcePosition(sourcePosition, targetPosition);
                // targetPosition = this.getUpwardsDisplacedTargetPosition(sourcePosition, targetPosition);
                sourcePosition = this.getClusterRingDisplacedSourcePosition(sourcePosition, targetPosition);
                targetPosition = this.getClusterRingDisplacedTargetPosition(sourcePosition, targetPosition);
                // Draw arrow. The arrow should point to the source since we assume all connections
                // to be ingoing connections.
                connectionView.draw(targetPosition, sourcePosition, lineWidth);
            }
            else {
                Logger_8.Logger.logDebug("Beacon with nodeId " + targetNodeId + " does not exist.");
            }
        }
        getUpwardsDisplacedSourcePosition(sourcePosition, targetPosition) {
            let diffVector = new Vector2_43.Vector2(targetPosition.x - sourcePosition.x, targetPosition.y - sourcePosition.y);
            let normalVector = new Vector2_43.Vector2(-diffVector.y, diffVector.x);
            normalVector.normalize();
            let offsetInTx = this.sourceBeacon.getView().height / 2;
            let modifiedSourcePosition = new Vector2_43.Vector2(sourcePosition.x - normalVector.getX() * offsetInTx, sourcePosition.y - normalVector.getY() * offsetInTx);
            return modifiedSourcePosition;
        }
        getUpwardsDisplacedTargetPosition(sourcePosition, targetPosition) {
            let diffVector = new Vector2_43.Vector2(targetPosition.x - sourcePosition.x, targetPosition.y - sourcePosition.y);
            let normalVector = new Vector2_43.Vector2(-diffVector.y, diffVector.x);
            normalVector.normalize();
            let offsetInTx = this.sourceBeacon.getView().height / 2;
            let modifiedTargetPosition = new Vector2_43.Vector2(targetPosition.x - normalVector.getX() * offsetInTx, targetPosition.y - normalVector.getY() * offsetInTx);
            return modifiedTargetPosition;
        }
        getClusterRingDisplacedSourcePosition(sourcePosition, targetPosition) {
            let diffPoint = new Vector2_43.Vector2(targetPosition.x - sourcePosition.x, targetPosition.y - sourcePosition.y);
            let diffVector = new Vector2_43.Vector2(diffPoint.x, diffPoint.y);
            diffVector.normalize();
            let stretchFactor = this.clusterIndicatorRing.width / 2;
            let displacedSourcePosition = new Vector2_43.Vector2(sourcePosition.x + diffVector.getX() * stretchFactor, sourcePosition.y + diffVector.getY() * stretchFactor);
            return displacedSourcePosition;
        }
        getClusterRingDisplacedTargetPosition(sourcePosition, targetPosition) {
            let diffPoint = new Vector2_43.Vector2(targetPosition.x - sourcePosition.x, targetPosition.y - sourcePosition.y);
            let diffVector = new Vector2_43.Vector2(diffPoint.x, diffPoint.y);
            diffVector.normalize();
            let stretchFactor = this.clusterIndicatorRing.width / 2;
            let displacedTargetPosition = new Vector2_43.Vector2(targetPosition.x - diffVector.getX() * stretchFactor, targetPosition.y - diffVector.getY() * stretchFactor);
            return displacedTargetPosition;
        }
        retransformConnectionDirectionView(scaleFactor) {
            // Line width
            let lineWidth = this.referenceArrowLineWidth * scaleFactor;
            // Source and target position
            if (this.sourceBeacon.getModel().inConnectionPartner !== 0) {
                let targetNodeId = this.sourceBeacon.getModel().inConnectionPartner;
                let targetBeacon = this.deviceLayer.getBeaconWithNodeId(targetNodeId);
                if (targetBeacon != null) {
                    // Since the connection is bidirectional, we move the arrow a bit upwards
                    // to see both directions.
                    let sourcePosition = Vector2_43.Vector2.getVector2(this.sourceBeacon.getView().position);
                    let targetPosition = Vector2_43.Vector2.getVector2(targetBeacon.getView().position);
                    // sourcePosition = this.getUpwardsDisplacedSourcePosition(sourcePosition, targetPosition);
                    // targetPosition = this.getUpwardsDisplacedTargetPosition(sourcePosition, targetPosition);
                    sourcePosition = this.getClusterRingDisplacedSourcePosition(sourcePosition, targetPosition);
                    targetPosition = this.getClusterRingDisplacedTargetPosition(sourcePosition, targetPosition);
                    // Draw arrow
                    this.connectionDirectionView.draw(targetPosition, sourcePosition, lineWidth);
                }
                else {
                    Logger_8.Logger.logDebug("Beacon with nodeId " + targetNodeId + " does not exist.");
                }
            }
        }
        retransformConnectionInfoView(scaleFactor) {
            if (this.sourceBeacon.getModel().inConnectionPartner !== 0) {
                let targetId = this.sourceBeacon.getModel().inConnectionPartner;
                let targetBeacon = this.deviceLayer.getBeaconWithNodeId(targetId);
                if (targetBeacon != null) {
                    // Pivot
                    this.connectionInfoView.pivot.x = this.connectionInfoView.texture.width / 2;
                    this.connectionInfoView.pivot.y = this.connectionInfoView.texture.height / 2;
                    // Scale
                    this.connectionInfoView.scale.x = scaleFactor;
                    this.connectionInfoView.scale.y = scaleFactor;
                    // Rotation
                    let camera = this.getScene().getCamera();
                    this.connectionInfoView.rotation = camera.getRotation();
                    // Translation
                    let sourcePosition = this.sourceBeacon.getView().position;
                    let targetPosition = targetBeacon.getView().position;
                    let meanPosition = new Vector2_43.Vector2((sourcePosition.x + targetPosition.x) / 2, (sourcePosition.y + targetPosition.y) / 2);
                    this.connectionInfoView.x = meanPosition.x;
                    this.connectionInfoView.y = meanPosition.y;
                }
            }
        }
        retransformConnectionOwnMasterBitView(scaleFactor) {
            let masterBitView = this.connectionOwnMasterBitView;
            if (this.sourceBeacon.getModel().inConnectionPartner === 0 || !this.sourceBeacon.getModel().inConnectionHasMasterBit) {
                masterBitView.visible = false;
                return;
            }
            else {
                masterBitView.visible = true;
                this.retransformConnectionMasterBitView(masterBitView, scaleFactor, true);
            }
        }
        retransformConnectionPartnerMasterBitView(scaleFactor) {
            let masterBitView = this.connectionPartnerMasterBitView;
            if (this.sourceBeacon.getModel().inConnectionPartner === 0 || !this.sourceBeacon.getModel().inConnectionPartnerHasMasterBit) {
                masterBitView.visible = false;
                return;
            }
            else {
                masterBitView.visible = true;
                this.retransformConnectionMasterBitView(masterBitView, scaleFactor, false);
            }
        }
        retransformConnectionMasterBitView(masterBitView, scaleFactor, isSourceView) {
            // Scale
            masterBitView.scale.x = scaleFactor;
            masterBitView.scale.y = scaleFactor;
            // Translation
            if (this.sourceBeacon.getModel().inConnectionPartner !== 0) {
                let targetNodeId = this.sourceBeacon.getModel().inConnectionPartner;
                let targetBeacon = this.deviceLayer.getBeaconWithNodeId(targetNodeId);
                if (targetBeacon != null) {
                    let sourcePosition = Vector2_43.Vector2.getVector2(this.sourceBeacon.getView().position);
                    let targetPosition = Vector2_43.Vector2.getVector2(targetBeacon.getView().position);
                    sourcePosition = this.getMasterBitSourcePosition(sourcePosition, targetPosition);
                    targetPosition = this.getMasterBitTargetPosition(sourcePosition, targetPosition);
                    if (isSourceView) {
                        masterBitView.x = sourcePosition.x;
                        masterBitView.y = sourcePosition.y;
                    }
                    else {
                        masterBitView.x = targetPosition.x;
                        masterBitView.y = targetPosition.y;
                    }
                }
            }
        }
        getMasterBitSourcePosition(sourcePosition, targetPosition) {
            let diffPoint = new Vector2_43.Vector2(targetPosition.x - sourcePosition.x, targetPosition.y - sourcePosition.y);
            let diffVector = new Vector2_43.Vector2(diffPoint.x, diffPoint.y);
            diffVector.normalize();
            let stretchFactor = this.clusterIndicatorRing.width;
            let displacedSourcePosition = new Vector2_43.Vector2(sourcePosition.x + diffVector.getX() * stretchFactor, sourcePosition.y + diffVector.getY() * stretchFactor);
            let upperDisplacement = 0;
            displacedSourcePosition.x += -diffVector.getY() * upperDisplacement;
            displacedSourcePosition.x += diffVector.getX() * upperDisplacement;
            return displacedSourcePosition;
        }
        getMasterBitTargetPosition(sourcePosition, targetPosition) {
            let diffPoint = new Vector2_43.Vector2(targetPosition.x - sourcePosition.x, targetPosition.y - sourcePosition.y);
            let diffVector = new Vector2_43.Vector2(diffPoint.x, diffPoint.y);
            diffVector.normalize();
            let stretchFactor = this.clusterIndicatorRing.width;
            let displacedTargetPosition = new Vector2_43.Vector2(targetPosition.x - diffVector.getX() * stretchFactor, targetPosition.y - diffVector.getY() * stretchFactor);
            let upperDisplacement = 0;
            displacedTargetPosition.x += -diffVector.getY() * upperDisplacement;
            displacedTargetPosition.x += diffVector.getX() * upperDisplacement;
            return displacedTargetPosition;
        }
        retransformNodeIdView(scaleFactor) {
            let camera = this.getScene().getCamera();
            // Pivot
            this.nodeIdView.pivot.x = this.nodeIdView.texture.width / 2;
            this.nodeIdView.pivot.y = this.nodeIdView.texture.height / 2;
            // Scale
            this.nodeIdView.scale.x = scaleFactor;
            this.nodeIdView.scale.y = scaleFactor;
            // Rotation
            this.nodeIdView.rotation = camera.getRotation();
            // Translation
            let worldCamera = this.getScene().getCamera();
            let deviceBoundsInImage = this.sourceBeacon.getAabbInImageCoordinates();
            let textBounds = this.nodeIdView.getBounds();
            let textPositionInImage = new Vector2_43.Vector2(deviceBoundsInImage.min.x + (deviceBoundsInImage.max.x - deviceBoundsInImage.min.x) / 2, deviceBoundsInImage.min.y - textBounds.height);
            let textPositionInWorld = worldCamera.getWorldCoordinateFromImagePoint(textPositionInImage);
            if (Math.abs(this.nodeIdView.x - textPositionInWorld.x) > 0.00001) {
                this.nodeIdView.x = textPositionInWorld.x;
            }
            if (Math.abs(this.nodeIdView.y - textPositionInWorld.y) > 0.00001) {
                this.nodeIdView.y = textPositionInWorld.y;
            }
        }
        retransformSendingMessageView(scaleFactor) {
            // Scale
            let beaconWidth = this.sourceBeacon.getView().width;
            let beaconHeight = this.sourceBeacon.getView().height;
            let radiusInPx = beaconWidth / 3;
            this.sendingMessageView.scale.x = radiusInPx;
            this.sendingMessageView.scale.y = radiusInPx;
            // Translation
            this.sendingMessageView.x = this.sourceBeacon.getView().x + beaconWidth * 1.5;
            this.sendingMessageView.y = this.sourceBeacon.getView().y - beaconHeight * 1.5;
        }
        syncWithCameraRotation() {
            let camera = this.getScene().getCamera();
            let orientation = camera.getRotation();
            let scaleFactor = this.sourceBeacon.getView().scale.x;
            if (this.nodeIdView.rotation !== orientation || this.invalidated) {
                this.retransformNodeIdView(scaleFactor);
            }
        }
        syncWithCameraTranslation() {
            let scaleFactor = this.sourceBeacon.getView().scale.x;
            if (this.lastScaleFactorForTranslation !== scaleFactor || this.invalidated) {
                this.lastScaleFactorForTranslation = scaleFactor;
                this.retransformNodeIdView(scaleFactor);
            }
        }
        updateSendingMessageView() {
            if (this.sendingMessageViewUpdateRequested) {
                this.sendingMessageViewUpdateRequested = false;
                let lastSentMessageTimestampMs = this.sourceBeacon.getModel().lastSentMessageTimestampMs;
                let nowInMs = Date.now();
                let diffInMs = nowInMs - lastSentMessageTimestampMs;
                if (diffInMs > 500) {
                    this.sendingMessageView.alpha = 0.0;
                }
                else {
                    this.sendingMessageView.alpha = 1.0;
                }
            }
        }
        // Model Event-handling
        // @Override
        modelChanged(deviceModel) {
            this.redraw();
        }
        // @Override
        lastSentMessageTimestampMsChanged(deviceModel) {
            this.sendingMessageViewUpdateRequested = true;
        }
        // Getters and setters
        getSourceBeacon() {
            return this.sourceBeacon;
        }
    }
    exports.BeaconConnectionDetails = BeaconConnectionDetails;
    BeaconConnectionDetails.clusterColors = new Array();
    (function (BeaconConnectionDetails) {
        class Cluster {
            constructor(clusterId, color) {
                this.clusterId = clusterId;
                this.color = color;
            }
        }
        BeaconConnectionDetails.Cluster = Cluster;
    })(BeaconConnectionDetails = exports.BeaconConnectionDetails || (exports.BeaconConnectionDetails = {}));
});
define("src/app/relution/view/world/layers/deviceLayers/beaconDetailsLayer/BeaconConnectionDetailsLayer", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/beaconDetailsLayer/BeaconConnectionDetails", "src/app/relution/view/world/RelutionMapAttributeObjectLayer"], function (require, exports, BeaconConnectionDetails_1, RelutionMapAttributeObjectLayer_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BeaconConnectionDetailsLayer = void 0;
    class BeaconConnectionDetailsLayer extends RelutionMapAttributeObjectLayer_6.RelutionMapAttributeObjectLayer {
        // Initialization
        constructor(environment, deviceLayer) {
            super(environment, deviceLayer);
            this.deviceLayer = deviceLayer;
        }
        // Device attribute object creation
        createAttributeObjectsForObject(device) {
            let resultList = new Array();
            if (device.getModel().isBleNode()) {
                let beacon = device;
                let details = new BeaconConnectionDetails_1.BeaconConnectionDetails(this.getEnvironment(), beacon, this.deviceLayer);
                resultList.push(details);
            }
            return resultList;
        }
    }
    exports.BeaconConnectionDetailsLayer = BeaconConnectionDetailsLayer;
});
define("src/app/relution/view/world/layers/floorplanLayers/benchmarkLayers/TextureUpdateLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer"], function (require, exports, FloorplanRelatedLayer_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextureUpdateLayer = void 0;
    class TextureUpdateLayer extends FloorplanRelatedLayer_12.FloorplanRelatedLayer {
        // Initialization
        constructor(environment, floorplanLayer) {
            super(environment, floorplanLayer);
            // Updating
            this.accumulator = 0;
            this.initView();
        }
        initView() {
            this.spriteView = this.getEnvironment().renderer.newSpriteObject();
            this.getView().addChild(this.spriteView);
            this.createCanvas();
        }
        updateTexture(canvas) {
            if (this.spriteView.texture != null) {
                this.spriteView.texture.destroy();
            }
            this.spriteView.texture = this.getEnvironment().renderer.newTexture(canvas);
            this.spriteView.width = this.getFloorplanLayer().getFloorSize().x;
            this.spriteView.height = this.getFloorplanLayer().getFloorSize().y;
        }
        createCanvas() {
            this.canvas = document.createElement("canvas");
            this.powerTwoTextureSize = 512;
            this.canvas.width = this.powerTwoTextureSize;
            this.canvas.height = this.powerTwoTextureSize;
            return this.canvas;
        }
        // Updating
        // @Override
        update(lastFramtime) {
            super.update(lastFramtime);
            this.accumulator += lastFramtime;
            if (this.accumulator > 500) {
                this.accumulator = 0;
                this.updateCanvas();
                this.updateTexture(this.canvas);
            }
        }
        updateCanvas() {
            let ctx = this.canvas.getContext("2d");
            let x = Math.random() * this.powerTwoTextureSize;
            let y = Math.random() * this.powerTwoTextureSize;
            let width = Math.random() * this.powerTwoTextureSize / 2;
            let height = Math.random() * this.powerTwoTextureSize / 2;
            let colorHex = this.getRandomColor();
            ctx.fillStyle = colorHex;
            ctx.fillRect(x, y, width, height);
        }
        getRandomColor() {
            let letters = "0123456789ABCDEF";
            let color = "#";
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }
    }
    exports.TextureUpdateLayer = TextureUpdateLayer;
});
define("src/app/relution/view/world/layers/floorplanLayers/benchmarkLayers/TileBasedBenchmarkLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/map/view/world/layers/tileLayer/TileEngine"], function (require, exports, FloorplanRelatedLayer_13, TileEngine_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TileBasedBenchmarkLayer = void 0;
    class TileBasedBenchmarkLayer extends FloorplanRelatedLayer_13.FloorplanRelatedLayer {
        // Initialization
        constructor(environment, floorplanLayer) {
            super(environment, floorplanLayer);
            // View
            this.rectangles = new Array();
        }
        // @Override
        initialize() {
            super.initialize();
            this.initTileEngine();
        }
        initTileEngine() {
            let worldCamera = this.getScene().getCamera();
            this.tileEngine = new TileEngine_2.TileEngine(new TileEngine_2.TileEngine.Config(), this.getEnvironment(), worldCamera, 256);
            this.tileEngine.addTileEngineObserver(this);
        }
        // Event-Handling: Tile-Engine
        onLoadTiles(tiles) {
            for (let i = 0; i < tiles.length; i++) {
                let tile = tiles[i];
                this.loadTile(tile);
            }
        }
        loadTile(tile) {
            let graphics = this.getEnvironment().renderer.newGraphicsObject();
            // Drawing
            let color = this.getRandomColor();
            graphics.beginFill(parseInt(color, 10));
            let x = 0;
            let y = 0;
            let width = this.tileEngine.getTileSizeInPx();
            let height = this.tileEngine.getTileSizeInPx();
            graphics.drawRect(x, y, width, height);
            graphics.endFill();
            // Position
            graphics.x = tile.columnIndex * this.tileEngine.getTileSizeInPx() * tile.depthIndex;
            graphics.y = tile.rowIndex * this.tileEngine.getTileSizeInPx() * tile.depthIndex;
            // Scale
            graphics.scale.x = tile.depthIndex;
            graphics.scale.y = tile.depthIndex;
            // Scene graph
            this.getView().addChild(graphics);
            this.rectangles.push(graphics);
        }
        getRandomColor() {
            let letters = "0123456789ABCDEF";
            let color = "0x";
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }
        // @Override
        onReplaceTiles(tileReplacements) {
            for (let i = 0; i < tileReplacements.length; i++) {
                let tileReplacement = tileReplacements[i];
                this.onUnloadTiles(tileReplacement.oldTiles);
                this.onLoadTiles(tileReplacement.newTiles);
            }
        }
        // @Override
        onUnloadTiles(tiles) {
            for (let i = 0; i < tiles.length; i++) {
                let tile = tiles[i];
                this.unloadTile(tile);
            }
        }
        unloadTile(tile) {
            let tileX = tile.columnIndex * this.tileEngine.getTileSizeInPx() * tile.depthIndex;
            let tileY = tile.rowIndex * this.tileEngine.getTileSizeInPx() * tile.depthIndex;
            for (let i = 0; i < this.rectangles.length; i++) {
                let rectangle = this.rectangles[i];
                let rectX = rectangle.x;
                let rectY = rectangle.y;
                if (tileX === rectX && tileY === rectY) {
                    rectangle.destroy();
                    this.getView().removeChild(rectangle);
                    let index = this.rectangles.indexOf(rectangle);
                    if (index > -1) {
                        this.rectangles.splice(index, 1);
                    }
                    return;
                }
            }
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            this.tileEngine.update(lastFrametime);
        }
    }
    exports.TileBasedBenchmarkLayer = TileBasedBenchmarkLayer;
});
define("src/app/simulator/view/hud/popupLayer/BeaconConnectionDetailsPopupLayer", ["require", "exports", "src/app/relution/view/hud/popupLayer/PopupLayer", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/BeaconMapObject"], function (require, exports, PopupLayer_2, BeaconMapObject_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BeaconConnectionDetailsPopupLayer = void 0;
    class BeaconConnectionDetailsPopupLayer extends PopupLayer_2.PopupLayer {
        // @Override
        getContentForObject(object) {
            if (object instanceof BeaconMapObject_8.BeaconMapObject) {
                let device = object;
                let content = ""
                    + "Serial: " + device.getModel().deviceId + "\n"
                    + "Node ID: " + device.getModel().nodeId + "\n"
                    + "Cluster ID: " + device.getModel().clusterId + "\n"
                    + "Cluster size: " + device.getModel().clusterSize + "\n"
                    + "Connection losses: " + device.getModel().connectionLossCounter + "\n"
                    + "Free In: " + device.getModel().freeIn + "\n"
                    + "Free Out: " + device.getModel().freeOut + "\n"
                    + "Last Message Timestamp: " + device.getModel().lastSentMessageTimestampMs + "\n"
                    + "Last Message: " + JSON.stringify(device.getModel().lastSentAdvertisingMessage);
                return content;
            }
            else {
                return "";
            }
        }
        // Localization Event-Handling
        // @Override
        onLocalizationChanged() {
            return false;
        }
    }
    exports.BeaconConnectionDetailsPopupLayer = BeaconConnectionDetailsPopupLayer;
});
define("src/app/simulator/SimulatorMap", ["require", "exports", "src/app/relution/RelutionMap", "src/app/relution/view/world/layers/deviceLayers/beaconDetailsLayer/BeaconConnectionDetailsLayer", "src/app/simulator/view/hud/popupLayer/BeaconConnectionDetailsPopupLayer", "src/app/relution/view/hud/popupLayer/PopupLayer"], function (require, exports, RelutionMap_2, BeaconConnectionDetailsLayer_1, BeaconConnectionDetailsPopupLayer_1, PopupLayer_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimulatorMap = void 0;
    class SimulatorMap extends RelutionMap_2.RelutionMap {
        // Initialization
        constructor(options) {
            super(options);
        }
        // @Override
        load(floor, initializedCallback) {
            super.load(floor, () => {
                this.configureFloors();
                this.configureHud();
                initializedCallback();
            });
        }
        configureFloors() {
            this.getBuilding().addFloorObserver(this);
            this.floorAdded(this.getBuilding().getCurrentFloor());
        }
        configureHud() {
            // Make beacon connection details popup layer visible
            let popupLayer = new BeaconConnectionDetailsPopupLayer_1.BeaconConnectionDetailsPopupLayer(new PopupLayer_3.PopupLayer.Config(), this.fruityMap.getEnvironment(), this.getBuilding());
            this.fruityMap.getHud().addLayer(popupLayer);
            // Make device info popup layer invisible
            this.relutionMapHud.removeLayer(this.relutionMapHud.popupLayer);
        }
        // Floor events
        // @Override
        floorAdded(floor) {
            if (floor !== null) {
                floor.getDeviceLayer().setShowMeshGatewayInsteadOfCommunicationBeaconEnabled(false);
                floor.getInfoLayerContainer().getView().visible = false;
                this.addBeaconConnectionDetailsLayer(floor);
            }
        }
        addBeaconConnectionDetailsLayer(floor) {
            let beaconConnectionDetailsLayer = new BeaconConnectionDetailsLayer_1.BeaconConnectionDetailsLayer(this.fruityMap.getEnvironment(), floor.getDeviceLayer());
            floor.getDeviceLayerContainer().addLayerAfterLayer(beaconConnectionDetailsLayer, floor.getBeaconRangeLayer());
        }
        // Image preloading
        // @Override
        getPreloadingImageNames() {
            let preloadingImages = super.getPreloadingImageNames();
            preloadingImages.push("light");
            return preloadingImages;
        }
    }
    exports.SimulatorMap = SimulatorMap;
});
define("src/map/view/world/layers/tileLayer/RemoteTileResponse", ["require", "exports", "src/map/view/world/layers/tileLayer/TileResponse"], function (require, exports, TileResponse_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RemoteTileResponse = void 0;
    class RemoteTileResponse extends TileResponse_2.TileResponse {
        constructor(tile, tileLoader, source) {
            super(tile, tileLoader);
            this.source = source;
        }
        getSource() {
            return this.source;
        }
    }
    exports.RemoteTileResponse = RemoteTileResponse;
});
define("src/map/utils/StringUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StringUtils = void 0;
    class StringUtils {
        // See https://github.com/Leaflet/Leaflet/blob/master/src/core/Util.js
        static fillFieldsForTemplate(template, data) {
            let templateRe = /\{ *([\w_\-]+) *\}/g;
            return template.replace(templateRe, function (str, key) {
                let value = data[key];
                if (value === undefined) {
                    throw new Error("No value provided for variable " + str);
                }
                else if (typeof value === "function") {
                    value = value(data);
                }
                return value;
            });
        }
    }
    exports.StringUtils = StringUtils;
});
define("src/map/view/world/layers/tileLayer/RemoteTileLoader", ["require", "exports", "src/map/view/world/layers/tileLayer/TileLoader", "src/map/utils/Language", "src/map/view/world/layers/tileLayer/RemoteTileResponse", "src/map/utils/SystemUtils", "src/map/utils/StringUtils"], function (require, exports, TileLoader_2, Language_2, RemoteTileResponse_1, SystemUtils_2, StringUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RemoteTileLoader = void 0;
    class RemoteTileLoader extends TileLoader_2.TileLoader {
        // Initialization
        constructor(urlTemplate, options) {
            super(options);
            Language_2.Language.setOptions(this, new RemoteTileLoader.Options(), options);
            this.postprocessOptions();
            this.urlTemplate = urlTemplate;
            this.computeDimensions();
        }
        postprocessOptions() {
            if (typeof this.options.subdomains === "string") {
                this.options.subdomains = this.options.subdomains.split("");
            }
        }
        computeDimensions() {
            let numZoomLevels = (this.options.maxNativeZoom - this.options.minNativeZoom) + 1;
            let widthInPx = Math.pow(2, numZoomLevels - 1) * this.options.tileSizeInPx;
            this.worldWidthInPx = widthInPx;
            this.worldHeightInPx = widthInPx;
        }
        // Dimensions
        // @Override
        getWorldWidth() {
            return this.worldWidthInPx;
        }
        // @Override
        getWorldHeight() {
            return this.worldHeightInPx;
        }
        // Tile loading
        // @Override
        loadTile(tile, responseCallback) {
            if (this.tileOutsideWorld(tile)) {
                let tileResponse = new RemoteTileResponse_1.RemoteTileResponse(tile, this, this.drawEmptyTileOnCanvas());
                responseCallback(tileResponse);
                return null;
            }
            else {
                let image = this.loadTileAsync(tile, responseCallback);
                return image;
            }
        }
        tileOutsideWorld(tile) {
            let logDepthIndex = tile.getLogDepthIndex();
            return tile.columnIndex < 0 || tile.rowIndex < 0 || logDepthIndex < this.options.minZoom;
        }
        loadTileAsync(tile, responseCallback) {
            // Create tile
            let image = document.createElement("img");
            // Callback
            let that = this;
            image.onload = function () {
                let tileResponse = new RemoteTileResponse_1.RemoteTileResponse(tile, that, image);
                responseCallback(tileResponse);
            };
            image.onerror = function () {
                let tileResponse = new RemoteTileResponse_1.RemoteTileResponse(tile, that, that.drawEmptyTileOnCanvas());
                responseCallback(tileResponse);
            };
            // Cross origin
            if (this.options.crossOrigin) {
                image.crossOrigin = "";
            }
            // Screen readers should ignore this image element
            image.alt = "";
            image.setAttribute("role", "presentation");
            // Load tile
            image.src = this.getTileUrl(tile);
            return image;
        }
        getTileUrl(tile) {
            // Get url for tile
            let data = {
                r: SystemUtils_2.SystemUtils.isRetinaDisplay() ? "@2x" : "",
                s: this.getSubdomain(tile.columnIndex, tile.rowIndex),
                x: tile.columnIndex,
                y: tile.rowIndex,
                z: this.getZoomForUrl(tile)
            };
            let url = StringUtils_1.StringUtils.fillFieldsForTemplate(this.urlTemplate, data);
            return url;
        }
        getSubdomain(columnIndex, rowIndex) {
            // Load balancing
            let index = Math.abs(columnIndex + rowIndex) % this.options.subdomains.length;
            return this.options.subdomains[index];
        }
        getZoomForUrl(tile) {
            let zoom = tile.getLogDepthIndex();
            let maxZoom = this.options.maxZoom;
            let zoomReverse = this.options.zoomReverse;
            let zoomOffset = this.options.zoomOffset;
            if (!zoomReverse) {
                zoom = maxZoom - zoom;
            }
            return zoom + zoomOffset;
        }
        cancelTile(tileImage) {
            if (tileImage) {
                tileImage.onload = function () {
                    return false;
                };
                tileImage.onerror = function () {
                    return false;
                };
                tileImage.src = "";
            }
        }
        // Tile drawing
        // @Override
        drawTileOnCanvas(tileResponse) {
            let source = tileResponse.getSource();
            if (source instanceof HTMLCanvasElement) {
                return source;
            }
            else {
                // Create canvas
                let canvas = document.createElement("canvas");
                canvas.width = this.getTileSizeInPx();
                canvas.height = this.getTileSizeInPx();
                // Draw tile on canvas context
                let ctx = canvas.getContext("2d");
                let image = tileResponse.getSource();
                ctx.drawImage(image, 0, 0);
                return canvas;
            }
        }
    }
    exports.RemoteTileLoader = RemoteTileLoader;
    (function (RemoteTileLoader) {
        class Options extends TileLoader_2.TileLoader.Options {
            constructor() {
                super(...arguments);
                this.minZoom = 0;
                this.maxZoom = 18;
                this.minNativeZoom = 0;
                this.maxNativeZoom = 18;
                this.subdomains = "abc";
                this.zoomOffset = 0;
                this.zoomReverse = false;
                this.crossOrigin = false;
            }
        }
        RemoteTileLoader.Options = Options;
    })(RemoteTileLoader = exports.RemoteTileLoader || (exports.RemoteTileLoader = {}));
});
define("src/app/world/WorldMap", ["require", "exports", "src/map/FruityMap", "src/map/view/world/layers/tileLayer/TileLayer", "src/map/view/hud/layers/navigationLayer/NavigationLayer", "src/map/view/hud/layers/controlLayer/ControlLayer", "src/app/relution/locale/LocalizationEn", "src/map/view/world/layers/tileLayer/RemoteTileLoader", "src/map/view/world/objects/WorldCamera", "src/app/relution/RelutionMap", "src/rendering/pixi/PixiRenderer", "src/engine/rendering/Renderer"], function (require, exports, FruityMap_2, TileLayer_2, NavigationLayer_2, ControlLayer_2, LocalizationEn_2, RemoteTileLoader_1, WorldCamera_4, RelutionMap_3, PixiRenderer_2, Renderer_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorldMap = void 0;
    class WorldMap {
        constructor() {
            const environment = new RelutionMap_3.RelutionMap.Environment();
            environment.scene.localization = new LocalizationEn_2.LocalizationEn();
            environment.scene.renderer = new PixiRenderer_2.PixiRenderer(new Renderer_4.Renderer.Config());
            this.fruityMap = new FruityMap_2.FruityMap({
                parentHtmlElement: document.body,
                camera: new WorldCamera_4.WorldCamera.Config(),
                preloadingImages: [{
                        resourceName: "map",
                        url: "http://www.nationsonline.org/maps/political_world_map3000.jpg"
                    },
                    this.getPreloadingImage("compass"),
                    this.getPreloadingImage("plus_normal"),
                    this.getPreloadingImage("minus_normal"),
                    this.getPreloadingImage("pan_center"),
                    this.getPreloadingImage("pan_down"),
                    this.getPreloadingImage("pan_up"),
                    this.getPreloadingImage("pan_left"),
                    this.getPreloadingImage("pan_right")
                ]
            }, environment, () => {
                // World
                let world = this.fruityMap.getWorld();
                let tileLoader = new RemoteTileLoader_1.RemoteTileLoader("http://{s}.tile.osm.org/{z}/{x}/{y}.png", { crossOrigin: true });
                // let tileLoader = new LocalTileLoader("map");
                const config = new TileLayer_2.TileLayer.Config();
                config.tileEngine.loadTilesForRetinaDisplay = false;
                this.tileLayer = new TileLayer_2.TileLayer(config, this.fruityMap.getEnvironment(), tileLoader);
                world.addLayer(this.tileLayer);
                // HUD
                let hud = this.fruityMap.getHud();
                let worldCamera = world.getScene().getCamera();
                this.navigationLayer = new NavigationLayer_2.NavigationLayer(new NavigationLayer_2.NavigationLayer.Config(), this.fruityMap.getEnvironment(), worldCamera);
                this.controlLayer = new ControlLayer_2.ControlLayer(new ControlLayer_2.ControlLayer.Config(), this.fruityMap.getEnvironment(), worldCamera);
                hud.addLayer(this.navigationLayer);
                hud.addLayer(this.controlLayer);
            });
            window.addEventListener("resize", () => {
                let newWidth = window.innerWidth - 30;
                let newHeight = window.innerHeight - 30;
                this.fruityMap.setCanvasSize(newWidth, newHeight);
            });
        }
        getPreloadingImage(imageName) {
            return { resourceName: imageName, url: "../../../img/png/" + imageName + ".png" };
        }
    }
    exports.WorldMap = WorldMap;
});
define("src/engine/animation/BackInterpolator", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BackInterpolator = void 0;
    class BackInterpolator {
        getInterpolationValue(timeProgress) {
            let t = timeProgress;
            let result = Math.pow(t, 2) * (2.70158 * t - 1.70158);
            return result;
        }
    }
    exports.BackInterpolator = BackInterpolator;
});
define("src/engine/animation/BounceInterpolator", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BounceInterpolator = void 0;
    class BounceInterpolator {
        getInterpolationValue(timeProgress) {
            let result = 0;
            let t = timeProgress;
            if (1 - t >= 0 && 1 - t < 4 / 11) {
                result = 1 - Math.pow((11 / 4) * (1 - t), 2);
            }
            else if (1 - t >= 4 / 11 && 1 - t < 8 / 11) {
                let base = (11 / 4) * (1 - t - (6 / 11));
                result = 1 - (Math.pow(base, 2) + (3 / 4));
            }
            else if (1 - t >= 8 / 11 && 1 - t < 10 / 11) {
                let base = (11 / 4) * (1 - t - (9 / 11));
                result = 1 - (Math.pow(base, 2) + (15 / 16));
            }
            else if (1 - t >= 10 / 11 && 1 - t <= 11 / 11) {
                let base = (11 / 4) * (1 - t - (10.5 / 11));
                result = 1 - (Math.pow(base, 2) + (63 / 64));
            }
            return result;
        }
    }
    exports.BounceInterpolator = BounceInterpolator;
});
define("src/engine/animation/CubicInterpolator", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CubicInterpolator = void 0;
    class CubicInterpolator {
        getInterpolationValue(timeProgress) {
            return Math.pow(timeProgress, 3);
        }
    }
    exports.CubicInterpolator = CubicInterpolator;
});
define("src/engine/animation/QuatricInterpolator", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QuatricInterpolator = void 0;
    class QuatricInterpolator {
        getInterpolationValue(timeProgress) {
            return Math.pow(timeProgress, 4);
        }
    }
    exports.QuatricInterpolator = QuatricInterpolator;
});
define("src/engine/animation/SquareInterpolator", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SquareInterpolator = void 0;
    class SquareInterpolator {
        getInterpolationValue(timeProgress) {
            return Math.pow(timeProgress, 2);
        }
    }
    exports.SquareInterpolator = SquareInterpolator;
});
define("src/engine/utils/UnsupportedOperationException", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnsupportedOperationException = void 0;
    class UnsupportedOperationException extends Error {
        constructor() {
            super("Operation unsupported.");
            Object.setPrototypeOf(this, UnsupportedOperationException.prototype);
        }
    }
    exports.UnsupportedOperationException = UnsupportedOperationException;
});
define("src/map/utils/ArrayUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayUtils = void 0;
    class ArrayUtils {
        static getSubArrayWithIndices(path, indices) {
            let subarray = new Array();
            for (let i = 0; i < indices.length; i++) {
                let index = indices[i];
                subarray.push(path[index]);
            }
            return subarray;
        }
    }
    exports.ArrayUtils = ArrayUtils;
});
define("src/map/utils/Simplify", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Simplify = void 0;
    /* tslint:disable */
    class Simplify {
        /*
        (c) 2013, Vladimir Agafonkin
        Simplify.js, a high-performance JS polyline simplification library
        mourner.github.io/simplify-js
        */
        // to suit your point format, run search/replace for '.x' and '.y';
        // for 3D version, see 3d branch (configurability would draw significant performance overhead)
        // square distance between 2 points
        static getSqDist(p1, p2) {
            var dx = p1.x - p2.x, dy = p1.y - p2.y;
            return dx * dx + dy * dy;
        }
        // square distance from a point to a segment
        static getSqSegDist(p, p1, p2) {
            var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y;
            if (dx !== 0 || dy !== 0) {
                var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);
                if (t > 1) {
                    x = p2.x;
                    y = p2.y;
                }
                else if (t > 0) {
                    x += dx * t;
                    y += dy * t;
                }
            }
            dx = p.x - x;
            dy = p.y - y;
            return dx * dx + dy * dy;
        }
        // rest of the code doesn't care about point format
        // basic distance-based simplification
        static simplifyRadialDist(points, sqTolerance) {
            var prevPoint = points[0], newPoints = [prevPoint], point;
            for (var i = 1, len = points.length; i < len; i++) {
                point = points[i];
                if (Simplify.getSqDist(point, prevPoint) > sqTolerance) {
                    newPoints.push(point);
                    prevPoint = point;
                }
            }
            if (prevPoint !== point)
                newPoints.push(point);
            return newPoints;
        }
        static simplifyDPStep(points, first, last, sqTolerance, simplified) {
            var maxSqDist = sqTolerance, index;
            for (var i = first + 1; i < last; i++) {
                var sqDist = Simplify.getSqSegDist(points[i], points[first], points[last]);
                if (sqDist > maxSqDist) {
                    index = i;
                    maxSqDist = sqDist;
                }
            }
            if (maxSqDist > sqTolerance) {
                if (index - first > 1)
                    Simplify.simplifyDPStep(points, first, index, sqTolerance, simplified);
                simplified.push(points[index]);
                if (last - index > 1)
                    Simplify.simplifyDPStep(points, index, last, sqTolerance, simplified);
            }
        }
        // simplification using Ramer-Douglas-Peucker algorithm
        static simplifyDouglasPeucker(points, sqTolerance) {
            var last = points.length - 1;
            var simplified = [points[0]];
            Simplify.simplifyDPStep(points, 0, last, sqTolerance, simplified);
            simplified.push(points[last]);
            return simplified;
        }
        // both algorithms combined for awesome performance
        static simplify(points, tolerance, highestQuality) {
            if (points.length <= 2)
                return points;
            var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;
            points = highestQuality ? points : Simplify.simplifyRadialDist(points, sqTolerance);
            points = Simplify.simplifyDouglasPeucker(points, sqTolerance);
            return points;
        }
    }
    exports.Simplify = Simplify;
});
define("src/map/view/world/objects/InvisibleObject", ["require", "exports", "src/engine/scene/SceneObject"], function (require, exports, SceneObject_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvisibleObject = void 0;
    class InvisibleObject extends SceneObject_15.SceneObject {
        // Initialization
        constructor(environment) {
            super(environment);
            this.container = this.getEnvironment().renderer.newDisplayObjectContainer();
            this.container.visible = false;
        }
        // View
        // @Override
        getView() {
            return this.container;
        }
    }
    exports.InvisibleObject = InvisibleObject;
});
// tslint:disable
define("src/rendering/pixi/extensions/filters/PixiTextureMatrix", ["require", "exports", "pixijs"], function (require, exports, PIXI) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    PIXI = __importStar(PIXI);
    const tempMat = new PIXI.Matrix();
    /**
     * Class controls uv transform and frame clamp for texture
     * Can be used in Texture "transform" field, or separately, you can use different clamp settings on the same texture.
     * If you want to add support for texture region of certain feature or filter, that's what you're looking for.
     *
     * @see TextObjecture
     * @see PIXI.mesh.Mesh
     * @see PIXI.extras.TilingSprite
     * @class
     * @memberof PIXI
     */
    class PixiTextureMatrix {
        /**
         *
         * @param {TextObjecture} texture observed texture
         * @param {number} [clampMargin] Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
         * @constructor
         */
        constructor(texture, clampMargin) {
            this._texture = texture;
            this.mapCoord = new PIXI.Matrix();
            this.uClampFrame = new Float32Array(4);
            this.uClampOffset = new Float32Array(2);
            this._lastTextureID = -1;
            /**
             * Changes frame clamping
             * Works with TilingSprite and Mesh
             * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders
             *
             * @default 0
             * @member {number}
             */
            this.clampOffset = 0;
            /**
             * Changes frame clamping
             * Works with TilingSprite and Mesh
             * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
             *
             * @default 0.5
             * @member {number}
             */
            this.clampMargin = (typeof clampMargin === 'undefined') ? 0.5 : clampMargin;
        }
        /**
         * texture property
         * @member {TextObjecture}
         */
        get texture() {
            return this._texture;
        }
        set texture(value) {
            this._texture = value;
            this._lastTextureID = -1;
        }
        /**
         * Multiplies uvs array to transform
         * @param {Float32Array} uvs mesh uvs
         * @param {Float32Array} [out=uvs] output
         * @returns {Float32Array} output
         */
        multiplyUvs(uvs, out) {
            if (out === undefined) {
                out = uvs;
            }
            const mat = this.mapCoord;
            for (let i = 0; i < uvs.length; i += 2) {
                const x = uvs[i];
                const y = uvs[i + 1];
                out[i] = (x * mat.a) + (y * mat.c) + mat.tx;
                out[i + 1] = (x * mat.b) + (y * mat.d) + mat.ty;
            }
            return out;
        }
        /**
         * updates matrices if texture was changed
         * @param {boolean} forceUpdate if true, matrices will be updated any case
         * @returns {boolean} whether or not it was updated
         */
        update(forceUpdate) {
            const tex = this._texture;
            if (!tex || !tex.valid) {
                return false;
            }
            if (!forceUpdate
                && this._lastTextureID === tex._updateID) {
                return false;
            }
            this._lastTextureID = tex._updateID;
            const uvs = tex._uvs;
            this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
            const orig = tex.orig;
            const trim = tex.trim;
            if (trim) {
                tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
                this.mapCoord.append(tempMat);
            }
            const texBase = tex.baseTexture;
            const frame = this.uClampFrame;
            const margin = this.clampMargin / texBase.resolution;
            const offset = this.clampOffset;
            frame[0] = (tex._frame.x + margin + offset) / texBase.width;
            frame[1] = (tex._frame.y + margin + offset) / texBase.height;
            frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
            frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
            this.uClampOffset[0] = offset / texBase.realWidth;
            this.uClampOffset[1] = offset / texBase.realHeight;
            return true;
        }
    }
    exports.default = PixiTextureMatrix;
});
define("src/index", ["require", "exports", "src/app/portal/PortalMap", "src/app/relution/RelutionMap", "src/app/relution/events/RelutionEventSystem", "src/app/relution/locale/LocalizationDe", "src/app/relution/locale/LocalizationEn", "src/app/relution/model/Model", "src/app/relution/model/RelutionMapModel", "src/app/relution/model/RelutionMapModelLoader", "src/app/relution/model/RelutionMapObjectModel", "src/app/relution/model/device/DeviceModel", "src/app/relution/model/device/DeviceTagModel", "src/app/relution/model/floor/FloorElementModel", "src/app/relution/model/floor/FloorModel", "src/app/relution/model/floor/FloorModelLoader", "src/app/relution/model/geofence/GeofenceModel", "src/app/relution/model/geofence/GeofenceStateModel", "src/app/relution/model/indoor/PositionEstimateModel", "src/app/relution/model/sensor/SensorHeatpointModel", "src/app/relution/model/usercount/UserCountHeatmapDeviceModel", "src/app/relution/model/usercount/UserCountHeatmapModel", "src/app/relution/modes/DeviceEditMode", "src/app/relution/modes/DeviceTaggingMode", "src/app/relution/modes/GeofenceEditMode", "src/app/relution/modes/RelutionMapMode", "src/app/relution/modes/RoomEditMode", "src/app/relution/modes/SingleDeviceEditMode", "src/app/relution/modes/TapeMeasureEditMode", "src/app/relution/modes/ZoneEditMode", "src/app/relution/utils/ColorUtils", "src/app/relution/utils/KeyUtils", "src/app/relution/utils/MouseUtils", "src/app/relution/utils/ReflectionUtils", "src/app/relution/utils/RssiToDistance", "src/app/relution/utils/SerialNumberUtils", "src/app/relution/utils/UuidUtils", "src/app/relution/view/hud/RelutionMapHud", "src/app/relution/view/hud/barLayer/Bar", "src/app/relution/view/hud/barLayer/BarLayer", "src/app/relution/view/hud/barLayer/actionBar/Action", "src/app/relution/view/hud/barLayer/actionBar/ActionBar", "src/app/relution/view/hud/barLayer/actionBar/ToggleAction", "src/app/relution/view/hud/barLayer/deviceBar/DeviceBar", "src/app/relution/view/hud/barLayer/deviceBar/DeviceItem", "src/app/relution/view/hud/debugLayer/DebugLayer", "src/app/relution/view/hud/helpLayer/HelpLayer", "src/app/relution/view/hud/popupLayer/PopupLayer", "src/app/relution/view/hud/selectionLayer/SelectionLayer", "src/app/relution/view/hud/tapeMeasure/TapeMeasureHudLayer", "src/app/relution/view/world/Building", "src/app/relution/view/world/Floor", "src/app/relution/view/world/RelutionMapAttributeObject", "src/app/relution/view/world/RelutionMapAttributeObjectLayer", "src/app/relution/view/world/RelutionMapObject", "src/app/relution/view/world/RelutionMapObjectLayer", "src/app/relution/view/world/RelutionMapWorld", "src/app/relution/view/world/layers/deviceLayers/beaconConnectionsLayer/BeaconConnection", "src/app/relution/view/world/layers/deviceLayers/beaconConnectionsLayer/BeaconConnectionsLayer", "src/app/relution/view/world/layers/deviceLayers/beaconDetailsLayer/BeaconConnectionDetails", "src/app/relution/view/world/layers/deviceLayers/beaconDetailsLayer/BeaconConnectionDetailsLayer", "src/app/relution/view/world/layers/deviceLayers/beaconRangeLayer/BeaconRange", "src/app/relution/view/world/layers/deviceLayers/beaconRangeLayer/BeaconRangeLayer", "src/app/relution/view/world/layers/deviceLayers/deviceAccuracyRangeLayer/DeviceAccuracyRange", "src/app/relution/view/world/layers/deviceLayers/deviceAccuracyRangeLayer/DeviceAccuracyRangeLayer", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/AssetMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/BACnetDeviceMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/BeaconMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceLayer", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/KnxDeviceMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/MeshGatewayMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceTaggingLayer/DeviceTaggingLayer", "src/app/relution/view/world/layers/deviceLayers/deviceTaggingLayer/DeviceTagMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceTrackLayer/DeviceTrack", "src/app/relution/view/world/layers/deviceLayers/deviceTrackLayer/DeviceTrackLayer", "src/app/relution/view/world/layers/deviceLayers/sensorHeatmapLayer/SensorHeatmapLayer", "src/app/relution/view/world/layers/deviceLayers/singleDeviceEditLayer/SingleDeviceEditLayer", "src/app/relution/view/world/layers/deviceLayers/userCountHeatmapLayer/UserCountHeatmapLayer", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/app/relution/view/world/layers/floorplanLayers/benchmarkLayers/TextureUpdateLayer", "src/app/relution/view/world/layers/floorplanLayers/benchmarkLayers/TileBasedBenchmarkLayer", "src/app/relution/view/world/layers/floorplanLayers/floorElementLayer/FloorElementLayer", "src/app/relution/view/world/layers/floorplanLayers/floorElementLayer/FloorElementMapObject", "src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/AbstractFloorplanLayer", "src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/FloorplanLayer", "src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/ImageBasedFloorplanLayer", "src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/TileBasedFloorplanLayer", "src/app/relution/view/world/layers/floorplanLayers/floorplanOverlayLayer/FloorplanOverlayLayer", "src/app/relution/view/world/layers/floorplanLayers/wallplanLayer/WallplanLayer", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/GeofenceLayer", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/GeofenceMapObject", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/geofences/CircleGeofenceMapObject", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/geofences/PolygonGeofenceMapObject", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/geofences/RectangleGeofenceMapObject", "src/app/relution/view/world/layers/objectLayers/objectInfoLayer/RelutionMapObjectInfo", "src/app/relution/view/world/layers/objectLayers/objectInfoLayer/RelutionMapObjectInfoLayer", "src/app/relution/view/world/layers/overlayLayers/tapeMeasureLayer/TapeMeasureWorldLayer", "src/app/relution/view/world/management/AutonomousObjectModelBinder", "src/app/relution/view/world/management/CoupledObjectModelBinder", "src/app/relution/view/world/management/RelutionMapObjectModelBinder", "src/app/relution/view/world/management/ViewModelBinder", "src/app/relution/view/world/management/ViewModelBinderDelegate", "src/app/simulator/SimulatorMap", "src/app/simulator/view/hud/popupLayer/BeaconConnectionDetailsPopupLayer", "src/app/world/WorldMap", "src/engine/Game", "src/engine/animation/Animation", "src/engine/animation/BackInterpolator", "src/engine/animation/BounceInterpolator", "src/engine/animation/CubicInterpolator", "src/engine/animation/EaseIn", "src/engine/animation/EaseOut", "src/engine/animation/Interpolator", "src/engine/animation/LinearInterpolator", "src/engine/animation/QuatricInterpolator", "src/engine/animation/SquareInterpolator", "src/engine/general/AABB", "src/engine/general/OBB", "src/engine/input/GestureRecognizer", "src/engine/input/InputEvent", "src/engine/input/InputSystem", "src/engine/input/MacKeyDetector", "src/engine/locale/Localization", "src/engine/locale/UnresolvedLocalization", "src/engine/math/Matrix2x3", "src/engine/math/Transform", "src/engine/math/Vector2", "src/engine/rendering/Renderer", "src/engine/rendering/WebGlRenderer", "src/engine/rendering/objects/DisplayObject", "src/engine/rendering/objects/DisplayObjectContainer", "src/engine/rendering/objects/GraphicsObject", "src/engine/rendering/objects/SpriteObject", "src/engine/rendering/objects/TextObject", "src/engine/rendering/objects/text/TextStyle", "src/engine/rendering/texture/Texture", "src/engine/rendering/utils/Matrix", "src/engine/rendering/utils/Point", "src/engine/scene/Camera", "src/engine/scene/GameObject", "src/engine/scene/Scene", "src/engine/scene/SceneObject", "src/engine/structs/SceneObjectIterator", "src/engine/structs/SceneObjectListIterator", "src/engine/utils/IntersectionUtils", "src/engine/utils/PlatformUtils", "src/engine/utils/UnsupportedOperationException", "src/map/FruityMap", "src/map/utils/ArrayUtils", "src/map/utils/DateUtils", "src/map/utils/DeviceUtils", "src/map/utils/GraphicsUtils", "src/map/utils/Language", "src/map/utils/Logger", "src/map/utils/MathUtils", "src/map/utils/Prando", "src/map/utils/Simplify", "src/map/utils/StringUtils", "src/map/utils/SystemUtils", "src/map/view/Layer", "src/map/view/hud/Hud", "src/map/view/hud/layers/controlLayer/Compass", "src/map/view/hud/layers/controlLayer/ControlLayer", "src/map/view/hud/layers/controlLayer/PanObject", "src/map/view/hud/layers/controlLayer/ZoomObject", "src/map/view/hud/layers/navigationLayer/NavigationLayer", "src/map/view/hud/objects/ArrowObject", "src/map/view/hud/objects/ButtonObject", "src/map/view/hud/objects/ScrollableContentObject", "src/map/view/hud/objects/ScrollableObject", "src/map/view/world/World", "src/map/view/world/layers/heatmapLayer/HeatmapLayer", "src/map/view/world/layers/heatmapLayer/HeatmapLayerImpl", "src/map/view/world/layers/heatmapLayer/canvas/CanvasHeatmap", "src/map/view/world/layers/heatmapLayer/canvas/CanvasHeatmapLayer", "src/map/view/world/layers/heatmapLayer/webgl/Framebuffer", "src/map/view/world/layers/heatmapLayer/webgl/Heights", "src/map/view/world/layers/heatmapLayer/webgl/Node", "src/map/view/world/layers/heatmapLayer/webgl/Shader", "src/map/view/world/layers/heatmapLayer/webgl/TextureObject", "src/map/view/world/layers/heatmapLayer/webgl/WebGlHeatmap", "src/map/view/world/layers/heatmapLayer/webgl/WebGlHeatmapLayer", "src/map/view/world/layers/heatmapLayer/webgl/shaders/BlurShader", "src/map/view/world/layers/heatmapLayer/webgl/shaders/ClampShader", "src/map/view/world/layers/heatmapLayer/webgl/shaders/HeatmapShader", "src/map/view/world/layers/heatmapLayer/webgl/shaders/HeightsShader", "src/map/view/world/layers/heatmapLayer/webgl/shaders/MultiplyShader", "src/map/view/world/layers/tileLayer/LocalTileLoader", "src/map/view/world/layers/tileLayer/RemoteTileLoader", "src/map/view/world/layers/tileLayer/RemoteTileResponse", "src/map/view/world/layers/tileLayer/Tile", "src/map/view/world/layers/tileLayer/TileEngine", "src/map/view/world/layers/tileLayer/TileLayer", "src/map/view/world/layers/tileLayer/TileLoader", "src/map/view/world/layers/tileLayer/TileObject", "src/map/view/world/layers/tileLayer/TilePainter", "src/map/view/world/layers/tileLayer/TileReplacement", "src/map/view/world/layers/tileLayer/TileResponse", "src/map/view/world/objects/InvisibleObject", "src/map/view/world/objects/WorldCamera", "src/map/view/world/objects/WorldObject", "src/rendering/pixi/PixiDecoratingObject", "src/rendering/pixi/PixiRenderer", "src/rendering/pixi/extensions/filters/PixiSpriteInverseMaskFilter", "src/rendering/pixi/extensions/filters/PixiTextureMatrix", "src/rendering/pixi/objects/PixiDisplayObject", "src/rendering/pixi/objects/PixiDisplayObjectContainer", "src/rendering/pixi/objects/PixiGraphicsObject", "src/rendering/pixi/objects/PixiHighResTextObject", "src/rendering/pixi/objects/PixiSpriteObject", "src/rendering/pixi/objects/PixiTextObject", "src/rendering/pixi/objects/text/PixiTextStyle", "src/rendering/pixi/texture/PixiBaseTexture", "src/rendering/pixi/texture/PixiTexture", "src/rendering/pixi/utils/PixiMatrix", "src/rendering/pixi/utils/PixiObservablePoint", "src/rendering/pixi/utils/PixiPoint", "src/rendering/pixi/utils/PixiScaledPoint"], function (require, exports, PortalMap_1, RelutionMap_4, RelutionEventSystem_1, LocalizationDe_1, LocalizationEn_3, Model_13, RelutionMapModel_7, RelutionMapModelLoader_2, RelutionMapObjectModel_6, DeviceModel_8, DeviceTagModel_3, FloorElementModel_2, FloorModel_2, FloorModelLoader_1, GeofenceModel_4, GeofenceStateModel_2, PositionEstimateModel_1, SensorHeatpointModel_1, UserCountHeatmapDeviceModel_2, UserCountHeatmapModel_2, DeviceEditMode_2, DeviceTaggingMode_2, GeofenceEditMode_2, RelutionMapMode_8, RoomEditMode_2, SingleDeviceEditMode_2, TapeMeasureEditMode_2, ZoneEditMode_2, ColorUtils_3, KeyUtils_2, MouseUtils_3, ReflectionUtils_1, RssiToDistance_3, SerialNumberUtils_1, UuidUtils_2, RelutionMapHud_2, Bar_3, BarLayer_2, Action_3, ActionBar_1, ToggleAction_2, DeviceBar_2, DeviceItem_2, DebugLayer_2, HelpLayer_2, PopupLayer_4, SelectionLayer_2, TapeMeasureHudLayer_2, Building_2, Floor_3, RelutionMapAttributeObject_8, RelutionMapAttributeObjectLayer_7, RelutionMapObject_14, RelutionMapObjectLayer_6, RelutionMapWorld_2, BeaconConnection_2, BeaconConnectionsLayer_2, BeaconConnectionDetails_2, BeaconConnectionDetailsLayer_2, BeaconRange_2, BeaconRangeLayer_2, DeviceAccuracyRange_2, DeviceAccuracyRangeLayer_2, AssetMapObject_5, BACnetDeviceMapObject_2, BeaconMapObject_9, DeviceLayer_3, DeviceMapObject_8, KnxDeviceMapObject_2, MeshGatewayMapObject_3, DeviceTaggingLayer_2, DeviceTagMapObject_3, DeviceTrack_2, DeviceTrackLayer_2, SensorHeatmapLayer_2, SingleDeviceEditLayer_2, UserCountHeatmapLayer_2, FloorplanRelatedLayer_14, TextureUpdateLayer_1, TileBasedBenchmarkLayer_1, FloorElementLayer_2, FloorElementMapObject_3, AbstractFloorplanLayer_3, FloorplanLayer_2, ImageBasedFloorplanLayer_2, TileBasedFloorplanLayer_2, FloorplanOverlayLayer_2, WallplanLayer_2, GeofenceLayer_2, GeofenceMapObject_4, CircleGeofenceMapObject_2, PolygonGeofenceMapObject_3, RectangleGeofenceMapObject_2, RelutionMapObjectInfo_2, RelutionMapObjectInfoLayer_2, TapeMeasureWorldLayer_2, AutonomousObjectModelBinder_2, CoupledObjectModelBinder_2, RelutionMapObjectModelBinder_3, ViewModelBinder_2, ViewModelBinderDelegate_1, SimulatorMap_1, BeaconConnectionDetailsPopupLayer_2, WorldMap_1, Game_2, Animation_12, BackInterpolator_1, BounceInterpolator_1, CubicInterpolator_1, EaseIn_2, EaseOut_4, Interpolator_1, LinearInterpolator_12, QuatricInterpolator_1, SquareInterpolator_1, AABB_13, OBB_4, GestureRecognizer_8, InputEvent_3, InputSystem_2, MacKeyDetector_2, Localization_4, UnresolvedLocalization_2, Matrix2x3_3, Transform_2, Vector2_44, Renderer_5, WebGlRenderer_3, DisplayObject_1, DisplayObjectContainer_1, GraphicsObject_1, SpriteObject_1, TextObject_1, TextStyle_1, Texture_2, Matrix_1, Point_1, Camera_4, GameObject_6, Scene_2, SceneObject_16, SceneObjectIterator_1, SceneObjectListIterator_2, IntersectionUtils_7, PlatformUtils_2, UnsupportedOperationException_1, FruityMap_3, ArrayUtils_1, DateUtils_3, DeviceUtils_32, GraphicsUtils_3, Language_3, Logger_9, MathUtils_2, Prando_2, Simplify_1, StringUtils_2, SystemUtils_3, Layer_21, Hud_2, Compass_2, ControlLayer_3, PanObject_2, ZoomObject_2, NavigationLayer_3, ArrowObject_3, ButtonObject_4, ScrollableContentObject_2, ScrollableObject_2, World_2, HeatmapLayer_2, HeatmapLayerImpl_3, CanvasHeatmap_3, CanvasHeatmapLayer_2, Framebuffer_2, Heights_2, Node_2, Shader_6, TextureObject_3, WebGlHeatmap_2, WebGlHeatmapLayer_2, BlurShader_2, ClampShader_2, HeatmapShader_2, HeightsShader_2, MultiplyShader_2, LocalTileLoader_2, RemoteTileLoader_2, RemoteTileResponse_2, Tile_2, TileEngine_3, TileLayer_3, TileLoader_3, TileObject_2, TilePainter_2, TileReplacement_2, TileResponse_3, InvisibleObject_1, WorldCamera_5, WorldObject_2, PixiDecoratingObject_8, PixiRenderer_3, PixiSpriteInverseMaskFilter_2, PixiTextureMatrix_1, PixiDisplayObject_4, PixiDisplayObjectContainer_4, PixiGraphicsObject_2, PixiHighResTextObject_2, PixiSpriteObject_3, PixiTextObject_3, PixiTextStyle_3, PixiBaseTexture_2, PixiTexture_3, PixiMatrix_3, PixiObservablePoint_4, PixiPoint_4, PixiScaledPoint_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(PortalMap_1, exports);
    __exportStar(RelutionMap_4, exports);
    __exportStar(RelutionEventSystem_1, exports);
    __exportStar(LocalizationDe_1, exports);
    __exportStar(LocalizationEn_3, exports);
    __exportStar(Model_13, exports);
    __exportStar(RelutionMapModel_7, exports);
    __exportStar(RelutionMapModelLoader_2, exports);
    __exportStar(RelutionMapObjectModel_6, exports);
    __exportStar(DeviceModel_8, exports);
    __exportStar(DeviceTagModel_3, exports);
    __exportStar(FloorElementModel_2, exports);
    __exportStar(FloorModel_2, exports);
    __exportStar(FloorModelLoader_1, exports);
    __exportStar(GeofenceModel_4, exports);
    __exportStar(GeofenceStateModel_2, exports);
    __exportStar(PositionEstimateModel_1, exports);
    __exportStar(SensorHeatpointModel_1, exports);
    __exportStar(UserCountHeatmapDeviceModel_2, exports);
    __exportStar(UserCountHeatmapModel_2, exports);
    __exportStar(DeviceEditMode_2, exports);
    __exportStar(DeviceTaggingMode_2, exports);
    __exportStar(GeofenceEditMode_2, exports);
    __exportStar(RelutionMapMode_8, exports);
    __exportStar(RoomEditMode_2, exports);
    __exportStar(SingleDeviceEditMode_2, exports);
    __exportStar(TapeMeasureEditMode_2, exports);
    __exportStar(ZoneEditMode_2, exports);
    __exportStar(ColorUtils_3, exports);
    __exportStar(KeyUtils_2, exports);
    __exportStar(MouseUtils_3, exports);
    __exportStar(ReflectionUtils_1, exports);
    __exportStar(RssiToDistance_3, exports);
    __exportStar(SerialNumberUtils_1, exports);
    __exportStar(UuidUtils_2, exports);
    __exportStar(RelutionMapHud_2, exports);
    __exportStar(Bar_3, exports);
    __exportStar(BarLayer_2, exports);
    __exportStar(Action_3, exports);
    __exportStar(ActionBar_1, exports);
    __exportStar(ToggleAction_2, exports);
    __exportStar(DeviceBar_2, exports);
    __exportStar(DeviceItem_2, exports);
    __exportStar(DebugLayer_2, exports);
    __exportStar(HelpLayer_2, exports);
    __exportStar(PopupLayer_4, exports);
    __exportStar(SelectionLayer_2, exports);
    __exportStar(TapeMeasureHudLayer_2, exports);
    __exportStar(Building_2, exports);
    __exportStar(Floor_3, exports);
    __exportStar(RelutionMapAttributeObject_8, exports);
    __exportStar(RelutionMapAttributeObjectLayer_7, exports);
    __exportStar(RelutionMapObject_14, exports);
    __exportStar(RelutionMapObjectLayer_6, exports);
    __exportStar(RelutionMapWorld_2, exports);
    __exportStar(BeaconConnection_2, exports);
    __exportStar(BeaconConnectionsLayer_2, exports);
    __exportStar(BeaconConnectionDetails_2, exports);
    __exportStar(BeaconConnectionDetailsLayer_2, exports);
    __exportStar(BeaconRange_2, exports);
    __exportStar(BeaconRangeLayer_2, exports);
    __exportStar(DeviceAccuracyRange_2, exports);
    __exportStar(DeviceAccuracyRangeLayer_2, exports);
    __exportStar(AssetMapObject_5, exports);
    __exportStar(BACnetDeviceMapObject_2, exports);
    __exportStar(BeaconMapObject_9, exports);
    __exportStar(DeviceLayer_3, exports);
    __exportStar(DeviceMapObject_8, exports);
    __exportStar(KnxDeviceMapObject_2, exports);
    __exportStar(MeshGatewayMapObject_3, exports);
    __exportStar(DeviceTaggingLayer_2, exports);
    __exportStar(DeviceTagMapObject_3, exports);
    __exportStar(DeviceTrack_2, exports);
    __exportStar(DeviceTrackLayer_2, exports);
    __exportStar(SensorHeatmapLayer_2, exports);
    __exportStar(SingleDeviceEditLayer_2, exports);
    __exportStar(UserCountHeatmapLayer_2, exports);
    __exportStar(FloorplanRelatedLayer_14, exports);
    __exportStar(TextureUpdateLayer_1, exports);
    __exportStar(TileBasedBenchmarkLayer_1, exports);
    __exportStar(FloorElementLayer_2, exports);
    __exportStar(FloorElementMapObject_3, exports);
    __exportStar(AbstractFloorplanLayer_3, exports);
    __exportStar(FloorplanLayer_2, exports);
    __exportStar(ImageBasedFloorplanLayer_2, exports);
    __exportStar(TileBasedFloorplanLayer_2, exports);
    __exportStar(FloorplanOverlayLayer_2, exports);
    __exportStar(WallplanLayer_2, exports);
    __exportStar(GeofenceLayer_2, exports);
    __exportStar(GeofenceMapObject_4, exports);
    __exportStar(CircleGeofenceMapObject_2, exports);
    __exportStar(PolygonGeofenceMapObject_3, exports);
    __exportStar(RectangleGeofenceMapObject_2, exports);
    __exportStar(RelutionMapObjectInfo_2, exports);
    __exportStar(RelutionMapObjectInfoLayer_2, exports);
    __exportStar(TapeMeasureWorldLayer_2, exports);
    __exportStar(AutonomousObjectModelBinder_2, exports);
    __exportStar(CoupledObjectModelBinder_2, exports);
    __exportStar(RelutionMapObjectModelBinder_3, exports);
    __exportStar(ViewModelBinder_2, exports);
    __exportStar(ViewModelBinderDelegate_1, exports);
    __exportStar(SimulatorMap_1, exports);
    __exportStar(BeaconConnectionDetailsPopupLayer_2, exports);
    __exportStar(WorldMap_1, exports);
    __exportStar(Game_2, exports);
    __exportStar(Animation_12, exports);
    __exportStar(BackInterpolator_1, exports);
    __exportStar(BounceInterpolator_1, exports);
    __exportStar(CubicInterpolator_1, exports);
    __exportStar(EaseIn_2, exports);
    __exportStar(EaseOut_4, exports);
    __exportStar(Interpolator_1, exports);
    __exportStar(LinearInterpolator_12, exports);
    __exportStar(QuatricInterpolator_1, exports);
    __exportStar(SquareInterpolator_1, exports);
    __exportStar(AABB_13, exports);
    __exportStar(OBB_4, exports);
    __exportStar(GestureRecognizer_8, exports);
    __exportStar(InputEvent_3, exports);
    __exportStar(InputSystem_2, exports);
    __exportStar(MacKeyDetector_2, exports);
    __exportStar(Localization_4, exports);
    __exportStar(UnresolvedLocalization_2, exports);
    __exportStar(Matrix2x3_3, exports);
    __exportStar(Transform_2, exports);
    __exportStar(Vector2_44, exports);
    __exportStar(Renderer_5, exports);
    __exportStar(WebGlRenderer_3, exports);
    __exportStar(DisplayObject_1, exports);
    __exportStar(DisplayObjectContainer_1, exports);
    __exportStar(GraphicsObject_1, exports);
    __exportStar(SpriteObject_1, exports);
    __exportStar(TextObject_1, exports);
    __exportStar(TextStyle_1, exports);
    __exportStar(Texture_2, exports);
    __exportStar(Matrix_1, exports);
    __exportStar(Point_1, exports);
    __exportStar(Camera_4, exports);
    __exportStar(GameObject_6, exports);
    __exportStar(Scene_2, exports);
    __exportStar(SceneObject_16, exports);
    __exportStar(SceneObjectIterator_1, exports);
    __exportStar(SceneObjectListIterator_2, exports);
    __exportStar(IntersectionUtils_7, exports);
    __exportStar(PlatformUtils_2, exports);
    __exportStar(UnsupportedOperationException_1, exports);
    __exportStar(FruityMap_3, exports);
    __exportStar(ArrayUtils_1, exports);
    __exportStar(DateUtils_3, exports);
    __exportStar(DeviceUtils_32, exports);
    __exportStar(GraphicsUtils_3, exports);
    __exportStar(Language_3, exports);
    __exportStar(Logger_9, exports);
    __exportStar(MathUtils_2, exports);
    __exportStar(Prando_2, exports);
    __exportStar(Simplify_1, exports);
    __exportStar(StringUtils_2, exports);
    __exportStar(SystemUtils_3, exports);
    __exportStar(Layer_21, exports);
    __exportStar(Hud_2, exports);
    __exportStar(Compass_2, exports);
    __exportStar(ControlLayer_3, exports);
    __exportStar(PanObject_2, exports);
    __exportStar(ZoomObject_2, exports);
    __exportStar(NavigationLayer_3, exports);
    __exportStar(ArrowObject_3, exports);
    __exportStar(ButtonObject_4, exports);
    __exportStar(ScrollableContentObject_2, exports);
    __exportStar(ScrollableObject_2, exports);
    __exportStar(World_2, exports);
    __exportStar(HeatmapLayer_2, exports);
    __exportStar(HeatmapLayerImpl_3, exports);
    __exportStar(CanvasHeatmap_3, exports);
    __exportStar(CanvasHeatmapLayer_2, exports);
    __exportStar(Framebuffer_2, exports);
    __exportStar(Heights_2, exports);
    __exportStar(Node_2, exports);
    __exportStar(Shader_6, exports);
    __exportStar(TextureObject_3, exports);
    __exportStar(WebGlHeatmap_2, exports);
    __exportStar(WebGlHeatmapLayer_2, exports);
    __exportStar(BlurShader_2, exports);
    __exportStar(ClampShader_2, exports);
    __exportStar(HeatmapShader_2, exports);
    __exportStar(HeightsShader_2, exports);
    __exportStar(MultiplyShader_2, exports);
    __exportStar(LocalTileLoader_2, exports);
    __exportStar(RemoteTileLoader_2, exports);
    __exportStar(RemoteTileResponse_2, exports);
    __exportStar(Tile_2, exports);
    __exportStar(TileEngine_3, exports);
    __exportStar(TileLayer_3, exports);
    __exportStar(TileLoader_3, exports);
    __exportStar(TileObject_2, exports);
    __exportStar(TilePainter_2, exports);
    __exportStar(TileReplacement_2, exports);
    __exportStar(TileResponse_3, exports);
    __exportStar(InvisibleObject_1, exports);
    __exportStar(WorldCamera_5, exports);
    __exportStar(WorldObject_2, exports);
    __exportStar(PixiDecoratingObject_8, exports);
    __exportStar(PixiRenderer_3, exports);
    __exportStar(PixiSpriteInverseMaskFilter_2, exports);
    __exportStar(PixiTextureMatrix_1, exports);
    __exportStar(PixiDisplayObject_4, exports);
    __exportStar(PixiDisplayObjectContainer_4, exports);
    __exportStar(PixiGraphicsObject_2, exports);
    __exportStar(PixiHighResTextObject_2, exports);
    __exportStar(PixiSpriteObject_3, exports);
    __exportStar(PixiTextObject_3, exports);
    __exportStar(PixiTextStyle_3, exports);
    __exportStar(PixiBaseTexture_2, exports);
    __exportStar(PixiTexture_3, exports);
    __exportStar(PixiMatrix_3, exports);
    __exportStar(PixiObservablePoint_4, exports);
    __exportStar(PixiPoint_4, exports);
    __exportStar(PixiScaledPoint_2, exports);
});
define("test/utils/HttpUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpUtils = void 0;
    class HttpUtils {
        static getJson(path, success, failure) {
            let xhr = new XMLHttpRequest();
            this.xhrQueue.push(xhr);
            xhr.onreadystatechange = function () {
                if (xhr.readyState === XMLHttpRequest.DONE) {
                    let i = HttpUtils.xhrQueue.indexOf(xhr);
                    if (i > -1) {
                        HttpUtils.xhrQueue.splice(i, 1);
                    }
                    if (xhr.status === 200) {
                        if (success) {
                            success(JSON.parse(xhr.responseText));
                        }
                    }
                    else {
                        if (failure) {
                            failure(xhr.responseText);
                        }
                    }
                }
            };
            xhr.open("GET", path, true);
            xhr.send();
        }
        static postJson(path, jsonObject, successCallback, failure) {
            let xhr = new XMLHttpRequest();
            this.xhrQueue.push(xhr);
            xhr.onreadystatechange = function () {
                if (xhr.readyState === XMLHttpRequest.DONE) {
                    let i = HttpUtils.xhrQueue.indexOf(xhr);
                    if (i > -1) {
                        HttpUtils.xhrQueue.splice(i, 1);
                    }
                    if (xhr.status === 200) {
                        if (successCallback) {
                            successCallback(JSON.parse(xhr.responseText));
                        }
                    }
                    else {
                        if (failure) {
                            document.body.innerHTML = xhr.responseText;
                        }
                    }
                }
            };
            xhr.open("POST", path, true);
            xhr.setRequestHeader("Content-Type", "application/json");
            xhr.send(JSON.stringify(jsonObject));
        }
        static abortAllRequests() {
            for (let i = 0; i < HttpUtils.xhrQueue.length; i++) {
                const xhr = HttpUtils.xhrQueue[i];
                xhr.abort();
                let index = HttpUtils.xhrQueue.indexOf(xhr);
                if (index > -1) {
                    HttpUtils.xhrQueue.splice(index, 1);
                    i--;
                }
            }
        }
        static getGetParameter(parameterName) {
            let result = null;
            let tmp = [];
            location.search
                .substr(1)
                .split("&")
                .forEach(function (item) {
                tmp = item.split("=");
                if (tmp[0] === parameterName) {
                    result = decodeURIComponent(tmp[1]);
                }
            });
            return result;
        }
    }
    exports.HttpUtils = HttpUtils;
    HttpUtils.xhrQueue = new Array();
});
define("test/tests/relution/helper/testPortalMap", ["require", "exports", "src/app/relution/locale/LocalizationEn", "src/app/portal/PortalMap", "test/utils/HttpUtils", "src/app/relution/model/device/DeviceModel", "src/app/relution/model/floor/FloorModelLoader", "src/map/utils/Logger", "src/app/relution/RelutionMap", "src/app/relution/model/RelutionMapModelLoader", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceMapObject"], function (require, exports, LocalizationEn_4, PortalMap_2, HttpUtils_1, DeviceModel_9, FloorModelLoader_2, Logger_10, RelutionMap_5, RelutionMapModelLoader_3, DeviceMapObject_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TestObserver = exports.PortalMapTestConfig = void 0;
    function testPortalMap(config, testFunction) {
        let testDataPath = "../../maps/" + config.mapName + "/";
        let testCasePath = testDataPath + "data/" + config.testCaseName + "/";
        let floorplanUrl = testDataPath + "img/floorplan.png";
        let wallplanUrl = testDataPath + "img/wallplan.png";
        let options = initMapOptions(config);
        let map = new PortalMap_2.PortalMap(options);
        loadFloor(map, testDataPath + "floor.json", floorplanUrl, wallplanUrl, (floor) => {
            loadMap(map, floor, config, testCasePath, (fruityMap) => {
                if (config.shouldLoadDevices) {
                    loadDevices(fruityMap, testCasePath, (deviceModels) => {
                        testFunction(fruityMap, deviceModels, testCasePath);
                    });
                }
                else {
                    testFunction(fruityMap, null, testCasePath);
                }
            });
        });
    }
    exports.default = testPortalMap;
    function initMapOptions(config) {
        let options = config.mapOptions;
        // General
        options.localization = new LocalizationEn_4.LocalizationEn();
        options.parentHtmlElement = document.body;
        options.renderer.renderTargetSize.x = window.innerWidth - 30;
        options.renderer.renderTargetSize.y = window.innerHeight - 30;
        options.pathToImages = "../../../img/png/";
        options.world.building.objectTypeVisibilities.set(DeviceMapObject_9.DeviceMapObject, true);
        options.world.building.layerVisibilities.set("connections", true);
        return options;
    }
    function loadFloor(map, floorModelUrl, floorplanUrl, wallplanUrl, callback) {
        HttpUtils_1.HttpUtils.getJson(floorModelUrl, function (floorObject) {
            let floorModelOptions = {
                jsonObject: floorObject,
                pathToFloorplan: floorplanUrl,
                wallplanUrl: wallplanUrl,
                isPortalMode: false,
            };
            let floorModel = FloorModelLoader_2.FloorModelLoader.loadFloor(floorModelOptions);
            let floor = map.createFloor("floor1", floorModel);
            floor.load(() => {
                callback(floor);
            });
        });
    }
    function loadMap(map, floor, config, testCasePath, callback) {
        map.load(floor, function () {
            window.fruityMap = map;
            window.addEventListener("resize", () => {
                let newWidth = window.innerWidth - 30;
                let newHeight = window.innerHeight - 30;
                map.setSize(newWidth, newHeight);
            });
            window.addEventListener("beforeunload", function (e) {
                map.destroy();
            });
            callback(map);
        });
        map.addObserver(new TestObserver());
    }
    function loadDevices(fruityMap, testCasePath, callback) {
        HttpUtils_1.HttpUtils.getJson(testCasePath + "devices.json", function (devicesObject) {
            let deviceModels = RelutionMapModelLoader_3.RelutionMapModelLoader.loadModels(devicesObject, DeviceModel_9.DeviceModel, false);
            fruityMap.getBuilding().getCurrentFloor().loadDevices(deviceModels);
            callback(deviceModels);
        });
    }
    class PortalMapTestConfig {
        constructor() {
            this.mapName = "mway";
            this.testCaseName = "default";
            this.shouldLoadDevices = true;
            this.mapOptions = new RelutionMap_5.RelutionMap.Options();
        }
    }
    exports.PortalMapTestConfig = PortalMapTestConfig;
    class TestObserver {
        // @Override
        onObjectMovedToMap(beacon) {
            Logger_10.Logger.logDebug("On Beacon moved to map");
        }
        // @Override
        onObjectMovedToStock(beacon) {
            Logger_10.Logger.logDebug("On Beacon moved to stock");
        }
        // @Override
        onObjectSelected(object) {
            Logger_10.Logger.logDebug("On object selected");
        }
        // @Override
        onObjectUnselected(object) {
            Logger_10.Logger.logDebug("On object unselected");
        }
        // @Override
        onObjectDoubleClicked(object) {
            Logger_10.Logger.logDebug("On object double clicked");
        }
        // @Override
        onLayerVisibilityChanged(layerName, visible) {
            let visibleString = "";
            if (visible) {
                visibleString = "visible";
            }
            else {
                visibleString = "invisible";
            }
            Logger_10.Logger.logDebug("Layer " + layerName + " has become " + visibleString);
        }
    }
    exports.TestObserver = TestObserver;
});
define("test/tests/heatmap/helper/MouseHeatmapLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/map/view/world/layers/heatmapLayer/HeatmapLayer", "src/engine/input/GestureRecognizer", "src/engine/math/Vector2"], function (require, exports, FloorplanRelatedLayer_15, HeatmapLayer_3, GestureRecognizer_9, Vector2_45) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MouseHeatmapLayer = void 0;
    class MouseHeatmapLayer extends FloorplanRelatedLayer_15.FloorplanRelatedLayer {
        // Construction
        constructor(building, floor) {
            super(building.getEnvironment(), floor.getFloorplanLayer());
            this.floor = floor;
            this.building = building;
            this.initHeatmap();
        }
        initHeatmap() {
            this.heatmap = new HeatmapLayer_3.HeatmapLayer(this.building.getEnvironment(), this.getFloorplanLayer());
            this.addChild(this.heatmap);
        }
        // Mouse interaction
        // @Override
        onMouseMove(x, y) {
            super.onMouseMove(x, y);
            if (this.floor === this.building.getCurrentFloor()) {
                if (GestureRecognizer_9.GestureRecognizer.isShiftPressed()) {
                    let mouseInRelative = this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new Vector2_45.Vector2(x, y));
                    let floorWidthInTx = this.getFloorplanLayer().getFloorSize().x;
                    let floorHeightInTx = this.getFloorplanLayer().getFloorSize().y;
                    let floorWidthInCm = this.getFloorplanLayer().getCmFromTexels(floorWidthInTx);
                    let floorHeightInCm = floorWidthInCm * (floorHeightInTx / floorWidthInTx);
                    let mouseInCm = new Vector2_45.Vector2(mouseInRelative.x * floorWidthInCm, mouseInRelative.y * floorHeightInCm);
                    let radiusInCm = 75;
                    this.heatmap.addPoint(mouseInCm.x, mouseInCm.y, radiusInCm, 0.2);
                    this.heatmap.clamp(0, 1);
                    this.heatmap.multiply(0.999);
                }
            }
            return false;
        }
        // @Override
        onTap(x, y, numTaps) {
            super.onTap(x, y, numTaps);
            if (this.floor === this.building.getCurrentFloor()) {
                if (GestureRecognizer_9.GestureRecognizer.isShiftPressed()) {
                    this.heatmap.clear();
                }
            }
            return false;
        }
    }
    exports.MouseHeatmapLayer = MouseHeatmapLayer;
});
define("test/tests/heatmap/testPortalHeatmap", ["require", "exports", "test/tests/relution/helper/testPortalMap", "test/tests/heatmap/helper/MouseHeatmapLayer"], function (require, exports, testPortalMap_1, MouseHeatmapLayer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    testPortalMap_1 = __importStar(testPortalMap_1);
    function testPortalHeatmap() {
        let config = new testPortalMap_1.PortalMapTestConfig();
        config.mapName = "mway";
        config.testCaseName = "default";
        config.shouldLoadDevices = false;
        (0, testPortalMap_1.default)(config, runTest);
    }
    exports.default = testPortalHeatmap;
    function runTest(fruityMap, deviceModels, testCasePath) {
        const floor = fruityMap.getBuilding().getCurrentFloor();
        let heatmapLayer = new MouseHeatmapLayer_1.MouseHeatmapLayer(fruityMap.getBuilding(), floor);
        floor.getDeviceLayerContainer().addLayerAtIndex(heatmapLayer, 0);
    }
});
define("test/tests/heatmap/helper/RandomHeatmapLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/map/view/world/layers/heatmapLayer/HeatmapLayer", "src/engine/math/Vector2"], function (require, exports, FloorplanRelatedLayer_16, HeatmapLayer_4, Vector2_46) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RandomHeatmapLayer = void 0;
    class RandomHeatmapLayer extends FloorplanRelatedLayer_16.FloorplanRelatedLayer {
        // Construction
        constructor(config, building, floor) {
            super(building.getEnvironment(), floor.getFloorplanLayer());
            // Configuration
            this.config = new RandomHeatmapLayer.Config();
            this.config = config;
            this.initModel();
            this.initView(building, floor);
        }
        initModel() {
            this.particles = new Array();
            const numParticles = 1000;
            for (let i = 0; i < numParticles; i++) {
                this.particles.push(new Vector2_46.Vector2(Math.random(), Math.random()));
            }
        }
        initView(building, floor) {
            this.floor = floor;
            this.building = building;
            this.initHeatmap();
        }
        initHeatmap() {
            this.heatmap = new HeatmapLayer_4.HeatmapLayer(this.building.getEnvironment(), this.getFloorplanLayer(), this.config.heatmapLayer);
            this.addChild(this.heatmap);
        }
        // Update
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            this.drawRandomHeatpoints();
        }
        drawRandomHeatpoints() {
            if (this.config.testCompleteRedraw) {
                this.heatmap.clear();
            }
            for (let i = 0; i < this.particles.length; i++) {
                this.moveParticleRandomly(i);
                this.drawParticle(i);
            }
        }
        moveParticleRandomly(index) {
            const oldX = this.particles[index].x;
            const oldY = this.particles[index].y;
            const maxShiftPerUpdateInCm = 40;
            this.particles[index].x = oldX + (((Math.random() - 0.5) * maxShiftPerUpdateInCm) / this.getFloorplanLayer().getFloorSize().x);
            this.particles[index].y = oldY + (((Math.random() - 0.5) * maxShiftPerUpdateInCm) / this.getFloorplanLayer().getFloorSize().y);
            this.particles[index].x = Math.max(Math.min(this.particles[index].x, 1.0), 0.0);
            this.particles[index].y = Math.max(Math.min(this.particles[index].y, 1.0), 0.0);
        }
        drawParticle(index) {
            const radiusInCm = this.config.testCompleteRedraw ? 60 : 40;
            let particle = this.particles[index];
            let mouseInRelative = new Vector2_46.Vector2(particle.x, particle.y);
            let floorWidthInTx = this.getFloorplanLayer().getFloorSize().x;
            let floorHeightInTx = this.getFloorplanLayer().getFloorSize().y;
            let floorWidthInCm = this.getFloorplanLayer().getCmFromTexels(floorWidthInTx);
            let floorHeightInCm = floorWidthInCm * (floorHeightInTx / floorWidthInTx);
            let mouseInCm = new Vector2_46.Vector2(mouseInRelative.x * floorWidthInCm, mouseInRelative.y * floorHeightInCm);
            const intensity = this.config.testCompleteRedraw ? 0.3 : 0.125;
            this.heatmap.addPoint(mouseInCm.x, mouseInCm.y, radiusInCm, intensity);
            this.heatmap.clamp(0, 1);
            this.heatmap.multiply(0.995);
        }
    }
    exports.RandomHeatmapLayer = RandomHeatmapLayer;
    (function (RandomHeatmapLayer) {
        class Config {
            constructor() {
                /**
                 * True, if the all heatpoints should be redrawn in each frame.
                 *
                 * Default: false
                 */
                this.testCompleteRedraw = false;
                /**
                 * The configuration of the heatmap layer
                 */
                this.heatmapLayer = new HeatmapLayer_4.HeatmapLayer.Config();
            }
        }
        RandomHeatmapLayer.Config = Config;
    })(RandomHeatmapLayer = exports.RandomHeatmapLayer || (exports.RandomHeatmapLayer = {}));
});
define("test/tests/heatmap/helper/testPortalHeatmapScalability", ["require", "exports", "test/tests/relution/helper/testPortalMap", "test/tests/heatmap/helper/RandomHeatmapLayer"], function (require, exports, testPortalMap_2, RandomHeatmapLayer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    testPortalMap_2 = __importStar(testPortalMap_2);
    function testPortalHeatmapScalability(config) {
        let mapConfig = new testPortalMap_2.PortalMapTestConfig();
        mapConfig.mapName = "mway";
        mapConfig.testCaseName = "default";
        mapConfig.shouldLoadDevices = false;
        (0, testPortalMap_2.default)(mapConfig, (fruityMap, deviceModels, testCasePath) => {
            const floor = fruityMap.getBuilding().getCurrentFloor();
            let heatmapLayer = new RandomHeatmapLayer_1.RandomHeatmapLayer(config, fruityMap.getBuilding(), floor);
            floor.getDeviceLayerContainer().addLayerAtIndex(heatmapLayer, 0);
        });
    }
    exports.default = testPortalHeatmapScalability;
});
define("test/tests/heatmap/testPortalHeatmapIncrementalScalability", ["require", "exports", "test/tests/heatmap/helper/RandomHeatmapLayer", "test/tests/heatmap/helper/testPortalHeatmapScalability"], function (require, exports, RandomHeatmapLayer_2, testPortalHeatmapScalability_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    testPortalHeatmapScalability_1 = __importDefault(testPortalHeatmapScalability_1);
    function testPortalHeatmapIncrementalScalability() {
        const config = new RandomHeatmapLayer_2.RandomHeatmapLayer.Config();
        config.testCompleteRedraw = false;
        (0, testPortalHeatmapScalability_1.default)(config);
    }
    exports.default = testPortalHeatmapIncrementalScalability;
});
define("test/tests/heatmap/testPortalHeatmapTotalRedrawScalability", ["require", "exports", "test/tests/heatmap/helper/RandomHeatmapLayer", "test/tests/heatmap/helper/testPortalHeatmapScalability"], function (require, exports, RandomHeatmapLayer_3, testPortalHeatmapScalability_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    testPortalHeatmapScalability_2 = __importDefault(testPortalHeatmapScalability_2);
    function testPortalHeatmapTotalRedrawScalability() {
        const config = new RandomHeatmapLayer_3.RandomHeatmapLayer.Config();
        config.testCompleteRedraw = true;
        (0, testPortalHeatmapScalability_2.default)(config);
    }
    exports.default = testPortalHeatmapTotalRedrawScalability;
});
define("test/tests/relution/helper/testMultiFloorPortalMap", ["require", "exports", "src/app/portal/PortalMap", "src/app/relution/locale/LocalizationEn", "test/utils/HttpUtils", "src/app/relution/model/device/DeviceModel", "src/app/relution/model/floor/FloorModelLoader", "src/app/relution/RelutionMap", "src/app/relution/model/RelutionMapModelLoader", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/AssetMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceMapObject"], function (require, exports, PortalMap_3, LocalizationEn_5, HttpUtils_2, DeviceModel_10, FloorModelLoader_3, RelutionMap_6, RelutionMapModelLoader_4, AssetMapObject_6, DeviceMapObject_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testMultiFloorPortalMap(buildingName, floorNames, testCaseName, useSvg, runTest) {
        let options = initMapOptions();
        let map = new PortalMap_3.PortalMap(options);
        initMap(map, buildingName, floorNames, testCaseName, useSvg, runTest);
    }
    exports.default = testMultiFloorPortalMap;
    function initMapOptions() {
        let options = new RelutionMap_6.RelutionMap.Options();
        options.parentHtmlElement = document.body;
        options.pathToImages = "../../../img/png/";
        options.renderer.renderTargetSize.x = window.innerWidth - 30;
        options.renderer.renderTargetSize.y = window.innerHeight - 30;
        options.world.building.layerVisibilities.set("ranges", true);
        options.world.building.layerVisibilities.set("connections", true);
        options.world.building.objectTypeVisibilities.set(DeviceMapObject_10.DeviceMapObject, true);
        options.world.building.objectTypeVisibilities.set(AssetMapObject_6.AssetMapObject, false);
        options.localization = new LocalizationEn_5.LocalizationEn();
        return options;
    }
    function initMap(map, buildingName, floorNames, testCaseName, useSvg, runTest) {
        // 3. Add floors to map
        let floors = new Array();
        let callback = function (floor) {
            floors.push(floor);
            if (floors.length === floorNames.length) {
                loadFruityMap(map, floors[0], (fruityMap) => {
                    addFloorsToMap(floors, fruityMap, buildingName, testCaseName, runTest);
                });
            }
        };
        // 2. Load floor textures
        let modelLoadedFloors = new Array();
        let floorModelCallback = function (floor) {
            modelLoadedFloors.push(floor);
            if (modelLoadedFloors.length == floorNames.length) {
                for (let i = 0; i < modelLoadedFloors.length; i++) {
                    let currentFloor = modelLoadedFloors[i];
                    currentFloor.load(callback);
                }
            }
        };
        // 1. Load floor models
        for (let i = 0; i < floorNames.length; i++) {
            let floorName = floorNames[i];
            let testDataPath = getTestDataPath(buildingName, floorName);
            let testCasePath = getTestCasePath(buildingName, floorName, testCaseName);
            let floorplanFile = "floorplan.png";
            if (useSvg === true) {
                floorplanFile = "floorplan.svg";
            }
            let floorplanUrl = testDataPath + "img/" + floorplanFile;
            let wallplanFile = "wallplan.png";
            let wallplanUrl = testDataPath + "img/" + wallplanFile;
            loadFloorModel(map, floorName, testDataPath + "floor.json", floorplanUrl, wallplanUrl, floorModelCallback);
        }
    }
    function getTestDataPath(buildingName, floorName) {
        let testDataPath = "../../maps/" + buildingName + "/" + floorName + "/";
        return testDataPath;
    }
    function getTestCasePath(buildingName, floorName, testCaseName) {
        let testDataPath = getTestDataPath(buildingName, floorName);
        let testCasePath = testDataPath + "data/" + testCaseName + "/";
        return testCasePath;
    }
    function loadFloorModel(map, floorName, floorModelUrl, floorplanUrl, wallplanUrl, callback) {
        HttpUtils_2.HttpUtils.getJson(floorModelUrl, function (floorObject) {
            let floorModelOptions = {
                jsonObject: floorObject,
                pathToFloorplan: floorplanUrl,
                wallplanUrl: wallplanUrl,
                isPortalMode: false,
            };
            let floorModel = FloorModelLoader_3.FloorModelLoader.loadFloor(floorModelOptions);
            let floor = map.createFloor(floorName, floorModel);
            callback(floor);
        });
    }
    function loadFruityMap(fruityMap, floor, callback) {
        fruityMap.load(floor, function () {
            window.fruityMap = fruityMap;
            window.addEventListener("beforeunload", function (e) {
                fruityMap.destroy();
            });
            window.addEventListener("resize", () => {
                let newWidth = window.innerWidth - 30;
                let newHeight = window.innerHeight - 30;
                fruityMap.setSize(newWidth, newHeight);
            });
            fruityMap.setDeviceEditModeEnabled(false);
            callback(fruityMap);
        });
    }
    function addFloorsToMap(floors, fruityMap, buildingName, testCaseName, runTest) {
        for (let i = 0; i < floors.length; i++) {
            let currentFloor = floors[i];
            let currentFloorName = currentFloor.getFloorName();
            fruityMap.getBuilding().addFloor(currentFloor);
            let testCasePath = getTestCasePath(buildingName, currentFloorName, testCaseName);
            loadDevices(fruityMap, currentFloor, testCasePath, (deviceModels) => {
                runTest(fruityMap, currentFloor, deviceModels, testCasePath);
            });
        }
    }
    function loadDevices(fruityMap, floor, testCasePath, callback) {
        HttpUtils_2.HttpUtils.getJson(testCasePath + "devices.json", function (devicesObject) {
            let deviceModels = RelutionMapModelLoader_4.RelutionMapModelLoader.loadModels(devicesObject, DeviceModel_10.DeviceModel, false);
            floor.loadDevices(deviceModels);
            callback(deviceModels);
        });
    }
});
define("test/tests/heatmap/testPortalMultiFloorHeatmap", ["require", "exports", "test/tests/relution/helper/testMultiFloorPortalMap", "src/engine/scene/Camera", "src/engine/animation/LinearInterpolator", "src/engine/animation/EaseIn", "src/engine/animation/EaseOut", "test/tests/heatmap/helper/MouseHeatmapLayer", "src/engine/math/Vector2"], function (require, exports, testMultiFloorPortalMap_1, Camera_5, LinearInterpolator_13, EaseIn_3, EaseOut_5, MouseHeatmapLayer_2, Vector2_47) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    testMultiFloorPortalMap_1 = __importDefault(testMultiFloorPortalMap_1);
    function testPortalMultiFloorHeatmap() {
        // Configuration
        let buildingName = "svg_map";
        let floorNames = ["001", "002"];
        let testCaseName = "default";
        let useSvg = true;
        (0, testMultiFloorPortalMap_1.default)(buildingName, floorNames, testCaseName, useSvg, runTest);
    }
    exports.default = testPortalMultiFloorHeatmap;
    function runTest(fruityMap, floor, deviceModels, testCasePath) {
        // Add heatmap layer
        let heatmapLayer = new MouseHeatmapLayer_2.MouseHeatmapLayer(fruityMap.getBuilding(), floor);
        floor.getDeviceLayerContainer().addLayerAtIndex(heatmapLayer, 0);
        floor.getFloorplanLayer().setIsInBackground(false);
        floor.getFloorplanLayer().setVisible(true);
        // Zoom to building
        let camera = fruityMap.getBuilding().getScene().getCamera();
        let floorSize = floor.getFloorplanLayer().getFloorSize();
        let topLeft = new Vector2_47.Vector2(floorSize.x * 0.25, floorSize.y * 0.33);
        let topRight = new Vector2_47.Vector2(floorSize.x * 0.75, floorSize.y * 0.33);
        let bottomLeft = new Vector2_47.Vector2(floorSize.x * 0.25, floorSize.y * 0.66);
        let bottomRight = new Vector2_47.Vector2(floorSize.x * 0.75, floorSize.y * 0.66);
        let frustum = new Camera_5.Camera.Frustum(topLeft, topRight, bottomLeft, bottomRight);
        camera.startAnimation(new EaseIn_3.EaseIn(new EaseOut_5.EaseOut(new LinearInterpolator_13.LinearInterpolator())), frustum.getObb(), 2000, 1500);
    }
});
define("test/tests/indoor/service/simulation/SimulationServiceConfig", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AssetTrackingDatasetSimulationModeConfig = exports.AssetTrackingMouseSimulationModeConfig = exports.AssetTrackingSimulationModeConfig = exports.AssetTrackingSimulationConfig = exports.BeaconTrackingSimulationConfig = exports.IntegrationTrackingSimulationConfig = exports.ObjectTrackingSimulationConfig = exports.TrackingSimulationConfig = exports.PositioningSimulationConfig = exports.SimulationConfig = exports.SimulationServiceConfig = exports.ApplicationConfig = void 0;
    class ApplicationConfig {
        constructor() {
            /**
             * Specifies the type of application.
             *
             * Possible values: ["monitoring", "simulation"].
             */
            this.type = SimulationServiceConfig.TYPE_NAME;
        }
    }
    exports.ApplicationConfig = ApplicationConfig;
    class SimulationServiceConfig extends ApplicationConfig {
        constructor() {
            super(...arguments);
            /**
             * The type specific simulation config.
             */
            this.simulation = new AssetTrackingSimulationConfig();
        }
    }
    exports.SimulationServiceConfig = SimulationServiceConfig;
    SimulationServiceConfig.TYPE_NAME = "simulation";
    class SimulationConfig {
        constructor() {
            /**
             * Specifies the type of simulation.
             *
             * Possible values: ["positioning", "objecttracking", "beacontracking", "assettracking"]
             */
            this.type = AssetTrackingSimulationConfig.TYPE_NAME;
            /**
             * The name dataset to be simulated
             */
            this.dataset = "longevity_bbbql_2018_06_07_000_reference_ruuvi_long_halts";
            /**
             * True, if the scalar field p(m | x) should be rendered on top of the floor.
             */
            this.renderProbabilityDensityMap = false;
            /**
             * True, if the radio map should be rendered on top of the floor, if a specific beacon is hovered.
             */
            this.renderRadioMap = true;
            /**
             * If true, the validation dataset itself will be used for calibration.
             * If false, the training dataset will be used for calibration.
             */
            this.useValidationDatasetForCalibration = true;
        }
    }
    exports.SimulationConfig = SimulationConfig;
    class PositioningSimulationConfig extends SimulationConfig {
        // Construction
        constructor() {
            super();
            this.type = PositioningSimulationConfig.TYPE_NAME;
        }
    }
    exports.PositioningSimulationConfig = PositioningSimulationConfig;
    PositioningSimulationConfig.TYPE_NAME = "positioning";
    /**
     * Base class for all simulations that make usage of time correlations between
     * measurements (tracking).
     */
    class TrackingSimulationConfig extends SimulationConfig {
        constructor() {
            super(...arguments);
            /**
             * The serial number of the device to be simulated.
             */
            this.deviceSerial = "ABCK4";
            /**
             * True, if the dataset should be simulated with max speed.
             */
            this.simulateWithMaxSpeed = true;
            /**
             * The simulation speed factor (time expansion factor).
             *
             * Default: 1.0
             */
            this.simulationSpeed = 1.0;
        }
    }
    exports.TrackingSimulationConfig = TrackingSimulationConfig;
    class ObjectTrackingSimulationConfig extends TrackingSimulationConfig {
        // Construction
        constructor() {
            super();
            this.type = ObjectTrackingSimulationConfig.TYPE_NAME;
        }
    }
    exports.ObjectTrackingSimulationConfig = ObjectTrackingSimulationConfig;
    ObjectTrackingSimulationConfig.TYPE_NAME = "objecttracking";
    /**
     * Base class for all simulations that simulate the complete tracking pipeline.
     */
    class IntegrationTrackingSimulationConfig extends TrackingSimulationConfig {
    }
    exports.IntegrationTrackingSimulationConfig = IntegrationTrackingSimulationConfig;
    class BeaconTrackingSimulationConfig extends IntegrationTrackingSimulationConfig {
        // Construction
        constructor() {
            super();
            this.type = BeaconTrackingSimulationConfig.TYPE_NAME;
        }
    }
    exports.BeaconTrackingSimulationConfig = BeaconTrackingSimulationConfig;
    BeaconTrackingSimulationConfig.TYPE_NAME = "beacontracking";
    class AssetTrackingSimulationConfig extends IntegrationTrackingSimulationConfig {
        // Construction
        constructor() {
            super();
            /**
             * The mode specific config.
             */
            this.mode = new AssetTrackingDatasetSimulationModeConfig();
            this.type = AssetTrackingSimulationConfig.TYPE_NAME;
        }
    }
    exports.AssetTrackingSimulationConfig = AssetTrackingSimulationConfig;
    // Constants
    AssetTrackingSimulationConfig.TYPE_NAME = "assettracking";
    class AssetTrackingSimulationModeConfig {
        constructor() {
            /**
             * Specifies the mode for asset tracking simulation.
             *
             * Possible values: ["assetMouseSimulation", "assetDatasetSimulation", "beaconDatasetSimulation"]
             */
            this.type = AssetTrackingDatasetSimulationModeConfig.TYPE_NAME;
        }
    }
    exports.AssetTrackingSimulationModeConfig = AssetTrackingSimulationModeConfig;
    class AssetTrackingMouseSimulationModeConfig extends AssetTrackingSimulationModeConfig {
        // Construction
        constructor() {
            super();
            this.simulateSpeed = true;
            this.simulateDirection = false;
            this.type = AssetTrackingMouseSimulationModeConfig.TYPE_NAME;
        }
    }
    exports.AssetTrackingMouseSimulationModeConfig = AssetTrackingMouseSimulationModeConfig;
    AssetTrackingMouseSimulationModeConfig.TYPE_NAME = "assetMouseSimulation";
    class AssetTrackingDatasetSimulationModeConfig extends AssetTrackingSimulationModeConfig {
        // Construction
        constructor() {
            super();
            this.type = AssetTrackingDatasetSimulationModeConfig.TYPE_NAME;
        }
    }
    exports.AssetTrackingDatasetSimulationModeConfig = AssetTrackingDatasetSimulationModeConfig;
    AssetTrackingDatasetSimulationModeConfig.TYPE_NAME = "assetDatasetSimulation";
});
define("test/tests/indoor/service/IndoorApplicationService", ["require", "exports", "test/tests/indoor/service/simulation/SimulationServiceConfig"], function (require, exports, SimulationServiceConfig_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndoorApplicationService = void 0;
    class IndoorApplicationService {
        // Service initilization
        init(config, finishedCallback) {
            throw new IndoorApplicationService.NotImplementedException();
        }
        // Configuration management
        updateConfig(configuration) {
            throw new IndoorApplicationService.NotImplementedException();
        }
        // Floor management
        loadFloor(siteName, callback) {
            throw new IndoorApplicationService.NotImplementedException();
        }
        // Device management
        loadDevices(siteName, callback) {
            throw new IndoorApplicationService.NotImplementedException();
        }
        // Geofence management
        loadGeofences(floorName, callback) {
            throw new IndoorApplicationService.NotImplementedException();
        }
    }
    exports.IndoorApplicationService = IndoorApplicationService;
    (function (IndoorApplicationService) {
        class Config {
            constructor() {
                /**
                 * The type specific simulation config.
                 */
                this.application = new SimulationServiceConfig_1.SimulationServiceConfig();
            }
        }
        IndoorApplicationService.Config = Config;
        class NotImplementedException extends Error {
        }
        IndoorApplicationService.NotImplementedException = NotImplementedException;
    })(IndoorApplicationService = exports.IndoorApplicationService || (exports.IndoorApplicationService = {}));
});
define("test/tests/indoor/models/DeviceTrackingStateModel", ["require", "exports", "src/app/relution/model/RelutionMapObjectModel", "src/app/relution/model/Model", "src/app/relution/model/RelutionMapModel"], function (require, exports, RelutionMapObjectModel_7, Model_14, RelutionMapModel_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeviceTrackingStateModel = exports.QualitativeTrackerState = exports.TrackingOutput = exports.TrackingState = exports.TrackingInput = exports.PointMatch = exports.VelocityEstimate = exports.PositionEstimate = void 0;
    // tslint:disable-next-line:max-classes-per-file
    class PositionEstimate extends RelutionMapModel_8.RelutionMapModel {
        // Getters and setters
        set positionMean(positionMean) {
            this._positionMean = positionMean;
            this.notifyObservers("positionMean");
        }
        get positionMean() {
            return this._positionMean;
        }
        set positionStd(positionStd) {
            this._positionStd = positionStd;
            this.notifyObservers("positionStd");
        }
        get positionStd() {
            return this._positionStd;
        }
        set timeInMs(timeInMs) {
            this._timeInMs = timeInMs;
            this.notifyObservers("timeInMs");
        }
        get timeInMs() {
            return this._timeInMs;
        }
    }
    __decorate([
        (0, Model_14.ModelProperty)()
    ], PositionEstimate.prototype, "_positionMean", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], PositionEstimate.prototype, "_positionStd", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], PositionEstimate.prototype, "_timeInMs", void 0);
    exports.PositionEstimate = PositionEstimate;
    class VelocityEstimate extends RelutionMapModel_8.RelutionMapModel {
        // Getters and setters
        set timestampMs(timestampMs) {
            this._timestampMs = timestampMs;
            this.notifyObservers("timestampMs");
        }
        get timestampMs() {
            return this._timestampMs;
        }
        set linearSpeedInCmPerSec(linearSpeedInCmPerSec) {
            this._linearSpeedInCmPerSec = linearSpeedInCmPerSec;
            this.notifyObservers("linearSpeedInCmPerSec");
        }
        get linearSpeedInCmPerSec() {
            return this._linearSpeedInCmPerSec;
        }
        set angularSpeedInRadPerSec(angularSpeedInRadPerSec) {
            this._angularSpeedInRadPerSec = angularSpeedInRadPerSec;
            this.notifyObservers("angularSpeedInRadPerSec");
        }
        get angularSpeedInRadPerSec() {
            return this._angularSpeedInRadPerSec;
        }
        set linearSpeedStdInCmPerSec(linearSpeedStdInCmPerSec) {
            this._linearSpeedStdInCmPerSec = linearSpeedStdInCmPerSec;
            this.notifyObservers("linearSpeedStdInCmPerSec");
        }
        get linearSpeedStdInCmPerSec() {
            return this._linearSpeedStdInCmPerSec;
        }
        set angularSpeedStdInRadPerSec(angularSpeedStdInRadPerSec) {
            this._angularSpeedStdInRadPerSec = angularSpeedStdInRadPerSec;
            this.notifyObservers("angularSpeedStdInRadPerSec");
        }
        get angularSpeedStdInRadPerSec() {
            return this._angularSpeedStdInRadPerSec;
        }
        set deltaTimeInSec(deltaTimeInSec) {
            this._deltaTimeInSec = deltaTimeInSec;
            this.notifyObservers("deltaTimeInSec");
        }
        get deltaTimeInSec() {
            return this._deltaTimeInSec;
        }
    }
    __decorate([
        (0, Model_14.ModelProperty)()
    ], VelocityEstimate.prototype, "_timestampMs", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], VelocityEstimate.prototype, "_linearSpeedInCmPerSec", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], VelocityEstimate.prototype, "_angularSpeedInRadPerSec", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], VelocityEstimate.prototype, "_linearSpeedStdInCmPerSec", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], VelocityEstimate.prototype, "_angularSpeedStdInRadPerSec", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], VelocityEstimate.prototype, "_deltaTimeInSec", void 0);
    exports.VelocityEstimate = VelocityEstimate;
    // tslint:disable-next-line:max-classes-per-file
    class PointMatch extends RelutionMapModel_8.RelutionMapModel {
        // Getters and setters
        set estimatedPosition(estimatedPosition) {
            this._estimatedPosition = estimatedPosition;
            this.notifyObservers("estimatedPosition");
        }
        get estimatedPosition() {
            return this._estimatedPosition;
        }
        set groundTruthPosition(groundTruthPosition) {
            this._groundTruthPosition = groundTruthPosition;
            this.notifyObservers("groundTruthPosition");
        }
        get groundTruthPosition() {
            return this._groundTruthPosition;
        }
    }
    __decorate([
        (0, Model_14.ModelProperty)()
    ], PointMatch.prototype, "_estimatedPosition", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], PointMatch.prototype, "_groundTruthPosition", void 0);
    exports.PointMatch = PointMatch;
    // tslint:disable-next-line:max-classes-per-file
    class TrackingInput extends Model_14.Model {
        // Getters and setters
        set measurementDeviceAvailable(measurementDeviceAvailable) {
            this._measurementDeviceAvailable = measurementDeviceAvailable;
            this.notifyObservers("measurementDeviceAvailable");
        }
        get measurementDeviceAvailable() {
            return this._measurementDeviceAvailable;
        }
    }
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingInput.prototype, "_measurementDeviceAvailable", void 0);
    exports.TrackingInput = TrackingInput;
    // tslint:disable-next-line:max-classes-per-file
    class TrackingState extends Model_14.Model {
        constructor() {
            // Absolute positioning system
            super(...arguments);
            this._nodeSerialNumbers = new Array();
            this._standstillTransitioningNodes = new Array();
            this._measurementMeans = new Array();
            this._measurementCounts = new Array();
            this._preaccumulatedMeasurementCounts = new Array();
            this._measurementAgesMs = new Array();
            this._particles = new Array();
            // Region estimation
            this._publicationAllowed = true;
        }
        // Getters and setters
        set nodeSerialNumbers(nodeSerialNumbers) {
            this._nodeSerialNumbers = nodeSerialNumbers;
            this.notifyObservers("nodeSerialNumbers");
        }
        get nodeSerialNumbers() {
            return this._nodeSerialNumbers;
        }
        set standstillTransitioningNodes(standstillTransitioningNodes) {
            this._standstillTransitioningNodes = standstillTransitioningNodes;
            this.notifyObservers("standstillTransitioningNodes");
        }
        get standstillTransitioningNodes() {
            return this._standstillTransitioningNodes;
        }
        set measurementMeans(measurementMeans) {
            this._measurementMeans = measurementMeans;
            this.notifyObservers("measurementMeans");
        }
        get measurementMeans() {
            return this._measurementMeans;
        }
        set measurementCounts(measurementCounts) {
            this._measurementCounts = measurementCounts;
            this.notifyObservers("measurementCounts");
        }
        get measurementCounts() {
            return this._measurementCounts;
        }
        set preaccumulatedMeasurementCounts(preaccumulatedMeasurementCounts) {
            this._preaccumulatedMeasurementCounts = preaccumulatedMeasurementCounts;
            this.notifyObservers("preaccumulatedMeasurementCounts");
        }
        get preaccumulatedMeasurementCounts() {
            return this._preaccumulatedMeasurementCounts;
        }
        set measurementAgesMs(measurementAgesMs) {
            this._measurementAgesMs = measurementAgesMs;
            this.notifyObservers("measurementAgesMs");
        }
        get measurementAgesMs() {
            return this._measurementAgesMs;
        }
        set apsPositionEstimate(apsPositionEstimate) {
            this._apsPositionEstimate = apsPositionEstimate;
            this.notifyObservers("apsPositionEstimate");
        }
        get apsPositionEstimate() {
            return this._apsPositionEstimate;
        }
        set particleFilterEstimation(particleFilterEstimation) {
            this._particleFilterEstimation = particleFilterEstimation;
            this.notifyObservers("particleFilterEstimation");
        }
        get particleFilterEstimation() {
            return this._particleFilterEstimation;
        }
        set particleFilterConverged(particleFilterConverged) {
            this._particleFilterConverged = particleFilterConverged;
            this.notifyObservers("particleFilterConverged");
        }
        get particleFilterConverged() {
            return this._particleFilterConverged;
        }
        set particles(particles) {
            this._particles = particles;
            this.notifyObservers("particles");
        }
        get particles() {
            return this._particles;
        }
        set state(state) {
            this._state = state;
            this.notifyObservers("state");
        }
        get state() {
            return this._state;
        }
        set publicationAllowed(publicationAllowed) {
            this._publicationAllowed = publicationAllowed;
            this.notifyObservers("publicationAllowed");
        }
        get publicationAllowed() {
            return this._publicationAllowed;
        }
    }
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingState.prototype, "_nodeSerialNumbers", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingState.prototype, "_standstillTransitioningNodes", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingState.prototype, "_measurementMeans", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingState.prototype, "_measurementCounts", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingState.prototype, "_preaccumulatedMeasurementCounts", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingState.prototype, "_measurementAgesMs", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingState.prototype, "_apsPositionEstimate", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingState.prototype, "_particleFilterEstimation", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingState.prototype, "_particleFilterConverged", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingState.prototype, "_particles", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingState.prototype, "_state", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingState.prototype, "_publicationAllowed", void 0);
    exports.TrackingState = TrackingState;
    class TrackingOutput extends Model_14.Model {
        constructor() {
            // Position estimate
            super(...arguments);
            // Path - Position estimates
            this._positionEstimatePath = new Array();
            // Path - Ground Truth
            this._groundTruthPath = new Array();
            this._observationPath = new Array();
            // Path - Matching
            this._pathMatching = new Array();
        }
        // Getters and setters
        set positionEstimate(positionEstimate) {
            this._positionEstimate = positionEstimate;
            this.notifyObservers("positionEstimate");
        }
        get positionEstimate() {
            return this._positionEstimate;
        }
        set velocityEstimate(velocityEstimate) {
            this._velocityEstimate = velocityEstimate;
            this.notifyObservers("velocityEstimate");
        }
        get velocityEstimate() {
            return this._velocityEstimate;
        }
        set motionStateEstimate(motionStateEstimate) {
            this._motionStateEstimate = motionStateEstimate;
            this.notifyObservers("motionStateEstimate");
        }
        get motionStateEstimate() {
            return this._motionStateEstimate;
        }
        set trackingStateEstimate(trackingStateEstimate) {
            this._trackingStateEstimate = trackingStateEstimate;
            this.notifyObservers("trackingStateEstimate");
        }
        get trackingStateEstimate() {
            return this._trackingStateEstimate;
        }
        set regionEstimate(regionEstimate) {
            this._regionEstimate = regionEstimate;
            this.notifyObservers("regionEstimate");
        }
        get regionEstimate() {
            return this._regionEstimate;
        }
        set positionEstimatePath(positionEstimatePath) {
            this._positionEstimatePath = positionEstimatePath;
            this.notifyObservers("positionEstimatePath");
        }
        get positionEstimatePath() {
            return this._positionEstimatePath;
        }
        set groundTruthPath(groundTruthPath) {
            this._groundTruthPath = groundTruthPath;
            this.notifyObservers("groundTruthPath");
        }
        get groundTruthPath() {
            return this._groundTruthPath;
        }
        set observationPath(observationPath) {
            this._observationPath = observationPath;
            this.notifyObservers("observationPath");
        }
        get observationPath() {
            return this._observationPath;
        }
        set pathMatching(pathMatching) {
            this._pathMatching = pathMatching;
            this.notifyObservers("pathMatching");
        }
        get pathMatching() {
            return this._pathMatching;
        }
    }
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingOutput.prototype, "_positionEstimate", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingOutput.prototype, "_velocityEstimate", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingOutput.prototype, "_motionStateEstimate", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingOutput.prototype, "_trackingStateEstimate", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingOutput.prototype, "_regionEstimate", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingOutput.prototype, "_positionEstimatePath", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingOutput.prototype, "_groundTruthPath", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], TrackingOutput.prototype, "_observationPath", void 0);
    __decorate([
        (0, Model_14.ModelProperty)({ clazz: PointMatch })
    ], TrackingOutput.prototype, "_pathMatching", void 0);
    exports.TrackingOutput = TrackingOutput;
    class QualitativeTrackerState extends Model_14.Model {
        constructor() {
            // Device identity
            super(...arguments);
            // Tracking input
            this._trackingInput = null;
            // Tracking state
            this._trackingState = null;
            // Tracking output
            this._trackingOutput = null;
        }
        // Getters and setters
        set deviceUuid(deviceUuid) {
            this._deviceUuid = deviceUuid;
            this.notifyObservers("deviceUuid");
        }
        get deviceUuid() {
            return this._deviceUuid;
        }
        set trackingInput(trackingInput) {
            this._trackingInput = trackingInput;
            this.notifyObservers("trackingInput");
        }
        get trackingInput() {
            return this._trackingInput;
        }
        set trackingState(trackingState) {
            this._trackingState = trackingState;
            this.notifyObservers("trackingInput");
        }
        get trackingState() {
            return this._trackingState;
        }
        set trackingOutput(trackingOutput) {
            this._trackingOutput = trackingOutput;
            this.notifyObservers("trackingOutput");
        }
        get trackingOutput() {
            return this._trackingOutput;
        }
    }
    __decorate([
        (0, Model_14.ModelProperty)()
    ], QualitativeTrackerState.prototype, "_deviceUuid", void 0);
    __decorate([
        (0, Model_14.ModelProperty)({ clazz: TrackingInput })
    ], QualitativeTrackerState.prototype, "_trackingInput", void 0);
    __decorate([
        (0, Model_14.ModelProperty)({ clazz: TrackingState })
    ], QualitativeTrackerState.prototype, "_trackingState", void 0);
    __decorate([
        (0, Model_14.ModelProperty)()
    ], QualitativeTrackerState.prototype, "_trackingOutput", void 0);
    exports.QualitativeTrackerState = QualitativeTrackerState;
    // tslint:disable-next-line:max-classes-per-file
    class DeviceTrackingStateModel extends RelutionMapObjectModel_7.RelutionMapObjectModel {
        constructor() {
            // Device information
            super(...arguments);
            this._state = new QualitativeTrackerState();
        }
        // Getters and setters
        set deviceUuid(deviceUuid) {
            this._deviceUuid = deviceUuid;
            this.notifyObservers("deviceUuid");
        }
        get deviceUuid() {
            return this._deviceUuid;
        }
        set state(state) {
            this._state = state;
            this.notifyObservers("state");
        }
        get state() {
            return this._state;
        }
    }
    __decorate([
        (0, RelutionMapObjectModel_7.ParentModel)(),
        (0, Model_14.ModelProperty)()
    ], DeviceTrackingStateModel.prototype, "_deviceUuid", void 0);
    __decorate([
        (0, Model_14.ModelProperty)({ clazz: QualitativeTrackerState })
    ], DeviceTrackingStateModel.prototype, "_state", void 0);
    exports.DeviceTrackingStateModel = DeviceTrackingStateModel;
});
define("test/tests/indoor/view/map/layers/deviceTrackingDetailsLayer/DeviceTrackingDetails", ["require", "exports", "src/map/view/hud/objects/ArrowObject", "src/map/utils/DeviceUtils", "src/map/utils/ArrayUtils", "src/map/view/world/objects/InvisibleObject", "test/tests/indoor/models/DeviceTrackingStateModel", "src/app/relution/view/world/RelutionMapObject", "src/engine/math/Vector2", "src/map/utils/DateUtils"], function (require, exports, ArrowObject_4, DeviceUtils_33, ArrayUtils_2, InvisibleObject_2, DeviceTrackingStateModel_1, RelutionMapObject_15, Vector2_48, DateUtils_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeviceTrackingDetails = void 0;
    let DeviceTrackingDetails = class DeviceTrackingDetails extends RelutionMapObject_15.RelutionMapObject {
        // Initialization
        constructor(config, environment, floorplanLayer, model, device, deviceLayer, showDetailsOnHover) {
            super(config, environment, floorplanLayer, model, device);
            // Configuration
            this.alwaysShowBaseEstimationErrorView = true;
            // View: Absolute positioning system
            this.nodeSerialNumbers = new Array();
            this.nodeMeasurementArrows = new Array();
            this.nodeMeasurementArrowsBodyColorReliable = 0x0000ff;
            this.nodeMeasurementArrowsBodyColorUnreliable = 0xff0000;
            this.nodeMeasurementTexts = new Array();
            this.apsPositionEstimateViewSizeInPx = 10;
            // View: Particle filter
            // View: Particles
            this.particlePool = new Array();
            this.particleSizeInPx = 7;
            this.particleMeanSizeInPx = 20;
            this.particleMeanIsReliable = false;
            this.finalPositionViewSizeInPx = 10;
            // View: Accuracy
            this.shouldDrawAccuracyLine = false;
            this.accuracyViewAlpha = 0.2;
            // View: Interaction
            this.showDetailsOnHover = false;
            this.isHovering = false;
            this.lastScaleFactor = 1.0;
            this.invalidated = false;
            this.deviceLayer = deviceLayer;
            this.showDetailsOnHover = showDetailsOnHover;
            this.initView();
        }
        initView() {
            this.initRootView();
            this.initStateView();
            this.initApsViews();
            this.initProbabilityImageSpriteView();
            this.initRadioMapImageSpriteView();
            this.initPathView();
            this.initAccuracyPathView();
            this.initAccuracyView();
            this.initParticlePool();
            this.initParticleContainer();
            this.initParticleMeanView();
            this.initFinalPositionView();
            this.initStandardDeviationView();
            this.initPositionEstimateErrorView();
            this.initGroundTruthPathView();
            this.initObservationPathView();
            this.initPathMatchingView();
            if (this.showDetailsOnHover) {
                this.rootObject.getView().alpha = 0.0;
            }
            this.invalidated = true;
        }
        initRootView() {
            this.rootObject = new InvisibleObject_2.InvisibleObject(this.getEnvironment());
            this.rootObject.getView().visible = true;
            this.addChild(this.rootObject);
        }
        initStateView() {
            // Drawing
            this.stateView = this.getEnvironment().renderer.newGraphicsObject();
            this.stateView.beginFill(0x0000ff);
            this.stateView.drawRect(0, 0, 1, 1);
            this.stateView.endFill();
            // Transformation
            let floorplanLayer = this.getDeviceLayer().getFloorplanLayer();
            this.stateView.width = floorplanLayer.getFloorSize().x;
            this.stateView.height = floorplanLayer.getFloorSize().y;
            // Alpha
            // To enable the state view set alpha to 0.05
            // However the state view in the current version does
            // not work well if multiple devices are tracked.
            // Thus, the state view should only be visible
            // next to the device.
            this.stateView.alpha = 0.00;
            // Add to scene graph
            this.rootObject.getView().addChild(this.stateView);
        }
        initApsViews() {
            this.removeNodeNodeIds();
            this.removeNodeMeasurementArrows();
            this.removeNodeMeasurementTexts();
            this.removeApsPositionEstimateView();
            this.removeApsPositionEstimateAccuracyView();
            this.initNodeNodeIds();
            this.initNodeMeasurementArrows();
            this.initNodeMeasurementTexts();
            this.initApsPositionEstimateView();
            this.initApsPositionEstimateAccuracyView();
        }
        removeNodeNodeIds() {
            this.nodeSerialNumbers = [];
        }
        removeNodeMeasurementArrows() {
            for (let i = 0; i < this.nodeMeasurementArrows.length; i++) {
                let nodeMeasurementArrow = this.nodeMeasurementArrows[i];
                this.rootObject.removeChild(nodeMeasurementArrow);
            }
            this.nodeMeasurementArrows = [];
        }
        removeNodeMeasurementTexts() {
            for (let i = 0; i < this.nodeMeasurementTexts.length; i++) {
                let text = this.nodeMeasurementTexts[i];
                this.rootObject.getView().removeChild(text);
            }
            this.nodeMeasurementTexts = [];
        }
        removeApsPositionEstimateView() {
            if (this.apsPositionEstimateView != null) {
                this.rootObject.getView().removeChild(this.apsPositionEstimateView);
            }
            this.apsPositionEstimateView = null;
        }
        removeApsPositionEstimateAccuracyView() {
            if (this.apsPositionEstimateAccuracyView != null) {
                this.rootObject.getView().removeChild(this.apsPositionEstimateAccuracyView);
            }
            this.apsPositionEstimateAccuracyView = null;
        }
        initNodeNodeIds() {
            this.nodeSerialNumbers = [];
            let nodes = this.getDeviceLayer().getAllBeacons();
            for (let i = 0; i < nodes.length; i++) {
                let node = nodes[i];
                this.nodeSerialNumbers.push(node.getModel().deviceId);
            }
        }
        initNodeMeasurementArrows() {
            this.nodeMeasurementArrows = new Array();
            let nodes = this.getDeviceLayer().getAllBeacons();
            for (let i = 0; i < nodes.length; i++) {
                // Get current node
                let node = nodes[i];
                // Create arrow
                let arrowObjectConfig = new ArrowObject_4.ArrowObject.Config();
                arrowObjectConfig.arrowBodyTextureName = "arrow_body";
                arrowObjectConfig.arrowHeadTextureName = "arrow_head";
                arrowObjectConfig.arrowHeadLengthInLogicalPx = DeviceUtils_33.DeviceUtils.getPhysicalPixelsFromLogical(12);
                arrowObjectConfig.maxArrowHeadLengthInPercent = 0.2;
                arrowObjectConfig.bodyColor = this.nodeMeasurementArrowsBodyColorReliable;
                let arrow = new ArrowObject_4.ArrowObject(arrowObjectConfig, this.getEnvironment());
                arrow.getView().alpha = 0.0;
                // Add arrow to scene
                this.nodeMeasurementArrows.push(arrow);
                this.rootObject.addChild(arrow);
            }
        }
        initNodeMeasurementTexts() {
            this.nodeMeasurementTexts = new Array();
            let nodes = this.getDeviceLayer().getAllBeacons();
            for (let i = 0; i < nodes.length; i++) {
                // Get current node
                let node = nodes[i];
                // Create text
                let fontSize = DeviceUtils_33.DeviceUtils.getPhysicalPixelsFromLogical(11);
                let textStyle = this.getEnvironment().renderer.newTextStyle();
                textStyle.fontSize = fontSize;
                let measurementText = this.getEnvironment().renderer.newTextObject("", 2, textStyle);
                measurementText.alpha = 0.0;
                // Add text to scene
                this.nodeMeasurementTexts.push(measurementText);
                this.rootObject.getView().addChild(measurementText);
            }
        }
        initApsPositionEstimateView() {
            this.apsPositionEstimateView = this.getEnvironment().renderer.newGraphicsObject();
            this.apsPositionEstimateView.clear();
            this.apsPositionEstimateView.beginFill(0x0000ff);
            this.apsPositionEstimateView.drawCircle(0, 0, this.apsPositionEstimateViewSizeInPx / 2);
            this.apsPositionEstimateView.endFill();
            this.rootObject.getView().addChild(this.apsPositionEstimateView);
        }
        initApsPositionEstimateAccuracyView() {
            this.apsPositionEstimateAccuracyView = this.getEnvironment().renderer.newGraphicsObject();
            this.apsPositionEstimateAccuracyView.clear();
            this.apsPositionEstimateAccuracyView.alpha = 0.3;
            this.rootObject.getView().addChild(this.apsPositionEstimateAccuracyView);
        }
        initProbabilityImageSpriteView() {
            this.probabilityImageSprite = this.getEnvironment().renderer.newSpriteObject();
            this.rootObject.getView().addChild(this.probabilityImageSprite);
        }
        initRadioMapImageSpriteView() {
            this.radioMapImageSprite = this.getEnvironment().renderer.newSpriteObject();
            this.rootObject.getView().addChild(this.radioMapImageSprite);
        }
        initPathView() {
            this.pathView = this.getEnvironment().renderer.newGraphicsObject();
            this.rootObject.getView().addChild(this.pathView);
        }
        initAccuracyPathView() {
            this.accuracyPathView = this.getEnvironment().renderer.newGraphicsObject();
            this.rootObject.getView().addChild(this.accuracyPathView);
        }
        initAccuracyView() {
            this.accuracyView = this.getEnvironment().renderer.newGraphicsObject();
            this.rootObject.getView().addChild(this.accuracyView);
            this.accuracyView.alpha = this.accuracyViewAlpha;
            this.accuracyView.beginFill(0x0000ff, 1.0);
            this.accuracyView.drawCircle(0.0, 0.0, 1.0);
            this.accuracyView.endFill();
        }
        initParticlePool() {
            this.particlePool = new Array();
        }
        initParticleContainer() {
            this.particleContainer = this.getEnvironment().renderer.newDisplayObjectContainer();
            this.rootObject.getView().addChild(this.particleContainer);
        }
        initParticleMeanView() {
            this.particleMeanView = this.getEnvironment().renderer.newGraphicsObject();
            this.drawParticleMeanView();
            // Alpha
            this.particleMeanView.alpha = 0.0;
            // Add to scene graph
            this.rootObject.getView().addChild(this.particleMeanView);
        }
        drawParticleMeanView() {
            let color = null;
            if (this.particleMeanIsReliable) {
                color = 0x008000;
            }
            else {
                color = 0x000080;
            }
            this.particleMeanView.clear();
            this.particleMeanView.beginFill(color);
            this.particleMeanView.drawCircle(0, 0, this.particleMeanSizeInPx / 2);
            this.particleMeanView.endFill();
        }
        initFinalPositionView() {
            this.finalPositionView = this.getEnvironment().renderer.newGraphicsObject();
            this.finalPositionView.clear();
            this.finalPositionView.beginFill(0x66ccff);
            this.finalPositionView.drawCircle(0, 0, this.finalPositionViewSizeInPx / 2);
            this.finalPositionView.endFill();
            this.finalPositionView.alpha = 0.0;
            this.rootObject.getView().addChild(this.finalPositionView);
        }
        initStandardDeviationView() {
            this.standardDeviationView = this.getEnvironment().renderer.newGraphicsObject();
            this.standardDeviationView.beginFill(0x00ff00);
            this.standardDeviationView.endFill();
            // Alpha
            this.standardDeviationView.alpha = 0;
            // Add to scene graph
            this.rootObject.getView().addChild(this.standardDeviationView);
        }
        initPositionEstimateErrorView() {
            let arrowObjectConfig = new ArrowObject_4.ArrowObject.Config();
            arrowObjectConfig.arrowBodyTextureName = "arrow_body";
            arrowObjectConfig.arrowHeadTextureName = "arrow_head";
            arrowObjectConfig.arrowHeadLengthInLogicalPx = DeviceUtils_33.DeviceUtils.getPhysicalPixelsFromLogical(12);
            arrowObjectConfig.maxArrowHeadLengthInPercent = 0.2;
            arrowObjectConfig.bodyColor = 0xff0000;
            this.positionEstimateErrorView = new ArrowObject_4.ArrowObject(arrowObjectConfig, this.getEnvironment());
            if (this.alwaysShowBaseEstimationErrorView) {
                // We add this view not from the root view but from the scene object itself,
                // because it should be visible also when not hovering.
                this.addChild(this.positionEstimateErrorView);
            }
            else {
                this.rootObject.addChild(this.positionEstimateErrorView);
            }
        }
        initGroundTruthPathView() {
            this.groundTruthPathView = this.getEnvironment().renderer.newGraphicsObject();
            this.rootObject.getView().addChild(this.groundTruthPathView);
        }
        initObservationPathView() {
            this.observationPathView = this.getEnvironment().renderer.newGraphicsObject();
            this.rootObject.getView().addChild(this.observationPathView);
        }
        initPathMatchingView() {
            this.pathMatchingView = this.getEnvironment().renderer.newGraphicsObject();
            this.rootObject.getView().addChild(this.pathMatchingView);
        }
        // Model loading
        // @Override
        onModelUpdated(model) {
            this.updateStateModel();
        }
        updateStateModel() {
            this.updateStateView();
            this.updateNodeMeasurementArrowAndTextViews();
            this.updateApsPositionEstimateView();
            this.updateApsPositionEstimateAccuracyView();
            this.updatePathViewAndAccuracyPathView();
            this.updateParticlesView();
            this.updateParticleMeanView();
            this.updateFinalPositionView();
            this.updateStandardDeviationView();
            this.updatePositionEstimateErrorView();
            this.updateRegionProbabilityView();
        }
        updateStateView() {
            if (this.getModel().state != null && this.getModel().state.trackingOutput.trackingStateEstimate != null) {
                if (this.getModel().state.trackingOutput.trackingStateEstimate === "TRACKED") {
                    this.changeStateToColor(0x00ff00);
                    this.rootObject.getView().alpha = 1.0;
                }
                else {
                    this.changeStateToColor(0x0000ff);
                    this.rootObject.getView().alpha = 0.5;
                }
            }
        }
        changeStateToColor(color) {
            this.stateView.clear();
            this.stateView.beginFill(color);
            this.stateView.drawRect(0, 0, 1, 1);
            this.stateView.endFill();
        }
        updateNodeMeasurementArrowAndTextViews() {
            if (this.getModel().state.trackingState.nodeSerialNumbers != null) {
                // Make all arrows visible that correspond with the measurement vector.
                for (let i = 0; i < this.nodeMeasurementArrows.length; i++) {
                    let arrow = this.nodeMeasurementArrows[i];
                    let text = this.nodeMeasurementTexts[i];
                    let serialNumber = this.nodeSerialNumbers[i];
                    let indexOfSerialNumber = this.getModel().state.trackingState.nodeSerialNumbers.indexOf(serialNumber);
                    if (indexOfSerialNumber > -1) {
                        arrow.getView().alpha = 1.0;
                        text.alpha = 1.0;
                        // Measurement value
                        const measurementMean = this.getModel().state.trackingState.measurementMeans[indexOfSerialNumber];
                        // Measurement age
                        const measurementAgeMs = this.getModel().state.trackingState.measurementAgesMs[indexOfSerialNumber];
                        let timeSince = DateUtils_4.DateUtils.getFormattedTimeDifference(measurementAgeMs);
                        let interval = timeSince[0];
                        let intervalType = timeSince[1];
                        let measurementAge = interval + this.getLocalizedStringFor("popup_time_unit_" + intervalType);
                        // Measurement count
                        const measurementCount = this.getModel().state.trackingState.measurementCounts[indexOfSerialNumber];
                        // Preaccumulated measurements count
                        const lastMeasurementsPreaccumulatedCount = this.getModel().state.trackingState.preaccumulatedMeasurementCounts[indexOfSerialNumber];
                        const lastMeasurementsPreaccumulatedCountText = lastMeasurementsPreaccumulatedCount == 0
                            ? ""
                            : "," + lastMeasurementsPreaccumulatedCount;
                        text.text = "" + measurementMean + " (" + measurementAge + ", " + measurementCount + lastMeasurementsPreaccumulatedCountText + ")";
                    }
                    else {
                        arrow.getView().alpha = 0.0;
                        text.alpha = 0.0;
                    }
                    if (this.getModel().state.trackingInput.measurementDeviceAvailable !== null && !this.getModel().state.trackingInput.measurementDeviceAvailable) {
                        arrow.setBodyColor(this.nodeMeasurementArrowsBodyColorUnreliable);
                    }
                    else if (this.getModel().state.trackingState.standstillTransitioningNodes[indexOfSerialNumber]) {
                        arrow.setBodyColor(0x00ff00);
                    }
                    else {
                        arrow.setBodyColor(this.nodeMeasurementArrowsBodyColorReliable);
                    }
                }
            }
        }
        updateApsPositionEstimateView() {
            if (this.apsPositionEstimateView != null && this.getModel().state.trackingState.apsPositionEstimate != null) {
                let xInTx = this.getPixelsFromCm(this.getModel().state.trackingState.apsPositionEstimate.positionMean.x);
                let yInTx = this.getPixelsFromCm(this.getModel().state.trackingState.apsPositionEstimate.positionMean.y);
                this.apsPositionEstimateView.position.x = xInTx;
                this.apsPositionEstimateView.position.y = yInTx;
            }
        }
        updateApsPositionEstimateAccuracyView() {
            if (this.apsPositionEstimateAccuracyView != null && this.getModel().state.trackingState.apsPositionEstimate != null) {
                // Scale
                const trustFactor = 3;
                let stdXInTx = this.getPixelsFromCm(this.getModel().state.trackingState.apsPositionEstimate.positionStd.x * trustFactor);
                let stdYInTx = this.getPixelsFromCm(this.getModel().state.trackingState.apsPositionEstimate.positionStd.y * trustFactor);
                // Position
                let xInTx = this.getPixelsFromCm(this.getModel().state.trackingState.apsPositionEstimate.positionMean.x);
                let yInTx = this.getPixelsFromCm(this.getModel().state.trackingState.apsPositionEstimate.positionMean.y);
                // Draw
                this.apsPositionEstimateAccuracyView.clear();
                this.apsPositionEstimateAccuracyView.beginFill(0x0000ff);
                this.apsPositionEstimateAccuracyView.drawEllipse(xInTx, yInTx, stdXInTx, stdYInTx);
                this.apsPositionEstimateAccuracyView.endFill();
            }
        }
        updatePathViewAndAccuracyPathView() {
            // Update path view and accuracy path view in next update cycle
            this.invalidated = true;
        }
        updateParticlesView() {
            // Add all particles to pool
            this.addAllParticlesToPool();
            // Add new particles
            let particles = this.getModel().state.trackingState.particles;
            let maxParticleWeight = this.getMaxParticleWeight(particles);
            let minParticleWeight = this.getMinParticleWeight(particles);
            let particleWeightRange = maxParticleWeight - minParticleWeight;
            for (let i = 0; i < particles.length; i++) {
                let particleModel = particles[i];
                let particleWeight = 1.0;
                if (particleWeightRange > 0) {
                    particleWeight = (particleModel.weight - minParticleWeight) / particleWeightRange;
                }
                this.addParticleForModel(particleModel, particleWeight);
            }
        }
        getMaxParticleWeight(particles) {
            let maxParticleWeight = -Number.MAX_VALUE;
            for (let i = 0; i < particles.length; i++) {
                let particleModel = particles[i];
                let weight = particleModel.weight;
                if (weight > maxParticleWeight) {
                    maxParticleWeight = weight;
                }
            }
            return maxParticleWeight;
        }
        getMinParticleWeight(particles) {
            let minParticleWeight = Number.MAX_VALUE;
            for (let i = 0; i < particles.length; i++) {
                let particleModel = particles[i];
                let weight = particleModel.weight;
                if (weight < minParticleWeight) {
                    minParticleWeight = weight;
                }
            }
            return minParticleWeight;
        }
        addAllParticlesToPool() {
            this.particlePool = [];
            for (let i = 0; i < this.particleContainer.children.length; i++) {
                let particleViewContainer = this.particleContainer.getChildAt(i);
                this.particlePool.push(particleViewContainer);
            }
            this.particleContainer.removeChildren();
        }
        addParticleForModel(particleModel, particleWeight) {
            // Get particle view container
            let particleViewContainer = null;
            if (this.particlePool.length === 0) {
                particleViewContainer = this.getNewParticle();
            }
            else {
                particleViewContainer = this.popParticleFromPool();
            }
            // Update scale
            let particleWrapper = particleViewContainer.getChildAt(0);
            let particleView = particleWrapper.getChildAt(0);
            particleView.width = this.particleSizeInPx * particleWeight;
            particleView.height = this.particleSizeInPx * particleWeight;
            // Update orientation
            let particleArrow = particleViewContainer.arrowObject;
            let currentXInTx = this.getDeviceLayer().getFloorplanLayer().getTexelsFromCm(particleModel.x);
            let currentYInTx = this.getDeviceLayer().getFloorplanLayer().getTexelsFromCm(particleModel.y);
            let previousXInTx = this.getDeviceLayer().getFloorplanLayer().getTexelsFromCm(particleModel.lastX);
            let previousYInTx = this.getDeviceLayer().getFloorplanLayer().getTexelsFromCm(particleModel.lastY);
            // Update orientation - Radius
            let diffVector = new Vector2_48.Vector2(currentXInTx - previousXInTx, currentYInTx - previousYInTx);
            let radiusInTx = Math.min(300, Math.max(30, this.getDeviceLayer().getFloorplanLayer().getTexelsFromCm(diffVector.getLength())));
            // Update orientation - Heading angle
            let headingAngle = particleModel.headingAngle;
            let sourcePosition = new Vector2_48.Vector2(currentXInTx, currentYInTx);
            let targetPosition = new Vector2_48.Vector2(currentXInTx + radiusInTx * Math.cos(headingAngle), currentYInTx + radiusInTx * Math.sin(headingAngle));
            particleArrow.sourcePosition = sourcePosition;
            particleArrow.targetPosition = targetPosition;
            // Set the arrow thickness proportional to the particle weight.
            particleArrow.getView().scale.y = particleWeight;
            // Update Position
            particleWrapper.x = currentXInTx;
            particleWrapper.y = currentYInTx;
            // Update color
            let motionColor = 0x000000;
            if (this.getModel().state.trackingOutput.motionStateEstimate !== undefined) {
                if (this.getModel().state.trackingOutput.motionStateEstimate === "STANDSTILL") {
                    motionColor = 0x000077;
                }
                else if (this.getModel().state.trackingOutput.motionStateEstimate === "STANDSTILL_INIT") {
                    motionColor = 0x00ff00;
                }
                else if (this.getModel().state.trackingOutput.motionStateEstimate === "MOVING") {
                    motionColor = 0xff0000;
                }
                else if (this.getModel().state.trackingOutput.motionStateEstimate === "UNKNOWN") {
                    motionColor = 0x000000;
                }
                else {
                    motionColor = 0xaaaaaa;
                }
            }
            particleArrow.setBodyColor(motionColor);
            particleView.tint = motionColor;
        }
        getNewParticle() {
            // Particle View container
            let particleViewContainer = this.getEnvironment().renderer.newDisplayObjectContainer();
            // Scale
            this.rescaleParticleView(particleViewContainer);
            // Add to scene graph
            this.particleContainer.addChild(particleViewContainer);
            // Particle view
            let particleWrapper = this.getEnvironment().renderer.newDisplayObjectContainer();
            let particleView = this.getEnvironment().renderer.newSpriteObject();
            particleView.texture = this.getEnvironment().renderer.getTexture("particle");
            // Pivot
            particleView.pivot.x = particleView.width / 2;
            particleView.pivot.y = particleView.height / 2;
            // Scale
            particleView.width = this.particleSizeInPx;
            particleView.height = this.particleSizeInPx;
            // Add to scene graph
            particleViewContainer.addChild(particleWrapper);
            particleWrapper.addChild(particleView);
            // Particle direction view
            let arrowObjectConfig = new ArrowObject_4.ArrowObject.Config();
            arrowObjectConfig.arrowBodyTextureName = "arrow_body";
            arrowObjectConfig.arrowHeadTextureName = "arrow_head_transparent";
            arrowObjectConfig.arrowHeadLengthInLogicalPx = 1;
            arrowObjectConfig.maxArrowHeadLengthInPercent = 0.4;
            arrowObjectConfig.bodyColor = 0xff0000;
            let particleArrow = new ArrowObject_4.ArrowObject(arrowObjectConfig, this.getEnvironment());
            // Add particle arrow to the scene so that the arrow object has camera access.
            this.addChild(particleArrow);
            // Change parent view to the particle view container
            particleViewContainer.addChild(particleArrow.getView());
            // Attach scene object to particle view container
            particleViewContainer.arrowObject = particleArrow;
            return particleViewContainer;
        }
        popParticleFromPool() {
            let particleViewContainer = this.particlePool[this.particlePool.length - 1];
            // Remove from pool
            this.particlePool.splice(this.particlePool.length - 1, 1);
            // Add to particle container
            this.particleContainer.addChild(particleViewContainer);
            return particleViewContainer;
        }
        updateParticleMeanView() {
            if (this.getModel() != null) {
                if (this.getModel().state.trackingState.particleFilterEstimation != null) {
                    this.particleMeanView.alpha = 1.0;
                    this.particleMeanView.position.x = this.getPixelsFromCm(this.getModel().state.trackingState.particleFilterEstimation.positionMean.x);
                    this.particleMeanView.position.y = this.getPixelsFromCm(this.getModel().state.trackingState.particleFilterEstimation.positionMean.y);
                    if (this.particleMeanReliabilityHasChanged()) {
                        this.particleMeanIsReliable = this.getModel().state.trackingState.particleFilterConverged;
                        this.drawParticleMeanView();
                    }
                }
            }
        }
        particleMeanReliabilityHasChanged() {
            return (!this.getModel().state.trackingState.particleFilterConverged && this.particleMeanIsReliable)
                || (this.getModel().state.trackingState.particleFilterConverged && !this.particleMeanIsReliable);
        }
        updateFinalPositionView() {
            if (this.getModel().state.trackingOutput.positionEstimate != null) {
                this.finalPositionView.alpha = 1.0;
                this.finalPositionView.position.x = this.getPixelsFromCm(this.getModel().state.trackingOutput.positionEstimate.positionMean.x);
                this.finalPositionView.position.y = this.getPixelsFromCm(this.getModel().state.trackingOutput.positionEstimate.positionMean.y);
            }
        }
        updateStandardDeviationView() {
            if (this.getModel() != null) {
                if (this.getModel().state.trackingState.particleFilterEstimation != null) {
                    // Alpha
                    this.standardDeviationView.alpha = 1.0;
                    // Draw graphics
                    this.redrawStandardDeviationViewWithScaleFactor(this.lastScaleFactor);
                    // Reposition view
                    this.standardDeviationView.position.x
                        = this.getPixelsFromCm(this.getModel().state.trackingState.particleFilterEstimation.positionMean.x);
                    this.standardDeviationView.position.y
                        = this.getPixelsFromCm(this.getModel().state.trackingState.particleFilterEstimation.positionMean.y);
                }
            }
        }
        redrawStandardDeviationViewWithScaleFactor(scaleFactor) {
            this.standardDeviationView.clear();
            let lineWidth = 1 * scaleFactor;
            this.standardDeviationView.lineStyle(lineWidth, 0x00ff00);
            this.standardDeviationView.beginFill(0x000000, 0);
            let width = this.getPixelsFromCm(this.getModel().state.trackingState.particleFilterEstimation.positionStd.x) * 2;
            let height = this.getPixelsFromCm(this.getModel().state.trackingState.particleFilterEstimation.positionStd.y) * 2;
            this.standardDeviationView.drawEllipse(0, 0, width, height);
            this.standardDeviationView.endFill();
        }
        updatePositionEstimateErrorView() {
            if (this.getModel().state.trackingOutput.groundTruthPath != null
                && this.getModel().state.trackingOutput.groundTruthPath.length > 0) {
                // Make error arrow visible
                this.positionEstimateErrorView.getView().alpha = 1.0;
            }
            else {
                this.positionEstimateErrorView.getView().alpha = 0.0;
            }
        }
        updatePathView(lineWidth) {
            // Configuration
            let targetColor = 0x8A2BE2;
            // Draw path
            this.pathView.clear();
            if (this.getModel() != null) {
                if (this.getModel().state.trackingOutput.positionEstimatePath.length > 0) {
                    // Get path
                    let path = this.getPositionsFromModel();
                    if (path.length === 0) {
                        return;
                    }
                    // Get last subpath
                    path = this.getLastSubPath(path);
                    if (path.length === 0) {
                        return;
                    }
                    // Remove duplicates
                    path = this.removePositionDuplicatesInPath(path);
                    if (path.length === 0) {
                        return;
                    }
                    // Remove unknown positions
                    path = this.removeUnknownPositionsInPath(path);
                    if (path.length === 0) {
                        return;
                    }
                    // Convert to world coordinates
                    const points = this.getPathInWorldCoordinates(path);
                    // Draw path
                    this.pathView.lineStyle(lineWidth, targetColor, 1);
                    this.pathView.drawPolygon(points);
                    // Draw point
                    let lastPoint = path[path.length - 1];
                    this.pathView.beginFill(targetColor, 1.0);
                    this.pathView.drawCircle(lastPoint.x, lastPoint.y, lineWidth * 2);
                    this.pathView.endFill();
                }
            }
        }
        getPositionsFromModel() {
            let result = [];
            for (let i = 0; i < this.getModel().state.trackingOutput.positionEstimatePath.length; i++) {
                let estimation = this.getModel().state.trackingOutput.positionEstimatePath[i];
                if (estimation !== null) {
                    result.push(new Vector2_48.Vector2(estimation.positionMean.x, estimation.positionMean.y));
                }
            }
            return result;
        }
        getAccuraciesFromModel() {
            let result = [];
            for (let i = 0; i < this.getModel().state.trackingOutput.positionEstimatePath.length; i++) {
                let estimation = this.getModel().state.trackingOutput.positionEstimatePath[i];
                if (estimation !== null) {
                    let stdX = estimation.positionStd.x;
                    let stdY = estimation.positionStd.y;
                    let std = (stdX + stdY) / 2;
                    result.push(std);
                }
            }
            return result;
        }
        getLastSubPath(path) {
            let remainingIndices = this.getIndicesOfLastSubPath(path);
            let newPath = ArrayUtils_2.ArrayUtils.getSubArrayWithIndices(path, remainingIndices);
            return newPath;
        }
        getIndicesOfLastSubPath(path) {
            // Get last "unknown" position (0,0)
            let newPath = new Array();
            let indexOfLastUnknownPosition = this.getIndexOfLastUnknownPosition(path);
            for (let i = indexOfLastUnknownPosition + 1; i < path.length; i++) {
                newPath.push(i);
            }
            return newPath;
        }
        getIndexOfLastUnknownPosition(path) {
            for (let i = path.length - 1; i >= 0; i--) {
                if (this.isUnknownPosition(path[i])) {
                    return i;
                }
            }
            return -1;
        }
        removePositionDuplicatesInPath(path) {
            let remainingIndices = this.getIndicesOfPathWhenRemovingDuplicates(path);
            let newPath = ArrayUtils_2.ArrayUtils.getSubArrayWithIndices(path, remainingIndices);
            return newPath;
        }
        getIndicesOfPathWhenRemovingDuplicates(path) {
            let indices = new Array();
            indices.push(0);
            for (let i = 1; i < path.length; i++) {
                if (!((path[i].x === path[i - 1].x) && (path[i].y === path[i - 1].y))) {
                    indices.push(i);
                }
            }
            return indices;
        }
        removeUnknownPositionsInPath(path) {
            let remainingIndices = this.getIndicesOfPathWhenRemovingUnknownPositions(path);
            let newPath = ArrayUtils_2.ArrayUtils.getSubArrayWithIndices(path, remainingIndices);
            return newPath;
        }
        getIndicesOfPathWhenRemovingUnknownPositions(path) {
            let indices = new Array();
            for (let i = 0; i < path.length; i++) {
                let p = path[i];
                if (!this.isUnknownPosition(p)) {
                    indices.push(i);
                }
            }
            return indices;
        }
        isUnknownPosition(p) {
            return p.x === 0 && p.y === 0;
        }
        getPathInWorldCoordinates(path) {
            let pathInWorld = new Array();
            for (let i = 0; i < path.length; i++) {
                let pointInCm = path[i];
                let pixelPerMeter = this.getDeviceLayer().getFloorplanLayer().getModel().pixelPerMeter;
                let pointInWorld = this.getEnvironment().renderer.newPoint(pixelPerMeter * (pointInCm.x / 100), pixelPerMeter * (pointInCm.y / 100));
                pathInWorld.push(pointInWorld);
            }
            return pathInWorld;
        }
        updateAccuracyPathView(lineWidth) {
            // Configuration
            let targetColor = 0x8A2BE2;
            // Draw path
            this.accuracyPathView.clear();
            if (this.getModel() != null) {
                if (this.getModel().state.trackingOutput.positionEstimatePath.length > 3) {
                    // Getting path
                    let path = this.getPositionsFromModel();
                    let accuracies = this.getAccuraciesFromModel();
                    if (path.length === 0) {
                        return;
                    }
                    // Get last subpath
                    let indices = this.getIndicesOfLastSubPath(path);
                    path = ArrayUtils_2.ArrayUtils.getSubArrayWithIndices(path, indices);
                    accuracies = ArrayUtils_2.ArrayUtils.getSubArrayWithIndices(accuracies, indices);
                    if (path.length === 0) {
                        return;
                    }
                    // Removing duplicates
                    indices = this.getIndicesOfPathWhenRemovingDuplicates(path);
                    path = ArrayUtils_2.ArrayUtils.getSubArrayWithIndices(path, indices);
                    accuracies = ArrayUtils_2.ArrayUtils.getSubArrayWithIndices(accuracies, indices);
                    if (path.length === 0) {
                        return;
                    }
                    // Removing unknown positions
                    indices = this.getIndicesOfPathWhenRemovingUnknownPositions(path);
                    path = ArrayUtils_2.ArrayUtils.getSubArrayWithIndices(path, indices);
                    accuracies = ArrayUtils_2.ArrayUtils.getSubArrayWithIndices(accuracies, indices);
                    if (path.length === 0) {
                        return;
                    }
                    // Transform points to world coordinates
                    let points = this.getPathInWorldCoordinates(path);
                    if (this.shouldDrawAccuracyLine) {
                        // Construct polygon above the line
                        this.drawAccuracyLine(points, accuracies, lineWidth, true);
                        // Construct polygon below the line
                        this.drawAccuracyLine(points, accuracies, lineWidth, false);
                        this.accuracyPathView.alpha = 0.5;
                    }
                    // Draw accuracy view
                    if (path.length > 0) {
                        this.accuracyView.x = this.getFloorplanLayer().getTexelsFromCm(path[path.length - 1].x);
                        this.accuracyView.y = this.getFloorplanLayer().getTexelsFromCm(path[path.length - 1].y);
                        // We assume the accuracy to be the standard deviation.
                        // As 3*std is a rough estimate of the integral of the corresponding normal distribution,
                        // we set the radius to 3x of the standard deviation.
                        let accuracyInCm = accuracies[accuracies.length - 1];
                        let radiusInCm = accuracyInCm * 3;
                        let radiusInTx = this.getFloorplanLayer().getModel().pixelPerMeter * (radiusInCm / 100);
                        this.accuracyView.scale.x = radiusInTx;
                        this.accuracyView.scale.y = radiusInTx;
                        this.accuracyView.alpha = this.accuracyViewAlpha;
                    }
                    else {
                        this.accuracyView.alpha = 0.0;
                    }
                }
            }
        }
        drawAccuracyLine(path, accuracies, lineWidth, above) {
            // Early out
            if (path.length < 2) {
                return;
            }
            let line = new Array();
            for (let i = 0; i < path.length; i++) {
                // Get reference point index
                let index = 0;
                if (above) {
                    index = i;
                }
                else {
                    index = path.length - 1 - i;
                }
                // Get reference point
                let targetPoint = path[index];
                // Get accuracy in texels
                let standardDeviation = accuracies[index];
                let accuracyInCm = standardDeviation * 3;
                let standardDeviationInMeter = accuracyInCm / 100;
                let standardDeviationInWorldTexel = this.getDeviceLayer().getFloorplanLayer().getModel().pixelPerMeter * standardDeviationInMeter;
                // Compute edge direction
                let edgeX = 0;
                let edgeY = 0;
                if (index === 0) {
                    let nextPoint = path[index + 1];
                    edgeX = targetPoint.x - nextPoint.x;
                    edgeY = targetPoint.y - nextPoint.y;
                }
                else {
                    let previousPoint = path[index - 1];
                    edgeX = previousPoint.x - targetPoint.x;
                    edgeY = previousPoint.y - targetPoint.y;
                }
                // Do not consider position duplicates
                if (edgeX === 0 && edgeY === 0) {
                    continue;
                }
                // Compute normal vector
                let normalX = 0;
                let normalY = 0;
                if (above) {
                    normalX = -edgeY;
                    normalY = edgeX;
                }
                else {
                    normalX = edgeY;
                    normalY = -edgeX;
                }
                // Normalize normal vector
                let length = Math.sqrt(normalX * normalX + normalY * normalY);
                normalX /= length;
                normalY /= length;
                // Compute accuracy point position
                let accuracyPointX = targetPoint.x + normalX * standardDeviationInWorldTexel;
                let accuracyPointY = targetPoint.y + normalY * standardDeviationInWorldTexel;
                let accuracyPoint = this.getEnvironment().renderer.newPoint(accuracyPointX, accuracyPointY);
                // Add point to list
                line.push(accuracyPoint);
            }
            this.accuracyPathView.lineStyle(lineWidth, 0x0000ff, 1);
            this.accuracyPathView.drawPolygon(line);
        }
        updateGroundTruthPathView(lineWidth) {
            // Configuration
            let targetColor = 0x00ff00;
            // Draw path
            this.groundTruthPathView.clear();
            if (this.getModel() != null && this.getModel().state.trackingOutput.groundTruthPath != null) {
                if (this.getModel().state.trackingOutput.groundTruthPath.length > 0) {
                    let path = this.getModel().state.trackingOutput.groundTruthPath.slice();
                    path = this.removePositionDuplicatesInPath(path);
                    path = this.removeUnknownPositionsInPath(path);
                    const points = this.getPathInWorldCoordinates(path);
                    // Draw path
                    this.groundTruthPathView.lineStyle(lineWidth, targetColor, 1);
                    this.groundTruthPathView.drawPolygon(points);
                    // Draw last recent point
                    let lastPoint = path[path.length - 1];
                    if (lastPoint !== undefined) {
                        this.groundTruthPathView.beginFill(targetColor, 1.0);
                        this.groundTruthPathView.drawCircle(lastPoint.x, lastPoint.y, lineWidth * 2);
                        this.groundTruthPathView.endFill();
                    }
                }
            }
        }
        updateObservationPathView(lineWidth) {
            // Configuration
            let targetColor = 0x000064;
            // Draw path
            this.observationPathView.clear();
            if (this.getModel() != null) {
                if (this.getModel().state.trackingOutput.observationPath.length > 0) {
                    let path = this.getModel().state.trackingOutput.observationPath.slice();
                    path = this.removePositionDuplicatesInPath(path);
                    path = this.removeUnknownPositionsInPath(path);
                    const points = this.getPathInWorldCoordinates(path);
                    this.observationPathView.beginFill(targetColor);
                    let radius = lineWidth;
                    for (let i = 0; i < points.length; i++) {
                        let point = points[i];
                        this.observationPathView.drawCircle(point.x, point.y, radius);
                    }
                    this.observationPathView.endFill();
                }
            }
        }
        updatePathMatchingView(lineWidth) {
            // Draw path
            this.pathMatchingView.clear();
            if (this.getModel() !== null) {
                if (this.getModel().state.trackingOutput.pathMatching.length > 0) {
                    let pathMatching = this.getModel().state.trackingOutput.pathMatching;
                    for (let i = 0; i < pathMatching.length; i++) {
                        const pointMatch = pathMatching[i];
                        const estimatedPosition = pointMatch.estimatedPosition;
                        const groundTruthPosition = pointMatch.groundTruthPosition;
                        const matchingLine = this.getPathInWorldCoordinates([estimatedPosition, groundTruthPosition]);
                        this.accuracyPathView.lineStyle(lineWidth, 0xff0000, 1);
                        this.accuracyPathView.drawPolygon(matchingLine);
                    }
                }
            }
        }
        updateRegionProbabilityView() {
            this.getView().alpha = this.getModel().state.trackingState.publicationAllowed ? 1.0 : 0.0;
        }
        // Helper methods
        getPixelsFromCm(widthInCm) {
            return (widthInCm / 100) * this.getDeviceLayer().getFloorplanLayer().getModel().pixelPerMeter;
        }
        loadProbabilityImage(probabilityImage) {
            this.loadImage(probabilityImage, this.probabilityImageSprite);
        }
        loadRadioMapImage(radioMapImage) {
            this.loadImage(radioMapImage, this.radioMapImageSprite);
            this.radioMapImageSprite.visible = true;
        }
        unloadRadioMapImage() {
            this.radioMapImageSprite.visible = false;
        }
        loadImage(image, spriteView) {
            // Load texture
            spriteView.texture = this.getEnvironment().renderer.newTexture(image);
            // Size
            spriteView.width = this.getDeviceLayer().getFloorplanLayer().getFloorSize().x;
            spriteView.height = this.getDeviceLayer().getFloorplanLayer().getFloorSize().y;
        }
        // View
        rescaleParticleView(particleViewContainer) {
            if (particleViewContainer.children.length > 0) {
                // Particle scaling
                let particleWrapper = particleViewContainer.getChildAt(0);
                particleWrapper.scale.x = this.lastScaleFactor;
                particleWrapper.scale.y = this.lastScaleFactor;
                // Arrow scaling
                let particleArrow = particleViewContainer.arrowObject;
                if (particleArrow !== undefined) {
                    particleArrow.draw(particleArrow.sourcePosition, particleArrow.targetPosition, 2 * this.lastScaleFactor);
                }
            }
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.getView().alpha > 0) {
                if (this.getModel() != null && this.getModel().state.trackingState !== null) {
                    this.updateScale();
                    this.updateRotation();
                }
            }
        }
        updateScale() {
            let scaleFactor = 1.0;
            if (this.getScene() != null) {
                let camera = this.getScene().getCamera();
                scaleFactor = camera.getScaleX();
            }
            if (this.lastScaleFactor !== scaleFactor || this.invalidated) {
                this.lastScaleFactor = scaleFactor;
                if (!this.showDetailsOnHover || this.isHovering) {
                    this.retransformNodeMeasurementArrows(scaleFactor);
                    this.retransformNodeMeasurementTexts(scaleFactor);
                    this.retransformApsPositionEstimateView(scaleFactor);
                    this.rescaleParticles();
                    this.rescaleParticleMeanView();
                    this.rescaleFinalPositionView();
                    this.rescaleStandardDeviationView();
                    this.rescalePathView(this.lastScaleFactor);
                    this.rescaleAccuracyPathView(this.lastScaleFactor);
                    this.rescaleGroundTruthPathView(this.lastScaleFactor);
                    this.rescaleObservationPathView(this.lastScaleFactor);
                    this.rescalePathMatchingView(this.lastScaleFactor);
                    this.invalidated = false;
                }
                this.retransformPositionEstimateErrorView(scaleFactor);
            }
        }
        retransformNodeMeasurementArrows(scaleFactor) {
            if (this.getModel().state.trackingState.apsPositionEstimate != null) {
                for (let i = 0; i < this.nodeMeasurementArrows.length; i++) {
                    let arrow = this.nodeMeasurementArrows[i];
                    let serialNumber = this.nodeSerialNumbers[i];
                    let device = this.getDeviceLayer().getBeaconWithSerial(serialNumber);
                    // Draw arrow
                    let referenceArrowLineWidth = 1.5;
                    let lineWidth = referenceArrowLineWidth * scaleFactor;
                    let sourceX = this.getPixelsFromCm(this.getModel().state.trackingState.apsPositionEstimate.positionMean.x);
                    let sourceY = this.getPixelsFromCm(this.getModel().state.trackingState.apsPositionEstimate.positionMean.y);
                    let sourcePosition = new Vector2_48.Vector2(sourceX, sourceY);
                    let targetPosition = Vector2_48.Vector2.getVector2(device.getView().position);
                    arrow.draw(sourcePosition, targetPosition, lineWidth);
                }
            }
        }
        retransformNodeMeasurementTexts(scaleFactor) {
            if (this.getModel().state.trackingState.apsPositionEstimate != null) {
                for (let i = 0; i < this.nodeMeasurementTexts.length; i++) {
                    let text = this.nodeMeasurementTexts[i];
                    let serialNumber = this.nodeSerialNumbers[i];
                    let device = this.getDeviceLayer().getBeaconWithSerial(serialNumber);
                    // Scale
                    text.scale.x = scaleFactor;
                    text.scale.y = scaleFactor;
                    // Position
                    let sourceX = this.getPixelsFromCm(this.getModel().state.trackingState.apsPositionEstimate.positionMean.x);
                    let sourceY = this.getPixelsFromCm(this.getModel().state.trackingState.apsPositionEstimate.positionMean.y);
                    let sourcePosition = new Vector2_48.Vector2(sourceX, sourceY);
                    let targetPosition = device.getView().position;
                    let meanPosition = new Vector2_48.Vector2((targetPosition.x + sourcePosition.x) / 2, (targetPosition.y + sourcePosition.y) / 2);
                    text.position = this.getEnvironment().renderer.newPointFromVector2(meanPosition);
                }
            }
        }
        retransformApsPositionEstimateView(scaleFactor) {
            if (this.apsPositionEstimateView != null) {
                if (this.apsPositionEstimateView.x == 0 && this.apsPositionEstimateView.y == 0) {
                    this.apsPositionEstimateView.alpha = 0;
                }
                else {
                    this.apsPositionEstimateView.scale.x = this.lastScaleFactor;
                    this.apsPositionEstimateView.scale.y = this.lastScaleFactor;
                    this.apsPositionEstimateView.alpha = 1;
                }
            }
        }
        retransformPositionEstimateErrorView(scaleFactor) {
            if (this.getModel().state.trackingOutput.groundTruthPath != null
                && this.getModel().state.trackingOutput.groundTruthPath.length > 0) {
                if (this.getModel().state.trackingOutput.positionEstimate !== undefined) {
                    // Draw arrow
                    let path = this.getModel().state.trackingOutput.groundTruthPath.slice();
                    path = this.removePositionDuplicatesInPath(path);
                    path = this.removeUnknownPositionsInPath(path);
                    const points = this.getPathInWorldCoordinates(path);
                    if (points.length > 0) {
                        let referenceArrowLineWidth = 1.5;
                        let lineWidth = referenceArrowLineWidth * scaleFactor;
                        let sourceX = this.getPixelsFromCm(this.getModel().state.trackingOutput.positionEstimate.positionMean.x);
                        let sourceY = this.getPixelsFromCm(this.getModel().state.trackingOutput.positionEstimate.positionMean.y);
                        let sourcePosition = new Vector2_48.Vector2(sourceX, sourceY);
                        let targetPosition = Vector2_48.Vector2.getVector2(points[points.length - 1]);
                        this.positionEstimateErrorView.draw(sourcePosition, targetPosition, lineWidth);
                    }
                }
            }
        }
        rescaleParticles() {
            for (let i = 0; i < this.particleContainer.children.length; i++) {
                let particleView = this.particleContainer.getChildAt(i);
                this.rescaleParticleView(particleView);
            }
        }
        rescaleParticleMeanView() {
            this.particleMeanView.scale.x = this.lastScaleFactor;
            this.particleMeanView.scale.y = this.lastScaleFactor;
        }
        rescaleFinalPositionView() {
            this.finalPositionView.scale.x = this.lastScaleFactor;
            this.finalPositionView.scale.y = this.lastScaleFactor;
        }
        rescaleStandardDeviationView() {
            if (this.getModel() != null) {
                if (this.getModel().state.trackingState.particleFilterEstimation != null) {
                    this.redrawStandardDeviationViewWithScaleFactor(this.lastScaleFactor);
                }
            }
        }
        rescalePathView(scaleFactor) {
            let targetLineWidth = 2;
            let lineWidth = targetLineWidth * scaleFactor;
            this.updatePathView(lineWidth);
        }
        rescaleAccuracyPathView(scaleFactor) {
            let targetLineWidth = 1;
            let lineWidth = targetLineWidth * scaleFactor;
            this.updateAccuracyPathView(lineWidth);
        }
        rescaleGroundTruthPathView(scaleFactor) {
            let targetLineWidth = 2;
            let lineWidth = targetLineWidth * scaleFactor;
            this.updateGroundTruthPathView(lineWidth);
        }
        rescaleObservationPathView(scaleFactor) {
            let targetLineWidth = 2;
            let lineWidth = targetLineWidth * scaleFactor;
            this.updateObservationPathView(lineWidth);
        }
        rescalePathMatchingView(scaleFactor) {
            let targetLineWidth = 2;
            let lineWidth = targetLineWidth * scaleFactor;
            this.updatePathMatchingView(lineWidth);
        }
        updateRotation() {
            this.rotateNodeMeasurementTexts();
        }
        rotateNodeMeasurementTexts() {
            let camera = this.getScene().getCamera();
            let orientation = camera.getRotation();
            for (let i = 0; i < this.nodeMeasurementTexts.length; i++) {
                let nodeMeasurementText = this.nodeMeasurementTexts[i];
                if (nodeMeasurementText.rotation !== orientation || this.invalidated) {
                    nodeMeasurementText.rotation = orientation;
                }
            }
        }
        // Event-Handling: Mouse over
        // @Override
        onMouseMove(x, y) {
            if (this.showDetailsOnHover) {
                let device = this.getDependentObjects()[0];
                if (device.intersectsPointInScreenPx(x, y)) {
                    if (!this.isHovering) {
                        this.isHovering = true;
                        this.rootObject.getView().alpha = 1.0;
                        this.invalidated = true;
                    }
                }
                else {
                    if (this.isHovering) {
                        this.isHovering = false;
                        this.rootObject.getView().alpha = 0.0;
                        this.invalidated = true;
                    }
                }
            }
            return false;
        }
        // Drawing
        // @Override
        redraw() {
            this.invalidated = true;
        }
        // Name
        getName() {
            let device = this.getDependentObjects()[0];
            return device.getName();
        }
        // Relution map object: Popup info
        isPopupInfoSupported() {
            return false;
        }
        // Relution map object: Moving
        isMovable() {
            return false;
        }
        // Getters and setters
        getDeviceLayer() {
            return this.deviceLayer;
        }
        getModel() {
            return super.getModel();
        }
        isShowDetailsOnHover() {
            return this.showDetailsOnHover;
        }
        setShowDetailsOnHover(showDetailsOnHover) {
            this.showDetailsOnHover = showDetailsOnHover;
        }
        getNamePosition(textBound) {
            return new Vector2_48.Vector2(this.getCenter().x, textBound.height * -1);
        }
    };
    DeviceTrackingDetails = __decorate([
        (0, RelutionMapObject_15.RelutionModelBinding)(DeviceTrackingStateModel_1.DeviceTrackingStateModel)
    ], DeviceTrackingDetails);
    exports.DeviceTrackingDetails = DeviceTrackingDetails;
});
define("test/tests/indoor/view/map/layers/deviceTrackingDetailsLayer/DeviceTrackingDetailsLayer", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/AssetMapObject", "src/map/view/world/layers/heatmapLayer/HeatmapLayer", "test/tests/indoor/view/map/layers/deviceTrackingDetailsLayer/DeviceTrackingDetails", "test/tests/indoor/models/DeviceTrackingStateModel", "src/app/relution/view/world/RelutionMapObjectLayer"], function (require, exports, AssetMapObject_7, HeatmapLayer_5, DeviceTrackingDetails_1, DeviceTrackingStateModel_2, RelutionMapObjectLayer_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeviceTrackingDetailsLayer = void 0;
    let DeviceTrackingDetailsLayer = class DeviceTrackingDetailsLayer extends RelutionMapObjectLayer_7.RelutionMapObjectLayer {
        // Initialization
        constructor(config, environment, deviceLayer) {
            super(config, environment, deviceLayer.getFloorplanLayer(), deviceLayer);
            this.detailsLayerConfig = config;
            this.deviceLayer = deviceLayer;
            this.initHeatmapLayer();
            this.setModelFactory((parentModel) => {
                let device = deviceLayer.getDeviceWithUuid(parentModel.uuid);
                if (device instanceof AssetMapObject_7.AssetMapObject) {
                    let model = new DeviceTrackingStateModel_2.DeviceTrackingStateModel();
                    model.state.deviceUuid = device.getModel().uuid;
                    model.deviceUuid = device.getModel().uuid;
                    model.uuid = device.getModel().uuid;
                    return model;
                }
                else {
                    return null;
                }
            });
            this.setObjectFactory((model, config) => {
                let device = deviceLayer.getDeviceWithUuid(model.parentUuid);
                if (device !== null) {
                    return new DeviceTrackingDetails_1.DeviceTrackingDetails(config, this.getEnvironment(), this.deviceLayer.getFloorplanLayer(), model, device, deviceLayer, this.detailsLayerConfig.showDetailsOnHover);
                }
                else {
                    return null;
                }
            });
        }
        initHeatmapLayer() {
            this.heatmapLayer = new HeatmapLayer_5.HeatmapLayer(this.getEnvironment(), this.deviceLayer.getFloorplanLayer());
            // this.addChild(this.heatmapLayer);
        }
        // Loading images
        loadProbabilityImage(probabilityImage) {
            if (this.getObjects().length !== 0) {
                let firstDetails = this.getObjects()[0];
                firstDetails.loadProbabilityImage(probabilityImage);
            }
        }
        loadRadioMapImage(radioMapImage) {
            if (this.getObjects().length !== 0) {
                let firstDetails = this.getObjects()[0];
                firstDetails.loadRadioMapImage(radioMapImage);
            }
        }
        unloadRadioMap() {
            if (this.getObjects().length !== 0) {
                let firstDetails = this.getObjects()[0];
                firstDetails.unloadRadioMapImage();
            }
        }
        // Getters and setters
        setShowDetailsOnHover(showDetailsOnHover) {
            this.detailsLayerConfig.showDetailsOnHover = showDetailsOnHover;
            for (let i = 0; i < this.getObjects().length; i++) {
                let details = this.getObjects()[i];
                details.setShowDetailsOnHover(showDetailsOnHover);
            }
        }
        isShowDetailsOnHover() {
            return this.detailsLayerConfig.showDetailsOnHover;
        }
    };
    DeviceTrackingDetailsLayer = __decorate([
        (0, RelutionMapObjectLayer_7.RelutionMapObjectBinding)(DeviceTrackingDetails_1.DeviceTrackingDetails)
    ], DeviceTrackingDetailsLayer);
    exports.DeviceTrackingDetailsLayer = DeviceTrackingDetailsLayer;
    (function (DeviceTrackingDetailsLayer) {
        class Config extends RelutionMapObjectLayer_7.RelutionMapObjectLayer.Config {
            constructor() {
                super(...arguments);
                /**
                 * If true, the details will only be shown when hovering with the mouse cursor.
                 *
                 * Default: false
                 */
                this.showDetailsOnHover = false;
            }
        }
        DeviceTrackingDetailsLayer.Config = Config;
    })(DeviceTrackingDetailsLayer = exports.DeviceTrackingDetailsLayer || (exports.DeviceTrackingDetailsLayer = {}));
    exports.DeviceTrackingDetailsLayer = DeviceTrackingDetailsLayer;
});
define("test/tests/indoor/models/IndoorStateModel", ["require", "exports", "src/app/relution/model/Model"], function (require, exports, Model_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndoorStateModel = void 0;
    class IndoorStateModel extends Model_15.Model {
        constructor() {
            super(...arguments);
            this._running = false;
            this._blocking = false;
            this._blockingText = "";
        }
        // Getters and setters
        set running(running) {
            this._running = running;
            this.notifyObservers("running");
        }
        get running() {
            return this._running;
        }
        set blocking(blocking) {
            this._blocking = blocking;
            this.notifyObservers("blocking");
        }
        get blocking() {
            return this._blocking;
        }
        set blockingText(blockingText) {
            this._blockingText = blockingText;
            this.notifyObservers("blockingText");
        }
        get blockingText() {
            return this._blockingText;
        }
    }
    __decorate([
        (0, Model_15.ModelProperty)()
    ], IndoorStateModel.prototype, "_running", void 0);
    __decorate([
        (0, Model_15.ModelProperty)()
    ], IndoorStateModel.prototype, "_blocking", void 0);
    __decorate([
        (0, Model_15.ModelProperty)()
    ], IndoorStateModel.prototype, "_blockingText", void 0);
    exports.IndoorStateModel = IndoorStateModel;
});
define("test/tests/indoor/view/map/IndoorMap", ["require", "exports", "src/app/relution/RelutionMap", "src/engine/input/GestureRecognizer", "src/app/relution/utils/RssiToDistance", "src/app/relution/utils/KeyUtils", "test/tests/indoor/view/map/layers/deviceTrackingDetailsLayer/DeviceTrackingDetailsLayer", "test/tests/indoor/models/IndoorStateModel", "src/engine/scene/GameObject", "src/engine/math/Vector2"], function (require, exports, RelutionMap_7, GestureRecognizer_10, RssiToDistance_4, KeyUtils_3, DeviceTrackingDetailsLayer_1, IndoorStateModel_1, GameObject_7, Vector2_49) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndoorMap = void 0;
    class IndoorMap extends RelutionMap_7.RelutionMap {
        // Initialization
        constructor(options) {
            super(options);
            this.radiusInPx = 5;
            // Model
            this.simulationState = new IndoorStateModel_1.IndoorStateModel();
            // View
            this.detailsLayers = new Array();
            this.lastScaleFactor = -1;
            this.taggingPath = new Array();
            this.taggingPathTimestamps = new Array();
            this.taggingData = new Array();
            this.taggingTimestampData = new Array();
            this.currentOrientationInRad = 0;
            this.currentDepth = 0;
            this.options = options;
        }
        // @Override
        load(floor, initializedCallback) {
            super.load(floor, () => {
                this.configureFloors();
                this.initViews();
                this.registerInputEvents();
                initializedCallback();
            });
        }
        // Mode initialization
        initViews() {
            this.initTaggingModeViews();
            this.initMouseSimulationModeViews();
        }
        initTaggingModeViews() {
            this.initActiveTagPoint();
            this.initTaggingPath();
        }
        initActiveTagPoint() {
            this.activeTagPoint = this.fruityMap.getEnvironment().renderer.newGraphicsObject();
            this.activeTagPoint.clear();
            this.activeTagPoint.beginFill(0xff00ff);
            this.activeTagPoint.drawCircle(0, 0, this.radiusInPx);
            this.activeTagPoint.endFill();
            this.activeTagPoint.alpha = 0.0;
            this.getBuilding().getView().addChild(this.activeTagPoint);
        }
        initTaggingPath() {
            this.taggingPathView = this.fruityMap.getEnvironment().renderer.newGraphicsObject();
            this.taggingPathView.alpha = 0.0;
            this.getBuilding().getView().addChild(this.taggingPathView);
        }
        initMouseSimulationModeViews() {
            if (this.options.type instanceof IndoorMap.Type.AssetTrackingDatasetMouseSimulationType) {
                this.initTargetPositionView();
            }
        }
        initTargetPositionView() {
            let widthInPx = 2;
            let heightInPx = 40;
            this.targetView = this.fruityMap.getEnvironment().renderer.newGraphicsObject();
            this.targetView.clear();
            this.targetView.beginFill(0xff00ff);
            this.targetView.lineStyle(1, 0x000000);
            this.targetView.drawRect(-widthInPx / 2, 0, widthInPx, heightInPx);
            this.targetView.drawCircle(0, 0, this.radiusInPx);
            this.targetView.endFill();
            this.targetView.alpha = 0.0;
            this.getBuilding().getView().addChild(this.targetView);
        }
        registerInputEvents() {
            let that = this;
            this.fruityMap.addScenelessGameObject(new class extends GameObject_7.GameObject {
                constructor(environment) {
                    super(environment);
                }
                // @Override
                update(lastFrametime) {
                    super.update(lastFrametime);
                    that.update(lastFrametime);
                }
                // @Override
                onKeyDown(keyCode) {
                    super.onKeyDown(keyCode);
                    that.onKeyDown(keyCode);
                    return false;
                }
                // @Override
                onMouseWheel(delta, mouseX, mouseY) {
                    super.onMouseWheel(delta, mouseX, mouseY);
                    that.onMouseWheel(delta, mouseX, mouseY);
                    return false;
                }
                // @Override
                onMouseMove(x, y) {
                    super.onMouseMove(x, y);
                    that.onMouseMove(x, y);
                    return false;
                }
            }(this.fruityMap.getEnvironment()));
        }
        // Floor management
        configureFloors() {
            this.getBuilding().addFloorObserver(this);
            this.floorAdded(this.getBuilding().getCurrentFloor());
        }
        // Floor events
        // @Override
        floorAdded(floor) {
            if (floor !== null) {
                // Create layer
                let config = new DeviceTrackingDetailsLayer_1.DeviceTrackingDetailsLayer.Config();
                config.showDetailsOnHover = this.options.showDetailsOnHover;
                let deviceLayer = floor.getDeviceLayer();
                let detailsLayer = new DeviceTrackingDetailsLayer_1.DeviceTrackingDetailsLayer(config, this.fruityMap.getEnvironment(), deviceLayer);
                // Add layer
                floor.getDeviceLayerContainer().addLayerAfterLayer(detailsLayer, deviceLayer);
                floor.getRelutionMapObjectLayers().push(detailsLayer);
                this.detailsLayers[floor.getFloorName()] = detailsLayer;
            }
        }
        // Image preloading
        // @Override
        getPreloadingImageNames() {
            let preloadingImages = super.getPreloadingImageNames();
            preloadingImages.push("particle");
            return preloadingImages;
        }
        // Updating devices' state models
        loadIndoorStateModels(floor, indoorStateModels) {
            if (this.detailsLayers[floor.getFloorName()] !== undefined) {
                let detailsLayer = this.detailsLayers[floor.getFloorName()];
                detailsLayer.updateModels(indoorStateModels);
            }
        }
        loadProbabilityImage(floor, probabilityImage) {
            if (this.detailsLayers[floor.getFloorName()] !== undefined) {
                let detailsLayer = this.detailsLayers[floor.getFloorName()];
                detailsLayer.loadProbabilityImage(probabilityImage);
            }
        }
        loadRadioMap(floor, radioMapImage) {
            if (this.detailsLayers[floor.getFloorName()] !== undefined) {
                let detailsLayer = this.detailsLayers[floor.getFloorName()];
                detailsLayer.loadRadioMapImage(radioMapImage);
            }
        }
        unloadRadioMap(floor) {
            if (this.detailsLayers[floor.getFloorName()] !== undefined) {
                let detailsLayer = this.detailsLayers[floor.getFloorName()];
                detailsLayer.unloadRadioMap();
            }
        }
        // Updating geofences' state models
        loadGeofenceStateModels(floor, geofenceStateModels) {
            let geofenceLayer = floor.getGeofenceLayer();
            geofenceLayer.loadGeofenceStateModels(geofenceStateModels);
        }
        // Updating
        update(lastFrametime) {
            if (this.options.type instanceof IndoorMap.Type.AssetTrackingDatasetMouseSimulationType) {
                this.updateMouseSimulationMode();
            }
            this.updateDatasetTaggingMode();
        }
        updateMouseSimulationMode() {
            this.updateTargetView();
        }
        updateTargetView() {
            if (this.simulationState.running) {
                // Scale
                let camera = this.fruityMap.getWorld().getScene().getCamera();
                this.targetView.scale.x = camera.getScaleX();
                this.targetView.scale.y = camera.getScaleY();
                // Rotation
                this.targetView.rotation = this.currentOrientationInRad;
                // Alpha
                const minRssi = RssiToDistance_4.RssiToDistance.MIN_RSSI;
                let currentFloor = this.getBuilding().getCurrentFloor();
                let floorHeightInCm = currentFloor.getHeightInMeter() * 100;
                let targetHeightInCm = this.getMouseDepthInWorldCm();
                let distanceToFloorInCm = Math.abs(targetHeightInCm - floorHeightInCm);
                let maxDistanceInCm = RssiToDistance_4.RssiToDistance.rssiToDistance(minRssi) * 100;
                let relativeDistanceToFloor = Math.max(Math.min(distanceToFloorInCm / maxDistanceInCm, 1), 0);
                this.targetView.alpha = 1 - relativeDistanceToFloor;
            }
            else {
                this.targetView.alpha = 0.0;
            }
        }
        updateDatasetTaggingMode() {
            this.updateActiveTagPointPosition();
            this.updateTaggingPath();
        }
        updateActiveTagPointPosition() {
            if (this.shouldTagBeVisible()) {
                let camera = this.fruityMap.getWorld().getScene().getCamera();
                this.activeTagPoint.scale.x = camera.getScaleX();
                this.activeTagPoint.scale.y = camera.getScaleY();
                this.activeTagPoint.alpha = 1.0;
            }
            else {
                this.activeTagPoint.alpha = 0.0;
            }
        }
        updateTaggingPath() {
            if (this.shouldTagBeVisible()) {
                let camera = this.fruityMap.getWorld().getScene().getCamera();
                let scaleFactor = camera.getScaleX();
                if (this.lastScaleFactor !== scaleFactor) {
                    this.lastScaleFactor = scaleFactor;
                    this.updateTaggingPathView();
                }
                this.constrainTaggingPathSize();
                this.taggingPathView.alpha = 1.0;
            }
            else {
                this.taggingPathView.alpha = 0.0;
            }
        }
        shouldTagBeVisible() {
            return (this.options.type instanceof IndoorMap.Type.AssetTrackingDatasetTaggingSimulationType) && (this.activeTagPoint.x !== 0.0 || this.activeTagPoint.y !== 0.0);
        }
        constrainTaggingPathSize() {
            let nowInMs = Date.now();
            const pointLifetimeInMs = 1000;
            let modified = false;
            while (this.taggingPathTimestamps.length > 0 && (nowInMs - this.taggingPathTimestamps[0] > pointLifetimeInMs)) {
                this.taggingPath.splice(0, 1);
                this.taggingPathTimestamps.splice(0, 1);
                modified = true;
            }
            if (modified) {
                this.updateTaggingPathView();
            }
        }
        // Interaction
        onMouseMove(x, y) {
            if (this.options.type instanceof IndoorMap.Type.AssetTrackingDatasetMouseSimulationType) {
                if (this.simulationState.running) {
                    this.onMouseMoveInMouseSimulationMode(x, y);
                }
            }
            else if (this.options.type instanceof IndoorMap.Type.AssetTrackingDatasetTaggingSimulationType) {
                if (this.simulationState.running) {
                    this.onMouseMoveInDatasetTaggingMode(x, y);
                }
            }
            return false;
        }
        onMouseMoveInMouseSimulationMode(x, y) {
            if (GestureRecognizer_10.GestureRecognizer.isCtrlPressed()) {
                // Position
                let positionInPx = new Vector2_49.Vector2(x, y);
                let positionInTx = this.getBuilding().getCurrentFloor().getFloorplanLayer().getTexelsFromScreenPixels(positionInPx);
                this.targetView.x = positionInTx.x;
                this.targetView.y = positionInTx.y;
            }
        }
        onMouseMoveInDatasetTaggingMode(x, y) {
            this.setTagPointTo(x, y);
        }
        setTagPointTo(x, y) {
            if (GestureRecognizer_10.GestureRecognizer.isCtrlPressed()) {
                this.moveActiveTagPointTo(x, y);
                this.updateTaggingPathTo(x, y);
            }
        }
        moveActiveTagPointTo(x, y) {
            let positionInPx = new Vector2_49.Vector2(x, y);
            let positionInTx = this.getBuilding().getCurrentFloor().getFloorplanLayer().getTexelsFromScreenPixels(positionInPx);
            this.activeTagPoint.x = positionInTx.x;
            this.activeTagPoint.y = positionInTx.y;
        }
        updateTaggingPathTo(x, y) {
            let pointInPx = new Vector2_49.Vector2(x, y);
            let pointInTx = this.getBuilding().getCurrentFloor().getFloorplanLayer().getTexelsFromScreenPixels(pointInPx);
            this.addPointToTaggingPath(pointInTx);
            this.updateTaggingPathView();
        }
        addPointToTaggingPath(pointInTx) {
            this.taggingPath.push(this.fruityMap.getEnvironment().renderer.newPointFromVector2(pointInTx));
            this.taggingPathTimestamps.push(Date.now());
            let floorplanLayer = this.getBuilding().getCurrentFloor().getFloorplanLayer();
            let pointInCm = new Vector2_49.Vector2(floorplanLayer.getCmFromTexels(pointInTx.x), floorplanLayer.getCmFromTexels(pointInTx.y));
            this.taggingData.push(pointInCm);
            this.taggingTimestampData.push(Date.now());
        }
        updateTaggingPathView() {
            this.taggingPathView.clear();
            this.taggingPathView.lineStyle(1 * this.lastScaleFactor, 0xff00ff);
            this.taggingPathView.drawPolygon(this.taggingPath);
            this.taggingPathView.endFill();
        }
        onKeyDown(keyCode) {
            if (this.options.type instanceof IndoorMap.Type.AssetTrackingDatasetMouseSimulationType) {
                this.handleOnKeyDownInMouseSimulationMode(keyCode);
            }
            else if (this.options.type instanceof IndoorMap.Type.AssetTrackingDatasetTaggingSimulationType) {
                this.handleOnKeyDownInDatasetTaggingMode(keyCode);
            }
            return false;
        }
        handleOnKeyDownInMouseSimulationMode(keyCode) {
            const clockWiseKeyCode = 88; // x
            const counterClockWiseKeyCode = 89; // y
            if (keyCode === clockWiseKeyCode) {
                this.updateTargetOrientation(-1);
            }
            else if (keyCode === counterClockWiseKeyCode) {
                this.updateTargetOrientation(+1);
            }
        }
        handleOnKeyDownInDatasetTaggingMode(keyCode) {
            if (this.simulationState.running) {
                if (KeyUtils_3.KeyUtils.isCtrlKey(keyCode)) {
                    this.setTagPointTo(GestureRecognizer_10.GestureRecognizer.getMousePositionX(), GestureRecognizer_10.GestureRecognizer.getMousePositionY());
                }
            }
        }
        onMouseWheel(delta, mouseX, mouseY) {
            if (this.options.type instanceof IndoorMap.Type.AssetTrackingDatasetMouseSimulationType) {
                this.updateDepth(delta);
            }
            return false;
        }
        updateTargetOrientation(delta) {
            let rotationInRad = (2 * Math.PI) * (10.0 / 360);
            rotationInRad = delta < 0 ? rotationInRad : -rotationInRad;
            this.currentOrientationInRad = (this.currentOrientationInRad + rotationInRad) % (Math.PI * 2);
        }
        updateDepth(delta) {
            if (!GestureRecognizer_10.GestureRecognizer.isCtrlPressed()) {
                if (delta < 0) {
                    this.currentDepth -= 1.0 / (this.getBuilding().getFloors().length);
                }
                else {
                    this.currentDepth += 1.0 / (this.getBuilding().getFloors().length);
                }
                this.currentDepth = Math.min(Math.max(this.currentDepth, 0), 1);
            }
        }
        // External events
        onSimulationStateUpdated(state) {
            if (!state.equals(this.simulationState)) {
                this.simulationState = state;
                if (!this.simulationState.running) {
                    this.reset();
                }
            }
        }
        reset() {
            this.resetDatasetTaggingModeViews();
            this.resetMouseSimulationModeViews();
        }
        resetDatasetTaggingModeViews() {
            if (this.options.type instanceof IndoorMap.Type.AssetTrackingDatasetTaggingSimulationType) {
                this.activeTagPoint.alpha = 0.0;
                this.taggingPathView.clear();
                this.taggingPathView.alpha = 0.0;
                this.taggingPath = [];
                this.taggingPathTimestamps = [];
                this.taggingData = [];
            }
        }
        resetMouseSimulationModeViews() {
            if (this.options.type instanceof IndoorMap.Type.AssetTrackingDatasetMouseSimulationType) {
                this.targetView.alpha = 0.0;
                this.currentOrientationInRad = 0;
                this.currentDepth = 0;
            }
        }
        // Getters and setters
        getType() {
            return this.options.type;
        }
        setType(type) {
            this.options.type = type;
        }
        pullTaggingData() {
            let taggingData = this.taggingData;
            this.taggingData = [];
            return taggingData;
        }
        pullTimestampData() {
            let taggingTimestampData = this.taggingTimestampData;
            this.taggingTimestampData = [];
            return taggingTimestampData;
        }
        getTargetPositionInWorldCm() {
            try {
                let deviceLayer = this.getBuilding().getCurrentFloor().getDeviceLayer();
                let targetPositionInTx = this.targetView.position;
                let targetPositionInCmX = (targetPositionInTx.x / deviceLayer.getFloorplanLayer().getModel().pixelPerMeter) * 100;
                let targetPositionInCmY = (targetPositionInTx.y / deviceLayer.getFloorplanLayer().getModel().pixelPerMeter) * 100;
                let noiseWidthInCm = 0;
                targetPositionInCmX = targetPositionInCmX + ((Math.random() - 0.5) * noiseWidthInCm);
                targetPositionInCmY = targetPositionInCmY + ((Math.random() - 0.5) * noiseWidthInCm);
                return new Vector2_49.Vector2(targetPositionInCmX, targetPositionInCmY);
            }
            catch (e) {
                return new Vector2_49.Vector2(0, 0);
            }
        }
        getTargetOrientationInRad() {
            return this.currentOrientationInRad;
        }
        getMouseDepthInWorldCm() {
            let nearestFloor = this.getNearestFloor(this.currentDepth);
            let mouseDepthInWorldCm = nearestFloor.getHeightInMeter() * 100;
            return mouseDepthInWorldCm;
        }
        getNearestFloor(floorNumber) {
            let floorIndex = Math.floor(this.currentDepth * (this.getBuilding().getFloors().length - 1));
            return this.getBuilding().getFloors()[floorIndex];
        }
        getNearestFloorName() {
            let nearestFloor = this.getNearestFloor(this.currentDepth);
            return nearestFloor.getFloorName();
        }
    }
    exports.IndoorMap = IndoorMap;
    (function (IndoorMap) {
        // Types
        let Type;
        (function (Type_1) {
            class Type {
            }
            Type_1.Type = Type;
            class PositioningDatasetSimulationType extends Type {
            }
            Type_1.PositioningDatasetSimulationType = PositioningDatasetSimulationType;
            class ObjectTrackingDatasetSimulationType extends Type {
            }
            Type_1.ObjectTrackingDatasetSimulationType = ObjectTrackingDatasetSimulationType;
            class AssetTrackingSimulationType extends Type {
            }
            Type_1.AssetTrackingSimulationType = AssetTrackingSimulationType;
            class AssetTrackingRealTimeMonitoringType extends AssetTrackingSimulationType {
            }
            Type_1.AssetTrackingRealTimeMonitoringType = AssetTrackingRealTimeMonitoringType;
            class AssetTrackingDatasetSimulationType extends AssetTrackingSimulationType {
            }
            Type_1.AssetTrackingDatasetSimulationType = AssetTrackingDatasetSimulationType;
            class AssetTrackingDatasetMouseSimulationType extends AssetTrackingDatasetSimulationType {
            }
            Type_1.AssetTrackingDatasetMouseSimulationType = AssetTrackingDatasetMouseSimulationType;
            class AssetTrackingDatasetValidationSimulationType extends AssetTrackingDatasetSimulationType {
            }
            Type_1.AssetTrackingDatasetValidationSimulationType = AssetTrackingDatasetValidationSimulationType;
            class AssetTrackingDatasetTaggingSimulationType extends AssetTrackingDatasetValidationSimulationType {
            }
            Type_1.AssetTrackingDatasetTaggingSimulationType = AssetTrackingDatasetTaggingSimulationType;
            class AssetTrackingDatasetBeaconSimulationType extends AssetTrackingDatasetSimulationType {
            }
            Type_1.AssetTrackingDatasetBeaconSimulationType = AssetTrackingDatasetBeaconSimulationType;
        })(Type = IndoorMap.Type || (IndoorMap.Type = {}));
        class Options extends RelutionMap_7.RelutionMap.Options {
        }
        IndoorMap.Options = Options;
    })(IndoorMap = exports.IndoorMap || (exports.IndoorMap = {}));
});
define("test/tests/indoor/IndoorApplicationController", ["require", "exports", "src/app/relution/locale/LocalizationEn", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/AssetMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/BeaconMapObject", "src/app/relution/view/world/Floor", "test/tests/indoor/IndoorApplication", "test/tests/indoor/view/map/IndoorMap", "test/tests/indoor/service/simulation/SimulationServiceConfig", "test/tests/indoor/view/map/layers/deviceTrackingDetailsLayer/DeviceTrackingDetails"], function (require, exports, LocalizationEn_6, AssetMapObject_8, BeaconMapObject_10, Floor_4, IndoorApplication_1, IndoorMap_1, SimulationServiceConfig_2, DeviceTrackingDetails_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ApplicationController = exports.Controller = exports.IndoorApplicationController = void 0;
    class IndoorApplicationController {
        // Construction
        constructor(config, subcontroller, service) {
            this.config = config;
            this.initSubcontroller(subcontroller);
            this.initService(service, (siteNames) => {
                this.initView(siteNames, () => {
                    this.startSynchronizingModels();
                });
            });
        }
        initSubcontroller(subcontroller) {
            this.subcontroller = subcontroller;
        }
        // 1. Service initialization
        initService(service, callback) {
            this.service = service;
            this.service.init(this.config.service, (resolvedServiceConfig, siteNames) => {
                // Replace the service configuration by the one resolved by the service.
                this.config.service = resolvedServiceConfig;
                callback(siteNames);
            });
        }
        // 2. View initialization
        initView(siteNames, initializationCallback) {
            this.initIndoorMap(siteNames, () => {
                this.initDomElements(() => {
                    initializationCallback();
                });
            });
        }
        // 2.1. Map initialization
        initIndoorMap(siteNames, initializationCallback) {
            let options = this.initMapOptions();
            let map = new IndoorMap_1.IndoorMap(options);
            this.initMap(map, siteNames, initializationCallback);
        }
        initMapOptions() {
            let options = new IndoorMap_1.IndoorMap.Options();
            options.parentHtmlElement = document.getElementById("map");
            options.pathToImages = "../../../img/png/";
            options.type = IndoorApplication_1.IndoorApplication.Config.getIndoorMapType(this.config);
            options.showDetailsOnHover = this.shouldShowDetailsOnHover();
            options.renderer.renderTargetSize.x = Number.parseInt($(options.parentHtmlElement).css("width"));
            options.renderer.renderTargetSize.y = Number.parseInt($(options.parentHtmlElement).css("height"));
            options.renderer.pixelRatio = window.devicePixelRatio;
            options.renderer.crossOriginAttribute = "anonymous";
            options.localization = new LocalizationEn_6.LocalizationEn();
            options.world.building.objectTypeVisibilities.set(BeaconMapObject_10.BeaconMapObject, $("#beacons-action").hasClass("active"));
            options.world.building.objectTypeVisibilities.set(AssetMapObject_8.AssetMapObject, $("#assets-action").hasClass("active"));
            options.world.building.objectTypeVisibilities.set(DeviceTrackingDetails_2.DeviceTrackingDetails, true);
            this.subcontroller.overrideMapConfig(options);
            return options;
        }
        initMap(map, siteNames, initializationCallback) {
            // 3. Add floors to map
            let floors = new Array();
            let callback = (floor) => {
                floors.push(floor);
                if (floors.length === siteNames.length) {
                    this.loadIndoorMap(map, floors[0], () => {
                        this.addFloorsToMap(floors, initializationCallback);
                    });
                }
            };
            // 2. Load floor textures
            let modelLoadedFloors = new Array();
            let floorModelCallback = (floor) => {
                modelLoadedFloors.push(floor);
                if (modelLoadedFloors.length == siteNames.length) {
                    for (let i = 0; i < modelLoadedFloors.length; i++) {
                        let currentFloor = modelLoadedFloors[i];
                        currentFloor.load(callback);
                    }
                }
            };
            // 1. Load floor models
            for (let i = 0; i < siteNames.length; i++) {
                let siteName = siteNames[i];
                this.loadFloorModel(map, siteName, floorModelCallback);
            }
        }
        loadFloorModel(map, floorName, callback) {
            this.service.loadFloor(floorName, (floorModel) => {
                let floor = map.createFloor(floorName, floorModel, new Floor_4.Floor.Config());
                callback(floor);
            });
        }
        loadIndoorMap(indoorMap, floor, callback) {
            // Instantiation
            indoorMap.load(floor, () => {
                this.indoorMap = indoorMap;
                window.addEventListener("beforeunload", (e) => {
                    this.indoorMap.destroy();
                });
                window.addEventListener("resize", () => {
                    let newWidth = Number.parseInt($(indoorMap.getConfig().parentHtmlElement).css("width"));
                    let newHeight = Number.parseInt($(indoorMap.getConfig().parentHtmlElement).css("height"));
                    this.indoorMap.setSize(newWidth, newHeight);
                });
                this.indoorMap.setDeviceEditModeEnabled(false);
                this.indoorMap.toggleLayerVisibility("connections", false);
                callback(this.indoorMap);
            });
        }
        shouldShowDetailsOnHover() {
            let applicationConfig = this.config.service.application;
            return applicationConfig.simulation.type === SimulationServiceConfig_2.BeaconTrackingSimulationConfig.TYPE_NAME;
        }
        addFloorsToMap(floors, initializationCallback) {
            let numberOfLoadedDeviceDatasets = 0;
            let devicesCallback = (deviceModels) => {
                numberOfLoadedDeviceDatasets++;
                if (numberOfLoadedDeviceDatasets == floors.length) {
                    this.orderFloorsByAvgBeaconHeight();
                    this.loadGeofences(floors, initializationCallback);
                }
            };
            for (let i = 0; i < floors.length; i++) {
                let currentFloor = floors[i];
                let currentFloorName = currentFloor.getFloorName();
                this.indoorMap.getBuilding().addFloor(currentFloor);
                this.loadDevices(currentFloorName, devicesCallback);
            }
        }
        loadDevices(siteName, callback) {
            this.service.loadDevices(siteName, (deviceModels) => {
                this.indoorMap.getBuilding().getFloorWithName(siteName).loadDevices(deviceModels);
                callback(deviceModels);
            });
        }
        orderFloorsByAvgBeaconHeight() {
            this.indoorMap.getBuilding().sortFloorsByHeight();
        }
        loadGeofences(floors, initializationCallback) {
            let numOfLoadedGeofenceDatasets = 0;
            let callback = (geofenceModels) => {
                numOfLoadedGeofenceDatasets++;
                if (numOfLoadedGeofenceDatasets == floors.length) {
                    initializationCallback();
                }
            };
            for (let i = 0; i < this.indoorMap.getBuilding().getFloors().length; i++) {
                let floor = this.indoorMap.getBuilding().getFloors()[i];
                this.loadGeofencesForFloor(floor, callback);
            }
        }
        loadGeofencesForFloor(floor, callback) {
            this.service.loadGeofences(floor.getFloorName(), (geofenceModels) => {
                this.indoorMap.getBuilding().getFloorWithName(floor.getFloorName()).loadGeofences(geofenceModels);
                callback(geofenceModels);
            });
        }
        // 2.2. DOM initialization
        initDomElements(initializationCallback) {
            this.initTabBar();
            this.initActionBar();
            this.initLeftBar();
            this.initRightBar();
            this.subcontroller.init(this.indoorMap, () => {
                this.showView();
                initializationCallback();
            });
        }
        initTabBar() {
            this.makeAllTabBarItemsInactive();
            let tabBarItemId = this.subcontroller.getId();
            this.setTabBarItemActive(tabBarItemId);
        }
        makeAllTabBarItemsInactive() {
            let children = $("#tabbar").children();
            for (let i = 0; i < children.length; i++) {
                let child = children[i];
                let aElement = $($(child).children()[0]);
                aElement.removeClass("active");
            }
        }
        setTabBarItemActive(tabBarItemId) {
            $(tabBarItemId).addClass("active");
        }
        initActionBar() {
            // General
            this.toggleLayerOnActionButtonToggleEvent("help-action", "help");
            // Floor
            this.toggleLayerOnActionButtonToggleEvent("floor-wallplan-action", "wallplan");
            this.toggleLayerOnActionButtonToggleEvent("floor-taggingplan-action", "taggingPlan");
            // Objects
            this.toggleLayerOnActionButtonToggleEvent("devices-action", "devices");
            this.toggleLayerOnActionButtonToggleEvent("geofences-action", "geofence");
            // Devices
            this.toggleRelutionMapObjectVisibilityOnButtonToggleEvent("beacons-action", BeaconMapObject_10.BeaconMapObject);
            this.toggleRelutionMapObjectVisibilityOnButtonToggleEvent("assets-action", AssetMapObject_8.AssetMapObject);
            // Device layers
            this.toggleLayerOnActionButtonToggleEvent("devices-info-action", "info");
            // Beacon layers
            this.toggleLayerOnActionButtonToggleEvent("beacons-ranges-action", "ranges");
            this.toggleLayerOnActionButtonToggleEvent("beacons-connections-action", "connections");
            // Asset layers
            this.toggleLayerOnActionButtonToggleEvent("assets-tracks-action", "tracking");
        }
        toggleLayerOnActionButtonToggleEvent(actionId, layerName) {
            // 1. Set initial layer visibility
            let actionElement = $("#" + actionId);
            let visible = actionElement.hasClass("active");
            if (visible) {
                actionElement.addClass("active");
            }
            else {
                actionElement.removeClass("active");
            }
            // 2. Change layer visibility on toggle
            actionElement.on("click", () => {
                var visible = actionElement.hasClass("active");
                this.indoorMap.toggleLayerVisibility(layerName, !visible);
            });
            // 3. Change button toggle on layer visibility change
            this.indoorMap.addObserver({
                onLayerVisibilityChanged: (name, visible) => {
                    if (name === layerName) {
                        if (visible) {
                            actionElement.addClass("active");
                        }
                        else {
                            actionElement.removeClass("active");
                        }
                    }
                }
            });
        }
        toggleRelutionMapObjectVisibilityOnButtonToggleEvent(actionId, objectType) {
            // 1. Set initial object type visibility
            let actionElement = $("#" + actionId);
            let visible = this.indoorMap.getConfig().world.building.objectTypeVisibilities.get(objectType);
            if (visible) {
                actionElement.addClass("active");
            }
            else {
                actionElement.removeClass("active");
            }
            // 2. Change object type visibility on toggle
            actionElement.on("click", () => {
                var visible = actionElement.hasClass("active");
                this.indoorMap.toggleRelutionMapObjectTypeVisibility(objectType, !visible, true);
            });
            // 3. Change button toggle on layer visibility change
            this.indoorMap.addObserver({
                onObjectTypeVisibilityChanged: (type, visible) => {
                    if (type === objectType) {
                        if (visible) {
                            actionElement.addClass("active");
                        }
                        else {
                            actionElement.removeClass("active");
                        }
                    }
                }
            });
        }
        initLeftBar() {
            // Nothing to do
        }
        initRightBar() {
            // 1. Add floor numbers to the right bar and move to the floor on click.
            for (let i = this.indoorMap.getBuilding().getFloors().length - 1; i >= 0; i--) {
                let floorNumber = (i + 1);
                let floor = this.indoorMap.getBuilding().getFloors()[i];
                let newButton = $("<button id='floor-" + floorNumber + "' type='button' class='btn btn-sm btn-light'>" + floorNumber + "</button>");
                newButton.on("click", () => {
                    this.indoorMap.getBuilding().animateToFloor(floor);
                });
                newButton.appendTo("#floor-bar");
            }
            // 2. Set current floor active
            let currentFloor = this.indoorMap.getBuilding().getCurrentFloor();
            this.setFloorButtonActive(currentFloor, currentFloor);
            // 2. On floor change update the corresponding buttons.
            let that = this;
            this.indoorMap.getBuilding().addFloorObserver({
                floorChanged(floorBefore, floorAfter) {
                    that.setFloorButtonActive(floorBefore, floorAfter);
                }
            });
        }
        setFloorButtonActive(floorBefore, floorAfter) {
            let previousFloorNumber = this.indoorMap.getBuilding().getFloorIndex(floorBefore) + 1;
            let nextFloorNumber = this.indoorMap.getBuilding().getFloorIndex(floorAfter) + 1;
            $("#floor-" + previousFloorNumber).removeClass("active");
            $("#floor-" + nextFloorNumber).addClass("active");
        }
        showView() {
            $("#application").removeClass("d-none");
        }
        // 3. Model synchronization
        startSynchronizingModels() {
            this.startConfigSync();
            let floors = this.indoorMap.getBuilding().getFloors();
            for (let i = 0; i < floors.length; i++) {
                let floor = floors[i];
                this.startFloorDataSync(floor);
            }
        }
        startConfigSync() {
            let intervalDurationInMs = 100;
            setInterval(() => {
                const oldConfigAsJsonString = JSON.stringify(this.config.service);
                this.updateConfig();
                this.subcontroller.updateServiceConfig();
                const newConfigAsJsonString = JSON.stringify(this.config.service);
                if (newConfigAsJsonString !== oldConfigAsJsonString) {
                    this.service.updateConfig(this.config.service);
                }
            }, intervalDurationInMs);
        }
        updateConfig() {
            // Nothing to do
        }
        startFloorDataSync(floor) {
            // Floor name
            let siteName = floor.getFloorName();
            // Devices
            this.startReloadingDevices(siteName);
        }
        // Updating state: devices
        startReloadingDevices(siteName) {
            let intervalDurationInMs = this.subcontroller.getConfig().deviceReloadingIntervalInMs;
            setInterval(() => {
                if (this.indoorMap.getBuilding().getCurrentFloor().getFloorName() === siteName) {
                    this.service.loadDevices(siteName, (deviceModels) => {
                        this.indoorMap.getBuilding().getCurrentFloor().updateDevices(deviceModels);
                    });
                }
            }, intervalDurationInMs);
        }
    }
    exports.IndoorApplicationController = IndoorApplicationController;
    class Controller {
        // Construction
        constructor(applicationConfig, service) {
            this.applicationConfig = applicationConfig;
            this.service = service;
        }
        // Identifier
        // Configuration
        getConfig() {
            return new Controller.Config();
        }
        // 1. Event handling: Map initialization
        /**
         * Subclasses should override this method, to override the indoor map options right before
         * the map will be instantiated.
         * @param indoorMapOptions
         */
        overrideMapConfig(indoorMapOptions) {
            for (let i = 0; i < this.getSubcontrollers().length; i++) {
                const subcontroller = this.getSubcontrollers()[i];
                subcontroller.overrideMapConfig(indoorMapOptions);
            }
        }
    }
    exports.Controller = Controller;
    class ApplicationController extends Controller {
        constructor(applicationConfig, service) {
            super(applicationConfig, service);
        }
    }
    exports.ApplicationController = ApplicationController;
    (function (Controller) {
        class Config {
            constructor() {
                this.deviceReloadingIntervalInMs = 100;
                this.geofenceUpdateIntervalInMs = 100;
            }
        }
        Controller.Config = Config;
    })(Controller = exports.Controller || (exports.Controller = {}));
});
define("test/tests/indoor/service/monitoring/MonitoringServiceConfig", ["require", "exports", "test/tests/indoor/service/simulation/SimulationServiceConfig"], function (require, exports, SimulationServiceConfig_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MonitoringServiceConfig = void 0;
    class MonitoringServiceConfig extends SimulationServiceConfig_3.ApplicationConfig {
    }
    exports.MonitoringServiceConfig = MonitoringServiceConfig;
    MonitoringServiceConfig.TYPE_NAME = "monitoring";
});
define("test/tests/indoor/service/monitoring/MonitoringService", ["require", "exports", "test/tests/indoor/service/IndoorApplicationService"], function (require, exports, IndoorApplicationService_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MonitoringService = void 0;
    class MonitoringService extends IndoorApplicationService_1.IndoorApplicationService {
        constructor() {
            super();
        }
    }
    exports.MonitoringService = MonitoringService;
});
define("test/tests/indoor/models/simulation/positioning/PositioningSimulationStateModel", ["require", "exports", "test/tests/indoor/models/IndoorStateModel", "src/app/relution/model/Model"], function (require, exports, IndoorStateModel_2, Model_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PositioningSimulationStateModel = void 0;
    class PositioningSimulationStateModel extends IndoorStateModel_2.IndoorStateModel {
        constructor() {
            super(...arguments);
            /**
             * The index of the current measurement the positioning dataset simulation is pointing to.
             *
             * Default: 0
             */
            this._cursor = 0;
            /**
             * The number of instances in the positioning dataset
             *
             * Default: 0
             */
            this._size = 0;
        }
        // Getters and setters
        set cursor(cursor) {
            this._cursor = cursor;
            this.notifyObservers("cursor");
        }
        get cursor() {
            return this._cursor;
        }
        set size(size) {
            this._size = size;
            this.notifyObservers("size");
        }
        get size() {
            return this._size;
        }
    }
    __decorate([
        (0, Model_16.ModelProperty)()
    ], PositioningSimulationStateModel.prototype, "_cursor", void 0);
    __decorate([
        (0, Model_16.ModelProperty)()
    ], PositioningSimulationStateModel.prototype, "_size", void 0);
    exports.PositioningSimulationStateModel = PositioningSimulationStateModel;
});
define("test/tests/indoor/models/simulation/tracking/TrackingSimulationStateModel", ["require", "exports", "src/app/relution/model/Model"], function (require, exports, Model_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TrackingSimulationStateModel = void 0;
    class TrackingSimulationStateModel extends Model_17.Model {
        constructor() {
            super(...arguments);
            this._paused = false;
            this._progress = 0.0;
            this._timeInMs = 0;
        }
        // Getters and setters
        set paused(paused) {
            this._paused = paused;
            this.notifyObservers("paused");
        }
        get paused() {
            return this._paused;
        }
        set progress(progress) {
            this._progress = progress;
            this.notifyObservers("progress");
        }
        get progress() {
            return this._progress;
        }
        set timeInMs(timeInMs) {
            this._timeInMs = timeInMs;
            this.notifyObservers("timeInMs");
        }
        get timeInMs() {
            return this._timeInMs;
        }
    }
    __decorate([
        (0, Model_17.ModelProperty)()
    ], TrackingSimulationStateModel.prototype, "_paused", void 0);
    __decorate([
        (0, Model_17.ModelProperty)()
    ], TrackingSimulationStateModel.prototype, "_progress", void 0);
    __decorate([
        (0, Model_17.ModelProperty)()
    ], TrackingSimulationStateModel.prototype, "_timeInMs", void 0);
    exports.TrackingSimulationStateModel = TrackingSimulationStateModel;
});
define("test/tests/indoor/models/simulation/tracking/asset/TaggingStateModel", ["require", "exports", "src/app/relution/model/Model"], function (require, exports, Model_18) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TaggingStateModel = void 0;
    class TaggingStateModel extends Model_18.Model {
        constructor() {
            super(...arguments);
            this._running = false;
        }
        // Getters and setters
        set running(running) {
            this._running = running;
            this.notifyObservers("running");
        }
        get running() {
            return this._running;
        }
    }
    __decorate([
        (0, Model_18.ModelProperty)()
    ], TaggingStateModel.prototype, "_running", void 0);
    exports.TaggingStateModel = TaggingStateModel;
});
define("test/tests/indoor/service/simulation/SimulationService", ["require", "exports", "test/tests/indoor/service/IndoorApplicationService", "test/utils/HttpUtils", "src/app/relution/model/floor/FloorModelLoader", "src/app/relution/model/device/DeviceModel", "src/app/relution/model/RelutionMapModelLoader", "src/map/utils/Logger", "src/app/relution/model/geofence/GeofenceModel", "src/app/relution/model/geofence/GeofenceStateModel", "test/tests/indoor/models/DeviceTrackingStateModel", "test/tests/indoor/models/simulation/positioning/PositioningSimulationStateModel", "test/tests/indoor/models/simulation/tracking/TrackingSimulationStateModel", "test/tests/indoor/models/simulation/tracking/asset/TaggingStateModel", "test/tests/indoor/models/IndoorStateModel"], function (require, exports, IndoorApplicationService_2, HttpUtils_3, FloorModelLoader_4, DeviceModel_11, RelutionMapModelLoader_5, Logger_11, GeofenceModel_5, GeofenceStateModel_3, DeviceTrackingStateModel_3, PositioningSimulationStateModel_1, TrackingSimulationStateModel_1, TaggingStateModel_1, IndoorStateModel_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimulationService = void 0;
    class SimulationService extends IndoorApplicationService_2.IndoorApplicationService {
        constructor() {
            super();
            this.indoorServerUrl = "http://localhost:4444/indoor";
        }
        // Initialization
        init(config, finishedCallback) {
            const initUrl = this.indoorServerUrl + "/init";
            HttpUtils_3.HttpUtils.postJson(initUrl, config, (response) => {
                const siteNames = response.results[0].info.siteNames;
                const resolvedConfig = response.results[0].config;
                finishedCallback(resolvedConfig, siteNames);
            }, (response) => {
                let text = document.createTextNode(response);
                document.body.appendChild(text);
            });
        }
        // Configuration
        loadConfig(callback) {
            const url = this.indoorServerUrl + "/config";
            HttpUtils_3.HttpUtils.getJson(url, (config) => {
                callback(config);
            });
        }
        updateConfig(configuration) {
            const url = this.indoorServerUrl + "/config";
            HttpUtils_3.HttpUtils.postJson(url, configuration, (resultObject) => {
                // Nothing to do
            });
        }
        // Floor
        loadFloor(siteName, callback) {
            const floorUrl = this.indoorServerUrl + "/site/" + siteName;
            const floorplanUrl = this.indoorServerUrl + "/site/" + siteName + "/floorplan-image";
            const wallplanUrl = this.indoorServerUrl + "/site/" + siteName + "/wallplan-image";
            const taggingPlanUrl = this.indoorServerUrl + "/site/" + siteName + "/taggingplan-image";
            HttpUtils_3.HttpUtils.getJson(floorUrl, (floorObject) => {
                let floorplanOverlayNameToImageUrl = new Map();
                floorplanOverlayNameToImageUrl.set("taggingPlan", taggingPlanUrl);
                let floorModelOptions = {
                    jsonObject: floorObject,
                    pathToFloorplan: floorplanUrl,
                    wallplanUrl: wallplanUrl,
                    floorplanOverlayNameToImageUrl: floorplanOverlayNameToImageUrl,
                    isPortalMode: false,
                };
                let floorModel = FloorModelLoader_4.FloorModelLoader.loadFloor(floorModelOptions);
                callback(floorModel);
            });
        }
        // Devices
        loadDevices(siteName, callback) {
            let devicesUrl = this.indoorServerUrl + "/site/" + siteName + "/devices";
            HttpUtils_3.HttpUtils.getJson(devicesUrl, (devicesObject) => {
                let deviceModels = RelutionMapModelLoader_5.RelutionMapModelLoader.loadModels(devicesObject, DeviceModel_11.DeviceModel, false);
                callback(deviceModels);
            });
        }
        // Devices: state
        loadDeviceStates(siteName, callback) {
            const url = this.indoorServerUrl + "/site/" + siteName + "/devices/state";
            HttpUtils_3.HttpUtils.getJson(url, (resultObject) => {
                if (resultObject["status"] === "success") {
                    let indoorStateArray = resultObject["results"];
                    let indoorStateModels = RelutionMapModelLoader_5.RelutionMapModelLoader.loadModels(indoorStateArray, DeviceTrackingStateModel_3.DeviceTrackingStateModel, false);
                    callback(indoorStateModels);
                }
                else {
                    Logger_11.Logger.logDebug("Updating indoor state not possible.");
                }
            });
        }
        // Devices: probability image
        loadDeviceProbabilityImage(siteName, callback) {
            const url = this.indoorServerUrl + "/site/" + siteName + "/devices/state/probability-image";
            this.loadImage(url, callback);
        }
        // Devices: radio map image
        loadDeviceRadioMapImage(siteName, beaconUuid, callback) {
            const url = this.indoorServerUrl + "/site/" + siteName + "/devices/" + beaconUuid + "/state/radiomap";
            this.loadImage(url, callback);
        }
        loadImage(url, callback) {
            if (url !== null) {
                let image = new Image();
                image.crossOrigin = "anonymous";
                image.onload = () => {
                    callback(image);
                };
                // We add math.random to the end of the url to prevent the browser
                // to load the next image from its cache.
                image.src = "" + url + "?random=" + Math.random();
            }
        }
        // Geofences
        loadGeofences(floorName, callback) {
            const url = this.indoorServerUrl + "/site/" + floorName + "/geofences";
            HttpUtils_3.HttpUtils.getJson(url, (json) => {
                let geofenceModels = new Array();
                if (json !== null) {
                    geofenceModels = RelutionMapModelLoader_5.RelutionMapModelLoader.loadModels(json, GeofenceModel_5.GeofenceModel, false);
                }
                callback(geofenceModels);
            }, (json) => {
                // If geofences are unsupported, just ignore them.
                callback(new Array());
            });
        }
        loadGeofenceStates(floorName, callback) {
            const url = this.indoorServerUrl + "/site/" + floorName + "/geofences/state";
            HttpUtils_3.HttpUtils.getJson(url, (resultObject) => {
                if (resultObject["status"] === "success") {
                    let geofenceStateArray = resultObject["results"];
                    let geofenceStateModels = RelutionMapModelLoader_5.RelutionMapModelLoader.loadModels(geofenceStateArray, GeofenceStateModel_3.GeofenceStateModel, false);
                    callback(geofenceStateModels);
                }
                else {
                    Logger_11.Logger.logDebug("Updating indoor state not possible.");
                }
            });
        }
        // Simulation
        getSimulationState(callback) {
            const url = this.indoorServerUrl + "/simulation/state";
            HttpUtils_3.HttpUtils.getJson(url, (json) => {
                let state = RelutionMapModelLoader_5.RelutionMapModelLoader.loadModel(json, IndoorStateModel_3.IndoorStateModel, false);
                callback(state);
            });
        }
        startCalibration(calibrateWithValidationData) {
            const url = this.indoorServerUrl + "/simulation/calibration/start";
            let payload = {
                calibrateWithValidationData: calibrateWithValidationData
            };
            HttpUtils_3.HttpUtils.postJson(url, payload, (r) => { });
        }
        stopCalibration() {
            const url = this.indoorServerUrl + "/simulation/calibration/stop";
            HttpUtils_3.HttpUtils.postJson(url, {}, (r) => { });
        }
        // Positioning simulation
        setPositioningDatasetCursor(floorName, cursor, callback) {
            const url = this.indoorServerUrl + "/positioning/site/" + floorName + "/cursor";
            let payload = {
                "cursor": cursor
            };
            HttpUtils_3.HttpUtils.postJson(url, payload, (resultObject) => {
                if (callback !== undefined) {
                    callback();
                }
            });
        }
        getPositioningSimulationState(floorName, callback) {
            const url = this.indoorServerUrl + "/positioning/site/" + floorName + "/state";
            HttpUtils_3.HttpUtils.getJson(url, (json) => {
                let state = RelutionMapModelLoader_5.RelutionMapModelLoader.loadModel(json, PositioningSimulationStateModel_1.PositioningSimulationStateModel, false);
                callback(state);
            });
        }
        // Tracking simulation
        startTrackingSimulation() {
            const url = this.indoorServerUrl + "/tracking/start";
            HttpUtils_3.HttpUtils.getJson(url, (responseObject) => { });
        }
        stopTrackingSimulation() {
            const url = this.indoorServerUrl + "/tracking/stop";
            HttpUtils_3.HttpUtils.getJson(url, (responseObject) => { });
        }
        restartTrackingSimulation() {
            HttpUtils_3.HttpUtils.abortAllRequests();
            const startUrl = this.indoorServerUrl + "/tracking/start";
            const stopUrl = this.indoorServerUrl + "/tracking/stop";
            HttpUtils_3.HttpUtils.getJson(stopUrl, (responseObject) => {
                HttpUtils_3.HttpUtils.getJson(startUrl, (responseObject) => { });
            });
        }
        pauseTrackingSimulation() {
            const url = this.indoorServerUrl + "/tracking/pause";
            HttpUtils_3.HttpUtils.getJson(url, (responseObject) => { });
        }
        setTrackingSimulationProgress(progress, callback) {
            const url = this.indoorServerUrl + "/tracking/progress";
            let payload = {
                "progress": progress
            };
            HttpUtils_3.HttpUtils.postJson(url, payload, (resultObject) => {
                if (callback !== undefined) {
                    callback();
                }
            });
        }
        getTrackingSimulationState(callback) {
            const url = this.indoorServerUrl + "/tracking/state";
            HttpUtils_3.HttpUtils.getJson(url, (json) => {
                let state = RelutionMapModelLoader_5.RelutionMapModelLoader.loadModel(json, TrackingSimulationStateModel_1.TrackingSimulationStateModel, false);
                callback(state);
            });
        }
        // Asset tracking: mouse simulation
        sendTargetState(targetStateObject) {
            const url = this.indoorServerUrl + "/assettracking/mouse/target-state";
            HttpUtils_3.HttpUtils.postJson(url, targetStateObject, (r) => { });
        }
        // Asset tracking: dataset tagging simulation
        startTagging() {
            const url = this.indoorServerUrl + "/assettracking/dataset/tagging/start";
            HttpUtils_3.HttpUtils.postJson(url, {}, (r) => { });
        }
        stopTagging() {
            const url = this.indoorServerUrl + "/assettracking/dataset/tagging/stop";
            HttpUtils_3.HttpUtils.postJson(url, {}, (r) => { });
        }
        sendTaggingData(payload) {
            const url = this.indoorServerUrl + "/assettracking/dataset/tagging/data";
            HttpUtils_3.HttpUtils.postJson(url, payload, (r) => { });
        }
        getTaggingState(callback) {
            const url = this.indoorServerUrl + "/assettracking/dataset/tagging/state";
            HttpUtils_3.HttpUtils.getJson(url, (json) => {
                let state = RelutionMapModelLoader_5.RelutionMapModelLoader.loadModel(json, TaggingStateModel_1.TaggingStateModel, false);
                callback(state);
            });
        }
    }
    exports.SimulationService = SimulationService;
});
define("test/tests/indoor/controller/monitoring/MonitoringController", ["require", "exports", "test/tests/indoor/IndoorApplicationController"], function (require, exports, IndoorApplicationController_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MonitoringController = void 0;
    class MonitoringController extends IndoorApplicationController_1.ApplicationController {
        // Construction
        constructor(config, service) {
            super(config, service);
        }
        // Subcontrollers
        // @Override
        getSubcontrollers() {
            return [];
        }
        // Identifier
        // @Override
        getId() {
            return "#monitoring-tabbar-item";
        }
        // Configuration
        // @Override
        getConfig() {
            let config = new IndoorApplicationController_1.Controller.Config();
            config.deviceReloadingIntervalInMs = 1000;
            config.geofenceUpdateIntervalInMs = 1000;
            return config;
        }
        // 1. Event handling: View initialization
        // @Override
        init(indoorMap, initializationCallback) {
            this.indoorMap = indoorMap;
            this.startSynchronizingModels();
            initializationCallback();
        }
        // 2. Event handling: Model synchronization
        // @Override
        startSynchronizingModels() {
            // Nothing to do
        }
        // 3. Event handling: Config synchronization
        // @Override
        updateServiceConfig() {
            // Nothing to do
        }
    }
    exports.MonitoringController = MonitoringController;
});
define("test/tests/indoor/IndoorApplicationView", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.View = exports.IndoorApplicationView = void 0;
    class IndoorApplicationView {
    }
    exports.IndoorApplicationView = IndoorApplicationView;
    class View {
        constructor(config) {
            this.config = config;
        }
    }
    exports.View = View;
});
define("test/tests/indoor/controller/simulation/SimulationView", ["require", "exports", "test/tests/indoor/IndoorApplicationView", "test/tests/indoor/service/simulation/SimulationServiceConfig"], function (require, exports, IndoorApplicationView_1, SimulationServiceConfig_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimulationView = void 0;
    class SimulationView extends IndoorApplicationView_1.View {
        // Construction
        constructor(config) {
            super(config);
            this.simulationFormArea = `
        <form id="simulation-mode-form" action="" class="form-inline" method="get" style="width: 100%">
            <div id="simulation-mode-form-group" class="form-group" style="width: 100%">
                <div class="col">
                    <fieldset class="scheduler-border">
                        <legend class="scheduler-border">
                            <small>Dataset</small>
                        </legend>
                        <div class="control-group" style="width: 100%">
                            <div id="dataset-area" class="row align-items-center" style="padding:3px">
                                <div class="col-sm-auto">
                                    Name:
                                </div>
                                <div class="col">
                                    <input id="asset-tracking-dataset" class="form-control form-control-sm" type="text" autocomplete="off"
                                    placeholder="Dataset name" style="width: 100%">
                                </div>
                            </div>
                        </div>
                    </fieldset>
                </div>
                <div class="col-sm-auto">
                    <fieldset class="scheduler-border">
                        <legend class="scheduler-border">
                            <small>Positioning</small>
                        </legend>
                        <div class="control-group align-items-center" style="margin-top: 4.5px; margin-bottom: 4.5px">
                            <button id="sim-positioning-button" class="btn btn-sm btn-light" data-toggle="button" type="button">
                                Dataset sim.
                            </button>
                        </div>
                    </fieldset>
                </div>
                <div class="col-sm-auto">
                    <fieldset class="scheduler-border">
                        <legend class="scheduler-border">
                            <small>Asset tracking</small>
                        </legend>
                        <div class="control-group align-items-center" style="margin-top: 4.5px; margin-bottom: 4.5px">
                            <button id="sim-tracking-integration-asset-mouse-button" class="btn btn-sm btn-light" data-toggle="button" type="button">
                                Mouse sim.
                            </button>
                            <button id="sim-tracking-integration-asset-dataset-button" class="btn btn-sm btn-light" data-toggle="button" type="button">
                                Dataset sim.
                            </button>
                        </div>
                    </fieldset>
                </div>
                <div class="col-sm-auto">
                    <fieldset class="scheduler-border">
                        <legend class="scheduler-border">
                            <small>Beacon tracking</small>
                        </legend>
                        <div class="control-group align-items-center" style="margin-top: 4.5px; margin-bottom: 4.5px">
                            <button id="sim-tracking-integration-beacon-dataset-button" class="btn btn-sm btn-light" data-toggle="button" value="beacon-d-validation" type="button">
                                Dataset sim.
                            </button>
                        </div>
                    </fieldset>
                </div>
            </div>
        </form>
    `;
            this.leftSideBarArea = `
        <div id="custom-left-side-bar-items">
        </div>
        <div id="general-left-side-bar-items">
            <li class="list-group-item asset-mouse-sim asset-dataset-sim bg-light">
                Render probability density map:
                <br>
                <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                    <input type="checkbox" class="c-switch-input" name="renderProbabilityDensity" id="renderProbabilityDensity">
                    <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </li>
            <li class="list-group-item asset-mouse-sim asset-dataset-sim bg-light">
                Render radio map:
                <br>
                <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                    <input type="checkbox" class="c-switch-input" name="renderRadioMap" id="renderRadioMap">
                    <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </li>
            <li class="list-group-item asset-mouse-sim asset-dataset-sim bg-light">
                Calibrate with validation dataset:
                <br>
                <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                    <input type="checkbox" class="c-switch-input" name="calibrateWithValidationData" id="calibrateWithValidationData" checked>
                    <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </li>
        </div>
        <li class="list-group-item bg-light">
            <!-- Placeholder -->
        </li>
    `;
            this.centerTopArea = `
        <div class="col-sm-auto">
            <div id="player" class="btn-group">
            </div>
        </div>
        <div id="player-progress-area" class="col">
        </div>
    `;
        }
        // Initialization
        init() {
            this.initActionBar();
            this.initSimulationForm();
            this.initLeftSideBar();
            this.initCenterTopArea();
        }
        initActionBar() {
            $("#floor-taggingplan-action-area").removeClass("d-none");
        }
        // Initialization: Simulation form
        initSimulationForm() {
            this.insertSimulationForm();
            this.fillSimulationForm();
        }
        insertSimulationForm() {
            $("#top-area").html(this.simulationFormArea);
        }
        fillSimulationForm() {
            let applicationConfig = this.config.service.application;
            let assetTrackingSimulationConfig = applicationConfig.simulation;
            const datasetName = assetTrackingSimulationConfig.dataset;
            $("#asset-tracking-dataset").attr("value", datasetName);
            this.toggleActiveSimulationModeButton();
        }
        toggleActiveSimulationModeButton() {
            let applicationConfig = this.config.service.application;
            if (applicationConfig.simulation.type == SimulationServiceConfig_4.AssetTrackingSimulationConfig.TYPE_NAME) {
                let assetTrackingSimulationConfig = applicationConfig.simulation;
                if (assetTrackingSimulationConfig.mode.type === SimulationServiceConfig_4.AssetTrackingMouseSimulationModeConfig.TYPE_NAME) {
                    $("#sim-tracking-integration-asset-mouse-button").addClass("active");
                }
                else if (assetTrackingSimulationConfig.mode.type === SimulationServiceConfig_4.AssetTrackingDatasetSimulationModeConfig.TYPE_NAME) {
                    $("#sim-tracking-integration-asset-dataset-button").addClass("active");
                }
            }
            else if (applicationConfig.simulation.type == SimulationServiceConfig_4.BeaconTrackingSimulationConfig.TYPE_NAME) {
                $("#sim-tracking-integration-beacon-dataset-button").addClass("active");
            }
            else if (applicationConfig.simulation.type == SimulationServiceConfig_4.PositioningSimulationConfig.TYPE_NAME) {
                $("#sim-positioning-button").addClass("active");
            }
        }
        // Initialization: Left side bar
        initLeftSideBar() {
            this.insertLeftSideBar();
            this.fillLeftSideBar();
        }
        insertLeftSideBar() {
            $("#left-area").html(this.leftSideBarArea);
        }
        fillLeftSideBar() {
            // 1. Update own config properties
            let applicationConfig = this.config.service.application;
            let assetTrackingConfig = applicationConfig.simulation;
            $("#renderProbabilityDensity").prop("checked", assetTrackingConfig.renderProbabilityDensityMap);
            $("#renderRadioMap").prop("checked", assetTrackingConfig.renderRadioMap);
            $("#calibrateWithValidationData").prop("checked", assetTrackingConfig.useValidationDatasetForCalibration);
        }
        // Initialization: Center area
        initCenterTopArea() {
            $("#center-top-area").html(this.centerTopArea);
        }
    }
    exports.SimulationView = SimulationView;
});
define("test/tests/indoor/controller/simulation/tracking/TrackingSimulationView", ["require", "exports", "test/tests/indoor/IndoorApplicationView"], function (require, exports, IndoorApplicationView_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TrackingSimulationView = void 0;
    class TrackingSimulationView extends IndoorApplicationView_2.View {
        // Construction
        constructor(config) {
            super(config);
            this.datasetAreaExtensions = `
        <div class="col-sm-auto">
            Device:
        </div>
        <div class="col-sm-auto">
            <input id="deviceSerial" class="form-control form-control-sm" type="text" autocomplete="off" placeholder="Serial number">
        </div>
    `;
            this.customLeftSideBarItems = `
        <li class="list-group-item asset-dataset-sim beacon-dataset-sim bg-light">
            Simulate with max. speed:
            <br>
            <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm">
                <input type="checkbox" class="c-switch-input" checked name="simulateWithMaxSpeed" id="simulateWithMaxSpeed">
                <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
            </label>
        </li>
        <li class="list-group-item asset-dataset-sim beacon-dataset-sim bg-light">
            Simulation speed:
            <span id="timeExpansionFactorSliderValue">1</span>x
            <br>
            <input id="timeExpansionFactorSlider" data-slider-id='ex1Slider' type="text" data-slider-min="0.1" data-slider-max="1000"
            data-slider-step="0.1" data-slider-value="1" style="width: 100%" />
        </li>
    `;
            this.playerButtons = `
        <button id="sim-record" class="btn btn-light d-none" href="#">
            <i id="sim-record-icon" class="fas fa-circle"></i>
        </button>
        <button id="sim-calibrate" class="btn btn-light d-none" href="#">
            <img id="sim-calibrate-icon" src="../../img/calibration.svg" width="20" />
        </button>
        <button id="sim-play-pause" class="btn btn-light" href="#">
            <i id="sim-play-pause-icon" class="fas fa-play"></i>
        </button>
        <button id="sim-stop" class="btn btn-light" href="#">
            <i id="sim-stop-icon" class="fas fa-stop"></i>
        </button>
        <button id="sim-replay" class="btn btn-light" href="#">
            <img id="sim-replay-icon" src="../../img/refresh.svg" width="20" />
        </button>
    `;
            this.playerProgressArea = `
        <div id="progress-line" class="progress" style="height: 20px;">
            <div id="sim-progress" class="progress-bar bg-secondary" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                <div id="sim-progress-value" style="line-height: 100%;" class="unselectable justify-content-center d-flex position-absolute w-100"></div>
            </div>
        </div>
        <input id="progress-slider" class="d-none" data-slider-id='progress-slider' type="text" data-slider-min="0" data-slider-max="100"
            data-slider-step="0.1" data-slider-value="0" style="width: 100%"/>
    `;
        }
        // @Override
        init() {
            this.initSimulationForm();
            this.initLeftSideBar();
            this.initPlayerItems();
        }
        initSimulationForm() {
            this.insertSimulationForm();
            this.fillSimulationForm();
        }
        insertSimulationForm() {
            let previousHtmlContent = $("#dataset-area").html();
            $("#dataset-area").html(previousHtmlContent + this.datasetAreaExtensions);
        }
        fillSimulationForm() {
            let applicationConfig = this.config.service.application;
            let trackingSimulationConfig = applicationConfig.simulation;
            const deviceSerial = trackingSimulationConfig.deviceSerial;
            $("#deviceSerial").attr("value", deviceSerial);
        }
        initLeftSideBar() {
            this.insertItemsIntoLeftSideBar();
            this.initLeftSideBarItems();
        }
        insertItemsIntoLeftSideBar() {
            let previousHtmlContent = $("#custom-left-side-bar-items").html();
            $("#custom-left-side-bar-items").html(this.customLeftSideBarItems + previousHtmlContent);
        }
        initLeftSideBarItems() {
            let applicationConfig = this.config.service.application;
            let assetTrackingConfig = applicationConfig.simulation;
            document.getElementById("simulateWithMaxSpeed").checked = assetTrackingConfig.simulateWithMaxSpeed;
            this.initTimeExpansionFactorSlider();
        }
        initTimeExpansionFactorSlider() {
            // Time expansion factor slider
            window.timeExpansionFactorSlider = new Slider("#timeExpansionFactorSlider", {
                formatter: function (value) {
                    return "" + value;
                },
                scale: 'logarithmic'
            });
            window.timeExpansionFactorSlider.on("slide", function (sliderValue) {
                $("#timeExpansionFactorSliderValue").text(sliderValue);
            });
            // Initial value
            let applicationConfig = this.config.service.application;
            let assetTrackingConfig = applicationConfig.simulation;
            document.getElementById("timeExpansionFactorSlider").value = "" + assetTrackingConfig.simulationSpeed;
        }
        initPlayerItems() {
            $("#player").html(this.playerButtons);
            $("#player-progress-area").html(this.playerProgressArea);
        }
    }
    exports.TrackingSimulationView = TrackingSimulationView;
});
define("test/tests/indoor/controller/simulation/tracking/TrackingSimulationController", ["require", "exports", "test/tests/indoor/IndoorApplicationController", "test/tests/indoor/controller/simulation/tracking/TrackingSimulationView", "test/tests/indoor/models/simulation/tracking/TrackingSimulationStateModel"], function (require, exports, IndoorApplicationController_2, TrackingSimulationView_1, TrackingSimulationStateModel_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TrackingSimulationController = void 0;
    class TrackingSimulationController extends IndoorApplicationController_2.Controller {
        // Construction
        constructor(applicationConfig, simulatorService, state) {
            super(applicationConfig, simulatorService);
            this.state = state;
            this.trackingState = new TrackingSimulationStateModel_2.TrackingSimulationStateModel();
        }
        // Subcontrollers
        // @Override
        getSubcontrollers() {
            return [];
        }
        // 1. Event handling: View initialization
        // @Override
        init(indoorMap, initializationCallback) {
            this.indoorMap = indoorMap;
            this.view = new TrackingSimulationView_1.TrackingSimulationView(this.applicationConfig);
            this.view.init();
            this.registerPlayerButtonEvents();
            this.startModelSynchronization();
        }
        registerPlayerButtonEvents() {
            this.registerCalibrateButton();
            this.registerPlayButton();
            this.registerStopButton();
            this.registerReplayButton();
            this.syncPlayerBarWithSimulationState();
        }
        registerCalibrateButton() {
            $("#sim-calibrate").on("click", () => {
                const calibrateWithValidationData = $("#calibrateWithValidationData").prop("checked");
                this.service.startCalibration(calibrateWithValidationData);
            });
        }
        registerPlayButton() {
            $("#sim-play-pause").on("click", () => {
                let playResumeElement = $("#sim-play-pause-icon");
                if (playResumeElement.hasClass("fa-play")) {
                    this.service.startTrackingSimulation();
                }
                else {
                    this.service.pauseTrackingSimulation();
                }
            });
        }
        registerStopButton() {
            $("#sim-stop").on("click", () => {
                this.service.stopTrackingSimulation();
            });
        }
        registerReplayButton() {
            $("#sim-replay").on("click", () => {
                this.service.restartTrackingSimulation();
            });
        }
        syncPlayerBarWithSimulationState() {
            setInterval(() => {
                this.service.getTrackingSimulationState((trackingState) => {
                    this.trackingState.update(trackingState);
                    // 1. Play/Pause button
                    if (!this.state.running) {
                        this.toggleToPlayButton();
                    }
                    else {
                        if (trackingState.paused) {
                            this.toggleToPlayButton();
                        }
                        else {
                            this.toggleToPauseButton();
                        }
                    }
                    // 2. Stop button
                    if (this.state.running) {
                        this.enableStopButton();
                    }
                    else {
                        this.disableStopButton();
                    }
                    // 3. Progress bar
                    let progressInPercent = trackingState.progress * 100;
                    this.setSimulationProgressBar(progressInPercent, trackingState.timeInMs);
                });
            }, 100);
        }
        toggleToPlayButton() {
            let playResumeElement = $("#sim-play-pause-icon");
            playResumeElement.addClass("fa-play");
            playResumeElement.removeClass("fa-pause");
        }
        toggleToPauseButton() {
            let playResumeElement = $("#sim-play-pause-icon");
            playResumeElement.addClass("fa-pause");
            playResumeElement.removeClass("fa-play");
        }
        enableStopButton() {
            $("#sim-stop").removeAttr("disabled");
        }
        disableStopButton() {
            $("#sim-stop").prop("disabled", true);
        }
        setSimulationProgressBar(progressInPercent, timeInMs) {
            let simProgressTag = $("#sim-progress");
            let simProgressValueTag = $("#sim-progress-value");
            // Disable progress animation when moving to 0%
            let transitionValue = "all 0.1s ease";
            if (progressInPercent === 0) {
                transitionValue = "none";
            }
            simProgressTag.css("transition", transitionValue);
            // Progress
            simProgressTag.css("width", progressInPercent + "%").attr("aria-valuenow", progressInPercent);
            // Progress value
            if (timeInMs === 0) {
                simProgressValueTag.html("");
            }
            else {
                const date = new Date(timeInMs);
                const timeString = date.toLocaleString();
                simProgressValueTag.html("" + timeString);
            }
            // Progress value color
            let color = "black";
            if (progressInPercent > 50) {
                color = "white";
            }
            simProgressValueTag.css("color", color);
        }
        // 2. Event handling: Model synchronization
        // @Override
        startModelSynchronization() {
            // Nothing to do
        }
        // 3. Event handling: Config synchronization
        // @Override
        updateServiceConfig() {
            let applicationConfig = this.applicationConfig.service.application;
            let assetTrackingConfig = applicationConfig.simulation;
            assetTrackingConfig.simulateWithMaxSpeed = document.getElementById("simulateWithMaxSpeed").checked;
            assetTrackingConfig.simulationSpeed = Number.parseFloat(document.getElementById("timeExpansionFactorSlider").value);
        }
    }
    exports.TrackingSimulationController = TrackingSimulationController;
});
define("test/tests/indoor/controller/simulation/tracking/asset/AssetTrackingMouseSimulationView", ["require", "exports", "test/tests/indoor/IndoorApplicationView"], function (require, exports, IndoorApplicationView_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AssetTrackingMouseSimulationView = void 0;
    class AssetTrackingMouseSimulationView extends IndoorApplicationView_3.View {
        // Construction
        constructor(config) {
            super(config);
            this.customLeftSideBarItems = `
        <li class="list-group-item asset-mouse-sim bg-light">
            Speed measurements:
            <br>
            <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                <input type="checkbox" class="c-switch-input" checked name="simulateWithSpeedMeasurements" id="simulateWithSpeedMeasurements">
                <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
            </label>
        </li>
        <li class="list-group-item asset-mouse-sim bg-light">
            Direction measurements:
            <br>
            <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                <input type="checkbox" class="c-switch-input" name="simulateWithDirectionMeasurements" id="simulateWithDirectionMeasurements">
                <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
            </label>
        </li>
    `;
        }
        // @Override
        init() {
            this.initLeftBar();
        }
        initLeftBar() {
            this.insertItemsIntoLeftSideBar();
            this.initLeftSideBar();
        }
        insertItemsIntoLeftSideBar() {
            let previousHtmlContent = $("#custom-left-side-bar-items").html();
            $("#custom-left-side-bar-items").html(this.customLeftSideBarItems + previousHtmlContent);
        }
        initLeftSideBar() {
            let applicationConfig = this.config.service.application;
            let assetTrackingConfig = applicationConfig.simulation;
            let mouseConfig = assetTrackingConfig.mode;
            $("#simulateWithSpeedMeasurements").prop("checked", mouseConfig.simulateSpeed);
            $("#simulateWithDirectionMeasurements").prop("checked", mouseConfig.simulateDirection);
        }
    }
    exports.AssetTrackingMouseSimulationView = AssetTrackingMouseSimulationView;
});
define("test/tests/indoor/controller/simulation/tracking/asset/AssetTrackingMouseSimulationController", ["require", "exports", "test/tests/indoor/controller/simulation/tracking/TrackingSimulationController", "test/tests/indoor/controller/simulation/tracking/asset/AssetTrackingMouseSimulationView"], function (require, exports, TrackingSimulationController_1, AssetTrackingMouseSimulationView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AssetTrackingMouseSimulationController = void 0;
    class AssetTrackingMouseSimulationController extends TrackingSimulationController_1.TrackingSimulationController {
        // Construction
        constructor(simulatorConfig, simulatorService, state) {
            super(simulatorConfig, simulatorService, state);
        }
        // 1. Event handling: View initialization
        // @Override
        init(indoorMap, initializationCallback) {
            super.init(indoorMap, initializationCallback);
            this.assetTrackingMouseSimulationView = new AssetTrackingMouseSimulationView_1.AssetTrackingMouseSimulationView(this.applicationConfig);
            this.assetTrackingMouseSimulationView.init();
            this.startModelSynchronization();
            initializationCallback();
        }
        // 2. Event handling: Model synchronization
        // @Override
        startModelSynchronization() {
            this.startSendingFakePosition();
        }
        startSendingFakePosition() {
            setInterval(() => {
                let targetPositionInWorldCm = this.indoorMap.getTargetPositionInWorldCm();
                let targetOrientationInRad = this.indoorMap.getTargetOrientationInRad();
                let floorName = this.indoorMap.getNearestFloorName();
                let speedEnabled = $("#simulateWithSpeedMeasurements").prop("checked");
                let directionEnabled = $("#simulateWithDirectionMeasurements").prop("checked");
                let targetStateObject = {
                    position: { x: targetPositionInWorldCm.x, y: targetPositionInWorldCm.y, z: 0 },
                    orientation: targetOrientationInRad,
                    regionId: floorName,
                    speedEnabled: speedEnabled,
                    directionEnabled: directionEnabled,
                    timestampMs: Date.now()
                };
                this.service.sendTargetState(targetStateObject);
            }, 500);
        }
        // 3. Event handling: Config synchronization
        // @Override
        updateServiceConfig() {
            super.updateServiceConfig();
            let applicationConfig = this.applicationConfig.service.application;
            let assetTrackingConfig = applicationConfig.simulation;
            let mouseConfig = assetTrackingConfig.mode;
            mouseConfig.simulateSpeed = $("#simulateWithSpeedMeasurements").prop("checked");
            mouseConfig.simulateDirection = $("#simulateWithDirectionMeasurements").prop("checked");
        }
    }
    exports.AssetTrackingMouseSimulationController = AssetTrackingMouseSimulationController;
});
define("test/tests/indoor/controller/simulation/tracking/asset/AssetTrackingDatasetSimulationView", ["require", "exports", "test/tests/indoor/IndoorApplicationView"], function (require, exports, IndoorApplicationView_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AssetTrackingDatasetSimulationView = void 0;
    class AssetTrackingDatasetSimulationView extends IndoorApplicationView_4.View {
        // Construction
        constructor(config) {
            super(config);
        }
        // @Override
        init() {
            this.initLeftBar();
            this.initTaggingViews();
        }
        initLeftBar() {
            $(".asset-dataset-sim").removeClass("d-none");
        }
        initTaggingViews() {
            this.initRecordButton();
            this.initCalibrateButton();
            this.initProgressSlider();
        }
        initRecordButton() {
            $("#sim-record").removeClass("d-none");
        }
        initCalibrateButton() {
            $("#sim-calibrate").removeClass("d-none");
        }
        initProgressSlider() {
            this.progressSlider = new Slider("#progress-slider", {
                formatter: function (value) {
                    return "" + value;
                }
            });
            // Hide the progress slider by default.
            $("#progress-slider").addClass("d-none");
        }
        // Getters and setters
        getProgressSlider() {
            return this.progressSlider;
        }
    }
    exports.AssetTrackingDatasetSimulationView = AssetTrackingDatasetSimulationView;
});
define("test/tests/indoor/controller/simulation/tracking/asset/AssetTrackingDatasetSimulationController", ["require", "exports", "test/tests/indoor/view/map/IndoorMap", "test/tests/indoor/controller/simulation/tracking/TrackingSimulationController", "test/tests/indoor/controller/simulation/tracking/asset/AssetTrackingDatasetSimulationView", "test/tests/indoor/models/simulation/tracking/asset/TaggingStateModel"], function (require, exports, IndoorMap_2, TrackingSimulationController_2, AssetTrackingDatasetSimulationView_1, TaggingStateModel_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AssetTrackingDatasetSimulationController = void 0;
    class AssetTrackingDatasetSimulationController extends TrackingSimulationController_2.TrackingSimulationController {
        // Construction
        constructor(simulatorConfig, simulatorService, state) {
            super(simulatorConfig, simulatorService, state);
            // State
            this.taggingState = new TaggingStateModel_2.TaggingStateModel();
        }
        // 1. Event handling: View initialization
        // @Override
        init(indoorMap, initializationCallback) {
            super.init(indoorMap, initializationCallback);
            this.assetTrackingSimulationView = new AssetTrackingDatasetSimulationView_1.AssetTrackingDatasetSimulationView(this.applicationConfig);
            this.assetTrackingSimulationView.init();
            this.continuouslyUpdateView();
            this.startModelSynchronization();
            initializationCallback();
        }
        continuouslyUpdateView() {
            this.updateProgressSlider();
            this.updateTaggingButton();
        }
        updateProgressSlider() {
            let sliding = false;
            this.assetTrackingSimulationView.getProgressSlider().on("slideStart", () => {
                sliding = true;
            });
            this.assetTrackingSimulationView.getProgressSlider().on("slideStop", () => {
                let sliderValue = this.assetTrackingSimulationView.getProgressSlider().getValue();
                this.service.pauseTrackingSimulation();
                this.service.setTrackingSimulationProgress(sliderValue / 100);
                setTimeout(() => {
                    sliding = false;
                }, 2000);
            });
            setInterval(() => {
                if (!sliding) {
                    let progressInPercent = this.trackingState.progress * 100;
                    this.assetTrackingSimulationView.getProgressSlider().setValue(progressInPercent, false, false);
                }
            }, 10);
        }
        updateTaggingButton() {
            $("#sim-record").on("click", () => {
                if (this.taggingState.running) {
                    this.service.stopTagging();
                }
                else {
                    this.service.startTagging();
                }
            });
        }
        // 2. Event handling: Model synchronization
        // @Override
        startModelSynchronization() {
            this.startLoadingTaggingState();
            this.startPublishingTaggingData();
        }
        startLoadingTaggingState() {
            setInterval(() => {
                this.service.getTaggingState((taggingState) => {
                    this.taggingState.update(taggingState);
                    if (this.taggingState.running) {
                        $("#sim-record-icon").css("color", "darkred");
                        if (!(this.indoorMap.getType() instanceof IndoorMap_2.IndoorMap.Type.AssetTrackingDatasetTaggingSimulationType)) {
                            this.indoorMap.setType(new IndoorMap_2.IndoorMap.Type.AssetTrackingDatasetTaggingSimulationType());
                        }
                    }
                    else {
                        $("#sim-record-icon").css("color", "black");
                        if (!(this.indoorMap.getType() instanceof IndoorMap_2.IndoorMap.Type.AssetTrackingDatasetValidationSimulationType)) {
                            this.indoorMap.setType(new IndoorMap_2.IndoorMap.Type.AssetTrackingDatasetValidationSimulationType());
                        }
                    }
                    this.updateProgressSliderState();
                });
            }, 16);
        }
        updateProgressSliderState() {
            if (this.taggingState.running) {
                $("#progress-slider").removeClass("d-none");
                $("#progress-line").addClass("d-none");
            }
            else {
                $("#progress-slider").addClass("d-none");
                $("#progress-line").removeClass("d-none");
            }
        }
        startPublishingTaggingData() {
            setInterval(() => {
                if (this.taggingState.running) {
                    let positions = this.indoorMap.pullTaggingData();
                    if (positions.length > 0) {
                        let timestamps = this.indoorMap.pullTimestampData();
                        let floorName = this.indoorMap.getNearestFloorName();
                        let applicationConfig = this.applicationConfig.service.application;
                        let simulation = applicationConfig.simulation;
                        let deviceSerial = simulation.deviceSerial;
                        let payload = {
                            datasetName: floorName,
                            deviceSerial: deviceSerial,
                            positions: positions,
                            timestamps: timestamps
                        };
                        this.service.sendTaggingData(payload);
                    }
                }
            }, 16);
        }
        // 3. Event handling: Config synchronization
        // @Override
        updateServiceConfig() {
            super.updateServiceConfig();
        }
    }
    exports.AssetTrackingDatasetSimulationController = AssetTrackingDatasetSimulationController;
});
define("test/tests/indoor/controller/simulation/tracking/beacon/BeaconTrackingSimulationView", ["require", "exports", "test/tests/indoor/IndoorApplicationView"], function (require, exports, IndoorApplicationView_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BeaconTrackingSimulationView = void 0;
    class BeaconTrackingSimulationView extends IndoorApplicationView_5.View {
        // Construction
        constructor(config) {
            super(config);
        }
        // @Override
        init() {
            this.initLeftBar();
        }
        initLeftBar() {
            $(".beacon-dataset-sim").removeClass("d-none");
        }
    }
    exports.BeaconTrackingSimulationView = BeaconTrackingSimulationView;
});
define("test/tests/indoor/controller/simulation/tracking/beacon/BeaconTrackingSimulationController", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/BeaconMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/AssetMapObject", "test/tests/indoor/controller/simulation/tracking/TrackingSimulationController", "test/tests/indoor/controller/simulation/tracking/beacon/BeaconTrackingSimulationView"], function (require, exports, BeaconMapObject_11, AssetMapObject_9, TrackingSimulationController_3, BeaconTrackingSimulationView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BeaconTrackingSimulationController = void 0;
    class BeaconTrackingSimulationController extends TrackingSimulationController_3.TrackingSimulationController {
        // Construction
        constructor(simulatorConfig, simulatorService, state) {
            super(simulatorConfig, simulatorService, state);
        }
        // 1. Event handling: View initialization
        // @Override
        init(indoorMap, initializationCallback) {
            super.init(indoorMap, initializationCallback);
            this.beaconTrackingSimulationView = new BeaconTrackingSimulationView_1.BeaconTrackingSimulationView(this.applicationConfig);
            this.beaconTrackingSimulationView.init();
            this.indoorMap.getBuilding().toggleRelutionMapObjectTypeVisibility(BeaconMapObject_11.BeaconMapObject, true);
            this.indoorMap.getBuilding().toggleRelutionMapObjectTypeVisibility(AssetMapObject_9.AssetMapObject, false);
            this.startModelSynchronization();
            initializationCallback();
        }
        // 2. Event handling: Model synchronization
        // @Override
        startModelSynchronization() {
            // Nothing to do
        }
        // 3. Event handling: Config synchronization
        // @Override
        updateServiceConfig() {
            super.updateServiceConfig();
        }
    }
    exports.BeaconTrackingSimulationController = BeaconTrackingSimulationController;
});
define("test/tests/indoor/controller/simulation/positioning/PositioningSimulationView", ["require", "exports", "test/tests/indoor/IndoorApplicationView"], function (require, exports, IndoorApplicationView_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PositioningSimulationView = void 0;
    class PositioningSimulationView extends IndoorApplicationView_6.View {
        // Construction
        constructor(config) {
            super(config);
            this.playerButtons = `
        <button id="sim-calibrate" class="btn btn-light" href="#">
            <img id="sim-calibrate-icon" src="../../img/calibration.svg" width="20" />
        </button>
        <button id="sim-step-backward" class="btn btn-light" href="#">
            <i id="sim-step-backward-icon" class="fas fa-step-backward"></i>
        </button>
        <button id="sim-step-forward" class="btn btn-light" href="#">
            <i id="sim-step-forward-icon" class="fas fa-step-forward"></i>
        </button>
    `;
            this.playerProgressArea = `
        <input id="cursor-slider" class="" data-slider-id='cursor-slider' type="text" data-slider-min="0" data-slider-max="1"
            data-slider-step="1" data-slider-value="0" style="width: 100%"/>
    `;
        }
        // @Override
        init() {
            this.initLeftSideBar();
            this.initPlayerItems();
            this.initCursorSlider();
        }
        initLeftSideBar() {
            // Calibration should always be done using the training data and not using validation data.
            $("#calibrateWithValidationData").prop("checked", false);
        }
        initPlayerItems() {
            $("#player").html(this.playerButtons);
            $("#player-progress-area").html(this.playerProgressArea);
        }
        initCursorSlider() {
            this.cursorSlider = new Slider("#cursor-slider", {
                formatter: function (value) {
                    return "" + value;
                }
            });
        }
        // Getters and setters
        getCursorSlider() {
            return this.cursorSlider;
        }
    }
    exports.PositioningSimulationView = PositioningSimulationView;
});
define("test/tests/indoor/controller/simulation/positioning/PositioningSimulationController", ["require", "exports", "test/tests/indoor/IndoorApplicationController", "test/tests/indoor/controller/simulation/positioning/PositioningSimulationView", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/BeaconMapObject"], function (require, exports, IndoorApplicationController_3, PositioningSimulationView_1, BeaconMapObject_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PositioningSimulationController = void 0;
    class PositioningSimulationController extends IndoorApplicationController_3.Controller {
        // Construction
        constructor(applicationConfig, simulatorService) {
            super(applicationConfig, simulatorService);
            this.sliding = false;
            this.states = new Map();
        }
        // Subcontrollers
        // @Override
        getSubcontrollers() {
            return [];
        }
        // Configuration
        getConfig() {
            return new IndoorApplicationController_3.Controller.Config();
        }
        // @Override
        overrideMapConfig(indoorMapOptions) {
            super.overrideMapConfig(indoorMapOptions);
            indoorMapOptions.world.building.objectTypeVisibilities.set(BeaconMapObject_12.BeaconMapObject, true);
        }
        // 1. Event handling: View initialization
        // @Override
        init(indoorMap, initializationCallback) {
            this.map = indoorMap;
            this.view = new PositioningSimulationView_1.PositioningSimulationView(this.applicationConfig);
            this.view.init();
            this.registerInputEvents();
            this.startSynchronizingModels();
            initializationCallback();
        }
        registerInputEvents() {
            this.registerCalibrateButtonEvents();
            this.registerStepForwardEvents();
            this.registerStepBackwardEvents();
            this.registerCursorSliderEvents();
        }
        registerCalibrateButtonEvents() {
            $("#sim-calibrate").on("click", () => {
                const calibrateWithValidationData = $("#calibrateWithValidationData").prop("checked");
                this.service.startCalibration(calibrateWithValidationData);
            });
        }
        registerStepBackwardEvents() {
            $("#sim-step-backward").on("click", () => {
                let floorName = this.map.getBuilding().getCurrentFloor().getFloorName();
                if (this.states.has(floorName)) {
                    let state = this.states.get(floorName);
                    let newCursor = Math.max(state.cursor - 1, 0);
                    this.service.setPositioningDatasetCursor(floorName, newCursor);
                }
            });
        }
        registerStepForwardEvents() {
            $("#sim-step-forward").on("click", () => {
                let floorName = this.map.getBuilding().getCurrentFloor().getFloorName();
                if (this.states.has(floorName)) {
                    let state = this.states.get(floorName);
                    let newCursor = Math.min(state.cursor + 1, state.size - 1);
                    this.service.setPositioningDatasetCursor(floorName, newCursor);
                }
            });
        }
        registerCursorSliderEvents() {
            this.sliding = false;
            this.view.getCursorSlider().on("slideStart", () => {
                this.sliding = true;
            });
            this.view.getCursorSlider().on("slideStop", () => {
                let floorName = this.map.getBuilding().getCurrentFloor().getFloorName();
                if (this.states.has(floorName)) {
                    let sliderValue = this.view.getCursorSlider().getValue();
                    let newCursor = Math.floor(sliderValue);
                    this.service.setPositioningDatasetCursor(floorName, newCursor);
                }
                setTimeout(() => {
                    this.sliding = false;
                }, 2000);
            });
        }
        // 2. Event handling: Model synchronization
        // @Override
        startSynchronizingModels() {
            this.continuouslyLoadStateModel();
        }
        continuouslyLoadStateModel() {
            setInterval(() => {
                let floorName = this.map.getBuilding().getCurrentFloor().getFloorName();
                this.service.getPositioningSimulationState(floorName, (state) => {
                    this.states.set(floorName, state);
                    this.syncSliderWithState(state);
                });
            }, 100);
        }
        syncSliderWithState(state) {
            if (!this.sliding) {
                this.setCursorSliderAttributeToValue("min", 0);
                this.setCursorSliderAttributeToValue("max", state.size);
                this.view.getCursorSlider().setValue(state.cursor);
                this.registerCursorSliderEvents();
            }
        }
        setCursorSliderAttributeToValue(attributeName, value) {
            if (this.view.getCursorSlider().getAttribute(attributeName) !== value) {
                this.view.getCursorSlider().setAttribute(attributeName, value);
                this.view.getCursorSlider().refresh();
                this.registerCursorSliderEvents();
            }
        }
        // 3. Event handling: Config synchronization
        // @Override
        updateServiceConfig() {
            // Nothing to do
        }
    }
    exports.PositioningSimulationController = PositioningSimulationController;
});
define("test/tests/indoor/controller/simulation/SimulationController", ["require", "exports", "test/tests/indoor/IndoorApplicationController", "test/tests/indoor/IndoorApplication", "src/engine/input/GestureRecognizer", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/BeaconMapObject", "test/tests/indoor/view/map/IndoorMap", "test/tests/indoor/service/simulation/SimulationServiceConfig", "test/tests/indoor/controller/simulation/SimulationView", "test/tests/indoor/models/IndoorStateModel", "test/tests/indoor/controller/simulation/tracking/asset/AssetTrackingMouseSimulationController", "test/tests/indoor/controller/simulation/tracking/asset/AssetTrackingDatasetSimulationController", "test/tests/indoor/controller/simulation/tracking/beacon/BeaconTrackingSimulationController", "test/tests/indoor/controller/simulation/positioning/PositioningSimulationController"], function (require, exports, IndoorApplicationController_4, IndoorApplication_2, GestureRecognizer_11, BeaconMapObject_13, IndoorMap_3, SimulationServiceConfig_5, SimulationView_1, IndoorStateModel_4, AssetTrackingMouseSimulationController_1, AssetTrackingDatasetSimulationController_1, BeaconTrackingSimulationController_1, PositioningSimulationController_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimulationController = void 0;
    class SimulationController extends IndoorApplicationController_4.ApplicationController {
        // Construction
        constructor(config, service) {
            super(config, service);
            // State
            this.state = new IndoorStateModel_4.IndoorStateModel();
            this.initSubcontroller();
        }
        initSubcontroller() {
            let indoorMapType = IndoorApplication_2.IndoorApplication.Config.getIndoorMapType(this.applicationConfig);
            if (indoorMapType instanceof IndoorMap_3.IndoorMap.Type.AssetTrackingDatasetMouseSimulationType) {
                this.subcontroller = new AssetTrackingMouseSimulationController_1.AssetTrackingMouseSimulationController(this.applicationConfig, this.service, this.state);
            }
            else if (indoorMapType instanceof IndoorMap_3.IndoorMap.Type.AssetTrackingDatasetValidationSimulationType) {
                this.subcontroller = new AssetTrackingDatasetSimulationController_1.AssetTrackingDatasetSimulationController(this.applicationConfig, this.service, this.state);
            }
            else if (indoorMapType instanceof IndoorMap_3.IndoorMap.Type.AssetTrackingDatasetBeaconSimulationType) {
                this.subcontroller = new BeaconTrackingSimulationController_1.BeaconTrackingSimulationController(this.applicationConfig, this.service, this.state);
            }
            else if (indoorMapType instanceof IndoorMap_3.IndoorMap.Type.PositioningDatasetSimulationType) {
                this.subcontroller = new PositioningSimulationController_1.PositioningSimulationController(this.applicationConfig, this.service);
            }
            else {
                throw new Error("No simulation controller for simulation type = " + indoorMapType);
            }
        }
        // Subcontrollers
        // @Override
        getSubcontrollers() {
            return [this.subcontroller];
        }
        // Identifier
        // @Override
        getId() {
            return "#simulation-tabbar-item";
        }
        // Event handling: View initialization
        // @Override
        init(indoorMap, initializationCallback) {
            this.indoorMap = indoorMap;
            this.initDomElements();
            this.continuouslyUpdateView();
            this.subcontroller.init(indoorMap, () => {
                this.startSynchronizingModels();
                initializationCallback();
            });
        }
        initDomElements() {
            this.view = new SimulationView_1.SimulationView(this.applicationConfig);
            this.view.init();
        }
        // View synchronization
        continuouslyUpdateView() {
            this.registerSimulationModeFormEvents();
        }
        registerSimulationModeFormEvents() {
            // Submit form
            var that = this;
            $("#sim-tracking-integration-asset-mouse-button").click(function () {
                that.submitSimulationForm($(this).attr("id"));
            });
            $("#sim-tracking-integration-asset-dataset-button").click(function () {
                that.submitSimulationForm($(this).attr("id"));
            });
            $("#sim-tracking-integration-beacon-dataset-button").click(function () {
                that.submitSimulationForm($(this).attr("id"));
            });
            $("#sim-positioning-button").click(function () {
                that.submitSimulationForm($(this).attr("id"));
            });
        }
        submitSimulationForm(mode) {
            let applicationConfig = this.applicationConfig.service.application;
            // Simulation configuration
            if (mode.indexOf("-tracking") >= 0) {
                if (mode.indexOf("-beacon") >= 0) {
                    applicationConfig.simulation.type = SimulationServiceConfig_5.BeaconTrackingSimulationConfig.TYPE_NAME;
                    applicationConfig.simulation = new SimulationServiceConfig_5.BeaconTrackingSimulationConfig();
                }
                else if (mode.indexOf("-asset") >= 0) {
                    applicationConfig.simulation.type = SimulationServiceConfig_5.AssetTrackingSimulationConfig.TYPE_NAME;
                    applicationConfig.simulation = new SimulationServiceConfig_5.AssetTrackingSimulationConfig();
                    let assetTrackingSimulationConfig = applicationConfig.simulation;
                    if (mode.indexOf("-mouse") >= 0) {
                        assetTrackingSimulationConfig.mode.type = SimulationServiceConfig_5.AssetTrackingMouseSimulationModeConfig.TYPE_NAME;
                    }
                    else if (mode.indexOf("-dataset") >= 0) {
                        assetTrackingSimulationConfig.mode.type = SimulationServiceConfig_5.AssetTrackingDatasetSimulationModeConfig.TYPE_NAME;
                    }
                }
                let trackingSimulation = applicationConfig.simulation;
                trackingSimulation.deviceSerial = $("#deviceSerial").val();
            }
            else if (mode.indexOf("-positioning")) {
                applicationConfig.simulation.type = SimulationServiceConfig_5.PositioningSimulationConfig.TYPE_NAME;
            }
            applicationConfig.simulation.dataset = $("#asset-tracking-dataset").val();
            // Add config as hidden input field
            this.addHiddenInputFieldToSimulationModeForm("config", JSON.stringify(this.applicationConfig));
            // Reload page
            $("#simulation-mode-form").submit();
        }
        addHiddenInputFieldToSimulationModeForm(key, value) {
            let inputElement = $("<input></input>");
            inputElement.attr("name", key);
            inputElement.attr("id", key);
            inputElement.attr("value", value);
            inputElement.attr("type", "hidden");
            inputElement.addClass("form-control");
            inputElement.appendTo("#simulation-mode-form-group");
        }
        // Event handling: Model synchronization
        // @Override
        startSynchronizingModels() {
            this.startSyncSimulationModels();
            this.startSyncFloorModels();
        }
        startSyncSimulationModels() {
            this.startSyncState();
        }
        startSyncState() {
            setInterval(() => {
                this.service.getSimulationState((state) => {
                    this.state.update(state);
                    // Loading indicator
                    if (state.blocking) {
                        this.enableLoadingMode(state.blockingText);
                    }
                    else {
                        this.disableLoadingMode();
                    }
                    // Map
                    this.indoorMap.onSimulationStateUpdated(state);
                });
            }, 100);
        }
        enableLoadingMode(loadingText) {
            this.showLoadingIndicator(loadingText);
            this.indoorMap.pause();
        }
        disableLoadingMode() {
            this.hideLoadingIndicator();
            this.indoorMap.resume();
        }
        showLoadingIndicator(loadingText) {
            $("#loading-modal").modal("show");
            $(".modal-backdrop").appendTo("#center");
            $("body").removeClass("modal-open");
            $("body").css("padding-right", "");
            $("#loading-modal-text").html(loadingText);
        }
        hideLoadingIndicator() {
            $("#loading-modal").modal("hide");
        }
        startSyncFloorModels() {
            let floors = this.indoorMap.getBuilding().getFloors();
            for (let i = 0; i < floors.length; i++) {
                let floor = floors[i];
                this.startFloorDataSync(floor);
            }
        }
        startFloorDataSync(floor) {
            let siteName = floor.getFloorName();
            this.startUpdatingDeviceStateModel(siteName);
            this.startUpdatingProbabilityImage(siteName);
            this.startUpdatingDeviceRadioMap(siteName);
            this.startUpdatingGeofenceStates(siteName);
        }
        // Updating state: devices state
        startUpdatingDeviceStateModel(siteName) {
            let intervalDurationMs = 50;
            setInterval(() => {
                if (this.state.running) {
                    if (this.indoorMap.getBuilding().getCurrentFloor().getFloorName() === siteName) {
                        this.loadIndoorStateModel(siteName);
                    }
                }
            }, intervalDurationMs);
        }
        loadIndoorStateModel(siteName) {
            this.service.loadDeviceStates(siteName, (deviceStateModels) => {
                let floor = this.indoorMap.getBuilding().getCurrentFloor();
                if (floor.getFloorName() === siteName) {
                    this.indoorMap.loadIndoorStateModels(floor, deviceStateModels);
                    // Automatic floor change
                    // this.changeFloorIfNecessary(floor, deviceStateModels);
                }
            });
        }
        changeFloorIfNecessary(currentFloor, deviceStateModels) {
            if (deviceStateModels.length == 1) {
                const trackingOutput = deviceStateModels[0].state.trackingOutput;
                if (trackingOutput !== null) {
                    const estimatedRegion = trackingOutput.regionEstimate;
                    if (estimatedRegion !== null && currentFloor.getFloorName() !== estimatedRegion) {
                        const building = this.indoorMap.getBuilding();
                        building.animateToFloor(building.getFloorWithName(estimatedRegion));
                    }
                }
            }
        }
        startUpdatingProbabilityImage(siteName) {
            let intervalDurationMs = 1000;
            setInterval(() => {
                if (this.state.running) {
                    if (this.indoorMap.getBuilding().getCurrentFloor().getFloorName() === siteName) {
                        if ($("#renderProbabilityDensity").prop("checked")) {
                            this.service.loadDeviceProbabilityImage(siteName, (image) => {
                                let floor = this.indoorMap.getBuilding().getCurrentFloor();
                                this.indoorMap.loadProbabilityImage(floor, image);
                            });
                        }
                    }
                }
            }, intervalDurationMs);
        }
        startUpdatingDeviceRadioMap(siteName) {
            let intervalDurationMs = 1000;
            setInterval(() => {
                let floor = this.indoorMap.getBuilding().getCurrentFloor();
                if (floor.getFloorName() === siteName) {
                    if ($("#renderRadioMap").prop("checked")) {
                        let mouseX = GestureRecognizer_11.GestureRecognizer.getMousePositionX();
                        let mouseY = GestureRecognizer_11.GestureRecognizer.getMousePositionY();
                        let hoveringObject = floor.getCollidingObject(mouseX, mouseY);
                        if (hoveringObject !== null && hoveringObject instanceof BeaconMapObject_13.BeaconMapObject) {
                            let beacon = hoveringObject;
                            this.service.loadDeviceRadioMapImage(siteName, beacon.getModel().uuid, (image) => {
                                this.indoorMap.loadRadioMap(floor, image);
                            });
                        }
                        else {
                            this.indoorMap.unloadRadioMap(floor);
                        }
                    }
                }
            }, intervalDurationMs);
        }
        // Updating state: geofence state
        startUpdatingGeofenceStates(siteName) {
            let intervalDurationMs = this.subcontroller.getConfig().geofenceUpdateIntervalInMs;
            setInterval(() => {
                if (this.state.running) {
                    if (this.indoorMap.getBuilding().getCurrentFloor().getFloorName() === siteName) {
                        this.loadGeofenceStates(siteName);
                    }
                }
            }, intervalDurationMs);
        }
        loadGeofenceStates(siteName) {
            this.service.loadGeofenceStates(siteName, (geofenceStateModels) => {
                let floor = this.indoorMap.getBuilding().getCurrentFloor();
                this.indoorMap.loadGeofenceStateModels(floor, geofenceStateModels);
            });
        }
        // Event handling: Config synchronization
        // @Override
        updateServiceConfig() {
            // 1. Update own config properties
            let applicationConfig = this.applicationConfig.service.application;
            let assetTrackingConfig = applicationConfig.simulation;
            assetTrackingConfig.renderProbabilityDensityMap = $("#renderProbabilityDensity").prop("checked");
            assetTrackingConfig.renderRadioMap = $("#renderRadioMap").prop("checked");
            assetTrackingConfig.useValidationDatasetForCalibration = $("#calibrateWithValidationData").prop("checked");
            // 2. Update subcontroller config properties
            this.subcontroller.updateServiceConfig();
        }
    }
    exports.SimulationController = SimulationController;
});
define("test/tests/indoor/IndoorApplication", ["require", "exports", "test/tests/indoor/IndoorApplicationController", "test/tests/indoor/service/IndoorApplicationService", "test/utils/HttpUtils", "test/tests/indoor/view/map/IndoorMap", "test/tests/indoor/service/monitoring/MonitoringServiceConfig", "test/tests/indoor/service/monitoring/MonitoringService", "test/tests/indoor/service/simulation/SimulationService", "test/tests/indoor/service/simulation/SimulationServiceConfig", "test/tests/indoor/controller/monitoring/MonitoringController", "test/tests/indoor/controller/simulation/SimulationController"], function (require, exports, IndoorApplicationController_5, IndoorApplicationService_3, HttpUtils_4, IndoorMap_4, MonitoringServiceConfig_1, MonitoringService_1, SimulationService_1, SimulationServiceConfig_6, MonitoringController_1, SimulationController_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndoorApplication = void 0;
    class IndoorApplication {
        constructor() {
            try {
                this.config = this.initConfig();
                this.service = this.initService();
                this.controller = this.initController();
            }
            catch (e) {
                console.log("Failed to initialize application. " + e);
            }
        }
        initConfig() {
            let configString = HttpUtils_4.HttpUtils.getGetParameter("config");
            if (configString === null) {
                return new IndoorApplication.Config();
            }
            else {
                return JSON.parse(configString);
            }
        }
        initService() {
            if (this.config.service.application.type === MonitoringServiceConfig_1.MonitoringServiceConfig.TYPE_NAME) {
                return new MonitoringService_1.MonitoringService();
            }
            else {
                return new SimulationService_1.SimulationService();
            }
        }
        initController() {
            let subcontroller = null;
            if (this.config.service.application.type === MonitoringServiceConfig_1.MonitoringServiceConfig.TYPE_NAME) {
                subcontroller = new MonitoringController_1.MonitoringController(this.config, this.service);
            }
            else if (this.config.service.application.type === SimulationServiceConfig_6.SimulationServiceConfig.TYPE_NAME) {
                subcontroller = new SimulationController_1.SimulationController(this.config, this.service);
            }
            else {
                throw new Error("No controller exists for simulation type: " + this.config.service.application.type);
            }
            let controller = new IndoorApplicationController_5.IndoorApplicationController(this.config, subcontroller, this.service);
            return controller;
        }
    }
    exports.IndoorApplication = IndoorApplication;
    (function (IndoorApplication) {
        class Config {
            constructor() {
                this.service = new IndoorApplicationService_3.IndoorApplicationService.Config();
            }
            // Convenience methods
            static getIndoorMapType(config) {
                if (config.service.application.type == MonitoringServiceConfig_1.MonitoringServiceConfig.TYPE_NAME) {
                    return new IndoorMap_4.IndoorMap.Type.AssetTrackingRealTimeMonitoringType();
                }
                else {
                    let simulationApplication = config.service.application;
                    let simConfig = simulationApplication.simulation;
                    if (simulationApplication.simulation.type === SimulationServiceConfig_6.PositioningSimulationConfig.TYPE_NAME) {
                        return new IndoorMap_4.IndoorMap.Type.PositioningDatasetSimulationType();
                    }
                    else if (simulationApplication.simulation.type === SimulationServiceConfig_6.ObjectTrackingSimulationConfig.TYPE_NAME) {
                        return new IndoorMap_4.IndoorMap.Type.ObjectTrackingDatasetSimulationType();
                    }
                    else if (simulationApplication.simulation.type === SimulationServiceConfig_6.AssetTrackingSimulationConfig.TYPE_NAME) {
                        if (simConfig.mode.type === SimulationServiceConfig_6.AssetTrackingMouseSimulationModeConfig.TYPE_NAME) {
                            return new IndoorMap_4.IndoorMap.Type.AssetTrackingDatasetMouseSimulationType();
                        }
                        else if (simConfig.mode.type === SimulationServiceConfig_6.AssetTrackingDatasetSimulationModeConfig.TYPE_NAME) {
                            return new IndoorMap_4.IndoorMap.Type.AssetTrackingDatasetValidationSimulationType();
                        }
                    }
                    else if (simulationApplication.simulation.type === SimulationServiceConfig_6.AssetTrackingSimulationConfig.TYPE_NAME) {
                        return new IndoorMap_4.IndoorMap.Type.AssetTrackingDatasetBeaconSimulationType();
                    }
                }
                throw new Error("Illegal simulator service config");
            }
        }
        IndoorApplication.Config = Config;
    })(IndoorApplication = exports.IndoorApplication || (exports.IndoorApplication = {}));
});
define("test/tests/indoor/testIndoorMap", ["require", "exports", "test/tests/indoor/IndoorApplication"], function (require, exports, IndoorApplication_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testIndoorFruityMap() {
        new IndoorApplication_3.IndoorApplication();
    }
    exports.default = testIndoorFruityMap;
});
define("test/tests/mesh/testSimulatorMap", ["require", "exports", "src/app/relution/model/floor/FloorModelLoader", "src/app/relution/locale/LocalizationEn", "src/app/simulator/SimulatorMap", "src/map/utils/Logger", "test/utils/HttpUtils", "src/app/relution/model/RelutionMapModelLoader", "src/app/relution/model/device/DeviceModel", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceMapObject"], function (require, exports, FloorModelLoader_5, LocalizationEn_7, SimulatorMap_2, Logger_12, HttpUtils_5, RelutionMapModelLoader_6, DeviceModel_12, DeviceMapObject_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testFruityMeshSimulatorMap() {
        let serverUrl = "/simulator";
        let options = new SimulatorMap_2.SimulatorMap.Options();
        options.parentHtmlElement = document.body;
        options.renderer.renderTargetSize.x = window.innerWidth - 30;
        options.renderer.renderTargetSize.y = window.innerHeight - 30;
        options.world.building.objectTypeVisibilities.set(DeviceMapObject_11.DeviceMapObject, true);
        options.localization = new LocalizationEn_7.LocalizationEn();
        options.pathToImages = "../../../img/png/";
        let map = new SimulatorMap_2.SimulatorMap(options);
        loadFloor(map, serverUrl + "/site", serverUrl + "/floorplan", serverUrl + "/wallplan", (floor) => {
            loadSimulatorMap(map, floor, (fruityMap) => {
                runTest(serverUrl, fruityMap);
            });
        });
    }
    exports.default = testFruityMeshSimulatorMap;
    function loadFloor(map, floorModelUrl, floorplanUrl, wallplanUrl, callback) {
        HttpUtils_5.HttpUtils.getJson(floorModelUrl, function (floorObject) {
            let floorModelOptions = {
                jsonObject: floorObject,
                pathToFloorplan: floorplanUrl,
                wallplanUrl: wallplanUrl,
                isPortalMode: false,
            };
            let floorModel = FloorModelLoader_5.FloorModelLoader.loadFloor(floorModelOptions);
            let floor = map.createFloor("floor1", floorModel);
            floor.load(() => {
                callback(floor);
            });
        });
    }
    function loadSimulatorMap(fruityMap, floor, callback) {
        fruityMap.load(floor, function () {
            window.fruityMap = fruityMap;
            window.addEventListener("beforeunload", function (e) {
                fruityMap.destroy();
            });
            window.addEventListener("resize", () => {
                let newWidth = window.innerWidth - 30;
                let newHeight = window.innerHeight - 30;
                fruityMap.setSize(newWidth, newHeight);
            });
            callback(fruityMap);
        });
    }
    function runTest(serverUrl, fruityMap) {
        // Initialization
        fruityMap.toggleLayerVisibility("connections", false);
        // Updating
        let intervalDurationMs = 1000;
        startUpdatingDeviceModels(fruityMap, serverUrl, intervalDurationMs);
    }
    function startUpdatingDeviceModels(fruityMap, serverUrl, intervalDurationMs) {
        let lastDevicesObject = "";
        setInterval(function () {
            HttpUtils_5.HttpUtils.getJson(serverUrl + "/devices", function (resultObject) {
                if (resultObject["status"] === "success") {
                    let devicesObject = resultObject.result;
                    let stringifiedDevicesObject = JSON.stringify(devicesObject);
                    if (stringifiedDevicesObject !== lastDevicesObject) {
                        lastDevicesObject = stringifiedDevicesObject;
                        let deviceModels = RelutionMapModelLoader_6.RelutionMapModelLoader.loadModels(devicesObject, DeviceModel_12.DeviceModel, false);
                        fruityMap.getBuilding().getCurrentFloor().updateDevices(deviceModels);
                    }
                }
                else {
                    Logger_12.Logger.logDebug("Updating device models not possible.");
                }
            });
        }, intervalDurationMs);
    }
});
define("test/tests/relution/testPortalDefault", ["require", "exports", "src/app/portal/PortalMap", "src/map/utils/Logger", "test/utils/HttpUtils", "src/app/relution/model/device/DeviceModel", "src/app/relution/model/floor/FloorModelLoader", "src/app/relution/model/RelutionMapModelLoader", "src/app/relution/RelutionMap", "src/app/relution/model/usercount/UserCountHeatmapModel", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceMapObject"], function (require, exports, PortalMap_4, Logger_13, HttpUtils_6, DeviceModel_13, FloorModelLoader_6, RelutionMapModelLoader_7, RelutionMap_8, UserCountHeatmapModel_3, DeviceMapObject_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TestObserver = void 0;
    function testPortalFruityMapDefault() {
        let mapName = "mway";
        let testCaseName = "default";
        let testDataPath = "../../maps/" + mapName + "/";
        let testCasePath = testDataPath + "data/" + testCaseName + "/";
        let floorplanImageUrl = testDataPath + "img/floorplan.png";
        let wallplanImageUrl = testDataPath + "img/wallplan.png";
        let options = initMapOptions();
        let map = new PortalMap_4.PortalMap(options);
        loadFloor(map, testDataPath + "floor.json", floorplanImageUrl, wallplanImageUrl, (floor) => {
            loadRelutionMap(map, floor, testCasePath, (fruityMap) => {
                loadDevices(fruityMap, testCasePath, (deviceModels) => {
                    runTest(fruityMap, deviceModels, testCasePath);
                });
            });
        });
    }
    exports.default = testPortalFruityMapDefault;
    function initMapOptions() {
        let options = new RelutionMap_8.RelutionMap.Options();
        options.parentHtmlElement = document.body;
        options.pathToImages = "../../../img/png/";
        options.renderer.renderTargetSize.x = window.innerWidth - 30;
        options.renderer.renderTargetSize.y = window.innerHeight - 30;
        options.world.building.objectTypeVisibilities.set(DeviceMapObject_12.DeviceMapObject, true);
        options.world.building.layerVisibilities.set("ranges", true);
        options.world.building.layerVisibilities.set("connections", true);
        options.world.building.layerVisibilities.set("userCountHeatmap", true);
        return options;
    }
    function loadFloor(map, floorModelUrl, floorplanUrl, wallplanUrl, callback) {
        HttpUtils_6.HttpUtils.getJson(floorModelUrl, function (floorObject) {
            let floorModelOptions = {
                jsonObject: floorObject,
                pathToFloorplan: floorplanUrl,
                wallplanUrl: wallplanUrl,
                isPortalMode: false,
            };
            let floorModel = FloorModelLoader_6.FloorModelLoader.loadFloor(floorModelOptions);
            let floor = map.createFloor("floor1", floorModel);
            floor.load(() => {
                callback(floor);
            });
        });
    }
    function loadRelutionMap(map, floor, testCasePath, callback) {
        map.load(floor, function () {
            window.fruityMap = map;
            window.addEventListener("beforeunload", function (e) {
                map.destroy();
            });
            window.addEventListener("resize", () => {
                let newWidth = window.innerWidth - 30;
                let newHeight = window.innerHeight - 30;
                map.setSize(newWidth, newHeight);
            });
            map.addObserver(new TestObserver());
            map.setDeviceEditModeEnabled(false);
            callback(map);
        });
    }
    function loadDevices(fruityMap, testCasePath, callback) {
        HttpUtils_6.HttpUtils.getJson(testCasePath + "devices.json", function (devicesObject) {
            let deviceModels = RelutionMapModelLoader_7.RelutionMapModelLoader.loadModels(devicesObject, DeviceModel_13.DeviceModel, false);
            fruityMap.getBuilding().getCurrentFloor().loadDevices(deviceModels);
            callback(deviceModels);
        });
    }
    function runTest(fruityMap, deviceModels, testCasePath) {
        HttpUtils_6.HttpUtils.getJson(testCasePath + "userCountHeatmap.json", function (heatmapSequenceArray) {
            let heatmapData = RelutionMapModelLoader_7.RelutionMapModelLoader.loadModels(heatmapSequenceArray, UserCountHeatmapModel_3.UserCountHeatmapModel, false);
            fruityMap.getBuilding().getCurrentFloor().loadUserCountHeatmapData(heatmapData);
        });
        fruityMap.getBuilding().getCurrentFloor().updateDevices(deviceModels);
        // Moving beacon to map/stock
        fruityMap.getBuilding().getCurrentFloor().moveDeviceWithUuidToStock("30BCBC00-3B31-4C5B-A923-126D2BA68702");
        fruityMap.getBuilding().getCurrentFloor().moveDeviceWithUuidToMap("30BCBC00-3B31-4C5B-A923-126D2BA68702");
        // testAnimation(fruityMap, testCasePath);
    }
    class TestObserver {
        // @Override
        onObjectMovedToMap(beacon) {
            Logger_13.Logger.logDebug("On Beacon moved to map");
        }
        // @Override
        onObjectMovedToStock(beacon) {
            Logger_13.Logger.logDebug("On Beacon moved to stock");
        }
        // @Override
        onObjectSelected(object) {
            Logger_13.Logger.logDebug("On object selected");
        }
        // @Override
        onObjectUnselected(object) {
            Logger_13.Logger.logDebug("On object unselected");
        }
        // @Override
        onObjectDoubleClicked(object) {
            Logger_13.Logger.logDebug("On object double clicked");
        }
        // @Override
        onObjectClicked(object) {
            if (object instanceof DeviceMapObject_12.DeviceMapObject) {
                Logger_13.Logger.logDebug("On device clicked");
            }
        }
        // @Override
        onLayerVisibilityChanged(layerName, visible) {
            let visibleString = "";
            if (visible) {
                visibleString = "visible";
            }
            else {
                visibleString = "invisible";
            }
            Logger_13.Logger.logDebug("Layer " + layerName + " has become " + visibleString);
        }
    }
    exports.TestObserver = TestObserver;
});
define("test/tests/relution/testPortalDeviceRanges", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/AssetMapObject", "test/tests/relution/helper/testPortalMap"], function (require, exports, AssetMapObject_10, testPortalMap_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    testPortalMap_3 = __importStar(testPortalMap_3);
    function testPortalDeviceRanges() {
        let config = new testPortalMap_3.PortalMapTestConfig();
        config.mapName = "mwayhq";
        config.testCaseName = "default";
        config.shouldLoadDevices = true;
        config.mapOptions.world.building.objectTypeVisibilities.set(AssetMapObject_10.AssetMapObject, false);
        config.mapOptions.world.building.layerVisibilities.set("ranges", true);
        (0, testPortalMap_3.default)(config, runTest);
    }
    exports.default = testPortalDeviceRanges;
    function runTest(fruityMap, deviceModels, testCasePath) {
        // Nothing to do
    }
});
define("test/tests/relution/testPortalDeviceScalability", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/AssetMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/BeaconMapObject", "test/tests/relution/helper/testPortalMap"], function (require, exports, AssetMapObject_11, BeaconMapObject_14, testPortalMap_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    testPortalMap_4 = __importStar(testPortalMap_4);
    let numDevices = 0;
    const maxNumDevices = 1000;
    const numTagsToAddPerSec = Math.round(maxNumDevices / 10);
    const updateRateMs = 100.0;
    function testPortalDeviceScalability() {
        let config = new testPortalMap_4.PortalMapTestConfig();
        config.mapName = "mwayhq";
        config.testCaseName = "1000_nodes";
        config.shouldLoadDevices = true;
        config.mapOptions.world.building.objectTypeVisibilities.set(AssetMapObject_11.AssetMapObject, false);
        config.mapOptions.world.building.objectTypeVisibilities.set(BeaconMapObject_14.BeaconMapObject, true);
        (0, testPortalMap_4.default)(config, testDeviceScalability);
    }
    exports.default = testPortalDeviceScalability;
    function testDeviceScalability(fruityMap, deviceModels, testCasePath) {
        fruityMap.getBuilding().getCurrentFloor().updateDevices(deviceModels);
        setInterval(() => {
            const maxDevices = Math.min(deviceModels.length, maxNumDevices);
            if (numDevices < maxDevices) {
                const numDevicesToAdd = Math.min(maxDevices - numDevices, numTagsToAddPerSec * (updateRateMs / 1000.0));
                numDevices += numDevicesToAdd;
            }
            updateText(fruityMap);
        }, updateRateMs);
    }
    function updateText(fruityMap) {
        const fps = Math.floor(1.0 / (fruityMap.getCurrentFrameTimeMs() / 1000));
        fruityMap.setDebugText("FPS: " + fps + "\nDevices: " + Math.round(numDevices));
    }
});
define("test/tests/relution/testPortalDeviceTracking", ["require", "exports", "src/app/relution/model/indoor/PositionEstimateModel", "src/app/relution/model/RelutionMapModelLoader", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/AssetMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/BeaconMapObject", "test/tests/relution/helper/testPortalMap", "test/utils/HttpUtils"], function (require, exports, PositionEstimateModel_2, RelutionMapModelLoader_8, AssetMapObject_12, BeaconMapObject_15, testPortalMap_5, HttpUtils_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    testPortalMap_5 = __importStar(testPortalMap_5);
    function testPortalDeviceTracking() {
        let config = new testPortalMap_5.PortalMapTestConfig();
        config.mapName = "mwayhq";
        config.testCaseName = "default";
        config.shouldLoadDevices = true;
        config.mapOptions.world.building.objectTypeVisibilities.set(AssetMapObject_12.AssetMapObject, true);
        config.mapOptions.world.building.objectTypeVisibilities.set(BeaconMapObject_15.BeaconMapObject, false);
        (0, testPortalMap_5.default)(config, testDeviceTracking);
    }
    exports.default = testPortalDeviceTracking;
    function testDeviceTracking(fruityMap, deviceModels, testCasePath) {
        // Load tracks
        HttpUtils_7.HttpUtils.getJson(testCasePath + "positionEstimates.json", (positionEstimatesJson) => {
            const positionEstimates = RelutionMapModelLoader_8.RelutionMapModelLoader.loadModels(positionEstimatesJson, PositionEstimateModel_2.PositionEstimateModel, false);
            testDeviceTrackingUsingTracksModel(fruityMap, deviceModels, positionEstimates, () => {
                setTimeout(() => {
                    testDeviceTrackingUsingDeviceModel(fruityMap, deviceModels, positionEstimates);
                }, 1000);
            });
        });
    }
    function testDeviceTrackingUsingTracksModel(fruityMap, deviceModels, positionEstimates, callback) {
        fruityMap.getBuilding().getCurrentFloor().loadTracks(positionEstimates);
        const startTimeInSec = positionEstimates[0].startTimeSec;
        const endTimeInSec = positionEstimates[positionEstimates.length - 1].endTimeSec;
        const animationDurationInMs = 5 * 1000;
        fruityMap.setAnimationConfiguration(startTimeInSec, endTimeInSec, animationDurationInMs, (progress, currentTimeInSec) => {
            if (progress == 1.0) {
                fruityMap.getBuilding().getCurrentFloor().loadTracks([]);
                callback();
            }
        });
        fruityMap.startAnimation();
    }
    function testDeviceTrackingUsingDeviceModel(fruityMap, deviceModels, positionEstimates) {
        const startTimeInSec = positionEstimates[0].startTimeSec;
        const endTimeInSec = positionEstimates[positionEstimates.length - 1].endTimeSec;
        const animationDurationInMs = 5 * 1000;
        let latestUpdateSec = 0;
        let updateIntervalSec = 0.5;
        fruityMap.setAnimationConfiguration(startTimeInSec, endTimeInSec, animationDurationInMs, (progress, currentTimeInSec) => {
            if (currentTimeInSec - latestUpdateSec > updateIntervalSec) {
                latestUpdateSec = currentTimeInSec;
                for (const positionEstimateModel of positionEstimates) {
                    const deviceModel = deviceModels.filter(deviceModel => deviceModel.uuid === positionEstimateModel.deviceUuid)[0];
                    const index = getCurrentPositionEstimateIndexOfDevice(deviceModel, positionEstimateModel, currentTimeInSec);
                    deviceModel.positionEstimate.x = positionEstimateModel.x[index];
                    deviceModel.positionEstimate.y = positionEstimateModel.y[index];
                    deviceModel.positionEstimate.accuracy = positionEstimateModel.accuracy[index];
                }
                fruityMap.getBuilding().getCurrentFloor().updateDevices(deviceModels);
            }
        });
        fruityMap.startAnimation();
    }
    function getCurrentPositionEstimateIndexOfDevice(deviceModel, positionEstimateModel, currentTimeInSec) {
        let index = 0;
        for (; index < positionEstimateModel.measurementTimes.length; index++) {
            const measurementTime = positionEstimateModel.measurementTimes[index];
            if (measurementTime > currentTimeInSec) {
                return index - 1;
            }
        }
        return index;
    }
});
define("test/tests/relution/testPortalDeviceTrackingScalability", ["require", "exports", "src/app/relution/model/indoor/PositionEstimateModel", "src/app/relution/model/RelutionMapModelLoader", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/AssetMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/BeaconMapObject", "test/tests/relution/helper/testPortalMap", "test/utils/HttpUtils"], function (require, exports, PositionEstimateModel_3, RelutionMapModelLoader_9, AssetMapObject_13, BeaconMapObject_16, testPortalMap_6, HttpUtils_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    testPortalMap_6 = __importStar(testPortalMap_6);
    let numDevices = 0;
    const maxNumTags = 1000;
    const numDevicesToAddPerSec = Math.round(maxNumTags / 10);
    const simulationSpeedFactor = 200.0;
    const pathLengthSec = 10.0;
    const updateRateMs = 100.0;
    function testPortalDeviceTrackingScalability() {
        let config = new testPortalMap_6.PortalMapTestConfig();
        config.mapName = "mwayhq";
        config.testCaseName = "1000_tags";
        config.shouldLoadDevices = true;
        config.mapOptions.world.building.objectTypeVisibilities.set(AssetMapObject_13.AssetMapObject, true);
        config.mapOptions.world.building.objectTypeVisibilities.set(BeaconMapObject_16.BeaconMapObject, false);
        (0, testPortalMap_6.default)(config, testDeviceTracking);
    }
    exports.default = testPortalDeviceTrackingScalability;
    function testDeviceTracking(fruityMap, deviceModels, testCasePath) {
        HttpUtils_8.HttpUtils.getJson(testCasePath + "positionEstimates.json", (positionEstimatesJson) => {
            const positionEstimates = RelutionMapModelLoader_9.RelutionMapModelLoader.loadModels(positionEstimatesJson, PositionEstimateModel_3.PositionEstimateModel, false);
            scaleNumberOfDevices(fruityMap, deviceModels, positionEstimates);
        });
    }
    function scaleNumberOfDevices(fruityMap, deviceModels, positionEstimates) {
        // 1. Initialize
        fruityMap.getBuilding().getCurrentFloor().updateDevices(deviceModels);
        fruityMap.getBuilding().getCurrentFloor().loadTracks([]);
        // 2. Start animation
        startAssetTrackingAnimation(fruityMap, positionEstimates);
    }
    function startAssetTrackingAnimation(fruityMap, positionEstimates) {
        const startTimeInSec = positionEstimates[0].startTimeSec;
        const endTimeInSec = positionEstimates[positionEstimates.length - 1].endTimeSec;
        const animationDurationInMs = (endTimeInSec - startTimeInSec) * 1000 / simulationSpeedFactor;
        setInterval(() => {
            const maxTags = Math.min(positionEstimates.length, maxNumTags);
            if (numDevices < maxTags) {
                const numTagsToAdd = Math.min(maxTags - numDevices, numDevicesToAddPerSec * (updateRateMs / 1000.0));
                numDevices += numTagsToAdd;
            }
            updateText(fruityMap);
        }, updateRateMs);
        let lastUpdateTimeMs = 0;
        fruityMap.setAnimationConfiguration(startTimeInSec, endTimeInSec, animationDurationInMs, (progress, currentTimeInSec) => {
            if (currentTimeInSec - lastUpdateTimeMs > (updateRateMs / 1000.0)) {
                lastUpdateTimeMs = currentTimeInSec;
                updateMap(fruityMap, positionEstimates, currentTimeInSec);
            }
        });
        fruityMap.startAnimation();
    }
    function updateMap(fruityMap, positionEstimates, currentTimeInSec) {
        if (numDevices == 0) {
            return;
        }
        // 1. Cut number of devices
        positionEstimates = positionEstimates.slice(0, numDevices);
        // 2. Cut position estimate paths
        const fromSec = currentTimeInSec - pathLengthSec;
        const untilSec = currentTimeInSec;
        positionEstimates = getPositionEstimatesFromUntil(positionEstimates, fromSec, untilSec);
        // 3. Load tracks
        if (Math.random() > 0.5) {
            // Test performance of device batch update
            fruityMap.getBuilding().getCurrentFloor().loadTracks(positionEstimates);
        }
        else {
            // Test performance of device specific update
            positionEstimates.forEach(positionEstimate => {
                fruityMap.getBuilding().getCurrentFloor().updateTrack(positionEstimate);
            });
        }
    }
    function getPositionEstimatesFromUntil(tracks, fromSec, untilSec) {
        let startIndex = getStartIndex(tracks, fromSec);
        let stopIndex = getStopIndex(tracks, untilSec);
        return getSlicedPositionEstimates(tracks, startIndex, stopIndex);
    }
    function getStartIndex(tracks, fromSec) {
        for (let i = 0; i < tracks[0].measurementTimes.length; i++) {
            if (tracks[0].measurementTimes[i] >= fromSec) {
                return i;
            }
        }
    }
    function getStopIndex(tracks, untilSec) {
        for (let i = 0; i < tracks[0].measurementTimes.length; i++) {
            if (tracks[0].measurementTimes[i] >= untilSec) {
                return i;
            }
        }
    }
    function getSlicedPositionEstimates(tracks, startIndex, stopIndex) {
        let newTracks = [];
        for (let i = 0; i < tracks.length; i++) {
            let oldTrack = tracks[i];
            let newTrack = new PositionEstimateModel_3.PositionEstimateModel();
            newTrack.x = oldTrack.x.slice(startIndex, stopIndex - 1);
            newTrack.y = oldTrack.y.slice(startIndex, stopIndex - 1);
            newTrack.accuracy = oldTrack.accuracy.slice(startIndex, stopIndex - 1);
            newTrack.measurementTimes = oldTrack.measurementTimes.slice(startIndex, stopIndex - 1);
            newTrack.deviceUuid = oldTrack.deviceUuid;
            newTrack.startTimeSec = newTrack.measurementTimes[0];
            newTrack.endTimeSec = newTrack.measurementTimes[newTrack.measurementTimes.length - 1];
            newTrack.siteUuid = oldTrack.siteUuid;
            newTrack.amount = newTrack.x.length;
            newTracks.push(newTrack);
        }
        return newTracks;
    }
    function updateText(fruityMap) {
        const fps = Math.floor(1.0 / (fruityMap.getCurrentFrameTimeMs() / 1000));
        fruityMap.setDebugText("FPS: " + fps + "\nAssets: " + Math.round(numDevices));
    }
});
define("test/tests/relution/testPortalDeviceTrackingState", ["require", "exports", "test/tests/relution/helper/testPortalMap"], function (require, exports, testPortalMap_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    testPortalMap_7 = __importStar(testPortalMap_7);
    function testPortalRanges() {
        let config = new testPortalMap_7.PortalMapTestConfig();
        config.mapName = "rocheload";
        config.testCaseName = "default";
        config.shouldLoadDevices = true;
        (0, testPortalMap_7.default)(config, runTest);
    }
    exports.default = testPortalRanges;
    function runTest(fruityMap, deviceModels, testCasePath) {
        // Nothing to do
    }
});
define("test/tests/relution/testPortalDeviceUpdate", ["require", "exports", "src/app/relution/model/device/DeviceModel", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/AssetMapObject", "test/tests/relution/helper/testPortalMap"], function (require, exports, DeviceModel_14, AssetMapObject_14, testPortalMap_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    testPortalMap_8 = __importStar(testPortalMap_8);
    function testPortalDeviceUpdate() {
        let config = new testPortalMap_8.PortalMapTestConfig();
        config.mapName = "mwayhq";
        config.testCaseName = "default";
        config.shouldLoadDevices = true;
        config.mapOptions.world.building.objectTypeVisibilities.set(AssetMapObject_14.AssetMapObject, false);
        config.mapOptions.world.building.layerVisibilities.set("ranges", true);
        (0, testPortalMap_8.default)(config, runTest);
    }
    exports.default = testPortalDeviceUpdate;
    function runTest(fruityMap, deviceModels, testCasePath) {
        setInterval(() => {
            randomizeDeviceModels(deviceModels);
            testUpdateDeviceModels(fruityMap, deviceModels);
        }, 10);
    }
    function randomizeDeviceModels(deviceModels) {
        deviceModels.forEach((deviceModel) => {
            if (deviceModel instanceof DeviceModel_14.BleNodeModel) {
                const bleNodeModel = deviceModel;
                for (let i = 0; i < bleNodeModel.connections.length; i++) {
                    // Negative the connection node ID to disable it for testing
                    if (Math.random() < 0.05) {
                        bleNodeModel.connections[i].target = -bleNodeModel.connections[i].target;
                    }
                }
            }
        });
    }
    function testUpdateDeviceModels(fruityMap, deviceModels) {
        if (Math.random() > 0.5) {
            // Test performance of device batch update
            fruityMap.getBuilding().getCurrentFloor().updateDevices(deviceModels);
        }
        else {
            // Test performance of device specific update
            deviceModels.forEach(deviceModel => {
                fruityMap.getBuilding().getCurrentFloor().updateDevice(deviceModel);
            });
        }
    }
});
define("test/tests/relution/testPortalGeofencing", ["require", "exports", "test/utils/HttpUtils", "test/tests/relution/helper/testPortalMap", "src/app/relution/model/RelutionMapModelLoader", "src/app/relution/model/geofence/GeofenceModel", "src/map/utils/Logger", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/GeofenceMapObject", "src/engine/math/Vector2"], function (require, exports, HttpUtils_9, testPortalMap_9, RelutionMapModelLoader_10, GeofenceModel_6, Logger_14, GeofenceMapObject_5, Vector2_50) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    testPortalMap_9 = __importStar(testPortalMap_9);
    function testPortalFruityMapGeofencing() {
        let config = new testPortalMap_9.PortalMapTestConfig();
        config.mapName = "mwayhq";
        config.testCaseName = "default";
        config.shouldLoadDevices = false;
        config.mapOptions.world.building.objectTypeVisibilities.set(GeofenceMapObject_5.GeofenceMapObject, true);
        config.mapOptions.world.building.layerVisibilities.set("geofence", true);
        (0, testPortalMap_9.default)(config, runTest);
    }
    exports.default = testPortalFruityMapGeofencing;
    function runTest(fruityMap, deviceModels, testCasePath) {
        testGeofences(fruityMap, testCasePath);
    }
    function testGeofences(fruityMap, testCasePath) {
        HttpUtils_9.HttpUtils.getJson(testCasePath + "geofences.json", function (jsonArray) {
            let models = testLoadingGeofences(fruityMap, jsonArray);
            testGeofenceEditMode(fruityMap);
            testAddGeofenceToScreenCenter(fruityMap, models);
            testGeofenceLayerVisibility(fruityMap);
            testSelectingGeofences(fruityMap, models);
        });
    }
    function testLoadingGeofences(fruityMap, jsonArray) {
        let geofenceModels = RelutionMapModelLoader_10.RelutionMapModelLoader.loadModels(jsonArray, GeofenceModel_6.GeofenceModel, false);
        fruityMap.getBuilding().getCurrentFloor().loadGeofences(geofenceModels);
        return geofenceModels;
    }
    function testGeofenceEditMode(fruityMap) {
        fruityMap.setGeofenceEditModeEnabled(true);
    }
    function testAddGeofenceToScreenCenter(fruityMap, geofenceModels) {
        window.addEventListener("keydown", (keyboardEvent) => {
            if (keyboardEvent.key === "r") {
                const newModel = new GeofenceModel_6.RectangleGeofenceModel();
                newModel.uuid = getRandomUuid();
                newModel.name = "Rectangle geofence";
                newModel.description = "";
                newModel.shape = "RECTANGLE";
                newModel.timeThreshold = 0;
                newModel.accuracyThreshold = 500;
                newModel.min = new Vector2_50.Vector2();
                newModel.max = new Vector2_50.Vector2();
                addGeofenceToMapCenter(newModel, fruityMap, geofenceModels);
            }
            else if (keyboardEvent.key === "c") {
                const newModel = new GeofenceModel_6.CircleGeofenceModel();
                newModel.uuid = getRandomUuid();
                newModel.name = "Circle geofence";
                newModel.description = "";
                newModel.shape = "CIRCLE";
                newModel.timeThreshold = 0;
                newModel.accuracyThreshold = 500;
                newModel.center = new Vector2_50.Vector2(0.5, 0.5);
                newModel.radius = 0.05;
                addGeofenceToMapCenter(newModel, fruityMap, geofenceModels);
            }
            else if (keyboardEvent.key === "p") {
                const newModel = new GeofenceModel_6.PolygonGeofenceModel();
                newModel.uuid = getRandomUuid();
                newModel.name = "Polygon geofence";
                newModel.description = "";
                newModel.shape = "POLYGON";
                newModel.timeThreshold = 0;
                newModel.accuracyThreshold = 500;
                newModel.points = new Array();
                newModel.points.push(new Vector2_50.Vector2(0.4, 0.4));
                newModel.points.push(new Vector2_50.Vector2(0.5, 0.4));
                newModel.points.push(new Vector2_50.Vector2(0.6, 0.4));
                newModel.points.push(new Vector2_50.Vector2(0.6, 0.5));
                newModel.points.push(new Vector2_50.Vector2(0.6, 0.6));
                newModel.points.push(new Vector2_50.Vector2(0.5, 0.6));
                newModel.points.push(new Vector2_50.Vector2(0.4, 0.6));
                newModel.points.push(new Vector2_50.Vector2(0.4, 0.5));
                addGeofenceToMapCenter(newModel, fruityMap, geofenceModels);
            }
        });
    }
    function addGeofenceToMapCenter(model, fruityMap, geofenceModels) {
        geofenceModels.push(model);
        fruityMap.getBuilding().getCurrentFloor().updateGeofences(geofenceModels);
        let geofence = fruityMap.getBuilding().getCurrentFloor().getGeofenceWithUuid(model.uuid);
        geofence.translateAndScaleToCameraCenter();
    }
    function getRandomUuid() {
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000)
                .toString(16)
                .substring(1);
        }
        return s4() + s4() + "-" + s4() + "-" + s4() + "-" + s4() + "-" + s4() + s4() + s4();
    }
    function testGeofenceLayerVisibility(fruityMap) {
        fruityMap.toggleLayerVisibility("geofence", true);
    }
    function testSelectingGeofences(fruityMap, geofenceModels) {
        let firstGeofenceModel = geofenceModels[0];
        fruityMap.getBuilding().getCurrentFloor().setGeofenceWithUuidSelected(firstGeofenceModel.uuid);
        fruityMap.getBuilding().getCurrentFloor().setGeofenceWithUuidUnselected(firstGeofenceModel.uuid);
        fruityMap.addObserver({
            onObjectSelected: function (object) {
                if (object instanceof GeofenceMapObject_5.GeofenceMapObject) {
                    Logger_14.Logger.logDebug("On geofence selected");
                }
            },
            onObjectUnselected: function (object) {
                if (object instanceof GeofenceMapObject_5.GeofenceMapObject) {
                    Logger_14.Logger.logDebug("On geofence unselected");
                }
            },
            onObjectDoubleClicked: function (object) {
                if (object instanceof GeofenceMapObject_5.GeofenceMapObject) {
                    Logger_14.Logger.logDebug("On geofence double clicked");
                }
            }
        });
    }
});
define("test/tests/relution/testPortalMultiFloor", ["require", "exports", "test/tests/relution/helper/testMultiFloorPortalMap"], function (require, exports, testMultiFloorPortalMap_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    testMultiFloorPortalMap_2 = __importDefault(testMultiFloorPortalMap_2);
    function testPortalFruityMapMultiFloor() {
        // Configuration
        let buildingName = "multifloor_003";
        let floorNames = ["001", "002", "003"];
        let testCaseName = "default";
        let useSvg = false;
        (0, testMultiFloorPortalMap_2.default)(buildingName, floorNames, testCaseName, useSvg, runTest);
    }
    exports.default = testPortalFruityMapMultiFloor;
    function runTest(fruityMap, floor, deviceModels, testCasePath) {
        // Nothing to do
    }
});
define("test/tests/relution/testPortalMultiNetwork", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/AssetMapObject", "test/tests/relution/helper/testPortalMap"], function (require, exports, AssetMapObject_15, testPortalMap_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    testPortalMap_10 = __importStar(testPortalMap_10);
    function testPortalMultiNetwork() {
        let config = new testPortalMap_10.PortalMapTestConfig();
        config.mapName = "mwayhq";
        config.testCaseName = "multi_network";
        config.shouldLoadDevices = true;
        config.mapOptions.world.building.objectTypeVisibilities.set(AssetMapObject_15.AssetMapObject, false);
        config.mapOptions.world.building.layerVisibilities.set("ranges", true);
        (0, testPortalMap_10.default)(config, runTest);
    }
    exports.default = testPortalMultiNetwork;
    function runTest(fruityMap, deviceModels, testCasePath) {
        // Nothing to do
    }
});
define("test/tests/relution/testPortalRoomOccupancyHeatmap", ["require", "exports", "src/index", "src/app/relution/model/RelutionMapModelLoader", "src/engine/math/Vector2", "test/tests/relution/helper/testPortalMap", "test/utils/HttpUtils"], function (require, exports, fruitymap_1, RelutionMapModelLoader_11, Vector2_51, testPortalMap_11, HttpUtils_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    testPortalMap_11 = __importStar(testPortalMap_11);
    var HeatmapScheme;
    (function (HeatmapScheme) {
        HeatmapScheme[HeatmapScheme["PALETTE"] = 0] = "PALETTE";
        HeatmapScheme[HeatmapScheme["COLOR_GRADIENT"] = 1] = "COLOR_GRADIENT";
        HeatmapScheme[HeatmapScheme["ALPHA_GRADIENT"] = 2] = "ALPHA_GRADIENT";
    })(HeatmapScheme || (HeatmapScheme = {}));
    ;
    let heatmapScheme = HeatmapScheme.ALPHA_GRADIENT;
    function testPortalRoomOccupancyHeatmap() {
        let config = new testPortalMap_11.PortalMapTestConfig();
        config.mapName = "mwayhq";
        config.testCaseName = "default";
        config.shouldLoadDevices = false;
        config.mapOptions.world.building.objectTypeVisibilities.set(fruitymap_1.FloorElementMapObject, true);
        config.mapOptions.world.building.layerVisibilities.set("room", true);
        config.mapOptions.world.building.layerVisibilities.set("zone", false);
        config.mapOptions.world.building.layerVisibilities.set("popup", false);
        (0, testPortalMap_11.default)(config, runTest);
    }
    exports.default = testPortalRoomOccupancyHeatmap;
    function runTest(fruityMap, deviceModels, testCasePath) {
        HttpUtils_10.HttpUtils.getJson(testCasePath + "rooms.json", function (jsonArray) {
            const roomModels = loadRooms(fruityMap, jsonArray);
            const zoneModels = loadZones(fruityMap, jsonArray);
            addKeyboardEvents(fruityMap, roomModels, zoneModels);
            testOccupancyChanges(fruityMap, roomModels, zoneModels);
            testEventListeners(fruityMap, roomModels, zoneModels);
        });
    }
    function loadRooms(fruityMap, jsonArray) {
        let roomModels = RelutionMapModelLoader_11.RelutionMapModelLoader.loadModels(jsonArray, fruitymap_1.RoomModel, false);
        fruityMap.getBuilding().getCurrentFloor().loadRooms(roomModels);
        return roomModels;
    }
    function loadZones(fruityMap, jsonArray) {
        let zoneModels = RelutionMapModelLoader_11.RelutionMapModelLoader.loadModels(jsonArray, fruitymap_1.ZoneModel, false);
        fruityMap.getBuilding().getCurrentFloor().loadZones(zoneModels);
        return zoneModels;
    }
    function testOccupancyChanges(fruityMap, roomModels, zoneModels) {
        // Enalbe occupancy by default
        [...roomModels, ...zoneModels].forEach(roomModel => roomModel.occupancyAvailable = true);
        // Update occupancy intensity based on the distance of the floor element to the mouse cursor
        updateOccupancy(fruityMap, roomModels, zoneModels);
        setInterval(() => {
            updateOccupancy(fruityMap, roomModels, zoneModels);
        }, 16);
    }
    function updateOccupancy(fruityMap, roomModels, zoneModels) {
        [...roomModels, ...zoneModels].forEach(floorElementModel => {
            const intensity = getIntensityForFloorElement(fruityMap, floorElementModel);
            floorElementModel.occupancyValue = intensity;
            if (heatmapScheme === HeatmapScheme.PALETTE) {
                if (intensity == 0.00) {
                    floorElementModel.occupancyColor = 0xf5f5f5;
                }
                else if (intensity > 0.00 && intensity <= 0.20) {
                    floorElementModel.occupancyColor = 0xffebde;
                }
                else if (intensity > 0.20 && intensity <= 0.40) {
                    floorElementModel.occupancyColor = 0xffc8ad;
                }
                else if (intensity > 0.40 && intensity <= 0.60) {
                    floorElementModel.occupancyColor = 0xffa685;
                }
                else if (intensity > 0.60 && intensity <= 0.80) {
                    floorElementModel.occupancyColor = 0xff7e67;
                }
                else if (intensity > 0.80 && intensity <= 1.00) {
                    floorElementModel.occupancyColor = 0xff5451;
                }
                floorElementModel.occupancyAlpha = 0.70;
            }
            else if (heatmapScheme === HeatmapScheme.COLOR_GRADIENT) {
                floorElementModel.occupancyColor = (0xff0000) | (255 * (1 - intensity) << 8) | (255 * (1 - intensity) << 0);
                floorElementModel.occupancyAlpha = 0.50;
            }
            else if (heatmapScheme === HeatmapScheme.ALPHA_GRADIENT) {
                floorElementModel.occupancyColor = 0xff0000;
                floorElementModel.occupancyAlpha = intensity * 0.5;
            }
        });
        fruityMap.getBuilding().getCurrentFloor().updateRooms(roomModels);
        fruityMap.getBuilding().getCurrentFloor().updateZones(zoneModels);
    }
    function getIntensityForFloorElement(fruityMap, floorElementModel) {
        // 1. Return maximum intensity, if cursor is inside the polygon
        if (fruitymap_1.IntersectionUtils.testPointPolygonIntersection(getCursorPositionInRelative(fruityMap), floorElementModel.points)) {
            return 1.0;
        }
        // 2. Return intensity proportional to the distance of the nearest verex.
        let minDistanceCm = Number.MAX_VALUE;
        for (let point of floorElementModel.points) {
            const floorplanLayer = fruityMap.getBuilding().getCurrentFloor().getFloorplanLayer();
            const cursorPointCm = getCursorPositionInCm(fruityMap);
            const floorElementPointInCm = new Vector2_51.Vector2(floorplanLayer.getCmFromRelative(point.x), floorplanLayer.getCmFromRelative(point.y));
            const distanceInCm = Vector2_51.Vector2.getDistanceBetweenPoints(cursorPointCm, floorElementPointInCm);
            if (distanceInCm < minDistanceCm) {
                minDistanceCm = distanceInCm;
            }
        }
        const referenceDistanceCm = 1000;
        return 1.0 - Math.min(1.0, minDistanceCm / referenceDistanceCm);
    }
    function getCursorPositionInCm(fruityMap) {
        const floorplanLayer = fruityMap.getBuilding().getCurrentFloor().getFloorplanLayer();
        const cursorRelative = getCursorPositionInRelative(fruityMap);
        const cursorXCm = floorplanLayer.getCmFromRelative(cursorRelative.x);
        const cursorYCm = floorplanLayer.getCmFromRelative(cursorRelative.y);
        const cursorPointCm = new Vector2_51.Vector2(cursorXCm, cursorYCm);
        return cursorPointCm;
    }
    function getCursorPositionInRelative(fruityMap) {
        const floorplanLayer = fruityMap.getBuilding().getCurrentFloor().getFloorplanLayer();
        const cursorPointPx = new Vector2_51.Vector2(fruitymap_1.GestureRecognizer.getMousePositionX(), fruitymap_1.GestureRecognizer.getMousePositionY());
        const cursorRelative = floorplanLayer.getRelativeWorldCoordsFromScreenPixels(cursorPointPx);
        return cursorRelative;
    }
    function addKeyboardEvents(fruityMap, roomModels, zoneModels) {
        window.addEventListener("keydown", (keyboardEvent) => {
            if (keyboardEvent.key === "r") {
                const newModel = new fruitymap_1.RoomModel();
                newModel.name = "Room";
                newModel.description = "";
                initFloorElement(newModel);
                addRoomToMapCenter(newModel, fruityMap, roomModels);
            }
            else if (keyboardEvent.key === "z") {
                const newModel = new fruitymap_1.ZoneModel();
                newModel.name = "Zone";
                newModel.description = "";
                initFloorElement(newModel);
                addZoneToMapCenter(newModel, fruityMap, zoneModels);
            }
            else if (keyboardEvent.key === "e") {
                if (fruityMap.getBuilding().getLayerWithName("room").isVisible()) {
                    fruityMap.setRoomEditModeEnabled(!fruityMap.isRoomEditModeEnabled());
                }
                else if (fruityMap.getBuilding().getLayerWithName("zone").isVisible()) {
                    fruityMap.setZoneEditModeEnabled(!fruityMap.isZoneEditModeEnabled());
                }
            }
            else if (keyboardEvent.key === "s") {
                fruityMap.getBuilding().toggleLayerVisibility("room");
                fruityMap.getBuilding().toggleLayerVisibility("zone");
            }
            else if (keyboardEvent.key === "o") {
                [...roomModels, ...zoneModels].forEach(floorElementModel => {
                    floorElementModel.occupancyAvailable = !floorElementModel.occupancyAvailable;
                });
                fruityMap.getBuilding().getCurrentFloor().updateRooms(roomModels);
                fruityMap.getBuilding().getCurrentFloor().updateZones(zoneModels);
            }
            else if (keyboardEvent.key === "c") {
                heatmapScheme = (heatmapScheme + 1) % (Object.keys(HeatmapScheme).length / 2);
            }
        });
    }
    function initFloorElement(model) {
        model.points = new Array();
        model.points.push(new Vector2_51.Vector2(0.4, 0.4));
        model.points.push(new Vector2_51.Vector2(0.5, 0.4));
        model.points.push(new Vector2_51.Vector2(0.6, 0.4));
        model.points.push(new Vector2_51.Vector2(0.6, 0.5));
        model.points.push(new Vector2_51.Vector2(0.6, 0.6));
        model.points.push(new Vector2_51.Vector2(0.5, 0.6));
        model.points.push(new Vector2_51.Vector2(0.4, 0.6));
        model.points.push(new Vector2_51.Vector2(0.4, 0.5));
    }
    function addRoomToMapCenter(model, fruityMap, roomModels) {
        roomModels.push(model);
        fruityMap.getBuilding().getCurrentFloor().updateRooms(roomModels);
        let room = fruityMap.getBuilding().getCurrentFloor().getRoomWithUuid(model.uuid);
        room.translateAndScaleToCameraCenter();
    }
    function addZoneToMapCenter(model, fruityMap, zoneModels) {
        zoneModels.push(model);
        fruityMap.getBuilding().getCurrentFloor().updateZones(zoneModels);
        let zone = fruityMap.getBuilding().getCurrentFloor().getZoneWithUuid(model.uuid);
        zone.translateAndScaleToCameraCenter();
    }
    function testEventListeners(fruityMap, roomModels, zoneModels) {
        let firstRoomModel = roomModels[0];
        fruityMap.getBuilding().getCurrentFloor().setRoomWithUuidSelected(firstRoomModel.uuid);
        fruityMap.getBuilding().getCurrentFloor().setRoomWithUuidUnselected(firstRoomModel.uuid);
        let firstZoneModel = zoneModels[0];
        fruityMap.getBuilding().getCurrentFloor().setZoneWithUuidSelected(firstZoneModel.uuid);
        fruityMap.getBuilding().getCurrentFloor().setZoneWithUuidUnselected(firstZoneModel.uuid);
        fruityMap.addObserver({
            onObjectHovering(object, x, y) {
                if (object instanceof fruitymap_1.FloorElementMapObject) {
                    if (object.getModel() instanceof fruitymap_1.RoomModel) {
                        fruitymap_1.Logger.logDebug("Room hovered: " + object.getModel().name + ", occupancyValue: " + object.getModel().occupancyValue);
                    }
                    else if (object.getModel() instanceof fruitymap_1.ZoneModel) {
                        fruitymap_1.Logger.logDebug("Zone hovered: " + object.getModel().name + ", occupancyValue: " + object.getModel().occupancyValue);
                    }
                }
            },
            onObjectSelected(object) {
                if (object instanceof fruitymap_1.FloorElementMapObject) {
                    if (object.getModel() instanceof fruitymap_1.RoomModel) {
                        fruitymap_1.Logger.logDebug("Room selected: " + object.getModel().name + ", occupancyValue: " + object.getModel().occupancyValue);
                    }
                    else if (object.getModel() instanceof fruitymap_1.ZoneModel) {
                        fruitymap_1.Logger.logDebug("Zone selected: " + object.getModel().name + ", occupancyValue: " + object.getModel().occupancyValue);
                    }
                }
            },
            onObjectUnselected(object) {
                if (object instanceof fruitymap_1.FloorElementMapObject) {
                    if (object.getModel() instanceof fruitymap_1.RoomModel) {
                        fruitymap_1.Logger.logDebug("Room unselected: " + object.getModel().name + ", occupancyValue: " + object.getModel().occupancyValue);
                    }
                    else if (object.getModel() instanceof fruitymap_1.ZoneModel) {
                        fruitymap_1.Logger.logDebug("Zone unselected: " + object.getModel().name + ", occupancyValue: " + object.getModel().occupancyValue);
                    }
                }
            },
            onObjectDoubleClicked(object) {
                if (object instanceof fruitymap_1.FloorElementMapObject) {
                    if (object.getModel() instanceof fruitymap_1.RoomModel) {
                        fruitymap_1.Logger.logDebug("Room double clicked: " + object.getModel().name + ", occupancyValue: " + object.getModel().occupancyValue);
                    }
                    else if (object.getModel() instanceof fruitymap_1.ZoneModel) {
                        fruitymap_1.Logger.logDebug("Zone double clicked: " + object.getModel().name + ", occupancyValue: " + object.getModel().occupancyValue);
                    }
                }
            }
        });
    }
});
define("test/tests/relution/testPortalStabilityReinitialization", ["require", "exports", "test/tests/relution/helper/testPortalMap"], function (require, exports, testPortalMap_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    testPortalMap_12 = __importStar(testPortalMap_12);
    function testPortalStabilityReinitialization() {
        console.log("Initializing map");
        let config = new testPortalMap_12.PortalMapTestConfig();
        config.mapName = "mway";
        config.testCaseName = "default";
        config.shouldLoadDevices = false;
        (0, testPortalMap_12.default)(config, (fruityMap, deviceModels, testCasePath) => {
            setTimeout(() => {
                fruityMap.destroy();
                document.body.innerHTML = '';
                testPortalStabilityReinitialization();
            }, 1000);
        });
    }
    exports.default = testPortalStabilityReinitialization;
});
define("test/tests/relution/testPortalTaggingMode", ["require", "exports", "test/tests/relution/helper/testPortalMap", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/BeaconMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/MeshGatewayMapObject", "src/map/utils/Logger", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/KnxDeviceMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/BACnetDeviceMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceTaggingLayer/DeviceTagMapObject"], function (require, exports, testPortalMap_13, BeaconMapObject_17, MeshGatewayMapObject_4, Logger_15, KnxDeviceMapObject_3, BACnetDeviceMapObject_3, DeviceTagMapObject_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    testPortalMap_13 = __importStar(testPortalMap_13);
    function testPortalTaggingMode() {
        let config = new testPortalMap_13.PortalMapTestConfig();
        config.mapName = "mway";
        config.testCaseName = "default";
        config.shouldLoadDevices = true;
        config.mapOptions.world.building.objectTypeVisibilities.set(BeaconMapObject_17.BeaconMapObject, false);
        config.mapOptions.world.building.objectTypeVisibilities.set(MeshGatewayMapObject_4.MeshGatewayMapObject, false);
        config.mapOptions.world.building.objectTypeVisibilities.set(KnxDeviceMapObject_3.KnxDeviceMapObject, false);
        config.mapOptions.world.building.objectTypeVisibilities.set(BACnetDeviceMapObject_3.BACnetDeviceMapObject, false);
        config.mapOptions.world.building.objectTypeVisibilities.set(DeviceTagMapObject_4.DeviceTagMapObject, true);
        config.mapOptions.world.building.layerVisibilities.set("tagging", true);
        (0, testPortalMap_13.default)(config, runTest);
    }
    exports.default = testPortalTaggingMode;
    function runTest(map, deviceModels, testCasePath) {
        // testTaggingModeDefaultBehavior();
        // testTaggingModeDisabled(map);
        testTaggingModeEnabled(map);
    }
    function testTaggingModeDefaultBehavior() {
        // Testing default behavior
    }
    function testTaggingModeDisabled(map) {
        map.setDeviceTaggingModeEnabled(true);
        map.setDeviceTaggingModeEnabled(false);
    }
    function testTaggingModeEnabled(map) {
        // Enabling tagging mode
        map.setDeviceTaggingModeEnabled(true);
        // Adding prespecified models
        let models = map.getBuilding().getCurrentFloor().getDeviceTagModels();
        models[0].valid = true;
        models[0].x = 0.3;
        models[0].y = 0.3;
        map.getBuilding().getCurrentFloor().updateDeviceTags(models);
        // Fetching device tag models
        let deviceTagModels = map.getBuilding().getCurrentFloor().getDeviceTagModels();
        Logger_15.Logger.logDebug("Device tag models = " + deviceTagModels);
    }
});
define("test/tests/relution/testSensorHeatmap", ["require", "exports", "test/tests/relution/helper/testPortalMap", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/AssetMapObject", "src/app/relution/model/sensor/SensorHeatpointModel", "src/engine/math/Vector2"], function (require, exports, testPortalMap_14, AssetMapObject_16, SensorHeatpointModel_2, Vector2_52) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    testPortalMap_14 = __importStar(testPortalMap_14);
    function testSensorHeatmap() {
        let config = new testPortalMap_14.PortalMapTestConfig();
        config.mapName = "mwayhq";
        config.testCaseName = "default";
        config.shouldLoadDevices = true;
        config.mapOptions.world.building.layerVisibilities.set("sensorHeatmap", true);
        config.mapOptions.world.building.objectTypeVisibilities.set(AssetMapObject_16.AssetMapObject, true);
        (0, testPortalMap_14.default)(config, runTest);
    }
    exports.default = testSensorHeatmap;
    function runTest(map, deviceModels, testCasePath) {
        const heatmapTest = new SensorHeatmapTest(map);
        setInterval(() => {
            heatmapTest.update();
        }, 10);
    }
    class SensorHeatmapTest {
        // Construction
        constructor(map) {
            this.map = map;
            this.particles = new Array();
            this.initModel();
        }
        initModel() {
            this.particles = new Array();
            const numParticles = 50;
            for (let i = 0; i < numParticles; i++) {
                this.particles.push(new Vector2_52.Vector2(Math.random(), Math.random()));
            }
        }
        // Test
        update() {
            this.moveParticlesRandomly();
            this.redrawHeatmap();
        }
        moveParticlesRandomly() {
            for (let i = 0; i < this.particles.length; i++) {
                this.moveParticleRandomly(i);
            }
        }
        moveParticleRandomly(index) {
            const oldX = this.particles[index].x;
            const oldY = this.particles[index].y;
            const maxShiftPerUpdateInCm = 5;
            const floorplanLayer = this.map.getBuilding().getCurrentFloor().getFloorplanLayer();
            this.particles[index].x = oldX + (((Math.random() - 0.5) * maxShiftPerUpdateInCm) / floorplanLayer.getFloorSize().x);
            this.particles[index].y = oldY + (((Math.random() - 0.5) * maxShiftPerUpdateInCm) / floorplanLayer.getFloorSize().y);
            this.particles[index].x = Math.max(Math.min(this.particles[index].x, 1.0), 0.0);
            this.particles[index].y = Math.max(Math.min(this.particles[index].y, 1.0), 0.0);
        }
        redrawHeatmap() {
            const deviceLayer = this.map.getBuilding().getCurrentFloor().getDeviceLayer();
            let models = new Array();
            const devices = deviceLayer.getAllVisibleDevices();
            for (let i = 0; i < devices.length; i++) {
                const device = devices[i];
                const model = new SensorHeatpointModel_2.SensorHeatpointModel();
                model.uuid = device.getModel().uuid;
                model.deviceUuid = device.getModel().uuid;
                model.intensity = this.getIntensityForDevice(device);
                model.radiusInCm = 350;
                const fakeTemperature = 20 + (model.intensity * 10);
                model.description = "" + fakeTemperature.toFixed(1) + " °C";
                models.push(model);
            }
            this.map.getBuilding().getCurrentFloor().updateSensorHeatpoints(models);
        }
        getIntensityForDevice(device) {
            const devicePosition = device.getModel().getPosition();
            let minDistanceInRelative = Number.MAX_VALUE;
            for (let i = 0; i < this.particles.length; i++) {
                const particle = this.particles[i];
                const distanceInRelative = Vector2_52.Vector2.getDistanceBetweenPoints(new Vector2_52.Vector2(particle.x, particle.y), devicePosition);
                if (distanceInRelative < minDistanceInRelative) {
                    minDistanceInRelative = distanceInRelative;
                }
            }
            if (minDistanceInRelative === 0) {
                return 1.0;
            }
            else {
                const floorplanLayer = this.map.getBuilding().getCurrentFloor().getFloorplanLayer();
                const minDistanceInTx = floorplanLayer.getTexelsFromRelativeCoordinates(new Vector2_52.Vector2(minDistanceInRelative, 0.0));
                const minDistanceInCm = floorplanLayer.getCmFromTexels(Vector2_52.Vector2.getLengthOfPoint(minDistanceInTx));
                const intensity = 1.0 - Math.min(minDistanceInCm / 700, 1.0);
                return intensity;
            }
        }
    }
});
define("test/tests/relution/editor/testMapEditor", ["require", "exports", "src/app/relution/RelutionMap", "src/app/relution/locale/LocalizationEn", "src/app/portal/PortalMap", "test/utils/HttpUtils", "src/app/relution/model/device/DeviceModel", "src/app/relution/model/floor/FloorModelLoader", "src/app/relution/model/RelutionMapModelLoader", "src/app/relution/model/geofence/GeofenceModel", "src/map/utils/Logger", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceMapObject"], function (require, exports, RelutionMap_9, LocalizationEn_8, PortalMap_5, HttpUtils_11, DeviceModel_15, FloorModelLoader_7, RelutionMapModelLoader_12, GeofenceModel_7, Logger_16, DeviceMapObject_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TestMapEditor = void 0;
    class TestMapEditor {
        constructor(configClassConstructor) {
            this.config = null;
            // Model
            this.siteModel = null;
            this.deviceModels = null;
            this.geofenceModels = null;
            // View
            this.map = null;
            this.configClassConstructor = configClassConstructor;
            this.config = this.initConfig();
            this.initMap(() => {
                this.initUi();
            });
        }
        // Construction: Config
        initConfig() {
            let configString = HttpUtils_11.HttpUtils.getGetParameter("config");
            if (configString === null) {
                return new this.configClassConstructor();
            }
            else {
                return JSON.parse(configString);
            }
        }
        // Construction: Map
        initMap(callback) {
            let testDataPath = "../../../maps/" + this.config.mapName + "/";
            let testCasePath = testDataPath + "data/" + this.config.testCaseName + "/";
            let floorplanUrl = testDataPath + "img/floorplan.png";
            let wallplanUrl = testDataPath + "img/wallplan.png";
            let options = this.initMapOptions();
            this.map = new PortalMap_5.PortalMap(options);
            this.loadFloor(testDataPath + "floor.json", floorplanUrl, wallplanUrl, (floor) => {
                this.loadFruityMap(floor, testCasePath, () => {
                    this.loadDevices(testCasePath, () => {
                        this.loadGeofences(testCasePath, () => {
                            callback();
                        });
                    });
                });
            });
            this.map.addObserver({
                // @Override
                onUserMovedDevice(device) {
                    Logger_16.Logger.logDebug("On user moved device");
                }
            });
        }
        initMapOptions() {
            let options = new RelutionMap_9.RelutionMap.Options();
            options.parentHtmlElement = document.getElementById("center");
            options.pathToImages = "../../../../img/png/";
            options.renderer.renderTargetSize.x = options.parentHtmlElement.clientWidth;
            options.renderer.renderTargetSize.y = window.innerHeight - 20;
            options.localization = new LocalizationEn_8.LocalizationEn();
            options.world.building.objectTypeVisibilities.set(DeviceMapObject_13.DeviceMapObject, true);
            options.world.building.layerVisibilities.set("connections", true);
            this.onConfigMap(options);
            return options;
        }
        loadFloor(floorModelUrl, floorplanUrl, wallplanUrl, callback) {
            HttpUtils_11.HttpUtils.getJson(floorModelUrl, (floorObject) => {
                this.siteModel = floorObject;
                let floorModelOptions = {
                    jsonObject: floorObject,
                    pathToFloorplan: floorplanUrl,
                    wallplanUrl: wallplanUrl,
                    isPortalMode: false,
                };
                let floorModel = FloorModelLoader_7.FloorModelLoader.loadFloor(floorModelOptions);
                let floor = this.map.createFloor("floor1", floorModel);
                floor.load(() => {
                    callback(floor);
                });
            });
        }
        loadFruityMap(floor, testCasePath, callback) {
            this.map.load(floor, () => {
                window.fruityMap = this.map;
                window.addEventListener("beforeunload", (e) => {
                    this.map.destroy();
                });
                window.addEventListener("resize", () => {
                    let newWidth = this.map.getConfig().parentHtmlElement.clientWidth;
                    let newHeight = this.map.getConfig().parentHtmlElement.clientHeight;
                    this.map.setSize(newWidth, newHeight);
                });
                this.onMapLoaded();
                callback(this.map);
            });
        }
        loadDevices(testCasePath, callback) {
            HttpUtils_11.HttpUtils.getJson(testCasePath + "devices.json", (devicesObject) => {
                this.deviceModels = devicesObject;
                let deviceModels = RelutionMapModelLoader_12.RelutionMapModelLoader.loadModels(this.deviceModels, DeviceModel_15.DeviceModel, false);
                this.map.getBuilding().getCurrentFloor().loadDevices(deviceModels);
                callback(deviceModels);
            });
        }
        loadGeofences(testCasePath, callback) {
            HttpUtils_11.HttpUtils.getJson(testCasePath + "geofences.json", (geofencesObject) => {
                this.geofenceModels = geofencesObject;
                let geofenceModels = RelutionMapModelLoader_12.RelutionMapModelLoader.loadModels(this.geofenceModels, GeofenceModel_7.GeofenceModel, false);
                this.map.getBuilding().getCurrentFloor().loadGeofences(geofenceModels);
                callback(geofenceModels);
            }, () => {
                this.geofenceModels = [];
                callback([]);
            });
        }
        // Construction: UI
        initUi() {
            this.initBootstrap();
            this.initGeneralSection();
            this.initUiSections();
        }
        // Construction: Init bootstrap
        initBootstrap() {
            $(function () {
                $('[data-toggle="tooltip"]').tooltip();
            });
        }
        // Construction: General section
        initGeneralSection() {
            this.initMapName();
            this.initTestCaseName();
            this.initLoadButton();
        }
        initMapName() {
            $("#map-name").val(this.config.mapName);
        }
        initTestCaseName() {
            $("#test-case-name").val(this.config.testCaseName);
        }
        initLoadButton() {
            $("#reload-button").click(() => {
                this.loadSite(this.config);
            });
        }
        loadSite(config) {
            config.mapName = $("#map-name").val().toString();
            config.testCaseName = $("#test-case-name").val().toString();
            this.updateConfig(config);
            this.addHiddenInputFieldToSimulationModeForm("testName", HttpUtils_11.HttpUtils.getGetParameter("testName"));
            this.addHiddenInputFieldToSimulationModeForm("config", JSON.stringify(config));
            $("#form").submit();
        }
        addHiddenInputFieldToSimulationModeForm(key, value) {
            let inputElement = $("<input></input>");
            inputElement.attr("name", key);
            inputElement.attr("id", key);
            inputElement.attr("value", value);
            inputElement.attr("type", "hidden");
            inputElement.addClass("form-control");
            inputElement.appendTo("#form");
        }
        // Helper methods
        initSwitch(switchId, initiallySwitchedOn, switchCallback) {
            switchId = "#" + switchId;
            if (initiallySwitchedOn) {
                $(switchId).prop("checked", true);
            }
            else {
                $(switchId).prop("checked", false);
            }
            $(switchId).change(() => {
                const checked = $(switchId).prop("checked");
                switchCallback(checked);
            });
        }
    }
    exports.TestMapEditor = TestMapEditor;
    (function (TestMapEditor) {
        class Config {
            constructor() {
                this.mapName = "mway";
                this.testCaseName = "longtracks";
            }
        }
        TestMapEditor.Config = Config;
    })(TestMapEditor = exports.TestMapEditor || (exports.TestMapEditor = {}));
});
define("test/tests/relution/editor/mapEditor/MapEditorBeaconModel", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MapEditorBeaconModel = void 0;
    class MapEditorBeaconModel {
        static getBeaconModel(organizationUuid, siteUuid, enrollmentUuid, enrollmentDateInMs, uuid, serial, nodeId) {
            return {
                "meid": null,
                "enrollmentDate": enrollmentDateInMs,
                "uuid": uuid,
                "deviceId": serial,
                "installedApps": [],
                "securedSharedDeviceStatus": "NOT_SHARED",
                "model": "nRF5",
                "pushMagic": null,
                "details": {
                    "freeOut": 2,
                    "dfuState": "NOT_STARTED",
                    "serialNumber": serial,
                    "manufacturerId": 589,
                    "clusterId": null,
                    "uptimeSeconds": null,
                    "version": 70800,
                    "platform": "BLENODE",
                    "nonConnections": [],
                    "dfuProgress": 0,
                    "batteryInfo": 50,
                    "clusterSize": 11,
                    "macAddress": "CF:FB:F4:AC:C8:51",
                    "calibratedRssi": -55,
                    "dBmTX": 4,
                    "dfuMessage": "",
                    "dBmRX": -90,
                    "freeIn": 0,
                    "edgeRouterUuid": null,
                    "nodeId": nodeId,
                    "chipId": "51:C8:AC:F4:FB:8F:4D:22",
                    "connections": [],
                    "communicationBeacon": false
                },
                "migrated": false,
                "unlockToken": null,
                "siteUuid": siteUuid,
                "deviceType": null,
                "ruleset": null,
                "boundApp": null,
                "tags": [],
                "lastConnectionDate": enrollmentDateInMs,
                "deletedDate": null,
                "name": "SmartBeacon " + serial,
                "status": "COMPLIANT",
                "executedPolicy": null,
                "simSlots": [],
                "advertisingMessages": [],
                "siteName": "Heideck",
                "sharedDeviceStatus": "NOT_SHARED",
                "platform": "BLENODE",
                "deletedBy": null,
                "manufacturer": "Nordic Semiconductor",
                "iotDevice": true,
                "mdmClientVersionCode": null,
                "pushEnabled": false,
                "msisdn": null,
                "appPushToken": null,
                "policy": null,
                "os": "0.7.800",
                "jailbroken": false,
                "userName": "userName",
                "pushToken": null,
                "enrollment": enrollmentUuid,
                "modificationDate": enrollmentDateInMs,
                "organizationUuid": organizationUuid,
                "ownership": "COD",
                "mdmClientVersionName": null,
                "complianceNoticeCount": 0,
                "imei": null,
                "mdmClientInternalName": null,
                "comment": null,
                "user": "C99DBB8F-F3FB-476A-96BA-69CCA73C13A2",
                "complianceViolatedCount": 0,
                "properties": {
                    "onMap": "false",
                    "x": "0.0",
                    "y": "0.0"
                },
                "pushUdid": null
            };
        }
    }
    exports.MapEditorBeaconModel = MapEditorBeaconModel;
});
define("test/tests/relution/editor/mapEditor/MapEditorView", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MapEditorView = void 0;
    class MapEditorView {
        // Construction
        constructor() {
            this.customFieldset = `
        <fieldset class="scheduler-border">
            <legend class="scheduler-border">Devices:
                <a data-toggle="tooltip" data-html="true" style="float: right" title="
                Click on <code>Save JSON</code> and override your <code>devices.json</code> file, if you want to save the beacon positions.
            " class="far fa-question-circle"></a>
            </legend>

            <div class="row align-items-center" style="padding:3px">
                <a id="save-devices-link" class="button"><button type="button" class="btn btn-sm btn-light"
                        style="width: 100%" id="save-devices-button">Save JSON</button></a>
            </div>
            <div class="row align-items-center" style="padding:3px">
                <button type="button" class="button btn btn-sm btn-light" id="add-beacon-button">Add
                    beacon</button>
            </div>
            <div class="row align-items-center" style="padding:3px">
                <button type="button" class="button btn btn-sm btn-light" id="remove-beacon-button">Remove
                    selected
                    beacons</button>
            </div>
            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Edit devices:</small>
                </div>
                <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                    <input type="checkbox" class="c-switch-input" id="editDevices">
                    <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
            </legend>
        </fieldset>

        <fieldset class="scheduler-border">
            <legend class="scheduler-border">Map object visibility:
                <a data-toggle="tooltip" data-html="true" style="float: right"></a>
            </legend>
            
            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Show devices:</small>
                </div>
                <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                    <input type="checkbox" class="c-switch-input" id="showDevices">
                    <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Show beacons:</small>
                </div>
                <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                    <input type="checkbox" class="c-switch-input" id="showBeacons">
                    <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Show assets:</small>
                </div>
                <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                    <input type="checkbox" class="c-switch-input" id="showAssets">
                    <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Show gateways:</small>
                </div>
                <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                    <input type="checkbox" class="c-switch-input" id="showGateways">
                    <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Show geofences:</small>
                </div>
                <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                    <input type="checkbox" class="c-switch-input" id="showGeofences">
                    <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
            </legend>
        </fieldset>

        <fieldset class="scheduler-border">
            <legend class="scheduler-border">Map object info visibility:
                <a data-toggle="tooltip" data-html="true" style="float: right"></a>
            </legend>

            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Show infos:</small>
                </div>
                <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                    <input type="checkbox" class="c-switch-input" id="showInfos">
                    <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
            
            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Show device infos:</small>
                </div>
                <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                    <input type="checkbox" class="c-switch-input" id="showDeviceInfos">
                    <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Show beacon infos:</small>
                </div>
                <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                    <input type="checkbox" class="c-switch-input" id="showBeaconInfos">
                    <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Show asset infos:</small>
                </div>
                <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                    <input type="checkbox" class="c-switch-input" id="showAssetInfos">
                    <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Show gateway infos:</small>
                </div>
                <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                    <input type="checkbox" class="c-switch-input" id="showGatewayInfos">
                    <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Show geofence infos:</small>
                </div>
                <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                    <input type="checkbox" class="c-switch-input" id="showGeofenceInfos">
                    <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
            </legend>
        </fieldset>
    `;
            $("#custom-section").html(this.customFieldset);
        }
    }
    exports.MapEditorView = MapEditorView;
});
define("test/tests/relution/editor/mapEditor/MapEditorController", ["require", "exports", "src/app/relution/model/device/DeviceModel", "src/app/relution/utils/UuidUtils", "src/app/relution/utils/SerialNumberUtils", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceMapObject", "src/app/relution/model/RelutionMapModelLoader", "test/tests/relution/editor/testMapEditor", "test/tests/relution/editor/mapEditor/MapEditorView", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/BeaconMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/MeshGatewayMapObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/AssetMapObject", "test/tests/relution/editor/mapEditor/MapEditorBeaconModel", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/GeofenceMapObject"], function (require, exports, DeviceModel_16, UuidUtils_3, SerialNumberUtils_2, DeviceMapObject_14, RelutionMapModelLoader_13, TestMapEditor_1, MapEditorView_1, BeaconMapObject_18, MeshGatewayMapObject_5, AssetMapObject_17, MapEditorBeaconModel_1, GeofenceMapObject_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MapEditorController = void 0;
    class MapEditorController extends TestMapEditor_1.TestMapEditor {
        constructor() {
            super(MapEditorController.Config);
            this.createCustomUi();
        }
        // Custom UI construction
        createCustomUi() {
            this.view = new MapEditorView_1.MapEditorView();
        }
        // Map configuration
        onConfigMap(options) {
            options.world.building.objectTypeVisibilities.set(DeviceMapObject_14.DeviceMapObject, this.config.devicesVisible);
            options.world.building.objectTypeVisibilities.set(BeaconMapObject_18.BeaconMapObject, this.config.beaconsVisible);
            options.world.building.objectTypeVisibilities.set(MeshGatewayMapObject_5.MeshGatewayMapObject, this.config.gatewaysVisible);
            options.world.building.objectTypeVisibilities.set(AssetMapObject_17.AssetMapObject, this.config.assetsVisible);
            options.world.building.objectTypeVisibilities.set(GeofenceMapObject_6.GeofenceMapObject, this.config.geofencesVisible);
            options.world.building.layerVisibilities.set("info", this.config.infosVisible);
            options.world.building.objectTypeInfoVisibilities.set(DeviceMapObject_14.DeviceMapObject, this.config.deviceInfosVisible);
            options.world.building.objectTypeInfoVisibilities.set(BeaconMapObject_18.BeaconMapObject, this.config.beaconInfosVisible);
            options.world.building.objectTypeInfoVisibilities.set(AssetMapObject_17.AssetMapObject, this.config.assetInfosVisible);
            options.world.building.objectTypeInfoVisibilities.set(MeshGatewayMapObject_5.MeshGatewayMapObject, this.config.gatewayInfosVisible);
            options.world.building.objectTypeInfoVisibilities.set(GeofenceMapObject_6.GeofenceMapObject, this.config.geofenceInfosVisible);
        }
        // Map construction
        onMapLoaded() {
            this.map.setDeviceEditModeEnabled(this.config.editDevices);
            this.map.getBuilding().toggleRelutionMapObjectInfoVisibility(DeviceMapObject_14.DeviceMapObject, this.config.deviceInfosVisible);
        }
        // Construction: UI
        initUiSections() {
            this.initDevicesSection();
            this.initMapObjectVisibilitySection();
            this.initMapObjectInfoVisibilitySection();
        }
        // Construction: Devices section
        initDevicesSection() {
            this.initAddBeaconButton();
            this.initRemoveSelectedBeaconsButton();
            this.initSaveDevicesButton();
            this.initEditDevicesSwitch();
        }
        initAddBeaconButton() {
            $("#add-beacon-button").click(() => {
                RelutionMapModelLoader_13.RelutionMapModelLoader.syncModels(this.map.getBuilding().getCurrentFloor().getDeviceModels(), this.deviceModels, false);
                let newDevice = this.createBeacon();
                this.deviceModels.push(newDevice);
                let deviceModels = RelutionMapModelLoader_13.RelutionMapModelLoader.loadModels(this.deviceModels, DeviceModel_16.DeviceModel, false);
                this.map.getBuilding().getCurrentFloor().loadDevices(deviceModels);
            });
        }
        createBeacon() {
            const organizationUuid = this.siteModel.organizationUuid;
            const siteUuid = this.siteModel.uuid;
            const uuid = UuidUtils_3.UuidUtils.randomUuid();
            const nodeId = this.deviceModels.length;
            const serial = SerialNumberUtils_2.SerialNumberUtils.generateBeaconSerialForIndex(nodeId);
            const enrollmentDate = Date.now();
            const enrollmentUuid = UuidUtils_3.UuidUtils.randomUuid();
            return MapEditorBeaconModel_1.MapEditorBeaconModel.getBeaconModel(organizationUuid, siteUuid, enrollmentUuid, enrollmentDate, uuid, serial, nodeId);
        }
        initRemoveSelectedBeaconsButton() {
            $("#remove-beacon-button").click(() => {
                RelutionMapModelLoader_13.RelutionMapModelLoader.syncModels(this.map.getBuilding().getCurrentFloor().getDeviceModels(), this.deviceModels, false);
                let devices = this.map.getBuilding().getCurrentFloor().getDeviceLayer().getAllDevices();
                for (let i = 0; i < devices.length; i++) {
                    let device = devices[i];
                    if (device.isSelected()) {
                        let removed = this.removeBeacon(device);
                        if (removed) {
                            i--;
                        }
                    }
                }
                let deviceModels = RelutionMapModelLoader_13.RelutionMapModelLoader.loadModels(this.deviceModels, DeviceModel_16.DeviceModel, false);
                this.map.getBuilding().getCurrentFloor().loadDevices(deviceModels);
            });
        }
        removeBeacon(device) {
            for (let i = 0; i < this.deviceModels.length; i++) {
                let deviceModel = this.deviceModels[i];
                if (deviceModel.uuid === device.getModel().uuid) {
                    this.deviceModels.splice(i, 1);
                    return true;
                }
            }
            return false;
        }
        initSaveDevicesButton() {
            $("#save-devices-link").click(() => {
                RelutionMapModelLoader_13.RelutionMapModelLoader.syncModels(this.map.getBuilding().getCurrentFloor().getDeviceModels(), this.deviceModels, false);
                let payload = "text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.deviceModels, null, 2));
                $("#save-devices-link").attr("href", "data:" + payload);
                $("#save-devices-link").attr("download", "devices.json");
            });
        }
        initEditDevicesSwitch() {
            const switchId = "#editDevices";
            $(switchId).prop("checked", this.config.editDevices);
            $(switchId).change(() => {
                const checked = $(switchId).prop("checked");
                this.map.setDeviceEditModeEnabled(checked);
            });
        }
        // Construction: Map object visibility section
        initMapObjectVisibilitySection() {
            this.initShowObjectTypeSwitch("#showDevices", this.config.devicesVisible, DeviceMapObject_14.DeviceMapObject);
            this.initShowObjectTypeSwitch("#showBeacons", this.config.beaconsVisible, BeaconMapObject_18.BeaconMapObject);
            this.initShowObjectTypeSwitch("#showGateways", this.config.gatewaysVisible, MeshGatewayMapObject_5.MeshGatewayMapObject);
            this.initShowObjectTypeSwitch("#showAssets", this.config.assetsVisible, AssetMapObject_17.AssetMapObject);
            this.initShowObjectTypeSwitch("#showGeofences", this.config.geofencesVisible, GeofenceMapObject_6.GeofenceMapObject);
        }
        initShowObjectTypeSwitch(switchId, checked, objectType) {
            $(switchId).prop("checked", checked);
            $(switchId).change(() => {
                const checked = $(switchId).prop("checked");
                this.map.toggleRelutionMapObjectTypeVisibility(objectType, checked);
            });
        }
        // Construction: Map object info visibility section
        initMapObjectInfoVisibilitySection() {
            this.initShowMapObjectInfoLayerSwitch("#showInfos");
            this.initShowMapObjectInfosSwitch("#showDeviceInfos", this.config.deviceInfosVisible, DeviceMapObject_14.DeviceMapObject);
            this.initShowMapObjectInfosSwitch("#showBeaconInfos", this.config.beaconInfosVisible, BeaconMapObject_18.BeaconMapObject);
            this.initShowMapObjectInfosSwitch("#showAssetInfos", this.config.assetInfosVisible, AssetMapObject_17.AssetMapObject);
            this.initShowMapObjectInfosSwitch("#showGatewayInfos", this.config.gatewayInfosVisible, MeshGatewayMapObject_5.MeshGatewayMapObject);
            this.initShowMapObjectInfosSwitch("#showGeofenceInfos", this.config.geofenceInfosVisible, GeofenceMapObject_6.GeofenceMapObject);
        }
        initShowMapObjectInfoLayerSwitch(switchId) {
            $(switchId).prop("checked", this.config.infosVisible);
            $(switchId).change(() => {
                const checked = $(switchId).prop("checked");
                this.map.getBuilding().toggleLayerVisibility("info", checked);
            });
        }
        initShowMapObjectInfosSwitch(switchId, checked, objectType) {
            $(switchId).prop("checked", checked);
            $(switchId).change(() => {
                const checked = $(switchId).prop("checked");
                this.map.getBuilding().toggleRelutionMapObjectInfoVisibility(objectType, checked);
            });
        }
        updateConfig(config) {
            config.editDevices = $("#editDevices").prop("checked");
            config.devicesVisible = $("#showDevices").prop("checked");
            config.beaconsVisible = $("#showBeacons").prop("checked");
            config.gatewaysVisible = $("#showGateways").prop("checked");
            config.assetsVisible = $("#showAssets").prop("checked");
            config.geofencesVisible = $("#showGeofences").prop("checked");
            config.infosVisible = $("#showInfos").prop("checked");
            config.deviceInfosVisible = $("#showDeviceInfos").prop("checked");
            config.beaconInfosVisible = $("#showBeaconInfos").prop("checked");
            config.assetInfosVisible = $("#showAssetInfos").prop("checked");
            config.gatewayInfosVisible = $("#showGatewayInfos").prop("checked");
            config.geofenceInfosVisible = $("#showGeofenceInfos").prop("checked");
        }
    }
    exports.MapEditorController = MapEditorController;
    (function (MapEditorController) {
        class Config extends TestMapEditor_1.TestMapEditor.Config {
            constructor() {
                super(...arguments);
                this.editDevices = true;
                // Object type visibility
                this.devicesVisible = true;
                this.beaconsVisible = true;
                this.gatewaysVisible = true;
                this.assetsVisible = true;
                this.geofencesVisible = false;
                // Object type info visibility
                this.infosVisible = false;
                this.deviceInfosVisible = true;
                this.beaconInfosVisible = true;
                this.gatewayInfosVisible = true;
                this.assetInfosVisible = true;
                this.geofenceInfosVisible = true;
            }
        }
        MapEditorController.Config = Config;
    })(MapEditorController = exports.MapEditorController || (exports.MapEditorController = {}));
});
define("test/tests/relution/editor/mapEditor/testMapEditor", ["require", "exports", "test/tests/relution/editor/mapEditor/MapEditorController", "src/map/utils/Logger"], function (require, exports, MapEditorController_1, Logger_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testMapEditor() {
        Logger_17.Logger.loggingEnabled = true;
        new MapEditorController_1.MapEditorController();
    }
    exports.default = testMapEditor;
});
define("test/tests/relution/editor/testSingleDeviceEditMode/SingleDeviceEditorView", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SingleDeviceEditorView = void 0;
    class SingleDeviceEditorView {
        // Construction
        constructor() {
            this.customFieldset = `
            <fieldset class="scheduler-border">
            <legend class="scheduler-border">Configuration:
                <a data-toggle="tooltip" data-html="true" style="float: right" class="far fa-question-circle"></a>
            </legend>

            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Enable Single device edit mode:</small>
                </div>
                <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                    <input type="checkbox" class="c-switch-input" id="editModeEnabled">
                    <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Edit asset:</small>
                </div>
                <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                    <input type="checkbox" class="c-switch-input" id="editAsset">
                    <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
        </fieldset>
    `;
            $("#custom-section").html(this.customFieldset);
        }
    }
    exports.SingleDeviceEditorView = SingleDeviceEditorView;
});
define("test/tests/relution/editor/testSingleDeviceEditMode/SingleDeviceEditorController", ["require", "exports", "test/tests/relution/editor/testMapEditor", "test/tests/relution/editor/testSingleDeviceEditMode/SingleDeviceEditorView"], function (require, exports, TestMapEditor_2, SingleDeviceEditorView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SingleDeviceEditor = exports.SingleDeviceEditorController = void 0;
    class SingleDeviceEditorController extends TestMapEditor_2.TestMapEditor {
        // Construction
        constructor() {
            super(SingleDeviceEditor.Config);
            this.createCustomUi();
        }
        createCustomUi() {
            this.view = new SingleDeviceEditorView_1.SingleDeviceEditorView();
        }
        // Map configuration
        onConfigMap(options) {
            options.world.building.floor.singleDeviceEditLayer.enabled = this.config.editModeEnabled;
            options.world.building.floor.singleDeviceEditLayer.editableDeviceUuid = this.getEditableDeviceUuid();
            options.world.building.floor.tapeMeasureLayer.editModeEnabled = !this.config.editModeEnabled;
        }
        getEditableDeviceUuid() {
            if (this.config.editAsset) {
                return "C2963AFE-EBC9-4D1D-A6E1-EFB611CD7B9F";
            }
            else {
                return "88EAAED7-3FF4-42D6-B31A-34C696D509DB";
            }
        }
        // Construction: Map
        onMapLoaded() {
            this.map.getBuilding().getCurrentFloor().getSingleDeviceEditLayer().addObserver({
                onDevicePositionChanged: function (device) {
                    console.log("Device " + device.getModel().uuid + " positioned.");
                }
            });
        }
        // Construction: UI elements
        initUiSections() {
            this.initConfigurationSection();
        }
        initConfigurationSection() {
            this.initEditModeEnabledSwitch();
            this.initEditAssetSwitch();
        }
        initEditModeEnabledSwitch() {
            this.initSwitch("editModeEnabled", this.config.editModeEnabled, (checked) => {
                this.config.editModeEnabled = checked;
                this.updateMap();
            });
        }
        initEditAssetSwitch() {
            this.initSwitch("editAsset", this.config.editAsset, (checked) => {
                this.config.editAsset = checked;
                this.updateMap();
            });
        }
        updateMap() {
            this.map.setSingleDeviceEditModeEnabled(this.config.editModeEnabled, this.getEditableDeviceUuid());
            this.map.setTapeMeasureEditModeEnabled(!this.config.editModeEnabled);
        }
        // Configuration update
        updateConfig(config) {
            config.editModeEnabled = $("#editModeEnabled").prop("checked");
            config.editAsset = $("#editAsset").prop("checked");
        }
    }
    exports.SingleDeviceEditorController = SingleDeviceEditorController;
    var SingleDeviceEditor;
    (function (SingleDeviceEditor) {
        class Config extends TestMapEditor_2.TestMapEditor.Config {
            constructor() {
                super(...arguments);
                this.editModeEnabled = true;
                this.editAsset = false;
                this.editableDeviceUuid = "";
            }
        }
        SingleDeviceEditor.Config = Config;
    })(SingleDeviceEditor = exports.SingleDeviceEditor || (exports.SingleDeviceEditor = {}));
});
define("test/tests/relution/editor/testSingleDeviceEditMode/testSingleDeviceEditMode", ["require", "exports", "test/tests/relution/editor/testSingleDeviceEditMode/SingleDeviceEditorController"], function (require, exports, SingleDeviceEditorController_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testSingleDeviceEditMode() {
        new SingleDeviceEditorController_1.SingleDeviceEditorController();
    }
    exports.default = testSingleDeviceEditMode;
});
define("test/tests/relution/editor/testTapeMeasureMode/TapeMeasureModeEditorView", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TapeMeasureModeEditorView = void 0;
    class TapeMeasureModeEditorView {
        // Construction
        constructor() {
            this.customFieldset = `
            <fieldset class="scheduler-border">
            <legend class="scheduler-border">Configuration:
                <a data-toggle="tooltip" data-html="true" style="float: right" class="far fa-question-circle"></a>
            </legend>

            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Enable Tape measure edit mode:</small>
                </div>
                <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                    <input type="checkbox" class="c-switch-input" id="editModeEnabled">
                    <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Make tape measure layer visible:</small>
                </div>
                <label class="c-switch c-switch-label c-switch-pill c-switch-opposite-secondary c-switch-sm ">
                    <input type="checkbox" class="c-switch-input" id="visible">
                    <span class="c-switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
        </fieldset>
    `;
            $("#custom-section").html(this.customFieldset);
        }
    }
    exports.TapeMeasureModeEditorView = TapeMeasureModeEditorView;
});
define("test/tests/relution/editor/testTapeMeasureMode/TapeMeasureModeEditorController", ["require", "exports", "test/tests/relution/editor/testMapEditor", "test/tests/relution/editor/testTapeMeasureMode/TapeMeasureModeEditorView"], function (require, exports, TestMapEditor_3, TapeMeasureModeEditorView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SingleDeviceEditor = exports.TapeMeasureModeEditorController = void 0;
    class TapeMeasureModeEditorController extends TestMapEditor_3.TestMapEditor {
        // Construction
        constructor() {
            super(SingleDeviceEditor.Config);
            this.createCustomUi();
        }
        createCustomUi() {
            this.view = new TapeMeasureModeEditorView_1.TapeMeasureModeEditorView();
        }
        // Map configuration
        onConfigMap(options) {
            options.world.building.floor.tapeMeasureLayer.editModeEnabled = this.config.editModeEnabled;
            options.world.building.layerVisibilities.set("tapeMeasure", this.config.visible);
        }
        // Construction: Map
        onMapLoaded() {
            // Nothing to do
        }
        // Construction: UI elements
        initUiSections() {
            this.initConfigurationSection();
        }
        initConfigurationSection() {
            this.initEditModeEnabledSwitch();
            this.initVisibleSwitch();
        }
        initEditModeEnabledSwitch() {
            this.initSwitch("editModeEnabled", this.config.editModeEnabled, (checked) => {
                this.map.setTapeMeasureEditModeEnabled(checked);
            });
        }
        initVisibleSwitch() {
            this.initSwitch("visible", this.config.visible, (checked) => {
                this.map.toggleLayerVisibility("tapeMeasure", checked);
            });
        }
        // Configuration update
        updateConfig(config) {
            config.editModeEnabled = $("#editModeEnabled").prop("checked");
            config.visible = $("#visible").prop("checked");
        }
    }
    exports.TapeMeasureModeEditorController = TapeMeasureModeEditorController;
    var SingleDeviceEditor;
    (function (SingleDeviceEditor) {
        class Config extends TestMapEditor_3.TestMapEditor.Config {
            constructor() {
                super(...arguments);
                this.editModeEnabled = true;
                this.visible = true;
            }
        }
        SingleDeviceEditor.Config = Config;
    })(SingleDeviceEditor = exports.SingleDeviceEditor || (exports.SingleDeviceEditor = {}));
});
define("test/tests/relution/editor/testTapeMeasureMode/testTapeMeasureMode", ["require", "exports", "test/tests/relution/editor/testTapeMeasureMode/TapeMeasureModeEditorController"], function (require, exports, TapeMeasureModeEditorController_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testTapeMeasureMode() {
        new TapeMeasureModeEditorController_1.TapeMeasureModeEditorController();
    }
    exports.default = testTapeMeasureMode;
});
define("test/tests/tile/testPortalLargeScaleMap", ["require", "exports", "src/app/world/WorldMap"], function (require, exports, WorldMap_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testPortalFruityMapLargeScaleMap() {
        let worldMap = new WorldMap_2.WorldMap();
    }
    exports.default = testPortalFruityMapLargeScaleMap;
});
define("test/tests/tile/testPortalSvgMap", ["require", "exports", "src/app/relution/RelutionMap", "src/app/relution/locale/LocalizationEn", "src/app/portal/PortalMap", "test/utils/HttpUtils", "src/app/relution/model/floor/FloorModelLoader"], function (require, exports, RelutionMap_10, LocalizationEn_9, PortalMap_6, HttpUtils_12, FloorModelLoader_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testPortalFruityMapSvgMap() {
        let testDataPath = "../../maps/tiger/";
        let floorplanUrl = testDataPath + "img/floorplan.svg";
        let wallplanUrl = testDataPath + "img/wallplan.png";
        let options = initMapOptions();
        let map = new PortalMap_6.PortalMap(options);
        loadFloor(map, testDataPath + "floor.json", floorplanUrl, wallplanUrl, (floor) => {
            loadFruityMap(map, floor, (fruityMap) => {
                // Nothing to do
            });
        });
    }
    exports.default = testPortalFruityMapSvgMap;
    function initMapOptions() {
        let options = new RelutionMap_10.RelutionMap.Options();
        options.parentHtmlElement = document.body;
        options.pathToImages = "../../../img/png/";
        options.renderer.renderTargetSize.x = window.innerWidth - 30;
        options.renderer.renderTargetSize.y = window.innerHeight - 30;
        options.localization = new LocalizationEn_9.LocalizationEn();
        return options;
    }
    function loadFloor(map, floorModelUrl, floorplanUrl, wallplanUrl, callback) {
        HttpUtils_12.HttpUtils.getJson(floorModelUrl, function (floorObject) {
            let floorModelOptions = {
                jsonObject: floorObject,
                pathToFloorplan: floorplanUrl,
                wallplanUrl: wallplanUrl,
                isPortalMode: false,
            };
            let floorModel = FloorModelLoader_8.FloorModelLoader.loadFloor(floorModelOptions);
            let floor = map.createFloor("floor1", floorModel);
            floor.load(() => {
                callback(floor);
            });
        });
    }
    function loadFruityMap(fruityMap, floor, callback) {
        fruityMap.load(floor, function () {
            window.fruityMap = fruityMap;
            window.addEventListener("beforeunload", function (e) {
                fruityMap.destroy();
            });
            window.addEventListener("resize", () => {
                let newWidth = window.innerWidth - 30;
                let newHeight = window.innerHeight - 30;
                fruityMap.setSize(newWidth, newHeight);
            });
            fruityMap.setDeviceEditModeEnabled(false);
            callback(fruityMap);
        });
    }
});
define("test/unit/IntersectionUtilsTest", ["require", "exports", "chai", "src/engine/math/Vector2", "src/engine/utils/IntersectionUtils", "mocha"], function (require, exports, chai_1, Vector2_53, IntersectionUtils_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    describe('Geofence polygon test', () => {
        it('polygon test 1', () => {
            const polygon = new Array();
            polygon.push(new Vector2_53.Vector2(1.0, 1.0));
            polygon.push(new Vector2_53.Vector2(2.0, 2.0));
            polygon.push(new Vector2_53.Vector2(3.0, 2.0));
            polygon.push(new Vector2_53.Vector2(2.0, 4.0));
            polygon.push(new Vector2_53.Vector2(4.0, 3.0));
            polygon.push(new Vector2_53.Vector2(4.0, 1.0));
            (0, chai_1.expect)(IntersectionUtils_8.IntersectionUtils.testPointPolygonIntersection(new Vector2_53.Vector2(4.0, 2.0), polygon)).to.true;
            (0, chai_1.expect)(IntersectionUtils_8.IntersectionUtils.testPointPolygonIntersection(new Vector2_53.Vector2(3.0, 1.0), polygon)).to.true;
            (0, chai_1.expect)(IntersectionUtils_8.IntersectionUtils.testPointPolygonIntersection(new Vector2_53.Vector2(2.0, 1.5), polygon)).to.true;
            (0, chai_1.expect)(IntersectionUtils_8.IntersectionUtils.testPointPolygonIntersection(new Vector2_53.Vector2(3.0, 2.0), polygon)).to.true;
            (0, chai_1.expect)(IntersectionUtils_8.IntersectionUtils.testPointPolygonIntersection(new Vector2_53.Vector2(4.0, 1.0), polygon)).to.true;
            (0, chai_1.expect)(IntersectionUtils_8.IntersectionUtils.testPointPolygonIntersection(new Vector2_53.Vector2(3.0, 1.5), polygon)).to.true;
            (0, chai_1.expect)(IntersectionUtils_8.IntersectionUtils.testPointPolygonIntersection(new Vector2_53.Vector2(1.0, 1.0), polygon)).to.true;
            (0, chai_1.expect)(IntersectionUtils_8.IntersectionUtils.testPointPolygonIntersection(new Vector2_53.Vector2(5.0, 5.0), polygon)).to.false;
            (0, chai_1.expect)(IntersectionUtils_8.IntersectionUtils.testPointPolygonIntersection(new Vector2_53.Vector2(1.0, 0.9999999), polygon)).to.false;
            (0, chai_1.expect)(IntersectionUtils_8.IntersectionUtils.testPointPolygonIntersection(new Vector2_53.Vector2(2.1, 2.1), polygon)).to.false;
            (0, chai_1.expect)(IntersectionUtils_8.IntersectionUtils.testPointPolygonIntersection(new Vector2_53.Vector2(2.5, 3.5), polygon)).to.true;
            (0, chai_1.expect)(IntersectionUtils_8.IntersectionUtils.testPointPolygonIntersection(new Vector2_53.Vector2(2.0, 3.0), polygon)).to.false;
        });
        it('polygon test 2', () => {
            const polygon = new Array();
            polygon.push(new Vector2_53.Vector2(1.0, 1.0));
            polygon.push(new Vector2_53.Vector2(5.0, 5.0));
            polygon.push(new Vector2_53.Vector2(3.0, 7.0));
            polygon.push(new Vector2_53.Vector2(7.0, 7.0));
            polygon.push(new Vector2_53.Vector2(6.0, 4.0));
            polygon.push(new Vector2_53.Vector2(8.0, 2.5));
            polygon.push(new Vector2_53.Vector2(6.0, 1.0));
            (0, chai_1.expect)(IntersectionUtils_8.IntersectionUtils.testPointPolygonIntersection(new Vector2_53.Vector2(3.0, 3.0), polygon)).to.true;
            (0, chai_1.expect)(IntersectionUtils_8.IntersectionUtils.testPointPolygonIntersection(new Vector2_53.Vector2(4.0, 5.0), polygon)).to.false;
            (0, chai_1.expect)(IntersectionUtils_8.IntersectionUtils.testPointPolygonIntersection(new Vector2_53.Vector2(7.0, 4.0), polygon)).to.false;
            (0, chai_1.expect)(IntersectionUtils_8.IntersectionUtils.testPointPolygonIntersection(new Vector2_53.Vector2(5.0, 5.0), polygon)).to.true;
            (0, chai_1.expect)(IntersectionUtils_8.IntersectionUtils.testPointPolygonIntersection(new Vector2_53.Vector2(4.0, 3.0), polygon)).to.true;
        });
    });
});
define("test/utils/LargeScaleBeaconDataGenerator", ["require", "exports", "src/map/utils/Logger", "test/utils/HttpUtils"], function (require, exports, Logger_18, HttpUtils_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LargeScaleBeaconDataGenerator = void 0;
    class LargeScaleBeaconDataGenerator {
        static generate() {
            // Load base devices object
            let mapName = "mway";
            let testCaseName = "largescaledevices";
            let testDataPath = "../../maps/" + mapName + "/";
            let testCasePath = testDataPath + "data/" + testCaseName + "/";
            HttpUtils_13.HttpUtils.getJson(testCasePath + "base_devices.json", function (baseDevices) {
                let baseDevice = baseDevices[0];
                let devices = LargeScaleBeaconDataGenerator.generateDevices(baseDevice);
                Logger_18.Logger.logDebug(JSON.stringify(devices));
            });
        }
        static generateDevices(baseDevice) {
            let devices = [];
            for (let i = 0; i < this.numberDevices; i++) {
                let device = JSON.parse(JSON.stringify(baseDevice));
                // UUID
                device.uuid = this.generateUUID();
                // Node ID
                device.details.nodeId = i;
                // Position
                let scaleFactorWidth = 2;
                let scaleFactorHeight = 3;
                device.properties.x = (Math.random() / scaleFactorWidth) + (0.5 - ((1.0 / scaleFactorWidth / 2)));
                device.properties.y = (Math.random() / scaleFactorHeight) + (0.5 - ((1.0 / scaleFactorHeight / 2)));
                // Connections
                device.details.connections = LargeScaleBeaconDataGenerator.generateRandomConnections(i);
                devices.push(device);
            }
            return devices;
        }
        static generateRandomConnections(nodeId) {
            let connections = [];
            for (let i = 0; i < LargeScaleBeaconDataGenerator.numberConnections; i++) {
                let target = Math.floor(Math.random() * LargeScaleBeaconDataGenerator.numberDevices);
                let rssi = Math.floor(-((Math.random() * 100) + 30));
                let connection = { rssi: rssi, target: target };
                connections.push(connection);
            }
            return connections;
        }
        static generateUUID() {
            let d = new Date().getTime();
            if (typeof performance !== "undefined" && typeof performance.now === "function") {
                d += performance.now();
            }
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
                let r = (d + Math.random() * 16) % 16 | 0;
                d = Math.floor(d / 16);
                return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }
    }
    exports.LargeScaleBeaconDataGenerator = LargeScaleBeaconDataGenerator;
    LargeScaleBeaconDataGenerator.numberDevices = 100;
    LargeScaleBeaconDataGenerator.numberConnections = 2;
});
define("test/utils/TestPositionEstimateDataGenerator", ["require", "exports", "src/map/utils/Logger"], function (require, exports, Logger_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TestPositionEstimateDataGenerator = void 0;
    class TestPositionEstimateDataGenerator {
        generateData(devicesObject) {
            let devicePositionEstimates = new Array();
            for (let i = 0; i < devicesObject.length; i++) {
                let deviceObject = devicesObject[i];
                if (deviceObject.platform !== "BLENODE") {
                    let devicePositionEstimate = this.generateRectDistributedTrackDataForDevice(deviceObject);
                    devicePositionEstimates.push(devicePositionEstimate);
                }
            }
            let jsonString = JSON.stringify(devicePositionEstimates);
            Logger_19.Logger.logDebug(jsonString);
        }
        generateRectDistributedTrackDataForDevice(deviceObject) {
            let deviceUuid = deviceObject.uuid;
            let deviceEndX = deviceObject.details.positionEstimate.x;
            let deviceEndY = deviceObject.details.positionEstimate.y;
            let startTime = 1480678180;
            let endTime = 1480678190;
            let numLocations = 50;
            let jsonObject = {
                siteUuid: "97f596ea-2321-42d6-8267-c308f08a6bb1",
                deviceUuid: deviceUuid,
                floorId: [],
                x: [],
                y: [],
                accuracy: [],
                deltaTime: [],
                startTimeSec: startTime,
                endTimeSec: endTime,
            };
            for (let i = 0; i < numLocations; i++) {
                let floorId = 1;
                let x = this.getRandomByRect(deviceEndX);
                let y = this.getRandomByRect(deviceEndY);
                let accuracy = 1;
                let deltaTime = ((endTime - startTime) / numLocations) * Math.random();
                jsonObject.floorId.push(floorId);
                jsonObject.x.push(x);
                jsonObject.y.push(y);
                jsonObject.accuracy.push(accuracy);
                jsonObject.deltaTime.push(deltaTime);
            }
            return jsonObject;
        }
        getRandomByRect(mean) {
            let x = (Math.random() - 0.5) * 0.05 + mean;
            return x;
        }
        generateLineSimilarTrackDataForDevice(deviceObject) {
            let deviceUuid = deviceObject.uuid;
            let deviceEndX = deviceObject.details.positionEstimate.x;
            let deviceEndY = deviceObject.details.positionEstimate.y;
            let startTime = 1480678180;
            let endTime = 1480678190;
            let numLocations = 500;
            let jsonObject = {
                siteUuid: "97f596ea-2321-42d6-8267-c308f08a6bb1",
                deviceUuid: deviceUuid,
                floorId: [],
                x: [],
                y: [],
                accuracy: [],
                deltaTime: [],
                startTimeSec: startTime,
                endTimeSec: endTime,
            };
            for (let i = 0; i < numLocations; i++) {
                let floorId = 1;
                let x = 0;
                let y = 0;
                if (i !== numLocations - 1) {
                    x = deviceEndX - ((numLocations - i) * 0.005);
                    y = deviceEndY - (0.01 * Math.random());
                }
                else {
                    x = deviceEndX;
                    y = deviceEndY;
                }
                let accuracy = 1;
                let deltaTime = ((endTime - startTime) / numLocations) * Math.random();
                jsonObject.floorId.push(floorId);
                jsonObject.x.push(x);
                jsonObject.y.push(y);
                jsonObject.accuracy.push(accuracy);
                jsonObject.deltaTime.push(deltaTime);
            }
            return jsonObject;
        }
    }
    exports.TestPositionEstimateDataGenerator = TestPositionEstimateDataGenerator;
});
define("fruitymap", ["require", "exports", "src/index", "pixijs"], function (require, exports, index_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(index_1, exports);
});
//# sourceMappingURL=fruitymap.js.map